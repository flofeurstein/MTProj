///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430      10/Jun/2013  16:27:21 /
// Copyright 1996-2013 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\s /
//                     tack\nwk\BindingTable.c                                /
//    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleLight\CC2520DB\..\..\..\T /
//                     ools\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0    /
//                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                      /
//                     -DDEFAULT_CHANLIST=0x00000800                          /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100     /
//                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                  /
//                     -DBEACON_REQUEST_DELAY=100                             /
//                     -DBEACON_REQ_DELAY_MASK=0x00FF                         /
//                     -DLINK_STATUS_JITTER_MASK=0x007F                       /
//                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED /
//                     =3000 -DNWK_INDIRECT_MSG_TIMEOUT=7                     /
//                     -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3        /
//                     -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2  /
//                     -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16                      /
//                     -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4       /
//                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,      /
//                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,  /
//                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                   /
//                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS= /
//                     20 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000         /
//                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100        /
//                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\ /
//                     f8wRouter.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE= /
//                     TRUE -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8        /
//                     -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "C:\Texas             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\ /
//                     f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC        /
//                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH        /
//                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4         /
//                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10        /
//                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10       /
//                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING               /
//                     -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING            /
//                     -DZCL_TOU) -DZCL_DEVICE_MGMT "C:\Texas                 /
//                     Instruments\ZStack-MSP2618-2.5.1\Components\stack\nwk\ /
//                     BindingTable.c" -D MSP430F2618 -D ZTOOL_P1 -D MT_TASK  /
//                     -D MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED -lC     /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\Router\List\" /
//                      -lA "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projec /
//                     ts\zstack\HomeAutomation\SampleLight\CC2520DB\Router\L /
//                     ist\" --remarks --diag_suppress                        /
//                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\Router\Obj\" --debug    /
//                     -D__MSP430F2618__ -e --double=32 --clib -I "C:\Texas   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\" -I "C:\Texas          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\Source\" -I          /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\..\..\Source\ /
//                     " -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projec /
//                     ts\zstack\HomeAutomation\SampleLight\CC2520DB\..\..\.. /
//                     \ZMain\MSP2618\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\hal\include\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\hal\target\MSP2618CC2520\" -I "C:\Texas             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\include\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\high_level\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\low_level\srf04\" -I "C:\Texas                  /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\low_level\srf04\dual_chip\" -I "C:\Texas        /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ /
//                     Projects\zstack\HomeAutomation\SampleLight\CC2520DB\.. /
//                     \..\..\..\..\Components\osal\include\" -I "C:\Texas    /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\osal\mcu\msp430\" -I "C:\Texas                      /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\services\saddr\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\services\sdata\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\af\" -I "C:\Texas                             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\nwk\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sec\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sapi\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sys\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\zcl\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\zdo\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5. /
//                     1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB\ /
//                     ..\..\..\..\..\Components\zmac\f8w\" --core=430X       /
//                     --data_model=small -Ohz --multiplier=16s               /
//                     --require_prototypes                                   /
//    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst /
//                     ack\HomeAutomation\SampleLight\CC2520DB\Router\List\Bi /
//                     ndingTable.s43                                         /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME BindingTable

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC BindInitNV
        FUNCTION BindInitNV,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC BindRestoreFromNV
        FUNCTION BindRestoreFromNV,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC BindSetDefaultNV
        FUNCTION BindSetDefaultNV,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC BindWriteNV
        FUNCTION BindWriteNV,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 30, STACK
        PUBLIC GetBindingTableEntry
        FUNCTION GetBindingTableEntry,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC InitBindingTable
        FUNCTION InitBindingTable,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC bindAddClusterIdToList
        FUNCTION bindAddClusterIdToList,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC bindAddEntry
        FUNCTION bindAddEntry,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC bindAddrIndexGet
        FUNCTION bindAddrIndexGet,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC bindAddrMgrLocalLoad
        FUNCTION bindAddrMgrLocalLoad,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC bindCapacity
        FUNCTION bindCapacity,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC bindFind
        FUNCTION bindFind,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 16, STACK
        PUBLIC bindFindEmpty
        FUNCTION bindFindEmpty,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC bindFindExisting
        FUNCTION bindFindExisting,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC bindIsClusterIDinList
        FUNCTION bindIsClusterIDinList,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC bindNumBoundTo
        FUNCTION bindNumBoundTo,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC bindNumOfEntries
        FUNCTION bindNumOfEntries,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC bindNumReflections
        FUNCTION bindNumReflections,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC bindRemoveClusterIdFromList
        FUNCTION bindRemoveClusterIdFromList,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC bindRemoveDev
        FUNCTION bindRemoveDev,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC bindRemoveEntry
        FUNCTION bindRemoveEntry,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC bindRemoveSrcDev
        FUNCTION bindRemoveSrcDev,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC bindUpdateAddr
        FUNCTION bindUpdateAddr,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 18, STACK
        PUBLIC bindingAddrMgsHelperConvert
        FUNCTION bindingAddrMgsHelperConvert,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 22, STACK
        PUBLIC bindingAddrMgsHelperConvertShort
        FUNCTION bindingAddrMgsHelperConvertShort,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 18, STACK
        PUBLIC bindingAddrMgsHelperFind
        FUNCTION bindingAddrMgsHelperFind,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC pBindInitNV
        PUBLIC pBindRestoreFromNV
        PUBLIC pBindSetDefaultNV
        PUBLIC pBindWriteNV
        PUBLIC pbindAddEntry
        PUBLIC pbindNumOfEntries
        PUBLIC pbindRemoveDev
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        EXTERN gNWK_MAX_BINDING_ENTRIES
        EXTERN BindingTable
        EXTERN AddrMgrEntryLookupNwk
        FUNCTION AddrMgrEntryLookupNwk,0202H
        EXTERN AddrMgrExtAddrSet
        FUNCTION AddrMgrExtAddrSet,0202H
        EXTERN AddrMgrEntryLookupExt
        FUNCTION AddrMgrEntryLookupExt,0202H
        EXTERN AddrMgrEntryUpdate
        FUNCTION AddrMgrEntryUpdate,0202H
        EXTERN _NIB
        EXTERN NLME_GetExtAddr
        FUNCTION NLME_GetExtAddr,0202H
        EXTERN NLME_GetCoordShortAddr
        FUNCTION NLME_GetCoordShortAddr,0202H
        EXTERN NLME_GetCoordExtAddr
        FUNCTION NLME_GetCoordExtAddr,0202H
        EXTERN AddrMgrEntryGet
        FUNCTION AddrMgrEntryGet,0202H
        EXTERN sAddrExtCpy
        FUNCTION sAddrExtCpy,0202H
        EXTERN gBIND_REC_SIZE
        EXTERN osal_memcpy
        FUNCTION osal_memcpy,0202H
        EXTERN osal_nv_write
        FUNCTION osal_nv_write,0202H
        EXTERN osal_nv_read
        FUNCTION osal_nv_read,0202H
        EXTERN osal_nv_item_init
        FUNCTION osal_nv_item_init,0202H
        EXTERN gMAX_BINDING_CLUSTER_IDS
        EXTERN osal_memset
        FUNCTION osal_memset,0202H

// C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\stack\nwk\BindingTable.c
//    1 /**************************************************************************************************
//    2   Filename:       BindingTable.c
//    3   Revised:        $Date: 2012-03-28 15:40:50 -0700 (Wed, 28 Mar 2012) $
//    4   Revision:       $Revision: 29930 $
//    5 
//    6   Description:    Device binding table functions.
//    7 
//    8 
//    9   Copyright 2004-2012 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License"). You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product. Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 #include "ZComDef.h"
//   44 #include "OSAL.h"
//   45 #include "OSAL_Nv.h"
//   46 #include "nwk_globals.h"
//   47 #include "AddrMgr.h"
//   48 #include "BindingTable.h"
//   49 
//   50 /*********************************************************************
//   51  * MACROS
//   52  */
//   53 
//   54 /*********************************************************************
//   55  * CONSTANTS
//   56  */
//   57 #define NV_BIND_EMPTY   0xFF
//   58 #define NV_BIND_REC_SIZE (gBIND_REC_SIZE)
//   59 #define NV_BIND_ITEM_SIZE  (gBIND_REC_SIZE * gNWK_MAX_BINDING_ENTRIES)
//   60 
//   61 /*********************************************************************
//   62  * TYPEDEFS
//   63  */
//   64 typedef struct
//   65 {
//   66   uint8        srcEP;
//   67   uint16       srcIndex;
//   68   uint16       dstIndex;
//   69   uint8        dstEP;
//   70   uint8        dstAddrMode;
//   71   uint8        clusterIDs;
//   72   uint16*      clusterIDList;
//   73 } bindFields_t;
//   74 
//   75 /*********************************************************************
//   76  * GLOBAL VARIABLES
//   77  */
//   78 
//   79 /*********************************************************************
//   80  * LOCAL FUNCTIONS
//   81  */
//   82 void BindAddrMgrCB( uint8 update, AddrMgrEntry_t *entryOld,
//   83                     AddrMgrEntry_t *entryNew );
//   84 BindingEntry_t *bindFindEmpty( void );
//   85 uint16 bindingAddrMgsHelperFind( zAddrType_t *addr );
//   86 uint8 bindingAddrMgsHelperConvert( uint16 idx, zAddrType_t *addr );
//   87 void bindAddrMgrLocalLoad( void );
//   88 uint16 bindAddrIndexGet( zAddrType_t* addr );
//   89 
//   90 /*********************************************************************
//   91  * LOCAL VARIABLES
//   92  */

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//   93 static uint8 bindAddrMgrLocalLoaded = FALSE;
bindAddrMgrLocalLoaded:
        DS8 1
//   94 
//   95 /*********************************************************************
//   96  * Function Pointers
//   97  */
//   98 

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//   99 BindingEntry_t *(*pbindAddEntry)( byte srcEpInt,
pbindAddEntry:
        DS8 4
//  100                                   zAddrType_t *dstAddr, byte dstEpInt,
//  101                                   byte numClusterIds, uint16 *clusterIds ) = (void*)NULL;

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  102 uint16 (*pbindNumOfEntries)( void ) = (void*)NULL;
pbindNumOfEntries:
        DS8 4

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  103 void (*pbindRemoveDev)( zAddrType_t *Addr ) = (void*)NULL;
pbindRemoveDev:
        DS8 4

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  104 byte (*pBindInitNV)( void ) = (void*)NULL;
pBindInitNV:
        DS8 4

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  105 void (*pBindSetDefaultNV)( void ) = (void*)NULL;
pBindSetDefaultNV:
        DS8 4

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  106 uint16 (*pBindRestoreFromNV)( void ) = (void*)NULL;
pBindRestoreFromNV:
        DS8 4

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  107 void (*pBindWriteNV)( void ) = (void*)NULL;
pBindWriteNV:
        DS8 4
//  108 
//  109 #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
//  110 /*********************************************************************
//  111  * @fn      BindAddrMgrCB()
//  112  *
//  113  * @brief   Address Manager Callback function
//  114  *
//  115  * @param   update -
//  116  * @param   entry -
//  117  *
//  118  * @return  pointer to
//  119  */
//  120 void BindAddrMgrCB( uint8 update, AddrMgrEntry_t *entryNew,
//  121                     AddrMgrEntry_t *entryOld )
//  122 {
//  123   // Check for either deleted items or changed Extended (Duplicate) addresses
//  124 }
//  125 #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
//  126 
//  127 /*********************************************************************
//  128  * @fn      InitBindingTable()
//  129  *
//  130  * @brief
//  131  *
//  132  *   This function is used to initialise the binding table
//  133  *
//  134  * @param   none
//  135  *
//  136  * @return  none
//  137  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  138 void InitBindingTable( void )
InitBindingTable:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function InitBindingTable
//  139 {
//  140   osal_memset( BindingTable, 0xFF, gBIND_REC_SIZE * gNWK_MAX_BINDING_ENTRIES );
        FUNCALL InitBindingTable, osal_memset
        LOCFRAME CSTACK, 4, STACK
        PUSH.W  SR
          CFI CFA SP+6
        CALLA   #?Subroutine5
??CrossCallReturnLabel_8:
        MOV.W   &0x13a, R14
        POP.W   SR
          CFI CFA SP+4
        MOV.B   #0xff, R13
        MOV.W   #BindingTable, R12
        CALLA   #osal_memset
//  141 
//  142   pbindAddEntry = bindAddEntry;
        MOV.W   #LWRD(bindAddEntry), &pbindAddEntry
        MOV.W   #HWRD(bindAddEntry), &pbindAddEntry + 2
//  143   pbindNumOfEntries = bindNumOfEntries;
        MOV.W   #LWRD(bindNumOfEntries), &pbindNumOfEntries
        MOV.W   #HWRD(bindNumOfEntries), &pbindNumOfEntries + 2
//  144   pbindRemoveDev = bindRemoveDev;
        MOV.W   #LWRD(bindRemoveDev), &pbindRemoveDev
        MOV.W   #HWRD(bindRemoveDev), &pbindRemoveDev + 2
//  145   pBindInitNV = BindInitNV;
        MOV.W   #LWRD(BindInitNV), &pBindInitNV
        MOV.W   #HWRD(BindInitNV), &pBindInitNV + 2
//  146   pBindSetDefaultNV = BindSetDefaultNV;
        MOV.W   #LWRD(BindSetDefaultNV), &pBindSetDefaultNV
        MOV.W   #HWRD(BindSetDefaultNV), &pBindSetDefaultNV + 2
//  147   pBindRestoreFromNV = BindRestoreFromNV;
        MOV.W   #LWRD(BindRestoreFromNV), &pBindRestoreFromNV
        MOV.W   #HWRD(BindRestoreFromNV), &pBindRestoreFromNV + 2
//  148   pBindWriteNV = BindWriteNV;
        MOV.W   #LWRD(BindWriteNV), &pBindWriteNV
        MOV.W   #HWRD(BindWriteNV), &pBindWriteNV + 2
//  149 
//  150   bindAddrMgrLocalLoaded = FALSE;
        MOV.B   #0x0, &bindAddrMgrLocalLoaded
//  151 
//  152 #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
//  153   // Register with the address manager
//  154   AddrMgrRegister( ADDRMGR_REG_BINDING, BindAddrMgrCB );
//  155 #endif
//  156 }
        RETA
          CFI EndBlock cfiBlock0

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine5:
          CFI Block cfiCond1 Using cfiCommon0
          CFI Function BindInitNV
          CFI Conditional ??CrossCallReturnLabel_7
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+12
          CFI Block cfiCond2 Using cfiCommon0
          CFI (cfiCond2) Function InitBindingTable
          CFI (cfiCond2) Conditional ??CrossCallReturnLabel_8
          CFI (cfiCond2) CFA SP+10
          CFI Block cfiPicker3 Using cfiCommon1
          CFI (cfiPicker3) NoFunction
          CFI (cfiPicker3) Picker
        DINT
        NOP
        MOV.W   &gBIND_REC_SIZE, &0x130
        MOV.W   &gNWK_MAX_BINDING_ENTRIES, &0x138
        RETA
          CFI EndBlock cfiCond1
          CFI EndBlock cfiCond2
          CFI EndBlock cfiPicker3
//  157 
//  158 /*********************************************************************
//  159  * @fn      bindFindEmpty()
//  160  *
//  161  * @brief   This function returns a pointer to an empty binding slot
//  162  *
//  163  * @param   none
//  164  *
//  165  * @return  pointer to binding table entry, NULL if not added
//  166  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  167 BindingEntry_t *bindFindEmpty( void )
bindFindEmpty:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function bindFindEmpty
//  168 {
//  169   uint16 x;
//  170 
//  171   for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
        MOV.W   #0x0, R15
        JMP     ??bindFindEmpty_1
??bindFindEmpty_0:
        ADD.W   #0x1, R15
??bindFindEmpty_1:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R15
        JC      ??bindFindEmpty_2
//  172   {
//  173     // It's empty if the index is "Not Found"
//  174     if ( BindingTable[x].srcEP == NV_BIND_EMPTY )
        MOV.W   R15, R12
        RPT     #0xd
        ADDX.W  R15, R12
        CMP.B   #0xff, BindingTable(R12)
        JNE     ??bindFindEmpty_0
//  175     {
//  176       return ( &BindingTable[x] );
        ADD.W   #BindingTable, R12
        RETA
//  177     }
//  178   }
//  179 
//  180   return ( (BindingEntry_t *)NULL );
??bindFindEmpty_2:
        MOV.W   #0x0, R12
        RETA
          CFI EndBlock cfiBlock4
//  181 }
//  182 
//  183 /*********************************************************************
//  184  * @fn      bindNumOfEntries()
//  185  *
//  186  * @brief   This function returns the number of binding table entries.
//  187  *          The return for this is the number of clusters in the
//  188  *          table NOT the number of entries.
//  189  *
//  190  * @param   none
//  191  *
//  192  * @return  number of entries
//  193  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  194 uint16 bindNumOfEntries( void )
bindNumOfEntries:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function bindNumOfEntries
//  195 {
//  196   uint16 x;
//  197   uint16 found;
//  198 
//  199   for ( found = 0, x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
        MOV.W   #0x0, R12
        MOV.W   #0x0, R14
        JMP     ??bindNumOfEntries_1
//  200   {
//  201     // It's empty if the index is "Not Found"
//  202     if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
??bindNumOfEntries_0:
        MOV.W   R14, R15
        RPT     #0xd
        ADDX.W  R14, R15
        CMP.B   #0xff, BindingTable(R15)
        JEQ     ??bindNumOfEntries_2
//  203     {
//  204       found += BindingTable[x].numClusterIds;
        MOV.B   LWRD(BindingTable + 5)(R15), R15
        ADD.W   R15, R12
//  205     }
//  206   }
??bindNumOfEntries_2:
        ADD.W   #0x1, R14
??bindNumOfEntries_1:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R14
        JNC     ??bindNumOfEntries_0
//  207 
//  208   return ( found );
        RETA
          CFI EndBlock cfiBlock5
//  209 }
//  210 
//  211 /*********************************************************************
//  212  * @fn      bindCapacity()
//  213  *
//  214  * @brief   This function returns the number of binding entries
//  215  *          possible and used.
//  216  *
//  217  * @param   maxEntries - pointer to a place to put the max entries
//  218  * @param   usedEntries - pointer to a place to put the number
//  219  *               of used entries
//  220  *
//  221  * @return  none
//  222  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  223 void bindCapacity( uint16 *maxEntries, uint16 *usedEntries  )
bindCapacity:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function bindCapacity
//  224 {
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
//  225   uint16 x;
//  226   uint16 used;
//  227 
//  228   for ( used = 0, x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
        MOV.W   #0x0, R15
        MOV.W   #0x0, R14
        MOV.W   &gNWK_MAX_BINDING_ENTRIES, R10
        JMP     ??bindCapacity_1
//  229   {
//  230     // It's empty if the index is "Not Found"
//  231     if ( BindingTable[x].srcEP != NV_BIND_EMPTY )
??bindCapacity_0:
        MOV.W   R14, R11
        RPT     #0xd
        ADDX.W  R14, R11
        CMP.B   #0xff, BindingTable(R11)
        JEQ     ??bindCapacity_2
//  232     {
//  233       used++;
        ADD.W   #0x1, R15
//  234     }
//  235   }
??bindCapacity_2:
        ADD.W   #0x1, R14
??bindCapacity_1:
        CMP.W   R10, R14
        JNC     ??bindCapacity_0
//  236 
//  237   *maxEntries = gNWK_MAX_BINDING_ENTRIES;
        MOV.W   R10, 0(R12)
//  238   *usedEntries = used;
        MOV.W   R15, 0(R13)
//  239 }
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock6
//  240 
//  241 /*********************************************************************
//  242  * @fn      bindAddEntry()
//  243  *
//  244  * @brief   This function is used to Add an entry to the binding table
//  245  *
//  246  * @param       srcAddr - source Address
//  247  * @param       srcEpInt - source endpoint
//  248  * @param       dstAddr - destination Address
//  249  * @param       dstEpInt - destination endpoint
//  250  * @param       numClusterIds - number of cluster Ids in the list
//  251  * @param       clusterIds - pointer to the Object ID list
//  252  *
//  253  * @return  pointer to binding table entry, NULL if not added
//  254  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  255 BindingEntry_t *bindAddEntry( byte srcEpInt,
bindAddEntry:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function bindAddEntry
//  256                               zAddrType_t *dstAddr, byte dstEpInt,
//  257                               byte numClusterIds, uint16 *clusterIds )
//  258 {
        FUNCALL bindAddEntry, bindAddrMgrLocalLoad
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddEntry, bindAddrIndexGet
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddEntry, bindIsClusterIDinList
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddEntry, bindAddClusterIdToList
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddEntry, bindFindEmpty
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddEntry, osal_memcpy
        LOCFRAME CSTACK, 20, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R12, R8
        MOV.W   R13, R7
        MOV.B   R14, R5
        MOV.B   R15, R10
//  259   uint8           index;
//  260   BindingEntry_t* entry;
//  261   bindFields_t    fields;
//  262 
//  263   // initialize results
//  264   entry = NULL;
        MOV.W   #0x0, R9
//  265 
//  266   // make sure local addresses have been loaded
//  267   bindAddrMgrLocalLoad();
        CALLA   #bindAddrMgrLocalLoad
//  268 
//  269   // setup fields
//  270   fields.dstIndex = bindAddrIndexGet( dstAddr );
        MOV.W   R7, R12
        CALLA   #bindAddrIndexGet
        MOV.W   R12, R6
//  271   fields.srcEP    = srcEpInt;
//  272 
//  273   if ( dstAddr->addrMode == AddrGroup )
        CMP.B   #0x1, 0x8(R7)
        JNE     ??bindAddEntry_2
//  274   {
//  275     fields.dstAddrMode = DSTGROUPMODE_GROUP;
        MOV.B   #0x1, R7
//  276     fields.dstEP       = 0;
        MOV.B   #0x0, R5
        JMP     ??bindAddEntry_3
//  277   }
//  278   else
//  279   {
//  280     fields.dstAddrMode = DSTGROUPMODE_ADDR;
??bindAddEntry_2:
        MOV.B   #0x0, R7
//  281     fields.dstEP       = dstEpInt;
//  282   }
//  283 
//  284   if ( fields.dstIndex != INVALID_NODE_ADDR  )
??bindAddEntry_3:
        CMP.W   #0xfffe, R12
        JEQ     ??bindAddEntry_4
//  285   {
//  286     for ( index = 0; index < gNWK_MAX_BINDING_ENTRIES; index++ )
        MOV.B   #0x0, R11
        MOV.W   0x14(SP), R4
        JMP     ??bindAddEntry_5
??bindAddEntry_0:
        ADD.B   #0x1, R11
??bindAddEntry_5:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R11
        JC      ??bindAddEntry_6
//  287     {
//  288       if ( ( fields.srcEP       == BindingTable[index].srcEP        ) &&
//  289            ( fields.dstAddrMode == BindingTable[index].dstGroupMode ) &&
//  290            ( fields.dstIndex    == BindingTable[index].dstIdx       ) &&
//  291            ( fields.dstEP       == BindingTable[index].dstEP        )    )
        MOV.W   R11, R9
        RPT     #0xd
        ADDX.W  R11, R9
        CMP.B   BindingTable(R9), R8
        JNE     ??bindAddEntry_0
        CMP.B   BindingTable + 1(R9), R7
        JNE     ??bindAddEntry_0
        CMP.W   BindingTable + 2(R9), R12
        JNE     ??bindAddEntry_0
        CMP.B   LWRD(BindingTable + 4)(R9), R5
        JNE     ??bindAddEntry_0
//  292       {
//  293         entry = &BindingTable[index];
        ADD.W   #BindingTable, R9
//  294 
//  295         // break from loop
//  296         break;
//  297       }
//  298     }
//  299 
//  300     if ( entry != NULL )
//  301     {
//  302       // Loop through the cluster IDs
//  303       for ( index = 0; index < numClusterIds; index++ )
        MOV.B   #0x0, R11
??bindAddEntry_1:
        CMP.B   R10, R11
        JC      ??bindAddEntry_4
//  304       {
//  305         // Found - is the cluster already defined?
//  306         if ( bindIsClusterIDinList( entry, clusterIds[index] ) == FALSE )
        MOV.B   R11, R15
        RLA.W   R15
        MOV.W   R4, R7
        ADD.W   R15, R7
        MOV.W   @R7, R13
        MOV.W   R9, R12
        CALLA   #bindIsClusterIDinList
        CMP.B   #0x0, R12
        JNE     ??bindAddEntry_7
//  307         {
//  308           // Nope, add this cluster
//  309           if ( bindAddClusterIdToList( entry, clusterIds[index] ) == FALSE )
        MOV.W   @R7, R13
        MOV.W   R9, R12
        CALLA   #bindAddClusterIdToList
        CMP.B   #0x0, R12
        JNE     ??bindAddEntry_7
//  310           {
//  311             // Indicate error if cluster list was full
//  312             entry = NULL;
        MOV.W   #0x0, R9
//  313           }
//  314         }
//  315       }
??bindAddEntry_7:
        ADD.B   #0x1, R11
        JMP     ??bindAddEntry_1
//  316     }
//  317     else
//  318     {
//  319       // Find an empty slot
//  320       entry = bindFindEmpty();
??bindAddEntry_6:
        CALLA   #bindFindEmpty
        MOV.W   R12, R9
//  321 
//  322       // Check against the maximum number allowed
//  323       if ( entry != NULL )
        CMP.W   #0x0, R12
        JEQ     ??bindAddEntry_4
//  324       {
//  325         // Add new entry
//  326         entry->srcEP         = fields.srcEP;
        MOV.B   R8, 0(R12)
//  327         entry->dstGroupMode  = fields.dstAddrMode;
        MOV.B   R7, 0x1(R12)
//  328         entry->dstIdx        = fields.dstIndex;
        MOV.W   R6, 0x2(R12)
//  329         entry->dstEP         = fields.dstEP;
        MOV.B   R5, 0x4(R12)
//  330 
//  331         if ( numClusterIds > gMAX_BINDING_CLUSTER_IDS )
        MOV.B   &gMAX_BINDING_CLUSTER_IDS, R14
        CMP.B   R10, R14
        JC      ??bindAddEntry_8
//  332         {
//  333           numClusterIds = gMAX_BINDING_CLUSTER_IDS;
        MOV.B   R14, R10
//  334         }
//  335 
//  336         entry->numClusterIds = numClusterIds;
??bindAddEntry_8:
        MOV.B   R10, 0x5(R12)
//  337 
//  338         osal_memcpy( entry->clusterIdList,
//  339                      clusterIds,
//  340                      numClusterIds * sizeof(uint16) );
        MOV.B   R10, R14
        RLA.W   R14
        MOV.W   R4, R13
        ADD.W   #0x6, R12
        CALLA   #osal_memcpy
//  341       }
//  342     }
//  343   }
//  344 
//  345   return entry;
??bindAddEntry_4:
        MOV.W   R9, R12
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock7
//  346 }
//  347 
//  348 /*********************************************************************
//  349  * @fn      bindRemoveEntry
//  350  *
//  351  * @brief   Removes a binding table entry.
//  352  *
//  353  * @param   pBind - pointer to binding table entry to delete
//  354  *
//  355  * @return  TRUE if Removed, FALSE if not
//  356  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  357 byte bindRemoveEntry( BindingEntry_t *pBind )
bindRemoveEntry:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function bindRemoveEntry
//  358 {
//  359   osal_memset( pBind, 0xFF, gBIND_REC_SIZE );
        FUNCALL bindRemoveEntry, osal_memset
        LOCFRAME CSTACK, 4, STACK
        MOV.W   &gBIND_REC_SIZE, R14
        MOV.B   #0xff, R13
        CALLA   #osal_memset
//  360   return ( TRUE );
        MOV.B   #0x1, R12
        RETA
          CFI EndBlock cfiBlock8
//  361 }
//  362 
//  363 /*********************************************************************
//  364  * @fn      bindIsClusterIDinList()
//  365  *
//  366  * @brief   Is the clusterID in the clusterID list?
//  367  *
//  368  * @param   enter - binding table entry
//  369  * @param   clusterId  - Cluster ID to look for
//  370  *
//  371  * @return  TRUE if found, FALSE if not found
//  372  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  373 byte bindIsClusterIDinList( BindingEntry_t *entry, uint16 clusterId )
bindIsClusterIDinList:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function bindIsClusterIDinList
//  374 {
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
//  375   uint8 x;
//  376 
//  377   if ( entry != NULL )
        CMP.W   #0x0, R12
        JEQ     ??bindIsClusterIDinList_1
//  378   {
//  379     for ( x = 0; x < entry->numClusterIds; x++ )
        MOV.B   #0x0, R14
        JMP     ??bindIsClusterIDinList_2
??bindIsClusterIDinList_0:
        ADD.B   #0x1, R14
??bindIsClusterIDinList_2:
        CMP.B   0x5(R12), R14
        JC      ??bindIsClusterIDinList_1
//  380     {
//  381       if ( entry->clusterIdList[x] == clusterId )
        MOV.B   R14, R15
        RLA.W   R15
        MOV.W   R12, R10
        ADD.W   R15, R10
        CMP.W   R13, 0x6(R10)
        JNE     ??bindIsClusterIDinList_0
//  382       {
//  383         return ( TRUE );
        MOV.B   #0x1, R12
        JMP     ??bindIsClusterIDinList_3
//  384       }
//  385     }
//  386   }
//  387 
//  388   return ( FALSE );
??bindIsClusterIDinList_1:
        MOV.B   #0x0, R12
??bindIsClusterIDinList_3:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock9
//  389 }
//  390 
//  391 /*********************************************************************
//  392  * @fn      bindRemoveClusterIdFromList()
//  393  *
//  394  * @brief   Removes a ClusterID from a list of ClusterIDs.
//  395  *
//  396  * @param   enter - binding table entry
//  397  * @param   clusterId  - Cluster ID to look for
//  398  *
//  399  * @return  TRUE if there are at least 1 clusterID left, FALSE if none
//  400  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  401 byte bindRemoveClusterIdFromList( BindingEntry_t *entry, uint16 clusterId )
bindRemoveClusterIdFromList:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function bindRemoveClusterIdFromList
//  402 {
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
//  403   byte x;
//  404   uint16 *listPtr;
//  405   byte numIds;
//  406 
//  407   if ( entry )
        CMP.W   #0x0, R12
        JEQ     ??bindRemoveClusterIdFromList_2
//  408   {
//  409     if ( entry->numClusterIds > 0 )
        MOV.B   0x5(R12), R15
        CMP.B   #0x0, R15
        JEQ     ??bindRemoveClusterIdFromList_2
//  410     {
//  411       listPtr = entry->clusterIdList;
        MOV.W   R12, R10
        ADD.W   #0x6, R10
//  412       numIds = entry->numClusterIds;
//  413 
//  414       // Copy the new list over
//  415       for ( x = 0; x < numIds; x++ )
        MOV.B   #0x0, R14
        JMP     ??bindRemoveClusterIdFromList_3
//  416       {
//  417         if ( entry->clusterIdList[x] != clusterId )
//  418         {
//  419           *listPtr++ = entry->clusterIdList[x];
//  420         }
//  421         else
//  422         {
//  423           entry->numClusterIds--;
??bindRemoveClusterIdFromList_0:
        ADD.B   #0xff, 0x5(R12)
//  424           if ( entry->numClusterIds == 0 )
        JEQ     ??bindRemoveClusterIdFromList_2
//  425           {
//  426             break;
//  427           }
//  428         }
??bindRemoveClusterIdFromList_1:
        ADD.B   #0x1, R14
??bindRemoveClusterIdFromList_3:
        CMP.B   R15, R14
        JC      ??bindRemoveClusterIdFromList_4
        MOV.B   R14, R11
        RLA.W   R11
        MOV.W   R12, R8
        ADD.W   R11, R8
        MOV.W   0x6(R8), R11
        CMP.W   R13, R11
        JEQ     ??bindRemoveClusterIdFromList_0
        MOV.W   R11, 0(R10)
        ADD.W   #0x2, R10
        JMP     ??bindRemoveClusterIdFromList_1
//  429       }
//  430     }
//  431   }
??bindRemoveClusterIdFromList_4:
        CMP.B   #0x0, 0x5(R12)
        JEQ     ??bindRemoveClusterIdFromList_2
//  432 
//  433   if ( entry && (entry->numClusterIds > 0) )
//  434   {
//  435     return ( TRUE );
        MOV.B   #0x1, R12
        JMP     ??bindRemoveClusterIdFromList_5
//  436   }
//  437   else
//  438   {
//  439     return ( FALSE );
??bindRemoveClusterIdFromList_2:
        MOV.B   #0x0, R12
??bindRemoveClusterIdFromList_5:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock10
//  440   }
//  441 }
//  442 
//  443 /*********************************************************************
//  444  * @fn      bindAddClusterIdToList()
//  445  *
//  446  * @brief   Adds a ClusterID to a list of ClusterIDs.
//  447  *
//  448  * @param   enter - binding table entry
//  449  * @param   clusterId  - Cluster ID to Add
//  450  *
//  451  * @return  TRUE if Added, FALSE if not
//  452  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  453 byte bindAddClusterIdToList( BindingEntry_t *entry, uint16 clusterId )
bindAddClusterIdToList:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function bindAddClusterIdToList
//  454 {
//  455   if ( entry && entry->numClusterIds < gMAX_BINDING_CLUSTER_IDS )
        CMP.W   #0x0, R12
        JEQ     ??bindAddClusterIdToList_0
        MOV.B   0x5(R12), R15
        CMP.B   &gMAX_BINDING_CLUSTER_IDS, R15
        JC      ??bindAddClusterIdToList_0
//  456   {
//  457     // Add the new one
//  458     entry->clusterIdList[entry->numClusterIds] = clusterId;
        RLA.W   R15
        MOV.W   R12, R14
        ADD.W   R15, R14
        MOV.W   R13, 0x6(R14)
//  459     entry->numClusterIds++;
        ADD.B   #0x1, 0x5(R12)
//  460     return ( TRUE );
        MOV.B   #0x1, R12
        RETA
//  461   }
//  462   return ( FALSE );
??bindAddClusterIdToList_0:
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock11
//  463 }
//  464 
//  465 /*********************************************************************
//  466  * @fn      bindFindExisting
//  467  *
//  468  * @brief   Finds an existing src/epint to dst/epint bind record
//  469  *
//  470  * @param   srcAddr - Source address
//  471  * @param   srcEpInt - Source Endpoint/Interface
//  472  * @param   dstAddr - Destination address
//  473  * @param   dstEpInt - Destination Endpoint/Interface
//  474  *
//  475  * @return  pointer to existing entry or NULL
//  476  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  477 BindingEntry_t *bindFindExisting( byte srcEpInt,
bindFindExisting:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function bindFindExisting
//  478                                   zAddrType_t *dstAddr, byte dstEpInt )
//  479 {
        FUNCALL bindFindExisting, bindingAddrMgsHelperFind
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.B   R12, R10
        MOV.W   R13, R8
        MOV.B   R14, R11
//  480   uint16 dstIdx;
//  481   uint16 x;
//  482 
//  483   // Find the records in the assoc list
//  484   if ( dstAddr->addrMode == AddrGroup )
        CMP.B   #0x1, 0x8(R13)
        JNE     ??bindFindExisting_2
//  485   {
//  486     dstIdx = dstAddr->addr.shortAddr;
        MOV.W   @R13, R12
        JMP     ??bindFindExisting_3
//  487   }
//  488   else
//  489   {
//  490     dstIdx = bindingAddrMgsHelperFind( dstAddr );
??bindFindExisting_2:
        MOV.W   R13, R12
        CALLA   #bindingAddrMgsHelperFind
//  491   }
//  492 
//  493   if ( dstIdx == INVALID_NODE_ADDR )
??bindFindExisting_3:
        CMP.W   #0xfffe, R12
        JEQ     ??bindFindExisting_4
//  494   {
//  495     return ( (BindingEntry_t *)NULL );
//  496   }
//  497 
//  498   // Start at the beginning
//  499   for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
        MOV.W   #0x0, R14
        JMP     ??bindFindExisting_5
//  500   {
//  501     if ( (BindingTable[x].srcEP == srcEpInt) )
//  502     {
//  503       if ( ((dstAddr->addrMode == AddrGroup)
//  504               && (BindingTable[x].dstGroupMode == DSTGROUPMODE_GROUP)
//  505               && (dstIdx == BindingTable[x].dstIdx))
//  506          || ((dstAddr->addrMode != AddrGroup)
//  507              && (BindingTable[x].dstGroupMode == DSTGROUPMODE_ADDR)
//  508              && (dstIdx == BindingTable[x].dstIdx) && (BindingTable[x].dstEP == dstEpInt)) )
??bindFindExisting_1:
        CMP.B   #0x1, R13
        JNE     ??bindFindExisting_0
        CMP.W   BindingTable + 2(R15), R12
        JEQ     ??bindFindExisting_6
??bindFindExisting_0:
        ADD.W   #0x1, R14
??bindFindExisting_5:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R14
        JC      ??bindFindExisting_4
        MOV.W   R14, R15
        RPT     #0xd
        ADDX.W  R14, R15
        CMP.B   R10, BindingTable(R15)
        JNE     ??bindFindExisting_0
        MOV.B   BindingTable + 1(R15), R13
        CMP.B   #0x1, 0x8(R8)
        JEQ     ??bindFindExisting_1
        CMP.B   #0x0, R13
        JNE     ??bindFindExisting_0
        CMP.W   BindingTable + 2(R15), R12
        JNE     ??bindFindExisting_0
        CMP.B   R11, LWRD(BindingTable + 4)(R15)
        JNE     ??bindFindExisting_0
//  509       {
//  510         return ( &BindingTable[x] );
??bindFindExisting_6:
        ADD.W   #BindingTable, R15
        MOV.W   R15, R12
        JMP     ??bindFindExisting_7
//  511       }
//  512     }
//  513   }
//  514 
//  515   return ( (BindingEntry_t *)NULL );
??bindFindExisting_4:
        MOV.W   #0x0, R12
??bindFindExisting_7:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock12
//  516 }
//  517 
//  518 /*********************************************************************
//  519  * @fn       bindRemoveDev()
//  520  *
//  521  * @brief
//  522  *
//  523  *   Remove all bind(s) entries associated to a device address (destination).
//  524  *   Updates binding table.
//  525  *
//  526  * @param   Addr - address of device to be removed from Binding Table
//  527  *
//  528  * @return  none
//  529  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  530 void bindRemoveDev( zAddrType_t *Addr )
bindRemoveDev:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function bindRemoveDev
//  531 {
        FUNCALL bindRemoveDev, bindingAddrMgsHelperFind
        LOCFRAME CSTACK, 12, STACK
        FUNCALL bindRemoveDev, bindRemoveEntry
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R10
//  532   uint16 idx;
//  533   uint16 x;
//  534 
//  535   if ( Addr->addrMode == AddrGroup )
        CMP.B   #0x1, 0x8(R12)
        JNE     ??bindRemoveDev_5
//  536   {
//  537     idx = Addr->addr.shortAddr;
        MOV.W   @R12, R11
        JMP     ??bindRemoveDev_6
//  538   }
//  539   else
//  540   {
//  541     idx = bindingAddrMgsHelperFind( Addr );
??bindRemoveDev_5:
        CALLA   #bindingAddrMgsHelperFind
        MOV.W   R12, R11
//  542   }
//  543 
//  544   if ( idx == INVALID_NODE_ADDR )
??bindRemoveDev_6:
        CMP.W   #0xfffe, R11
        JEQ     ??bindRemoveDev_3
//  545   {
//  546     return;
//  547   }
//  548 
//  549   // Removes all the entries that match the destination Address/Index
//  550   for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
        MOV.W   #0x0, R8
        JMP     ??bindRemoveDev_7
//  551   {
//  552     if ( ( (Addr->addrMode == AddrGroup) && (BindingTable[x].dstGroupMode == DSTGROUPMODE_GROUP)
//  553                                          && (BindingTable[x].dstIdx == idx) ) ||
//  554          ( (Addr->addrMode != AddrGroup) && (BindingTable[x].dstGroupMode == DSTGROUPMODE_ADDR)
//  555                                          && (BindingTable[x].dstIdx == idx) ) )
??bindRemoveDev_0:
        CMP.B   #0x0, R14
        JNE     ??bindRemoveDev_1
        CMP.W   R11, BindingTable + 2(R12)
        JNE     ??bindRemoveDev_1
//  556     {
//  557       bindRemoveEntry( &BindingTable[x] );
??bindRemoveDev_2:
        ADD.W   #BindingTable, R12
        CALLA   #bindRemoveEntry
//  558     }
??bindRemoveDev_1:
        ADD.W   #0x1, R8
??bindRemoveDev_7:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R8
        JC      ??bindRemoveDev_3
        MOV.W   R8, R12
        RPT     #0xd
        ADDX.W  R8, R12
        MOV.B   BindingTable + 1(R12), R14
        CMP.B   #0x1, 0x8(R10)
        JNE     ??bindRemoveDev_0
        CMP.B   #0x1, R14
        JNE     ??bindRemoveDev_1
        CMP.W   R11, BindingTable + 2(R12)
        JEQ     ??bindRemoveDev_2
        JMP     ??bindRemoveDev_1
//  559   }
//  560 }
??bindRemoveDev_3:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock13
//  561 
//  562 /*********************************************************************
//  563  * @fn       bindRemoveSrcDev()
//  564  *
//  565  * @brief
//  566  *
//  567  *   Remove binds(s) associated to device address (source).
//  568  *   Updates binding table.
//  569  *
//  570  * @param   srcAddr - address of device
//  571  * @param   ep - endpoint to remove, 0xFF is all endpoints
//  572  *
//  573  * @return  none
//  574  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  575 void bindRemoveSrcDev( uint8 ep )
bindRemoveSrcDev:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function bindRemoveSrcDev
//  576 {
        FUNCALL bindRemoveSrcDev, bindRemoveEntry
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.B   R12, R10
//  577   uint16 x;
//  578 
//  579   for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
        MOV.W   #0x0, R11
        JMP     ??bindRemoveSrcDev_1
//  580   {
//  581     if ( (ep == 0xFF) || (ep == BindingTable[x].srcEP) )
??bindRemoveSrcDev_0:
        CMP.B   #0xff, R10
        JEQ     ??bindRemoveSrcDev_2
        MOV.W   R11, R15
        RPT     #0xd
        ADDX.W  R11, R15
        CMP.B   BindingTable(R15), R10
        JNE     ??bindRemoveSrcDev_3
//  582     {
//  583       bindRemoveEntry( &BindingTable[x] );
??bindRemoveSrcDev_2:
        MOV.W   R11, R12
        RPT     #0xd
        ADDX.W  R11, R12
        ADD.W   #BindingTable, R12
        CALLA   #bindRemoveEntry
//  584     }
//  585   }
??bindRemoveSrcDev_3:
        ADD.W   #0x1, R11
??bindRemoveSrcDev_1:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R11
        JNC     ??bindRemoveSrcDev_0
//  586 }
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock14
//  587 
//  588 /*********************************************************************
//  589  * @fn          bindNumBoundTo
//  590  *
//  591  * @brief       Calculate the number items this device is bound to.
//  592  *              When srcMode is set to TRUE, discard what value devAddr
//  593  *              has, it returns number count bound to the local dev.
//  594  *
//  595  * @param       devAddr - device Address
//  596  * @param       devEP - endpoint
//  597  * @param       srcMode - TRUE - assume devHandle is a source address
//  598  *                        FALSE - destination address
//  599  *
//  600  * @return      status
//  601  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  602 byte bindNumBoundTo( zAddrType_t *devAddr, byte devEpInt, byte srcMode )
bindNumBoundTo:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function bindNumBoundTo
//  603 {
        FUNCALL bindNumBoundTo, bindingAddrMgsHelperFind
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R9
        MOV.B   R13, R10
        MOV.B   R14, R8
//  604   BindingEntry_t *pBind;
//  605   uint16 idx;
//  606   byte   num;
//  607   uint16 x;
//  608 
//  609   // Init
//  610   num = 0;
        MOV.B   #0x0, R11
//  611 
//  612   if ( devAddr->addrMode == AddrGroup )
        CMP.B   #0x1, 0x8(R12)
        JNE     ??bindNumBoundTo_3
//  613   {
//  614     idx = devAddr->addr.shortAddr;
        MOV.W   @R9, R12
        JMP     ??bindNumBoundTo_4
//  615   }
//  616   else
//  617   {
//  618     idx = bindingAddrMgsHelperFind( devAddr );
??bindNumBoundTo_3:
        CALLA   #bindingAddrMgsHelperFind
//  619   }
//  620 
//  621   for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
??bindNumBoundTo_4:
        MOV.W   #0x0, R15
        JMP     ??bindNumBoundTo_5
//  622   {
//  623     pBind = &BindingTable[x];
//  624     if ( srcMode )
//  625     {
//  626       if ( pBind->srcEP == devEpInt )
//  627       {
//  628         num++;
//  629       }
//  630     }
//  631     else
//  632     {
//  633       if ( ((devAddr->addrMode == AddrGroup)
//  634               && (pBind->dstGroupMode == DSTGROUPMODE_GROUP) && (pBind->dstIdx == idx))
//  635           || ((devAddr->addrMode != AddrGroup) && (pBind->dstGroupMode == DSTGROUPMODE_ADDR)
//  636                                 && (pBind->dstIdx == idx) && (pBind->dstEP == devEpInt)) )
??bindNumBoundTo_2:
        CMP.B   #0x0, R14
        JNE     ??bindNumBoundTo_0
        CMP.W   R12, 0x2(R13)
        JNE     ??bindNumBoundTo_0
        CMP.B   R10, 0x4(R13)
        JNE     ??bindNumBoundTo_0
//  637       {
//  638         num++;
??bindNumBoundTo_1:
        ADD.B   #0x1, R11
//  639       }
??bindNumBoundTo_0:
        ADD.W   #0x1, R15
??bindNumBoundTo_5:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R15
        JC      ??bindNumBoundTo_6
        MOV.W   R15, R13
        RPT     #0xd
        ADDX.W  R15, R13
        ADD.W   #BindingTable, R13
        CMP.B   #0x0, R8
        JEQ     ??bindNumBoundTo_7
        CMP.B   R10, 0(R13)
        JNE     ??bindNumBoundTo_0
        JMP     ??bindNumBoundTo_1
??bindNumBoundTo_7:
        MOV.B   0x1(R13), R14
        CMP.B   #0x1, 0x8(R9)
        JNE     ??bindNumBoundTo_2
        CMP.B   #0x1, R14
        JNE     ??bindNumBoundTo_0
        CMP.W   R12, 0x2(R13)
        JEQ     ??bindNumBoundTo_1
        JMP     ??bindNumBoundTo_0
//  640     }
//  641   }
//  642 
//  643   return num;
??bindNumBoundTo_6:
        MOV.B   R11, R12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock15
//  644 }
//  645 
//  646 /*********************************************************************
//  647  * @fn          bindNumReflections
//  648  *
//  649  * @brief       Counts the number of reflections needed for a
//  650  *              endpoint and cluster ID combo.
//  651  *
//  652  * @param       ep - source endpoint
//  653  * @param       clusterID - matching clusterID
//  654  *
//  655  * @return      number of reflections needed.
//  656  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  657 uint16 bindNumReflections( uint8 ep, uint16 clusterID )
bindNumReflections:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function bindNumReflections
//  658 {
        FUNCALL bindNumReflections, bindIsClusterIDinList
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.B   R12, R10
        MOV.W   R13, R11
//  659   uint16 x;
//  660   BindingEntry_t *pBind;
//  661   uint16 cnt = 0;
        MOV.W   #0x0, R8
//  662   uint8 bindEP;
//  663 
//  664   for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
        MOV.W   #0x0, R9
        JMP     ??bindNumReflections_1
//  665   {
//  666     pBind = &BindingTable[x];
??bindNumReflections_0:
        MOV.W   R9, R12
        RPT     #0xd
        ADDX.W  R9, R12
        ADD.W   #BindingTable, R12
//  667     bindEP = pBind->srcEP;
//  668 
//  669     if ( (bindEP == ep) && (bindIsClusterIDinList( pBind, clusterID )) )
        CMP.B   R10, 0(R12)
        JNE     ??bindNumReflections_2
        MOV.W   R11, R13
        CALLA   #bindIsClusterIDinList
        CMP.B   #0x0, R12
        JEQ     ??bindNumReflections_2
//  670     {
//  671       cnt++;
        ADD.W   #0x1, R8
//  672     }
//  673   }
??bindNumReflections_2:
        ADD.W   #0x1, R9
??bindNumReflections_1:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R9
        JNC     ??bindNumReflections_0
//  674 
//  675   return ( cnt );
        MOV.W   R8, R12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock16
//  676 }
//  677 
//  678 /*********************************************************************
//  679  * @fn          bindFind
//  680  *
//  681  * @brief       Finds the binding entry for the source address, endpoint
//  682  *              and cluster ID passed in as a parameter.
//  683  *
//  684  * @param       ep - source endpoint
//  685  * @param       clusterID - matching clusterID
//  686  * @param       skip - number of matches to skip before returning
//  687  *
//  688  * @return      pointer to the binding table entry, NULL if not found
//  689  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  690 BindingEntry_t *bindFind( uint8 ep, uint16 clusterID, uint8 skipping )
bindFind:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function bindFind
//  691 {
        FUNCALL bindFind, bindIsClusterIDinList
        LOCFRAME CSTACK, 16, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
        MOV.B   R12, R11
        MOV.W   R13, R8
        MOV.B   R14, R10
//  692   BindingEntry_t *pBind;
//  693   byte skipped = 0;
        MOV.B   #0x0, R9
//  694   uint16 x;
//  695 
//  696   for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
        MOV.W   #0x0, R6
        JMP     ??bindFind_2
//  697   {
//  698     pBind = &BindingTable[x];
//  699 
//  700     if ( ( pBind->srcEP == ep) && bindIsClusterIDinList( pBind, clusterID ))
//  701     {
//  702       if ( skipped < skipping )
//  703       {
//  704         skipped++;
??bindFind_1:
        ADD.B   #0x1, R9
//  705       }
??bindFind_0:
        ADD.W   #0x1, R6
??bindFind_2:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R6
        JC      ??bindFind_3
        MOV.W   R6, R7
        RPT     #0xd
        ADDX.W  R6, R7
        ADD.W   #BindingTable, R7
        CMP.B   R11, 0(R7)
        JNE     ??bindFind_0
        MOV.W   R8, R13
        MOV.W   R7, R12
        CALLA   #bindIsClusterIDinList
        CMP.B   #0x0, R12
        JEQ     ??bindFind_0
        CMP.B   R10, R9
        JNC     ??bindFind_1
//  706       else
//  707       {
//  708         return ( pBind );
        MOV.W   R7, R12
        JMP     ??bindFind_4
//  709       }
//  710     }
//  711   }
//  712 
//  713   return ( (BindingEntry_t *)NULL );
??bindFind_3:
        MOV.W   #0x0, R12
??bindFind_4:
        POPM.W  #0x6, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock17
//  714 }
//  715 
//  716 /*********************************************************************
//  717  * @fn          BindInitNV
//  718  *
//  719  * @brief       Initialize the Binding NV Item
//  720  *
//  721  * @param       none
//  722  *
//  723  * @return      ZSUCCESS if successful, NV_ITEM_UNINIT if item did not
//  724  *              exist in NV, NV_OPER_FAILED if failure.
//  725  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  726 byte BindInitNV( void )
BindInitNV:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function BindInitNV
//  727 {
        FUNCALL BindInitNV, osal_nv_item_init
        LOCFRAME CSTACK, 6, STACK
        FUNCALL BindInitNV, BindSetDefaultNV
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
//  728   byte ret;
//  729 
//  730   // Initialize the device list
//  731   ret = osal_nv_item_init( ZCD_NV_BINDING_TABLE,
//  732                   (uint16)(gBIND_REC_SIZE + NV_BIND_ITEM_SIZE), NULL );
        MOV.W   #0x0, R14
        PUSH.W  SR
          CFI CFA SP+8
        CALLA   #?Subroutine5
??CrossCallReturnLabel_7:
        MOV.W   &0x13a, R13
        POP.W   SR
          CFI CFA SP+6
        ADD.W   &gBIND_REC_SIZE, R13
        MOV.W   #0x41, R12
        CALLA   #osal_nv_item_init
        MOV.B   R12, R10
//  733 
//  734   if ( ret != ZSUCCESS )
        CMP.B   #0x0, R12
        JEQ     ??BindInitNV_0
//  735   {
//  736     BindSetDefaultNV();
        CALLA   #BindSetDefaultNV
//  737   }
//  738 
//  739   return ( ret );
??BindInitNV_0:
        MOV.B   R10, R12
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock18
//  740 }
//  741 
//  742 /*********************************************************************
//  743  * @fn          BindSetDefaultNV
//  744  *
//  745  * @brief       Write the defaults to NV
//  746  *
//  747  * @param       none
//  748  *
//  749  * @return      none
//  750  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  751 void BindSetDefaultNV( void )
BindSetDefaultNV:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function BindSetDefaultNV
//  752 {
        FUNCALL BindSetDefaultNV, osal_nv_write
        LOCFRAME CSTACK, 6, STACK
        SUB.W   #0x2, SP
          CFI CFA SP+6
//  753   nvBindingHdr_t hdr;
//  754 
//  755   // Initialize the header
//  756   hdr.numRecs = 0;
        MOV.W   #0x0, 0(SP)
//  757 
//  758   // Save off the header
//  759   osal_nv_write( ZCD_NV_BINDING_TABLE, 0, sizeof( nvBindingHdr_t ), &hdr );
        CALLA   #?Subroutine1
//  760 }
??CrossCallReturnLabel_0:
        ADD.W   #0x2, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock19

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine1:
          CFI Block cfiCond20 Using cfiCommon0
          CFI Function BindWriteNV
          CFI Conditional ??CrossCallReturnLabel_1
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+32
          CFI Block cfiCond21 Using cfiCommon0
          CFI (cfiCond21) Function BindSetDefaultNV
          CFI (cfiCond21) Conditional ??CrossCallReturnLabel_0
          CFI (cfiCond21) CFA SP+10
          CFI Block cfiPicker22 Using cfiCommon1
          CFI (cfiPicker22) NoFunction
          CFI (cfiPicker22) Picker
        MOV.W   SP, R15
        ADD.W   #0x4, R15
        MOV.W   #0x2, R14
        MOV.W   #0x0, R13
        MOV.W   #0x41, R12
        BRA     #osal_nv_write
          CFI EndBlock cfiCond20
          CFI EndBlock cfiCond21
          CFI EndBlock cfiPicker22
//  761 
//  762 /*********************************************************************
//  763  * @fn          BindRestoreFromNV
//  764  *
//  765  * @brief       Restore the binding table from NV
//  766  *
//  767  * @param       none
//  768  *
//  769  * @return      Number of entries restored
//  770  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  771 uint16 BindRestoreFromNV( void )
BindRestoreFromNV:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function BindRestoreFromNV
//  772 {
        FUNCALL BindRestoreFromNV, osal_nv_read
        LOCFRAME CSTACK, 10, STACK
        FUNCALL BindRestoreFromNV, osal_nv_read
        LOCFRAME CSTACK, 10, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        SUB.W   #0x2, SP
          CFI CFA SP+10
//  773   nvBindingHdr_t hdr;
//  774   uint16 numAdded = 0;
        MOV.W   #0x0, R10
//  775 
//  776   if ( osal_nv_read( ZCD_NV_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdr ) == ZSuccess )
        MOV.W   SP, R15
        ADD.W   #0x0, R15
        MOV.W   #0x2, R14
        MOV.W   #0x0, R13
        MOV.W   #0x41, R12
        CALLA   #osal_nv_read
        CMP.B   #0x0, R12
        JNE     ??BindRestoreFromNV_0
//  777   {
//  778     if (hdr.numRecs > 0)
        CMP.W   #0x0, 0(SP)
        JEQ     ??BindRestoreFromNV_0
//  779     {
//  780       // Read the whole table at once
//  781       if ( osal_nv_read( ZCD_NV_BINDING_TABLE,
//  782                          (uint16)(sizeof(nvBindingHdr_t)),
//  783                          (NV_BIND_REC_SIZE * gNWK_MAX_BINDING_ENTRIES), BindingTable ) == ZSUCCESS )
        MOV.W   &gNWK_MAX_BINDING_ENTRIES, R11
        MOV.W   #BindingTable, R15
        PUSH.W  SR
          CFI CFA SP+12
        DINT
        NOP
        MOV.W   &gBIND_REC_SIZE, &0x130
        MOV.W   R11, &0x138
        MOV.W   &0x13a, R14
        POP.W   SR
          CFI CFA SP+10
        MOV.W   #0x2, R13
        MOV.W   #0x41, R12
        CALLA   #osal_nv_read
        CMP.B   #0x0, R12
        JNE     ??BindRestoreFromNV_0
//  784       {
//  785         numAdded = gNWK_MAX_BINDING_ENTRIES;
        MOV.W   R11, R10
//  786       }
//  787     }
//  788   }
//  789   return ( numAdded );
??BindRestoreFromNV_0:
        MOV.W   R10, R12
        ADD.W   #0x2, SP
          CFI CFA SP+8
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock23
//  790 }
//  791 
//  792 /*********************************************************************
//  793  * @fn          BindWriteNV
//  794  *
//  795  * @brief       Save the Binding Table in NV
//  796  *
//  797  * @param       none
//  798  *
//  799  * @return      none
//  800  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  801 void BindWriteNV( void )
BindWriteNV:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function BindWriteNV
//  802 {
        FUNCALL BindWriteNV, osal_memcpy
        LOCFRAME CSTACK, 28, STACK
        FUNCALL BindWriteNV, osal_nv_write
        LOCFRAME CSTACK, 28, STACK
        FUNCALL BindWriteNV, osal_nv_write
        LOCFRAME CSTACK, 28, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x10, SP
          CFI CFA SP+28
//  803   BindingEntry_t *pBind;
//  804   BindingEntry_t bind;
//  805   nvBindingHdr_t hdr;
//  806   uint16 x;
//  807 
//  808   hdr.numRecs = 0;
        MOV.W   #0x0, 0(SP)
//  809 
//  810   for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
        MOV.W   #0x0, R10
        MOV.W   &gBIND_REC_SIZE, R11
        JMP     ??BindWriteNV_1
//  811   {
//  812     pBind = &BindingTable[x];
??BindWriteNV_0:
        MOV.W   R10, R8
        RPT     #0xd
        ADDX.W  R10, R8
        ADD.W   #BindingTable, R8
//  813 
//  814     osal_memcpy( &bind, pBind, gBIND_REC_SIZE );
        MOV.W   R11, R14
        MOV.W   R8, R13
        MOV.W   SP, R12
        ADD.W   #0x2, R12
        CALLA   #osal_memcpy
//  815 
//  816     // Save the record to NV
//  817     osal_nv_write( ZCD_NV_BINDING_TABLE,
//  818                    (uint16)((sizeof(nvBindingHdr_t)) + (x * NV_BIND_REC_SIZE)),
//  819                    NV_BIND_REC_SIZE, &bind );
        MOV.W   SP, R15
        ADD.W   #0x2, R15
        MOV.W   R11, R14
        PUSH.W  SR
          CFI CFA SP+30
        DINT
        NOP
        MOV.W   R10, &0x130
        MOV.W   R11, &0x138
        MOV.W   &0x13a, R13
        POP.W   SR
          CFI CFA SP+28
        ADD.W   #0x2, R13
        MOV.W   #0x41, R12
        CALLA   #osal_nv_write
//  820 
//  821     if ( pBind->srcEP != NV_BIND_EMPTY )
        CMP.B   #0xff, 0(R8)
        JEQ     ??BindWriteNV_2
//  822     {
//  823       hdr.numRecs++;
        MOV.W   @SP, R15
        ADD.W   #0x1, R15
        MOV.W   R15, 0(SP)
//  824     }
//  825   }
??BindWriteNV_2:
        ADD.W   #0x1, R10
??BindWriteNV_1:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R10
        JNC     ??BindWriteNV_0
//  826 
//  827   // Save off the header
//  828   osal_nv_write( ZCD_NV_BINDING_TABLE, 0, sizeof(nvBindingHdr_t), &hdr );
        CALLA   #?Subroutine1
//  829 }
??CrossCallReturnLabel_1:
        ADD.W   #0x10, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock24
//  830 
//  831 /*********************************************************************
//  832  * @fn          bindUpdateAddr
//  833  *
//  834  * @brief       Update the network address in the binding table.
//  835  *
//  836  * @param       oldAddr - old network address
//  837  * @param       newAddr - new network address
//  838  *
//  839  * @return      none
//  840  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  841 void bindUpdateAddr( uint16 oldAddr, uint16 newAddr )
bindUpdateAddr:
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function bindUpdateAddr
//  842 {
        FUNCALL bindUpdateAddr, bindingAddrMgsHelperFind
        LOCFRAME CSTACK, 18, STACK
        FUNCALL bindUpdateAddr, bindingAddrMgsHelperFind
        LOCFRAME CSTACK, 18, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        SUB.W   #0xa, SP
          CFI CFA SP+18
        MOV.W   R13, R10
//  843   uint16 oldIdx;
//  844   uint16 newIdx;
//  845   zAddrType_t addr;
//  846   uint16 x;
//  847   BindingEntry_t *pBind;
//  848 
//  849   addr.addrMode = Addr16Bit;
        MOV.B   #0x2, 0x8(SP)
//  850   addr.addr.shortAddr = oldAddr;
        MOV.W   R12, 0(SP)
//  851   oldIdx = bindingAddrMgsHelperFind( &addr );
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #bindingAddrMgsHelperFind
        MOV.W   R12, R11
//  852   addr.addr.shortAddr = newAddr;
        MOV.W   R10, 0(SP)
//  853   newIdx = bindingAddrMgsHelperFind( &addr );
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #bindingAddrMgsHelperFind
//  854 
//  855   for ( x = 0; x < gNWK_MAX_BINDING_ENTRIES; x++ )
        MOV.W   #0x0, R15
        JMP     ??bindUpdateAddr_1
//  856   {
//  857     pBind = &BindingTable[x];
??bindUpdateAddr_0:
        MOV.W   R15, R14
        RPT     #0xd
        ADDX.W  R15, R14
        ADD.W   #BindingTable, R14
//  858 
//  859     if ( pBind->dstIdx == oldIdx )
        CMP.W   R11, 0x2(R14)
        JNE     ??bindUpdateAddr_2
//  860     {
//  861       pBind->dstIdx = newIdx;
        MOV.W   R12, 0x2(R14)
//  862     }
//  863   }
??bindUpdateAddr_2:
        ADD.W   #0x1, R15
??bindUpdateAddr_1:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R15
        JNC     ??bindUpdateAddr_0
//  864 }
        ADD.W   #0xa, SP
          CFI CFA SP+8
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock25

        RSEG CODE:CODE:NOROOT(1)
bindAddrIndexGet:
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function bindAddrIndexGet
        FUNCALL bindAddrIndexGet, AddrMgrEntryLookupNwk
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddrIndexGet, AddrMgrExtAddrSet
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddrIndexGet, AddrMgrEntryLookupExt
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddrIndexGet, AddrMgrEntryUpdate
        LOCFRAME CSTACK, 20, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        SUB.W   #0xe, SP
          CFI CFA SP+20
        MOV.B   #0x4, 0(SP)
        MOV.B   0x8(R12), R14
        MOV.W   SP, R10
        ADD.W   #0x0, R10
        CMP.B   #0x2, R14
        JNE     ??bindAddrIndexGet_0
        CALLA   #?Subroutine4
??CrossCallReturnLabel_6:
        CMP.B   #0x0, R12
        JNE     ??bindAddrIndexGet_1
        JMP     ??bindAddrIndexGet_2
??bindAddrIndexGet_0:
        CMP.B   #0x3, R14
        JNE     ??bindAddrIndexGet_3
        CALLA   #?Subroutine3
??CrossCallReturnLabel_4:
        CMP.B   #0x0, R12
        JNE     ??bindAddrIndexGet_1
??bindAddrIndexGet_2:
        MOV.W   R10, R12
        CALLA   #AddrMgrEntryUpdate
        JMP     ??bindAddrIndexGet_1
??bindAddrIndexGet_3:
        CMP.B   #0x1, R14
        JEQ     ??bindAddrIndexGet_4
        MOV.W   #0xfffe, 0xc(SP)
        JMP     ??bindAddrIndexGet_1
??bindAddrIndexGet_4:
        MOV.W   @R12, 0xc(SP)
          CFI EndBlock cfiBlock26
??bindAddrIndexGet_1:
        REQUIRE ?Subroutine0
        // Fall through to label ?Subroutine0
//  865 
//  866 /*********************************************************************
//  867  * @fn      bindingAddrMgsHelperFind
//  868  *
//  869  * @brief   Turns an zAddrType_t to an Addr Manager index
//  870  *
//  871  * @param   addr - zAddrType_t
//  872  *
//  873  * @return  INVALID_NODE_ADDR if not found, otherwise an index
//  874  */

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
          CFI Block cfiBlock27 Using cfiCommon0
          CFI NoFunction
          CFI CFA SP+20
          CFI R10L Frame(CFA, -6)
//  875 uint16 bindingAddrMgsHelperFind( zAddrType_t *addr )
//  876 {
//  877   AddrMgrEntry_t entry;
//  878 
//  879   // Resolve addresses with the address manager
//  880   entry.user = ADDRMGR_USER_BINDING;
//  881   if ( addr->addrMode == Addr16Bit )
//  882   {
//  883     entry.nwkAddr = addr->addr.shortAddr;
//  884     AddrMgrEntryLookupNwk( &entry );
//  885   }
//  886   else
//  887   {
//  888     AddrMgrExtAddrSet( entry.extAddr, addr->addr.extAddr );
//  889     AddrMgrEntryLookupExt( &entry );
//  890   }
//  891 
//  892   return ( entry.index );
        MOV.W   0xc(SP), R12
          CFI EndBlock cfiBlock27
        REQUIRE ??Subroutine7_0
        // Fall through to label ??Subroutine7_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine7_0:
          CFI Block cfiBlock28 Using cfiCommon0
          CFI NoFunction
          CFI CFA SP+20
          CFI R10L Frame(CFA, -6)
        ADD.W   #0xe, SP
          CFI CFA SP+6
        POP.W   R10
          CFI CFA SP+4
          CFI R10L SameValue
        RETA
          CFI EndBlock cfiBlock28

        RSEG CODE:CODE:NOROOT(1)
bindAddrMgrLocalLoad:
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function bindAddrMgrLocalLoad
        FUNCALL bindAddrMgrLocalLoad, NLME_GetExtAddr
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddrMgrLocalLoad, AddrMgrExtAddrSet
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddrMgrLocalLoad, AddrMgrEntryUpdate
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddrMgrLocalLoad, NLME_GetCoordShortAddr
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddrMgrLocalLoad, NLME_GetCoordExtAddr
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindAddrMgrLocalLoad, AddrMgrEntryUpdate
        LOCFRAME CSTACK, 20, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        SUB.W   #0xe, SP
          CFI CFA SP+20
        CMP.B   #0x0, &bindAddrMgrLocalLoaded
        JNE     ??bindAddrMgrLocalLoad_0
        MOV.B   #0x4, 0(SP)
        MOV.W   &_NIB + 22, 0x2(SP)
        CALLA   #NLME_GetExtAddr
        MOV.W   SP, R10
        ADD.W   #0x0, R10
        CALLA   #?Subroutine6
??CrossCallReturnLabel_9:
        CALLA   #AddrMgrEntryUpdate
        CALLA   #NLME_GetCoordShortAddr
        CMP.W   0x2(SP), R12
        JEQ     ??bindAddrMgrLocalLoad_1
        CMP.W   #0xfffe, R12
        JEQ     ??bindAddrMgrLocalLoad_1
        MOV.W   R12, 0x2(SP)
        MOV.W   R10, R12
        ADD.W   #0x4, R12
        CALLA   #NLME_GetCoordExtAddr
        MOV.W   R10, R12
        CALLA   #AddrMgrEntryUpdate
??bindAddrMgrLocalLoad_1:
        MOV.B   #0x1, &bindAddrMgrLocalLoaded
??bindAddrMgrLocalLoad_0:
        JMP     ??Subroutine7_0
          CFI EndBlock cfiBlock29

        RSEG CODE:CODE:NOROOT(1)
bindingAddrMgsHelperConvertShort:
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function bindingAddrMgsHelperConvertShort
        FUNCALL bindingAddrMgsHelperConvertShort, AddrMgrEntryGet
        LOCFRAME CSTACK, 18, STACK
        SUB.W   #0xe, SP
          CFI CFA SP+18
        CALLA   #?Subroutine2
??CrossCallReturnLabel_3:
        MOV.W   0x2(SP), R12
        ADD.W   #0xe, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock30

        RSEG CODE:CODE:NOROOT(1)
bindingAddrMgsHelperConvert:
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function bindingAddrMgsHelperConvert
        FUNCALL bindingAddrMgsHelperConvert, AddrMgrEntryGet
        LOCFRAME CSTACK, 22, STACK
        FUNCALL bindingAddrMgsHelperConvert, sAddrExtCpy
        LOCFRAME CSTACK, 22, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        SUB.W   #0xe, SP
          CFI CFA SP+22
        MOV.W   R13, R11
        CALLA   #?Subroutine2
??CrossCallReturnLabel_2:
        MOV.B   R12, R10
        CMP.B   #0x0, R12
        JEQ     ??bindingAddrMgsHelperConvert_0
        MOV.B   #0x3, 0x8(R11)
        MOV.W   SP, R13
        ADD.W   #0x4, R13
        MOV.W   R11, R12
        CALLA   #sAddrExtCpy
??bindingAddrMgsHelperConvert_0:
        MOV.B   R10, R12
        ADD.W   #0xe, SP
          CFI CFA SP+8
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock31

        RSEG CODE:CODE:NOROOT(1)
?Subroutine2:
          CFI Block cfiCond32 Using cfiCommon0
          CFI Function bindingAddrMgsHelperConvertShort
          CFI Conditional ??CrossCallReturnLabel_3
          CFI CFA SP+22
          CFI Block cfiCond33 Using cfiCommon0
          CFI (cfiCond33) Function bindingAddrMgsHelperConvert
          CFI (cfiCond33) Conditional ??CrossCallReturnLabel_2
          CFI (cfiCond33) R10L Frame(CFA, -8)
          CFI (cfiCond33) R11L Frame(CFA, -6)
          CFI (cfiCond33) CFA SP+26
          CFI Block cfiPicker34 Using cfiCommon1
          CFI (cfiPicker34) NoFunction
          CFI (cfiPicker34) Picker
        MOV.B   #0x4, 0x4(SP)
        MOV.W   R12, 0x10(SP)
        MOV.W   SP, R12
        ADD.W   #0x4, R12
        BRA     #AddrMgrEntryGet
          CFI EndBlock cfiCond32
          CFI EndBlock cfiCond33
          CFI EndBlock cfiPicker34

        RSEG CODE:CODE:REORDER:NOROOT(1)
bindingAddrMgsHelperFind:
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function bindingAddrMgsHelperFind
        FUNCALL bindingAddrMgsHelperFind, AddrMgrEntryLookupNwk
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindingAddrMgsHelperFind, AddrMgrExtAddrSet
        LOCFRAME CSTACK, 20, STACK
        FUNCALL bindingAddrMgsHelperFind, AddrMgrEntryLookupExt
        LOCFRAME CSTACK, 20, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        SUB.W   #0xe, SP
          CFI CFA SP+20
        MOV.B   #0x4, 0(SP)
        MOV.W   SP, R10
        ADD.W   #0x0, R10
        CMP.B   #0x2, 0x8(R12)
        JNE     ??bindingAddrMgsHelperFind_0
        CALLA   #?Subroutine4
??CrossCallReturnLabel_5:
        JMP     ??bindingAddrMgsHelperFind_1
??bindingAddrMgsHelperFind_0:
        CALLA   #?Subroutine3
??bindingAddrMgsHelperFind_1:
        JMP     ?Subroutine0
          CFI EndBlock cfiBlock35
//  893 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine4:
          CFI Block cfiCond36 Using cfiCommon0
          CFI Function bindAddrIndexGet
          CFI Conditional ??CrossCallReturnLabel_6
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+24
          CFI Block cfiCond37 Using cfiCommon0
          CFI (cfiCond37) Function bindingAddrMgsHelperFind
          CFI (cfiCond37) Conditional ??CrossCallReturnLabel_5
          CFI (cfiCond37) R10L Frame(CFA, -6)
          CFI (cfiCond37) CFA SP+24
          CFI Block cfiPicker38 Using cfiCommon1
          CFI (cfiPicker38) NoFunction
          CFI (cfiPicker38) Picker
//  894 
//  895 /*********************************************************************
//  896  * @fn      bindingAddrMgsHelperConvert
//  897  *
//  898  * @brief   Convert an index into an zAddrType_t
//  899  *
//  900  * @param   idx -
//  901  * @param   addr - zAddrType_t
//  902  *
//  903  * @return  TRUE if found, FALSE if not
//  904  */
//  905 uint8 bindingAddrMgsHelperConvert( uint16 idx, zAddrType_t *addr )
//  906 {
//  907   AddrMgrEntry_t entry;
//  908   uint8 stat;
//  909 
//  910   // Resolve addresses with the address manager
//  911   entry.user = ADDRMGR_USER_BINDING;
//  912   entry.index = idx;
//  913   stat = AddrMgrEntryGet( &entry );
//  914   if ( stat )
//  915   {
//  916     addr->addrMode = Addr64Bit;
//  917     osal_cpyExtAddr( addr->addr.extAddr, entry.extAddr );
//  918   }
//  919 
//  920   return ( stat );
//  921 }
//  922 
//  923 /*********************************************************************
//  924  * @fn      bindingAddrMgsHelperConvertShort
//  925  *
//  926  * @brief   Convert an index into a short address
//  927  *
//  928  * @param   idx -
//  929  *
//  930  * @return  INVALID_NODE_ADDR if not available, otherwise the short address
//  931  */
//  932 uint16 bindingAddrMgsHelperConvertShort( uint16 idx )
//  933 {
//  934   AddrMgrEntry_t entry;
//  935 
//  936   // Resolve addresses with the address manager
//  937   entry.user = ADDRMGR_USER_BINDING;
//  938   entry.index = idx;
//  939   AddrMgrEntryGet( &entry );
//  940 
//  941   return ( entry.nwkAddr );
//  942 }
//  943 
//  944 /*********************************************************************
//  945  * @fn      bindAddrMgrLocalLoad
//  946  *
//  947  * @brief   Load local(self and parent) address information into
//  948  *          Address Manager
//  949  *
//  950  * @param   none
//  951  *
//  952  * @return  none
//  953  */
//  954 void bindAddrMgrLocalLoad( void )
//  955 {
//  956   AddrMgrEntry_t entry;
//  957   uint16         parent;
//  958 
//  959   // add "local"(self and parent) address informtion into the Address
//  960   // Manager
//  961   if ( bindAddrMgrLocalLoaded == FALSE )
//  962   {
//  963     // add the device's address information
//  964     entry.user    = ADDRMGR_USER_BINDING;
//  965     entry.nwkAddr = _NIB.nwkDevAddress;
//  966     AddrMgrExtAddrSet( entry.extAddr, NLME_GetExtAddr() );
//  967     AddrMgrEntryUpdate( &entry );
//  968 
//  969     // make sure parent address is valid
//  970     parent = NLME_GetCoordShortAddr();
//  971     if ( ( parent != entry.nwkAddr     ) &&
//  972          ( parent != INVALID_NODE_ADDR )    )
//  973     {
//  974       // add the parent's address information
//  975       entry.nwkAddr = parent;
//  976       NLME_GetCoordExtAddr( entry.extAddr );
//  977       AddrMgrEntryUpdate( &entry );
//  978     }
//  979 
//  980     bindAddrMgrLocalLoaded = TRUE;
//  981   }
//  982 }
//  983 
//  984 /*********************************************************************
//  985  * @fn      bindAddrIndexGet
//  986  *
//  987  * @brief   Get bind address index.
//  988  *
//  989  * @param   addr - <zAddrType_t>
//  990  *
//  991  * @return  (uint16) address index
//  992  */
//  993 uint16 bindAddrIndexGet( zAddrType_t* addr )
//  994 {
//  995   AddrMgrEntry_t entry;
//  996   uint8          update;
//  997 
//  998   update = FALSE;
//  999 
// 1000   // sync binding addresses with the address manager
// 1001   entry.user = ADDRMGR_USER_BINDING;
// 1002 
// 1003   if ( addr->addrMode == Addr16Bit )
// 1004   {
// 1005     entry.nwkAddr = addr->addr.shortAddr;
        MOV.W   @R12, 0x6(SP)
// 1006 
// 1007     if ( AddrMgrEntryLookupNwk( &entry ) == FALSE )
        MOV.W   R10, R12
        BRA     #AddrMgrEntryLookupNwk
          CFI EndBlock cfiCond36
          CFI EndBlock cfiCond37
          CFI EndBlock cfiPicker38

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine3:
          CFI Block cfiCond39 Using cfiCommon0
          CFI Function bindAddrIndexGet
          CFI Conditional ??CrossCallReturnLabel_4
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+24
          CFI Block cfiCond40 Using cfiCommon0
          CFI (cfiCond40) Function bindingAddrMgsHelperFind
          CFI (cfiCond40) Conditional ??bindingAddrMgsHelperFind_1
          CFI (cfiCond40) R10L Frame(CFA, -6)
          CFI (cfiCond40) CFA SP+24
          CFI Block cfiPicker41 Using cfiCommon1
          CFI (cfiPicker41) NoFunction
          CFI (cfiPicker41) Picker
// 1008     {
// 1009       update = TRUE;
// 1010     }
// 1011   }
// 1012   else if ( addr->addrMode == Addr64Bit )
// 1013   {
// 1014     AddrMgrExtAddrSet( entry.extAddr, addr->addr.extAddr );
        CALLA   #?Subroutine6
// 1015 
// 1016     if ( AddrMgrEntryLookupExt( &entry ) == FALSE )
??CrossCallReturnLabel_10:
        BRA     #AddrMgrEntryLookupExt
          CFI EndBlock cfiCond39
          CFI EndBlock cfiCond40
          CFI EndBlock cfiPicker41

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine6:
          CFI Block cfiCond42 Using cfiCommon0
          CFI Function bindAddrMgrLocalLoad
          CFI Conditional ??CrossCallReturnLabel_9
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+24
          CFI Block cfiCond43 Using cfiCommon0
          CFI (cfiCond43) Function bindAddrIndexGet
          CFI (cfiCond43) Conditional ??CrossCallReturnLabel_10, ??CrossCallReturnLabel_4
          CFI (cfiCond43) R10L Frame(CFA, -6)
          CFI (cfiCond43) CFA SP+28
          CFI Block cfiCond44 Using cfiCommon0
          CFI (cfiCond44) Function bindingAddrMgsHelperFind
          CFI (cfiCond44) Conditional ??CrossCallReturnLabel_10, ??bindingAddrMgsHelperFind_1
          CFI (cfiCond44) R10L Frame(CFA, -6)
          CFI (cfiCond44) CFA SP+28
          CFI Block cfiPicker45 Using cfiCommon1
          CFI (cfiPicker45) NoFunction
          CFI (cfiPicker45) Picker
        MOV.W   R12, R13
        MOV.W   R10, R12
        ADD.W   #0x4, R12
        CALLA   #AddrMgrExtAddrSet
        MOV.W   R10, R12
        RETA
          CFI EndBlock cfiCond42
          CFI EndBlock cfiCond43
          CFI EndBlock cfiCond44
          CFI EndBlock cfiPicker45
// 1017     {
// 1018       update = TRUE;
// 1019     }
// 1020   }
// 1021   else if ( addr->addrMode == AddrGroup )
// 1022   {
// 1023     entry.index = addr->addr.shortAddr;
// 1024   }
// 1025   else
// 1026   {
// 1027     entry.index = INVALID_NODE_ADDR;
// 1028   }
// 1029 
// 1030   if ( update )
// 1031   {
// 1032     AddrMgrEntryUpdate( &entry );
// 1033   }
// 1034 
// 1035   return entry.index;
// 1036 }
// 1037 
// 1038 /*********************************************************************
// 1039  * @fn      GetBindingTableEntry
// 1040  *
// 1041  * @brief   Get a pointer to the Nth valid binding table entry.
// 1042  *
// 1043  * @param   Nth valid entry being requested.
// 1044  *
// 1045  * @return  The Nth valid binding table entry.
// 1046  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1047 BindingEntry_t *GetBindingTableEntry( uint16 Nth )
GetBindingTableEntry:
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function GetBindingTableEntry
// 1048 {
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
// 1049   BindingEntry_t *rtrn = NULL;
        MOV.W   #0x0, R14
// 1050 
// 1051 #if defined ( REFLECTOR )
// 1052   uint16 idx, cnt = 0;
        MOV.W   #0x0, R13
// 1053 
// 1054   for ( idx = 0; idx < gNWK_MAX_BINDING_ENTRIES; idx++ )
        MOV.W   #0x0, R10
        JMP     ??GetBindingTableEntry_1
??GetBindingTableEntry_0:
        ADD.W   #0x1, R10
??GetBindingTableEntry_1:
        CMP.W   &gNWK_MAX_BINDING_ENTRIES, R10
        JC      ??GetBindingTableEntry_2
// 1055   {
// 1056     if ( BindingTable[idx].srcEP != NV_BIND_EMPTY )
        MOV.W   R10, R11
        RPT     #0xd
        ADDX.W  R10, R11
        CMP.B   #0xff, BindingTable(R11)
        JEQ     ??GetBindingTableEntry_0
// 1057     {
// 1058       if ( cnt++ == Nth )
        MOV.W   R13, R15
        ADD.W   #0x1, R13
        CMP.W   R12, R15
        JNE     ??GetBindingTableEntry_0
// 1059       {
// 1060         rtrn = BindingTable+idx;
        MOV.W   R11, R14
        ADD.W   #BindingTable, R14
// 1061         break;
// 1062       }
// 1063     }
// 1064   }
// 1065 #else
// 1066   (void)Nth;
// 1067 #endif
// 1068 
// 1069   return rtrn;
??GetBindingTableEntry_2:
        MOV.W   R14, R12
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock46
// 1070 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 1071 
// 1072 /*********************************************************************
// 1073 *********************************************************************/
// 
// 1 774 bytes in segment CODE
//    29 bytes in segment DATA16_Z
// 
// 1 774 bytes of CODE memory
//    29 bytes of DATA memory
//
//Errors: none
//Warnings: none

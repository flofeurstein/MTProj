###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       10/Jun/2013  16:27:28 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\st #
#                     ack\zdo\ZDObject.c                                      #
#    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleLight\CC2520DB\..\..\..\Too #
#                     ls\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0       #
#                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                       #
#                     -DDEFAULT_CHANLIST=0x00000800                           #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100      #
#                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                   #
#                     -DBEACON_REQUEST_DELAY=100                              #
#                     -DBEACON_REQ_DELAY_MASK=0x00FF                          #
#                     -DLINK_STATUS_JITTER_MASK=0x007F                        #
#                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED= #
#                     3000 -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8  #
#                     -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2     #
#                     -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9              #
#                     -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40                #
#                     -DNWK_MAX_BINDING_ENTRIES=4                             #
#                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,       #
#                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,   #
#                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                    #
#                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=2 #
#                     0 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000           #
#                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100         #
#                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\f8 #
#                     wRouter.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                     E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8            #
#                     -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "C:\Texas              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\f8 #
#                     wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC           #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)                #
#                     -DZCL_DEVICE_MGMT "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Components\stack\zdo\Z #
#                     DObject.c" -D MSP430F2618 -D ZTOOL_P1 -D MT_TASK -D     #
#                     MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED -lC         #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\Router\List\"   #
#                     -lA "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects #
#                     \zstack\HomeAutomation\SampleLight\CC2520DB\Router\List #
#                     \" --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826    #
#                     -o "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleLight\CC2520DB\Router\Obj\" #
#                      --debug -D__MSP430F2618__ -e --double=32 --clib -I     #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\" -I "C:\Texas  #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\Source\" -I "C:\Texas  #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\Source\" -I         #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\..\..\..\ZMain\ #
#                     MSP2618\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1 #
#                     \Projects\zstack\HomeAutomation\SampleLight\CC2520DB\.. #
#                     \..\..\..\..\Components\hal\include\" -I "C:\Texas      #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \hal\target\MSP2618CC2520\" -I "C:\Texas                #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\include\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\high_level\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\low_level\srf04\" -I "C:\Texas                     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\low_level\srf04\dual_chip\" -I "C:\Texas           #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pro #
#                     jects\zstack\HomeAutomation\SampleLight\CC2520DB\..\..\ #
#                     ..\..\..\Components\osal\include\" -I "C:\Texas         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \osal\mcu\msp430\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \services\saddr\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \services\sdata\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\af\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5 #
#                     .1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB\ #
#                     ..\..\..\..\..\Components\stack\nwk\" -I "C:\Texas      #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\sec\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\stack\sapi\" -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\sys\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\stack\zcl\" -I "C:\Texas     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\zdo\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\zmac\" -I "C:\Texas          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \zmac\f8w\" --core=430X --data_model=small -Ohz         #
#                     --multiplier=16s --require_prototypes                   #
#    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleLight\CC2520DB\Router\List\ZDOb #
#                     ject.lst                                                #
#    Object file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleLight\CC2520DB\Router\Obj\ZDObj #
#                     ect.r43                                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\stack\zdo\ZDObject.c
      1          /**************************************************************************************************
      2            Filename:       ZDObject.c
      3            Revised:        $Date: 2011-07-13 10:55:53 -0700 (Wed, 13 Jul 2011) $
      4            Revision:       $Revision: 26766 $
      5          
      6            Description:    This is the Zigbee Device Object.
      7          
      8          
      9            Copyright 2004-2011 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComdef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Nv.h"
     46          #include "rtg.h"
     47          #include "NLMEDE.h"
     48          #include "nwk_globals.h"
     49          #include "APS.h"
     50          #include "APSMEDE.h"
     51          #include "AssocList.h"
     52          #include "BindingTable.h"
     53          #include "AddrMgr.h"
     54          #include "AF.h"
     55          #include "ZDObject.h"
     56          #include "ZDProfile.h"
     57          #include "ZDConfig.h"
     58          #include "ZDSecMgr.h"
     59          #include "ZDApp.h"
     60          #include "nwk_util.h"   // NLME_IsAddressBroadcast()
     61          #include "ZGlobals.h"
     62          #if defined MT_ZDO_CB_FUNC
     63          #include "MT.h"
     64          #endif
     65          
     66          #if defined( LCD_SUPPORTED )
     67            #include "OnBoard.h"
     68          #endif
     69          
     70          /* HAL */
     71          #include "hal_lcd.h"
     72          
     73          /*********************************************************************
     74           * MACROS
     75           */
     76          
     77          /*********************************************************************
     78           * CONSTANTS
     79           */
     80          // NLME Stub Implementations
     81          #define ZDO_ProcessMgmtPermitJoinTimeout NLME_PermitJoiningTimeout
     82          
     83          // Status fields used by ZDO_ProcessMgmtRtgReq
     84          #define ZDO_MGMT_RTG_ENTRY_ACTIVE             0x00
     85          #define ZDO_MGMT_RTG_ENTRY_DISCOVERY_UNDERWAY 0x01
     86          #define ZDO_MGMT_RTG_ENTRY_DISCOVERY_FAILED   0x02
     87          #define ZDO_MGMT_RTG_ENTRY_INACTIVE           0x03
     88          
     89          /*********************************************************************
     90           * TYPEDEFS
     91           */
     92          #if defined ( REFLECTOR )
     93          typedef struct
     94          {
     95            byte SrcTransSeq;
     96            zAddrType_t SrcAddr;
     97            uint16 LocalCoordinator;
     98            byte epIntf;
     99            uint16 ProfileID;
    100            byte numInClusters;
    101            uint16 *inClusters;
    102            byte numOutClusters;
    103            uint16 *outClusters;
    104            byte SecurityUse;
    105            byte status;
    106          } ZDO_EDBind_t;
    107          #endif // defined ( REFLECTOR )
    108          
    109          enum
    110          {
    111            ZDMATCH_INIT,           // Initialized
    112            ZDMATCH_WAIT_REQ,       // Received first request, waiting for second
    113            ZDMATCH_SENDING_BINDS   // Received both requests, sending unbind/binds
    114          };
    115          
    116          enum
    117          {
    118            ZDMATCH_SENDING_NOT,
    119            ZDMATCH_SENDING_UNBIND,
    120            ZDMATCH_SENDING_BIND
    121          };
    122          
    123          /*********************************************************************
    124           * GLOBAL VARIABLES
    125           */
    126          
    127          /*********************************************************************
    128           * EXTERNAL VARIABLES
    129           */
    130          
    131          /*********************************************************************
    132           * EXTERNAL FUNCTIONS
    133           */
    134          
    135          /*********************************************************************
    136           * LOCAL VARIABLES
    137           */

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    138          static uint16 ZDOBuildBuf[26];  // temp area to build data without allocation
   \                     ZDOBuildBuf:
   \   000000                DS8 52
    139          
    140          #if defined ( REFLECTOR )

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    141          static ZDO_EDBind_t *ZDO_EDBind;     // Null when not used
   \                     ZDO_EDBind:
   \   000000                DS8 2
    142          #endif
    143          
    144          #if defined ( MANAGED_SCAN )
    145            uint32 managedScanNextChannel = 0;
    146            uint32 managedScanChannelMask = 0;
    147            uint8  managedScanTimesPerChannel = 0;
    148          #endif
    149          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    150          ZDMatchEndDeviceBind_t *matchED = (ZDMatchEndDeviceBind_t *)NULL;
   \                     matchED:
   \   000000                DS8 2
    151          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    152          uint32 apsChannelMask = 0;
   \                     apsChannelMask:
   \   000000                DS8 4
    153          
    154          /*********************************************************************
    155           * LOCAL FUNCTIONS
    156           */
    157          static void ZDODeviceSetup( void );
    158          #if defined ( MANAGED_SCAN )
    159            static void ZDOManagedScan_Next( void );
    160          #endif
    161          #if defined ( REFLECTOR )
    162            static void ZDO_RemoveEndDeviceBind( void );
    163            static void ZDO_SendEDBindRsp( byte TransSeq, zAddrType_t *dstAddr, byte Status, byte secUse );
    164          #endif
    165          static byte ZDO_CompareClusterLists( byte numList1, uint16 *list1,
    166                                          byte numList2, uint16 *list2, uint16 *pMatches );
    167          static void ZDO_RemoveMatchMemory( void );
    168          static uint8 ZDO_CopyMatchInfo( ZDEndDeviceBind_t *destReq, ZDEndDeviceBind_t *srcReq );
    169          static void ZDO_EndDeviceBindMatchTimeoutCB( void );
    170          uint8 *ZDO_ConvertOTAClusters( uint8 cnt, uint8 *inBuf, uint16 *outList );
    171          static void zdoSendStateChangeMsg(uint8 state, uint8 taskId);
    172          
    173          /*********************************************************************
    174           * @fn          ZDO_Init
    175           *
    176           * @brief       ZDObject and ZDProfile initialization.
    177           *
    178           * @param       none
    179           *
    180           * @return      none
    181           */

   \                                 In  segment CODE, align 2
    182          void ZDO_Init( void )
   \                     ZDO_Init:
    183          {
    184            // Initialize ZD items
    185            #if defined ( REFLECTOR )
    186            ZDO_EDBind = NULL;
   \   000000   8243....     MOV.W   #0x0, &ZDO_EDBind
    187            #endif
    188          
    189            // Initialize default ZDO_UseExtendedPANID to the APS one.
    190            osal_cpyExtAddr( ZDO_UseExtendedPANID, AIB_apsUseExtendedPANID );
   \   000004   3D40....     MOV.W   #AIB_apsUseExtendedPANID, R13
   \   000008   3C40....     MOV.W   #ZDO_UseExtendedPANID, R12
   \   00000C   ........     CALLA   #sAddrExtCpy
    191          
    192            // Setup the device - type of device to create.
    193            ZDODeviceSetup();
   \   000010   C293....     CMP.B   #0x0, &zgDeviceLogicalType
   \   000014   0224         JEQ     ??ZDO_Init_0
   \   000016   5C43         MOV.B   #0x1, R12
   \   000018   013C         JMP     ??ZDO_Init_1
   \                     ??ZDO_Init_0:
   \   00001A   4C43         MOV.B   #0x0, R12
   \                     ??ZDO_Init_1:
   \   00001C   ........     CALLA   #APS_ReflectorInit
   \   000020   ........     BRA     #NLME_DeviceJoiningInit
    194          }
    195          
    196          #if defined ( MANAGED_SCAN )
    197          /*********************************************************************
    198           * @fn      ZDOManagedScan_Next()
    199           *
    200           * @brief   Setup a managed scan.
    201           *
    202           * @param   none
    203           *
    204           * @return  none
    205           */
    206          static void ZDOManagedScan_Next( void )
    207          {
    208            // Is it the first time
    209            if ( managedScanNextChannel == 0 && managedScanTimesPerChannel == 0 )
    210            {
    211              // Setup the defaults
    212              managedScanNextChannel  = 1;
    213          
    214              while( managedScanNextChannel && (zgDefaultChannelList & managedScanNextChannel) == 0 )
    215                managedScanNextChannel <<= 1;
    216          
    217              managedScanChannelMask = managedScanNextChannel;
    218              managedScanTimesPerChannel = MANAGEDSCAN_TIMES_PRE_CHANNEL;
    219            }
    220            else
    221            {
    222              // Do we need to go to the next channel
    223              if ( managedScanTimesPerChannel == 0 )
    224              {
    225                // Find next active channel
    226                managedScanChannelMask  = managedScanNextChannel;
    227                managedScanTimesPerChannel = MANAGEDSCAN_TIMES_PRE_CHANNEL;
    228              }
    229              else
    230              {
    231                managedScanTimesPerChannel--;
    232          
    233                if ( managedScanTimesPerChannel == 0 )
    234                {
    235                  managedScanNextChannel  <<= 1;
    236                  while( managedScanNextChannel && (zgDefaultChannelList & managedScanNextChannel) == 0 )
    237                    managedScanNextChannel <<= 1;
    238          
    239                  if ( managedScanNextChannel == 0 )
    240                    zdoDiscCounter  = NUM_DISC_ATTEMPTS + 1; // Stop
    241                }
    242              }
    243            }
    244          }
    245          #endif // MANAGED_SCAN
    246          
    247          /*********************************************************************
    248           * @fn      ZDODeviceSetup()
    249           *
    250           * @brief   Call set functions depending on the type of device compiled.
    251           *
    252           * @param   none
    253           *
    254           * @return  none
    255           */
    256          static void ZDODeviceSetup( void )
    257          {
    258            if ( ZG_BUILD_COORDINATOR_TYPE )
    259            {
    260              NLME_CoordinatorInit();
    261            }
    262          
    263          #if defined ( REFLECTOR )
    264            APS_ReflectorInit( (ZG_DEVICE_COORDINATOR_TYPE) ? APS_REFLECTOR_PUBLIC :  APS_REFLECTOR_PRIVATE );
    265          #endif
    266          
    267            if ( ZG_BUILD_JOINING_TYPE )
    268            {
    269              NLME_DeviceJoiningInit();
    270            }
    271          }
    272          
    273          /*********************************************************************
    274           * @fn          ZDO_StartDevice
    275           *
    276           * @brief       This function starts a device in a network.
    277           *
    278           * @param       logicalType     - Device type to start
    279           *              startMode       - indicates mode of device startup
    280           *              beaconOrder     - indicates time betwen beacons
    281           *              superframeOrder - indicates length of active superframe
    282           *
    283           * @return      none
    284           */

   \                                 In  segment CODE, align 2
    285          void ZDO_StartDevice( byte logicalType, devStartModes_t startMode, byte beaconOrder, byte superframeOrder )
   \                     ZDO_StartDevice:
    286          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31800C00     SUB.W   #0xc, SP
   \   000006   4A4D         MOV.B   R13, R10
    287            ZStatus_t ret;
    288          #if defined ( ZIGBEE_FREQ_AGILITY )
    289            static uint8 discRetries = 0;
    290          #endif
    291          #if defined ( ZIGBEE_COMMISSIONING )
    292            static uint8 scanCnt = 0;
    293          #endif
    294          
    295            ret = ZUnsupportedMode;
    296          
    297            if ( ZG_BUILD_COORDINATOR_TYPE && logicalType == NODETYPE_COORDINATOR )
    298            {
    299              if ( startMode == MODE_HARD )
    300              {
    301                devState = DEV_COORD_STARTING;
    302                ret = NLME_NetworkFormationRequest( zgConfigPANID, zgApsUseExtendedPANID, zgDefaultChannelList,
    303                                                    zgDefaultStartingScanDuration, beaconOrder,
    304                                                    superframeOrder, false );
    305              }
    306              else if ( startMode == MODE_RESUME )
    307              {
    308                // Just start the coordinator
    309                devState = DEV_COORD_STARTING;
    310                ret = NLME_StartRouterRequest( beaconOrder, beaconOrder, false );
    311              }
    312              else
    313              {
    314          #if defined( LCD_SUPPORTED )
    315                HalLcdWriteScreen( "StartDevice ERR", "MODE unknown" );
    316          #endif
    317              }
    318            }
    319          
    320            if ( ZG_BUILD_JOINING_TYPE && (logicalType == NODETYPE_ROUTER || logicalType == NODETYPE_DEVICE) )
   \   000008   5C93         CMP.B   #0x1, R12
   \   00000A   0224         JEQ     ??ZDO_StartDevice_3
   \   00000C   6C93         CMP.B   #0x2, R12
   \   00000E   2B20         JNE     ??ZDO_StartDevice_2
    321            {
    322              if ( (startMode == MODE_JOIN) || (startMode == MODE_REJOIN) )
   \                     ??ZDO_StartDevice_3:
   \   000010   5E42....     MOV.B   &zgDefaultStartingScanDuration, R14
   \   000014   4D93         CMP.B   #0x0, R13
   \   000016   0324         JEQ     ??ZDO_StartDevice_4
   \   000018   7D900300     CMP.B   #0x3, R13
   \   00001C   2F20         JNE     ??ZDO_StartDevice_5
    323              {
    324                devState = DEV_NWK_DISC;
   \                     ??ZDO_StartDevice_4:
   \   00001E   E243....     MOV.B   #0x2, &devState
    325          
    326            #if defined( MANAGED_SCAN )
    327                ZDOManagedScan_Next();
    328                ret = NLME_NetworkDiscoveryRequest( managedScanChannelMask, BEACON_ORDER_15_MSEC );
    329            #else
    330                ret = NLME_NetworkDiscoveryRequest( zgDefaultChannelList, zgDefaultStartingScanDuration );
   \   000022   1C42....     MOV.W   &zgDefaultChannelList, R12
   \   000026   1D42....     MOV.W   &zgDefaultChannelList + 2, R13
   \   00002A   ........     CALLA   #NLME_NetworkDiscoveryRequest
    331              #if defined ( ZIGBEE_FREQ_AGILITY )
    332                if ( !( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE ) &&
    333                      ( ret == ZSuccess ) && ( ++discRetries == 4 ) )
   \   00002E   F2B2....     BIT.B   #0x8, &ZDO_Config_Node_Descriptor + 2
   \   000032   092C         JC      ??ZDO_StartDevice_6
   \   000034   4C93         CMP.B   #0x0, R12
   \   000036   0720         JNE     ??ZDO_StartDevice_6
   \   000038   D253....     ADD.B   #0x1, &??discRetries
   \   00003C   E292....     CMP.B   #0x4, &??discRetries
   \   000040   0220         JNE     ??ZDO_StartDevice_6
    334                {
    335                  // For devices with RxOnWhenIdle equals to FALSE, any network channel
    336                  // change will not be recieved. On these devices or routers that have
    337                  // lost the network, an active scan shall be conducted on the Default
    338                  // Channel list using the extended PANID to find the network. If the
    339                  // extended PANID isn't found using the Default Channel list, an scan
    340                  // should be completed using all channels.
    341                  zgDefaultChannelList = MAX_CHANNELS_24GHZ;
   \   000042   ........     CALLA   #?Subroutine26
    342                }
    343              #endif // ZIGBEE_FREQ_AGILITY
    344              #if defined ( ZIGBEE_COMMISSIONING )
    345                if (startMode == MODE_REJOIN && scanCnt++ >= 5 )
   \                     ??ZDO_StartDevice_6:
   \   000046   7A900300     CMP.B   #0x3, R10
   \   00004A   0B20         JNE     ??ZDO_StartDevice_1
   \   00004C   5E42....     MOV.B   &??scanCnt, R14
   \   000050   4F4E         MOV.B   R14, R15
   \   000052   5F53         ADD.B   #0x1, R15
   \   000054   C24F....     MOV.B   R15, &??scanCnt
   \   000058   7E900500     CMP.B   #0x5, R14
   \   00005C   0228         JNC     ??ZDO_StartDevice_1
    346                {
    347                  // When ApsUseExtendedPanID is commissioned to a non zero value via
    348                  // application specific means, the device shall conduct an active scan
    349                  // on the Default Channel list and join the PAN with the same
    350                  // ExtendedPanID. If the PAN is not found, an scan should be completed
    351                  // on all channels.
    352                  // When devices rejoin the network and the PAN is not found from
    353                  zgDefaultChannelList = MAX_CHANNELS_24GHZ;
   \   00005E   ........     CALLA   #?Subroutine26
    354                }
    355              #endif // ZIGBEE_COMMISSIONING
    356            #endif
    357              }
    358              else if ( startMode == MODE_RESUME )
    359              {
    360                if ( logicalType == NODETYPE_ROUTER )
    361                {
    362                  ZMacScanCnf_t scanCnf;
    363                  devState = DEV_NWK_ORPHAN;
    364          
    365                  /* if router and nvram is available, fake successful orphan scan */
    366                  scanCnf.hdr.Status = ZSUCCESS;
    367                  scanCnf.ScanType = ZMAC_ORPHAN_SCAN;
    368                  scanCnf.UnscannedChannels = 0;
    369                  scanCnf.ResultListSize = 0;
    370                  nwk_ScanJoiningOrphan(&scanCnf);
    371          
    372                  ret = ZSuccess;
    373                }
    374                else
    375                {
    376                  devState = DEV_NWK_ORPHAN;
    377                  ret = NLME_OrphanJoinRequest( zgDefaultChannelList,
    378                                                zgDefaultStartingScanDuration );
    379                }
    380              }
    381              else
    382              {
    383          #if defined( LCD_SUPPORTED )
    384                HalLcdWriteScreen( "StartDevice ERR", "MODE unknown" );
    385          #endif
    386              }
    387            }
    388          
    389            if ( ret != ZSuccess )
   \                     ??ZDO_StartDevice_1:
   \   000062   4C93         CMP.B   #0x0, R12
   \   000064   0724         JEQ     ??ZDO_StartDevice_0
    390            {
    391              osal_start_timerEx(ZDAppTaskID, ZDO_NETWORK_INIT, NWK_RETRY_DELAY );
   \                     ??ZDO_StartDevice_2:
   \   000066   3E40E803     MOV.W   #0x3e8, R14
   \   00006A   1D43         MOV.W   #0x1, R13
   \   00006C   5C42....     MOV.B   &ZDAppTaskID, R12
   \   000070   ........     CALLA   #osal_start_timerEx
    392            }
    393          }
   \                     ??ZDO_StartDevice_0:
   \   000074   31500C00     ADD.W   #0xc, SP
   \   000078   3A41         POP.W   R10
   \   00007A   1001         RETA
   \                     ??ZDO_StartDevice_5:
   \   00007C   5D93         CMP.B   #0x1, R13
   \   00007E   1C20         JNE     ??ZDO_StartDevice_7
   \   000080   5C93         CMP.B   #0x1, R12
   \   000082   F2400A00.... MOV.B   #0xa, &devState
   \   000088   1020         JNE     ??ZDO_StartDevice_8
   \   00008A   C1430100     MOV.B   #0x0, 0x1(SP)
   \   00008E   F14003000200 MOV.B   #0x3, 0x2(SP)
   \   000094   81430400     MOV.W   #0x0, 0x4(SP)
   \   000098   81430600     MOV.W   #0x0, 0x6(SP)
   \   00009C   C1430800     MOV.B   #0x0, 0x8(SP)
   \   0000A0   0C41         MOV.W   SP, R12
   \   0000A2   0C53         ADD.W   #0x0, R12
   \   0000A4   ........     CALLA   #nwk_ScanJoiningOrphan
   \   0000A8   E53F         JMP     ??ZDO_StartDevice_0
   \                     ??ZDO_StartDevice_8:
   \   0000AA   1C42....     MOV.W   &zgDefaultChannelList, R12
   \   0000AE   1D42....     MOV.W   &zgDefaultChannelList + 2, R13
   \   0000B2   ........     CALLA   #NLME_OrphanJoinRequest
   \   0000B6   D53F         JMP     ??ZDO_StartDevice_1
   \                     ??ZDO_StartDevice_7:
   \   0000B8   3D40....     MOV.W   #`?<Constant "MODE unknown">`, R13
   \   0000BC   3C40....     MOV.W   #`?<Constant "StartDevice ERR">`, R12
   \   0000C0   ........     CALLA   #HalLcdWriteScreen
   \   0000C4   D03F         JMP     ??ZDO_StartDevice_2

   \                                 In  segment CODE, align 2
   \                     ?Subroutine26:
   \   000000   B24000F8.... MOV.W   #0xf800, &zgDefaultChannelList
   \   000006   B240FF07.... MOV.W   #0x7ff, &zgDefaultChannelList + 2
   \   00000C   1001         RETA

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??discRetries:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??scanCnt:
   \   000000                DS8 1
    394          
    395          /**************************************************************************************************
    396           * @fn          zdoSendStateChangeMsg
    397           *
    398           * @brief       Helper function for ZDO_UpdateNwkStatus.
    399           *
    400           * input parameters
    401           *
    402           * @param       taskId - The OSAL task identifier to which to send the ZDO_STATE_CHANGE_EVT.
    403           * @param       state - The current device state.
    404           *
    405           * output parameters
    406           *
    407           * None.
    408           *
    409           * @return      None.
    410           **************************************************************************************************
    411           */

   \                                 In  segment CODE, align 2
    412          static void zdoSendStateChangeMsg(uint8 state, uint8 taskId)
   \                     zdoSendStateChangeMsg:
    413          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
    414            osal_event_hdr_t *pMsg = (osal_event_hdr_t *)osal_msg_find(taskId, ZDO_STATE_CHANGE);
   \   000006   7D40D100     MOV.B   #0xd1, R13
   \   00000A   4C4B         MOV.B   R11, R12
   \   00000C   ........     CALLA   #osal_msg_find
    415          
    416            if (NULL == pMsg)
   \   000010   0C93         CMP.W   #0x0, R12
   \   000012   1620         JNE     ??zdoSendStateChangeMsg_0
    417            {
    418              if (NULL == (pMsg = (osal_event_hdr_t *)osal_msg_allocate(sizeof(osal_event_hdr_t))))
   \   000014   2C43         MOV.W   #0x2, R12
   \   000016   ........     CALLA   #osal_msg_allocate
   \   00001A   0C93         CMP.W   #0x0, R12
   \   00001C   0720         JNE     ??zdoSendStateChangeMsg_1
    419              {
    420                // Upon failure to notify any EndPoint of the state change, re-set the ZDO event to
    421                // try again later when more Heap may be available.
    422                osal_set_event(ZDAppTaskID, ZDO_STATE_CHANGE_EVT);
   \   00001E   3D401000     MOV.W   #0x10, R13
   \   000022   5C42....     MOV.B   &ZDAppTaskID, R12
   \   000026   ........     CALLA   #osal_set_event
   \   00002A   0C3C         JMP     ??zdoSendStateChangeMsg_2
    423              }
    424              else
    425              {
    426                pMsg->event = ZDO_STATE_CHANGE;
   \                     ??zdoSendStateChangeMsg_1:
   \   00002C   FC40D1000000 MOV.B   #0xd1, 0(R12)
    427                pMsg->status = state;
   \   000032   CC4A0100     MOV.B   R10, 0x1(R12)
    428          
    429                (void)osal_msg_send(taskId, (uint8 *)pMsg);
   \   000036   0D4C         MOV.W   R12, R13
   \   000038   4C4B         MOV.B   R11, R12
   \   00003A   ........     CALLA   #osal_msg_send
   \   00003E   023C         JMP     ??zdoSendStateChangeMsg_2
    430              }
    431            }
    432            else
    433            {
    434              // Modify in place the status of an existing ZDO_STATE_CHANGE message to the EndPoint.
    435              pMsg->status = state;
   \                     ??zdoSendStateChangeMsg_0:
   \   000040   CC4A0100     MOV.B   R10, 0x1(R12)
    436            }
    437          }
   \                     ??zdoSendStateChangeMsg_2:
   \   000044   1A17         POPM.W  #0x2, R11
   \   000046   1001         RETA
    438          
    439          /**************************************************************************************************
    440           * @fn          ZDO_UpdateNwkStatus
    441           *
    442           * @brief       This function sends a ZDO_STATE_CHANGE message to the task of every EndPoint
    443           *              registered with AF (except, of course, the ZDO_EP). Even if a single task has more
    444           *              than one registered EndPoint, it will only receive one notification per state
    445           *              change. Although the device may go through a sequence of state changes, the
    446           *              Application task may only receive notification of the final, steady-state state
    447           *              because it has the lowest priority and never even runs to receive the intermediate
    448           *              state change notifications.
    449           *
    450           * input parameters
    451           *
    452           * @param       state - The current device state.
    453           *
    454           * output parameters
    455           *
    456           * None.
    457           *
    458           * @return      None.
    459           **************************************************************************************************
    460           */

   \                                 In  segment CODE, align 2
    461          void ZDO_UpdateNwkStatus(devStates_t state)
   \                     ZDO_UpdateNwkStatus:
    462          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   4A4C         MOV.B   R12, R10
    463            epList_t *pItem = epList;
   \   000004   1B42....     MOV.W   &epList, R11
   \   000008   0C3C         JMP     ??ZDO_UpdateNwkStatus_1
    464          
    465            while (pItem != NULL)
    466            {
    467              if (pItem->epDesc->endPoint != ZDO_EP)
   \                     ??ZDO_UpdateNwkStatus_0:
   \   00000A   1F4B0200     MOV.W   0x2(R11), R15
   \   00000E   CF930000     CMP.B   #0x0, 0(R15)
   \   000012   0624         JEQ     ??ZDO_UpdateNwkStatus_2
    468              {
    469                zdoSendStateChangeMsg(state, *(pItem->epDesc->task_id));
   \   000014   1F4F0200     MOV.W   0x2(R15), R15
   \   000018   6D4F         MOV.B   @R15, R13
   \   00001A   4C4A         MOV.B   R10, R12
   \   00001C   ........     CALLA   #zdoSendStateChangeMsg
    470              }
    471          
    472              pItem = pItem->nextDesc;
   \                     ??ZDO_UpdateNwkStatus_2:
   \   000020   2B4B         MOV.W   @R11, R11
    473            }
   \                     ??ZDO_UpdateNwkStatus_1:
   \   000022   0B93         CMP.W   #0x0, R11
   \   000024   F223         JNE     ??ZDO_UpdateNwkStatus_0
    474          #if defined MT_ZDO_CB_FUNC
    475            zdoSendStateChangeMsg(state, MT_TaskID);
    476          #endif
    477          
    478            ZDAppNwkAddr.addr.shortAddr = NLME_GetShortAddr();
   \   000026   ........     CALLA   #NLME_GetShortAddr
   \   00002A   824C....     MOV.W   R12, &ZDAppNwkAddr
    479            (void)NLME_GetExtAddr();  // Load the saveExtAddr pointer.
   \   00002E   ........     CALLA   #NLME_GetExtAddr
    480          }
   \   000032   1A17         POPM.W  #0x2, R11
   \   000034   1001         RETA
    481          
    482          #if defined ( REFLECTOR )
    483          /*********************************************************************
    484           * @fn          ZDO_RemoveEndDeviceBind
    485           *
    486           * @brief       Remove the end device bind
    487           *
    488           * @param  none
    489           *
    490           * @return      none
    491           */
    492          static void ZDO_RemoveEndDeviceBind( void )
    493          {
    494            if ( ZDO_EDBind != NULL )
    495            {
    496              // Free the RAM
    497              if ( ZDO_EDBind->inClusters != NULL )
    498              {
    499                osal_mem_free( ZDO_EDBind->inClusters );
    500              }
    501              if ( ZDO_EDBind->outClusters != NULL )
    502              {
    503                osal_mem_free( ZDO_EDBind->outClusters );
    504              }
    505              osal_mem_free( ZDO_EDBind );
    506              ZDO_EDBind = NULL;
    507            }
    508          }
    509          #endif // REFLECTOR
    510          
    511          #if defined ( REFLECTOR )
    512          /*********************************************************************
    513           * @fn          ZDO_RemoveEndDeviceBind
    514           *
    515           * @brief       Remove the end device bind
    516           *
    517           * @param  none
    518           *
    519           * @return      none
    520           */
    521          static void ZDO_SendEDBindRsp( byte TransSeq, zAddrType_t *dstAddr, byte Status, byte secUse )
    522          {
    523            ZDP_EndDeviceBindRsp( TransSeq, dstAddr, Status, secUse );
    524          
    525          #if defined( LCD_SUPPORTED )
    526            HalLcdWriteString( "End Device Bind", HAL_LCD_LINE_1 );
    527            if ( Status == ZDP_SUCCESS )
    528            {
    529              HalLcdWriteString( "Success Sent", HAL_LCD_LINE_2 );
    530            }
    531            else
    532            {
    533              HalLcdWriteString( "Timeout", HAL_LCD_LINE_2 );
    534            }
    535          #endif
    536          
    537          }
    538          #endif // REFLECTOR
    539          
    540          /*********************************************************************
    541           * @fn          ZDO_CompareClusterLists
    542           *
    543           * @brief       Compare one list to another list
    544           *
    545           * @param       numList1 - number of items in list 1
    546           * @param       list1 - first list of cluster IDs
    547           * @param       numList2 - number of items in list 2
    548           * @param       list2 - second list of cluster IDs
    549           * @param       pMatches - buffer to put matches
    550           *
    551           * @return      number of matches
    552           */

   \                                 In  segment CODE, align 2
    553          static byte ZDO_CompareClusterLists( byte numList1, uint16 *list1,
   \                     ZDO_CompareClusterLists:
    554                                    byte numList2, uint16 *list2, uint16 *pMatches )
    555          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4E         MOV.B   R14, R11
   \   000006   084F         MOV.W   R15, R8
    556            byte x, y;
    557            uint16 z;
    558            byte numMatches = 0;
   \   000008   4C43         MOV.B   #0x0, R12
    559          
    560            // Check the first in against the seconds out
    561            for ( x = 0; x < numList1; x++ )
   \   00000A   4E43         MOV.B   #0x0, R14
   \   00000C   16411400     MOV.W   0x14(SP), R6
   \   000010   173C         JMP     ??ZDO_CompareClusterLists_2
    562            {
    563              for ( y = 0; y < numList2; y++ )
    564              {
    565                z = list2[y];
   \                     ??ZDO_CompareClusterLists_0:
   \   000012   474F         MOV.B   R15, R7
   \   000014   0757         RLA.W   R7
   \   000016   0948         MOV.W   R8, R9
   \   000018   0957         ADD.W   R7, R9
   \   00001A   2749         MOV.W   @R9, R7
    566                if ( list1[x] == z )
   \   00001C   494E         MOV.B   R14, R9
   \   00001E   0959         RLA.W   R9
   \   000020   044D         MOV.W   R13, R4
   \   000022   0459         ADD.W   R9, R4
   \   000024   84970000     CMP.W   R7, 0(R4)
   \   000028   0720         JNE     ??ZDO_CompareClusterLists_3
    567                {
    568                  pMatches[numMatches++] = z;
   \   00002A   444C         MOV.B   R12, R4
   \   00002C   0454         RLA.W   R4
   \   00002E   0946         MOV.W   R6, R9
   \   000030   0954         ADD.W   R4, R9
   \   000032   89470000     MOV.W   R7, 0(R9)
   \   000036   5C53         ADD.B   #0x1, R12
    569                }
    570              }
   \                     ??ZDO_CompareClusterLists_3:
   \   000038   5F53         ADD.B   #0x1, R15
   \                     ??ZDO_CompareClusterLists_1:
   \   00003A   4F9B         CMP.B   R11, R15
   \   00003C   EA2B         JNC     ??ZDO_CompareClusterLists_0
   \   00003E   5E53         ADD.B   #0x1, R14
   \                     ??ZDO_CompareClusterLists_2:
   \   000040   4E9A         CMP.B   R10, R14
   \   000042   022C         JC      ??ZDO_CompareClusterLists_4
   \   000044   4F43         MOV.B   #0x0, R15
   \   000046   F93F         JMP     ??ZDO_CompareClusterLists_1
    571            }
    572          
    573            return ( numMatches );
   \                     ??ZDO_CompareClusterLists_4:
   \   000048   7417         POPM.W  #0x8, R11
   \   00004A   1001         RETA
    574          }
    575          
    576          /*********************************************************************
    577           * Utility functions
    578           */
    579          
    580          /*********************************************************************
    581           * @fn          ZDO_CompareByteLists
    582           *
    583           * @brief       Compares two lists for matches.
    584           *
    585           * @param       ACnt  - number of entries in list A
    586           * @param       AList  - List A
    587           * @param       BCnt  - number of entries in list B
    588           * @param       BList  - List B
    589           *
    590           * @return      true if a match is found
    591           */

   \                                 In  segment CODE, align 2
    592          byte ZDO_AnyClusterMatches( byte ACnt, uint16 *AList, byte BCnt, uint16 *BList )
   \                     ZDO_AnyClusterMatches:
    593          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   484C         MOV.B   R12, R8
    594            byte x, y;
    595          
    596            for ( x = 0; x < ACnt; x++ )
   \   000004   4A43         MOV.B   #0x0, R10
   \   000006   013C         JMP     ??ZDO_AnyClusterMatches_3
   \                     ??ZDO_AnyClusterMatches_0:
   \   000008   5A53         ADD.B   #0x1, R10
   \                     ??ZDO_AnyClusterMatches_3:
   \   00000A   4A98         CMP.B   R8, R10
   \   00000C   4C43         MOV.B   #0x0, R12
   \   00000E   102C         JC      ??ZDO_AnyClusterMatches_2
    597            {
    598              for ( y = 0; y < BCnt; y++ )
   \   000010   013C         JMP     ??ZDO_AnyClusterMatches_4
   \                     ??ZDO_AnyClusterMatches_1:
   \   000012   5C53         ADD.B   #0x1, R12
   \                     ??ZDO_AnyClusterMatches_4:
   \   000014   4C9E         CMP.B   R14, R12
   \   000016   F82F         JC      ??ZDO_AnyClusterMatches_0
    599              {
    600                if ( AList[x] == BList[y] )
   \   000018   4B4A         MOV.B   R10, R11
   \   00001A   0B5B         RLA.W   R11
   \   00001C   094D         MOV.W   R13, R9
   \   00001E   095B         ADD.W   R11, R9
   \   000020   464C         MOV.B   R12, R6
   \   000022   0656         RLA.W   R6
   \   000024   0B4F         MOV.W   R15, R11
   \   000026   0B56         ADD.W   R6, R11
   \   000028   A99B0000     CMP.W   @R11, 0(R9)
   \   00002C   F223         JNE     ??ZDO_AnyClusterMatches_1
    601                {
    602                  return true;
   \   00002E   5C43         MOV.B   #0x1, R12
    603                }
    604              }
    605            }
    606          
    607            return false;
   \                     ??ZDO_AnyClusterMatches_2:
   \   000030   5617         POPM.W  #0x6, R11
   \   000032   1001         RETA
    608          }
    609          
    610          /*********************************************************************
    611           * Callback functions from ZDProfile
    612           */
    613          
    614          /*********************************************************************
    615           * @fn          ZDO_ProcessNodeDescReq
    616           *
    617           * @brief       This function processes and responds to the
    618           *              Node_Desc_req message.
    619           *
    620           * @param       inMsg - incoming message
    621           *
    622           * @return      none
    623           */

   \                                 In  segment CODE, align 2
   \                     ?Subroutine28:
   \   000000   5F4F0100     MOV.B   0x1(R15), R15
   \   000004                RPT     #0x8
   \   000004   47180F5F     RLAX.W  R15
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   0F4D         MOV.W   R13, R15
   \   000002   7E408000     MOV.B   #0x80, R14
   \   000006   0D4C         MOV.W   R12, R13
   \   000008   2D53         ADD.W   #0x2, R13
   \   00000A   5C4C1100     MOV.B   0x11(R12), R12
   \   00000E   ........     CALLA   #ZDP_GenericRsp
   \   000012   2152         ADD.W   #0x4, SP
   \   000014   1001         RETA

   \                                 In  segment CODE, align 2
    624          void ZDO_ProcessNodeDescReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessNodeDescReq:
    625          {
    626            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   \   000000   ........     CALLA   #?Subroutine18
    627            NodeDescriptorFormat_t *desc = NULL;
    628          
    629            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \                     ??CrossCallReturnLabel_28:
   \   000004   0420         JNE     ??ZDO_ProcessNodeDescReq_0
    630            {
    631              desc = &ZDO_Config_Node_Descriptor;
    632            }
    633          
    634            if ( desc != NULL )
    635            {
    636              ZDP_NodeDescMsg( inMsg, aoi, desc );
   \   000006   3E40....     MOV.W   #ZDO_Config_Node_Descriptor, R14
   \   00000A   ........     BRA     #ZDP_NodeDescMsg
    637            }
    638            else
    639            {
    640              ZDP_GenericRsp( inMsg->TransSeq, &(inMsg->srcAddr),
    641                        ZDP_INVALID_REQTYPE, aoi, Node_Desc_rsp, inMsg->SecurityUse );
   \                     ??ZDO_ProcessNodeDescReq_0:
   \   00000E   5C121000     PUSH.B  0x10(R12)
   \   000012   30120280     PUSH.W  #0x8002
   \   000016   ....         JMP     ?Subroutine0
    642            }
    643          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine18:
   \   000000   1F4C1600     MOV.W   0x16(R12), R15
   \   000004   6D4F         MOV.B   @R15, R13
   \   000006   ........     CALLA   #?Subroutine28
   \                     ??CrossCallReturnLabel_43:
   \   00000A   0D5F         ADD.W   R15, R13
   \   00000C   1D92....     CMP.W   &ZDAppNwkAddr, R13
   \   000010   1001         RETA
    644          
    645          /*********************************************************************
    646           * @fn          ZDO_ProcessPowerDescReq
    647           *
    648           * @brief       This function processes and responds to the
    649           *              Node_Power_req message.
    650           *
    651           * @param       inMsg  - incoming request
    652           *
    653           * @return      none
    654           */

   \                                 In  segment CODE, align 2, keep-with-next
    655          void ZDO_ProcessPowerDescReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessPowerDescReq:
    656          {
    657            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   \   000000   ........     CALLA   #?Subroutine18
    658            NodePowerDescriptorFormat_t *desc = NULL;
    659          
    660            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \                     ??CrossCallReturnLabel_27:
   \   000004   0420         JNE     ??ZDO_ProcessPowerDescReq_0
    661            {
    662              desc = &ZDO_Config_Power_Descriptor;
    663            }
    664          
    665            if ( desc != NULL )
    666            {
    667              ZDP_PowerDescMsg( inMsg, aoi, desc );
   \   000006   3E40....     MOV.W   #ZDO_Config_Power_Descriptor, R14
   \   00000A   ........     BRA     #ZDP_PowerDescMsg
    668            }
    669            else
    670            {
    671              ZDP_GenericRsp( inMsg->TransSeq, &(inMsg->srcAddr),
    672                        ZDP_INVALID_REQTYPE, aoi, Power_Desc_rsp, inMsg->SecurityUse );
   \                     ??ZDO_ProcessPowerDescReq_0:
   \   00000E   5C121000     PUSH.B  0x10(R12)
   \   000012   30120380     PUSH.W  #0x8003
   \   000016                REQUIRE ?Subroutine0
   \   000016                // Fall through to label ?Subroutine0
    673            }
    674          }
    675          
    676          /*********************************************************************
    677           * @fn          ZDO_ProcessSimpleDescReq
    678           *
    679           * @brief       This function processes and responds to the
    680           *              Simple_Desc_req message.
    681           *
    682           * @param       inMsg - incoming message (request)
    683           *
    684           * @return      none
    685           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine27_1:
   \   000000                RPT     #0x8
   \   000000   47180F5F     RLAX.W  R15
   \   000004   0E5F         ADD.W   R15, R14
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
    686          void ZDO_ProcessSimpleDescReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessSimpleDescReq:
    687          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4C         MOV.W   R12, R10
    688            SimpleDescriptionFormat_t *sDesc = NULL;
   \   000006   81430000     MOV.W   #0x0, 0(SP)
    689            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   \   00000A   1D4C1600     MOV.W   0x16(R12), R13
   \   00000E   6E4D         MOV.B   @R13, R14
   \   000010   5F4D0100     MOV.B   0x1(R13), R15
   \   000014   ........     CALLA   #??Subroutine27_1
    690            byte endPoint = inMsg->asdu[2];
   \                     ??CrossCallReturnLabel_52:
   \   000018   5D4D0200     MOV.B   0x2(R13), R13
    691            byte free = false;
   \   00001C   4B43         MOV.B   #0x0, R11
    692            byte stat = ZDP_SUCCESS;
   \   00001E   4843         MOV.B   #0x0, R8
    693          
    694            if ( (endPoint == ZDO_EP) || (endPoint > MAX_ENDPOINTS) )
   \   000020   4D93         CMP.B   #0x0, R13
   \   000022   0324         JEQ     ??ZDO_ProcessSimpleDescReq_0
   \   000024   7D90F100     CMP.B   #0xf1, R13
   \   000028   0328         JNC     ??ZDO_ProcessSimpleDescReq_1
    695            {
    696              stat = ZDP_INVALID_EP;
   \                     ??ZDO_ProcessSimpleDescReq_0:
   \   00002A   78408200     MOV.B   #0x82, R8
   \   00002E   103C         JMP     ??ZDO_ProcessSimpleDescReq_2
    697            }
    698            else if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \                     ??ZDO_ProcessSimpleDescReq_1:
   \   000030   1E92....     CMP.W   &ZDAppNwkAddr, R14
   \   000034   0B20         JNE     ??ZDO_ProcessSimpleDescReq_3
    699            {
    700              free = afFindSimpleDesc( &sDesc, endPoint );
   \   000036   0C41         MOV.W   SP, R12
   \   000038   0C53         ADD.W   #0x0, R12
   \   00003A   ........     CALLA   #afFindSimpleDesc
   \   00003E   4B4C         MOV.B   R12, R11
    701              if ( sDesc == NULL )
   \   000040   81930000     CMP.W   #0x0, 0(SP)
   \   000044   0520         JNE     ??ZDO_ProcessSimpleDescReq_2
    702              {
    703                stat = ZDP_NOT_ACTIVE;
   \   000046   78408300     MOV.B   #0x83, R8
   \   00004A   023C         JMP     ??ZDO_ProcessSimpleDescReq_2
    704              }
    705            }
    706            else
    707            {
    708              if ( ZSTACK_ROUTER_BUILD )
    709              {
    710                stat = ZDP_DEVICE_NOT_FOUND;
   \                     ??ZDO_ProcessSimpleDescReq_3:
   \   00004C   78408100     MOV.B   #0x81, R8
    711              }
    712              else if ( ZSTACK_END_DEVICE_BUILD )
    713              {
    714                stat = ZDP_INVALID_REQTYPE;
    715              }
    716            }
    717          
    718            ZDP_SimpleDescMsg( inMsg, stat, sDesc );
   \                     ??ZDO_ProcessSimpleDescReq_2:
   \   000050   2E41         MOV.W   @SP, R14
   \   000052   4D48         MOV.B   R8, R13
   \   000054   0C4A         MOV.W   R10, R12
   \   000056   ........     CALLA   #ZDP_SimpleDescMsg
    719          
    720            if ( free && sDesc )
   \   00005A   4B93         CMP.B   #0x0, R11
   \   00005C   0624         JEQ     ??ZDO_ProcessSimpleDescReq_4
   \   00005E   81930000     CMP.W   #0x0, 0(SP)
   \   000062   0324         JEQ     ??ZDO_ProcessSimpleDescReq_4
    721            {
    722              osal_mem_free( sDesc );
   \   000064   2C41         MOV.W   @SP, R12
   \   000066   ........     CALLA   #osal_mem_free
    723            }
    724          }
   \                     ??ZDO_ProcessSimpleDescReq_4:
   \   00006A   2153         ADD.W   #0x2, SP
   \   00006C   3817         POPM.W  #0x4, R11
   \   00006E   1001         RETA
    725          
    726          /*********************************************************************
    727           * @fn          ZDO_ProcessActiveEPReq
    728           *
    729           * @brief       This function processes and responds to the
    730           *              Active_EP_req message.
    731           *
    732           * @param       inMsg  - incoming message (request)
    733           *
    734           * @return      none
    735           */

   \                                 In  segment CODE, align 2
    736          void ZDO_ProcessActiveEPReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessActiveEPReq:
    737          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   084C         MOV.W   R12, R8
    738            byte cnt = 0;
   \   000004   4B43         MOV.B   #0x0, R11
    739            uint16 aoi;
    740            byte stat = ZDP_SUCCESS;
   \   000006   4A43         MOV.B   #0x0, R10
    741          
    742            aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   \   000008   1F4C1600     MOV.W   0x16(R12), R15
   \   00000C   694F         MOV.B   @R15, R9
   \   00000E   ........     CALLA   #?Subroutine28
   \                     ??CrossCallReturnLabel_42:
   \   000012   095F         ADD.W   R15, R9
    743          
    744            if ( aoi == NLME_GetShortAddr() )
   \   000014   ........     CALLA   #NLME_GetShortAddr
   \   000018   099C         CMP.W   R12, R9
   \   00001A   0A20         JNE     ??ZDO_ProcessActiveEPReq_0
    745            {
    746              cnt = afNumEndPoints() - 1;  // -1 for ZDO endpoint descriptor
   \   00001C   ........     CALLA   #afNumEndPoints
   \   000020   4B4C         MOV.B   R12, R11
   \   000022   7B53         ADD.B   #0xff, R11
    747              afEndPoints( (uint8 *)ZDOBuildBuf, true );
   \   000024   5D43         MOV.B   #0x1, R13
   \   000026   3C40....     MOV.W   #ZDOBuildBuf, R12
   \   00002A   ........     CALLA   #afEndPoints
   \   00002E   023C         JMP     ??ZDO_ProcessActiveEPReq_1
    748            }
    749            else
    750            {
    751              stat = ZDP_INVALID_REQTYPE;
   \                     ??ZDO_ProcessActiveEPReq_0:
   \   000030   7A408000     MOV.B   #0x80, R10
    752            }
    753          
    754            ZDP_ActiveEPRsp( inMsg->TransSeq, &(inMsg->srcAddr), stat,
    755                            aoi, cnt, (uint8 *)ZDOBuildBuf, inMsg->SecurityUse );
   \                     ??ZDO_ProcessActiveEPReq_1:
   \   000034   58121000     PUSH.B  0x10(R8)
   \   000038   3012....     PUSH.W  #ZDOBuildBuf
   \   00003C   4B12         PUSH.B  R11
   \   00003E   0912         PUSH.W  R9
   \   000040   4F4A         MOV.B   R10, R15
   \   000042   0E48         MOV.W   R8, R14
   \   000044   2E53         ADD.W   #0x2, R14
   \   000046   5D481100     MOV.B   0x11(R8), R13
   \   00004A   3C400580     MOV.W   #0x8005, R12
   \   00004E   ........     CALLA   #ZDP_EPRsp
    756          }
   \   000052   3152         ADD.W   #0x8, SP
   \   000054   3817         POPM.W  #0x4, R11
   \   000056   1001         RETA
    757          
    758          /*********************************************************************
    759           * @fn          ZDO_ConvertOTAClusters
    760           *
    761           * @brief       This function will convert the over-the-air cluster list
    762           *              format to an internal format.
    763           *
    764           * @param       inMsg  - incoming message (request)
    765           *
    766           * @return      pointer to incremented inBuf
    767           */

   \                                 In  segment CODE, align 2
    768          uint8 *ZDO_ConvertOTAClusters( uint8 cnt, uint8 *inBuf, uint16 *outList )
   \                     ZDO_ConvertOTAClusters:
    769          {
   \   000000   3B15         PUSHM.W #0x4, R11
    770            uint8 x;
    771          
    772            for ( x = 0; x < cnt; x++ )
   \   000002   4F43         MOV.B   #0x0, R15
   \   000004   0E3C         JMP     ??ZDO_ConvertOTAClusters_1
    773            {
    774              // convert ota format to internal
    775              outList[x] = BUILD_UINT16( inBuf[0], inBuf[1] );
   \                     ??ZDO_ConvertOTAClusters_0:
   \   000006   6B4D         MOV.B   @R13, R11
   \   000008   5A4D0100     MOV.B   0x1(R13), R10
   \   00000C                RPT     #0x8
   \   00000C   47180A5A     RLAX.W  R10
   \   000010   0B5A         ADD.W   R10, R11
   \   000012   484F         MOV.B   R15, R8
   \   000014   0858         RLA.W   R8
   \   000016   0A4E         MOV.W   R14, R10
   \   000018   0A58         ADD.W   R8, R10
   \   00001A   8A4B0000     MOV.W   R11, 0(R10)
    776              inBuf += sizeof( uint16 );
   \   00001E   2D53         ADD.W   #0x2, R13
    777            }
   \   000020   5F53         ADD.B   #0x1, R15
   \                     ??ZDO_ConvertOTAClusters_1:
   \   000022   4F9C         CMP.B   R12, R15
   \   000024   F02B         JNC     ??ZDO_ConvertOTAClusters_0
    778            return ( inBuf );
   \   000026   0C4D         MOV.W   R13, R12
   \   000028   3817         POPM.W  #0x4, R11
   \   00002A   1001         RETA
    779          }
    780          
    781          /*********************************************************************
    782           * @fn          ZDO_ProcessMatchDescReq
    783           *
    784           * @brief       This function processes and responds to the
    785           *              Match_Desc_req message.
    786           *
    787           * @param       inMsg  - incoming message (request)
    788           *
    789           * @return      none
    790           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine13:
   \   000000   4C4A         MOV.B   R10, R12
   \   000002                REQUIRE ??Subroutine13_0
   \   000002                // Fall through to label ??Subroutine13_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine13_0:
   \   000000   0C5C         RLA.W   R12
   \   000002   ........     BRA     #osal_mem_alloc

   \                                 In  segment CODE, align 2
    791          void ZDO_ProcessMatchDescReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessMatchDescReq:
    792          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   31800600     SUB.W   #0x6, SP
   \   000006   0B4C         MOV.W   R12, R11
    793            uint8 epCnt = 0;
   \   000008   C1430000     MOV.B   #0x0, 0(SP)
    794            uint8 numInClusters;
    795            uint16 *inClusters = NULL;
   \   00000C   0843         MOV.W   #0x0, R8
    796            uint8 numOutClusters;
    797            uint16 *outClusters = NULL;
   \   00000E   0943         MOV.W   #0x0, R9
    798            epList_t *epDesc;
    799            SimpleDescriptionFormat_t *sDesc = NULL;
    800            uint8 allocated;
    801            uint8 *msg;
    802            uint16 aoi;
    803            uint16 profileID;
    804          
    805            // Parse the incoming message
    806            msg = inMsg->asdu;
   \   000010   174C1600     MOV.W   0x16(R12), R7
    807            aoi = BUILD_UINT16( msg[0], msg[1] );
   \   000014   6E47         MOV.B   @R7, R14
   \   000016   5F470100     MOV.B   0x1(R7), R15
   \   00001A   ........     CALLA   #??Subroutine27_1
   \                     ??CrossCallReturnLabel_50:
   \   00001E   814E0200     MOV.W   R14, 0x2(SP)
    808            profileID = BUILD_UINT16( msg[2], msg[3] );
   \   000022   5E470200     MOV.B   0x2(R7), R14
   \   000026   5F470300     MOV.B   0x3(R7), R15
   \   00002A   ........     CALLA   #??Subroutine27_1
   \                     ??CrossCallReturnLabel_51:
   \   00002E   814E0400     MOV.W   R14, 0x4(SP)
    809            msg += 4;
   \   000032   2752         ADD.W   #0x4, R7
   \   000034   ........     CALLA   #?Subroutine25
   \                     ??CrossCallReturnLabel_40:
   \   000038   5C93         CMP.B   #0x1, R12
   \   00003A   0824         JEQ     ??ZDO_ProcessMatchDescReq_6
    810          
    811            if ( ADDR_BCAST_NOT_ME == NLME_IsAddressBroadcast(aoi) )
    812            {
    813              ZDP_MatchDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_INVALID_REQTYPE,
    814                                    ZDAppNwkAddr.addr.shortAddr, 0, NULL, inMsg->SecurityUse );
    815              return;
    816            }
    817            else if ( (ADDR_NOT_BCAST == NLME_IsAddressBroadcast(aoi)) && (aoi != ZDAppNwkAddr.addr.shortAddr) )
   \   00003C   ........     CALLA   #?Subroutine25
   \                     ??CrossCallReturnLabel_39:
   \   000040   4C93         CMP.B   #0x0, R12
   \   000042   1020         JNE     ??ZDO_ProcessMatchDescReq_7
   \   000044   9192....0200 CMP.W   &ZDAppNwkAddr, 0x2(SP)
   \   00004A   0C24         JEQ     ??ZDO_ProcessMatchDescReq_7
    818            {
    819              ZDP_MatchDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_INVALID_REQTYPE,
    820                                       ZDAppNwkAddr.addr.shortAddr, 0, NULL, inMsg->SecurityUse );
   \                     ??ZDO_ProcessMatchDescReq_6:
   \   00004C   5B121000     PUSH.B  0x10(R11)
   \   000050   0312         PUSH.W  #0x0
   \   000052   4312         PUSH.B  #0x0
   \   000054   1212....     PUSH.W  &ZDAppNwkAddr
   \   000058   7F408000     MOV.B   #0x80, R15
   \   00005C   ........     CALLA   #??Subroutine33_0
    821              return;
   \                     ??CrossCallReturnLabel_80:
   \   000060   3152         ADD.W   #0x8, SP
   \   000062   DF3C         JMP     ??ZDO_ProcessMatchDescReq_5
    822            }
    823          
    824            if ((numInClusters = *msg++) &&
    825                (inClusters = (uint16*)osal_mem_alloc( numInClusters * sizeof( uint16 ) )))
   \                     ??ZDO_ProcessMatchDescReq_7:
   \   000064   7447         MOV.B   @R7+, R4
   \   000066   4493         CMP.B   #0x0, R4
   \   000068   0D24         JEQ     ??ZDO_ProcessMatchDescReq_8
   \   00006A   4C44         MOV.B   R4, R12
   \   00006C   ........     CALLA   #??Subroutine13_0
   \                     ??CrossCallReturnLabel_62:
   \   000070   084C         MOV.W   R12, R8
   \   000072   0C93         CMP.W   #0x0, R12
   \   000074   0724         JEQ     ??ZDO_ProcessMatchDescReq_8
    826            {
    827              msg = ZDO_ConvertOTAClusters( numInClusters, msg, inClusters );
   \   000076   0E4C         MOV.W   R12, R14
   \   000078   0D47         MOV.W   R7, R13
   \   00007A   4C44         MOV.B   R4, R12
   \   00007C   ........     CALLA   #ZDO_ConvertOTAClusters
   \   000080   074C         MOV.W   R12, R7
   \   000082   013C         JMP     ??ZDO_ProcessMatchDescReq_9
    828            }
    829            else
    830            {
    831              numInClusters = 0;
   \                     ??ZDO_ProcessMatchDescReq_8:
   \   000084   4443         MOV.B   #0x0, R4
    832            }
    833          
    834            if ((numOutClusters = *msg++) &&
    835                (outClusters = (uint16 *)osal_mem_alloc( numOutClusters * sizeof( uint16 ) )))
   \                     ??ZDO_ProcessMatchDescReq_9:
   \   000086   7A47         MOV.B   @R7+, R10
   \   000088   4A93         CMP.B   #0x0, R10
   \   00008A   0B24         JEQ     ??ZDO_ProcessMatchDescReq_10
   \   00008C   ........     CALLA   #?Subroutine13
   \                     ??CrossCallReturnLabel_69:
   \   000090   094C         MOV.W   R12, R9
   \   000092   0C93         CMP.W   #0x0, R12
   \   000094   0624         JEQ     ??ZDO_ProcessMatchDescReq_10
    836            {
    837              msg = ZDO_ConvertOTAClusters( numOutClusters, msg, outClusters );
   \   000096   0E4C         MOV.W   R12, R14
   \   000098   0D47         MOV.W   R7, R13
   \   00009A   4C4A         MOV.B   R10, R12
   \   00009C   ........     CALLA   #ZDO_ConvertOTAClusters
   \   0000A0   013C         JMP     ??ZDO_ProcessMatchDescReq_11
    838            }
    839            else
    840            {
    841              numOutClusters = 0;
   \                     ??ZDO_ProcessMatchDescReq_10:
   \   0000A2   4A43         MOV.B   #0x0, R10
    842            }
    843          
    844            // First count the number of endpoints that match.
    845            epDesc = epList;
   \                     ??ZDO_ProcessMatchDescReq_11:
   \   0000A4   1642....     MOV.W   &epList, R6
   \   0000A8   183C         JMP     ??ZDO_ProcessMatchDescReq_12
    846            while ( epDesc )
    847            {
    848              // Don't search endpoint 0 and check if response is allowed
    849              if ( epDesc->epDesc->endPoint != ZDO_EP && (epDesc->flags&eEP_AllowMatch) )
    850              {
    851                if ( epDesc->pfnDescCB )
    852                {
    853                  sDesc = (SimpleDescriptionFormat_t *)epDesc->pfnDescCB( AF_DESCRIPTOR_SIMPLE, epDesc->epDesc->endPoint );
    854                  allocated = TRUE;
    855                }
    856                else
    857                {
    858                  sDesc = epDesc->epDesc->simpleDesc;
    859                  allocated = FALSE;
    860                }
    861          
    862                if ( sDesc && sDesc->AppProfId == profileID )
    863                {
    864                  uint8 *uint8Buf = (uint8 *)ZDOBuildBuf;
    865          
    866                  // Are there matching input clusters?
    867                  if ((ZDO_AnyClusterMatches( numInClusters, inClusters,
    868                             sDesc->AppNumInClusters, sDesc->pAppInClusterList )) ||
    869                      // Are there matching output clusters?
    870                      (ZDO_AnyClusterMatches( numOutClusters, outClusters,
    871                             sDesc->AppNumOutClusters, sDesc->pAppOutClusterList )))
    872                  {
    873                    // Notify the endpoint of the match.
    874                    uint8 bufLen = sizeof( ZDO_MatchDescRspSent_t ) + (numOutClusters + numInClusters) * sizeof(uint16);
    875                    ZDO_MatchDescRspSent_t *pRspSent = (ZDO_MatchDescRspSent_t *) osal_msg_allocate( bufLen );
    876          
    877                    if (pRspSent)
    878                    {
    879                      pRspSent->hdr.event = ZDO_MATCH_DESC_RSP_SENT;
    880                      pRspSent->nwkAddr = inMsg->srcAddr.addr.shortAddr;
    881                      pRspSent->numInClusters = numInClusters;
    882                      pRspSent->numOutClusters = numOutClusters;
    883          
    884                      if (numInClusters)
    885                      {
    886                        pRspSent->pInClusters = (uint16*) (pRspSent + 1);
    887                        osal_memcpy(pRspSent->pInClusters, inClusters, numInClusters * sizeof(uint16));
    888                      }
    889                      else
    890                      {
    891                        pRspSent->pInClusters = NULL;
    892                      }
    893          
    894                      if (numOutClusters)
    895                      {
    896                        pRspSent->pOutClusters = (uint16*)(pRspSent + 1) + numInClusters;
    897                        osal_memcpy(pRspSent->pOutClusters, outClusters, numOutClusters * sizeof(uint16));
    898                      }
    899                      else
    900                      {
    901                        pRspSent->pOutClusters = NULL;
   \                     ??ZDO_ProcessMatchDescReq_3:
   \   0000AA   85430A00     MOV.W   #0x0, 0xa(R5)
    902                      }
    903          
    904                      osal_msg_send( *epDesc->epDesc->task_id, (uint8 *)pRspSent );
   \                     ??ZDO_ProcessMatchDescReq_4:
   \   0000AE   0D45         MOV.W   R5, R13
   \   0000B0   1F460200     MOV.W   0x2(R6), R15
   \   0000B4   1F4F0200     MOV.W   0x2(R15), R15
   \   0000B8   6C4F         MOV.B   @R15, R12
   \   0000BA   ........     CALLA   #osal_msg_send
    905                    }
    906          
    907                    uint8Buf[epCnt++] = sDesc->EndPoint;
   \                     ??ZDO_ProcessMatchDescReq_2:
   \   0000BE   6F41         MOV.B   @SP, R15
   \   0000C0   EF47....     MOV.B   @R7, ZDOBuildBuf(R15)
   \   0000C4   6E41         MOV.B   @SP, R14
   \   0000C6   5E53         ADD.B   #0x1, R14
   \   0000C8   C14E0000     MOV.B   R14, 0(SP)
    908                  }
    909                }
    910          
    911                if ( allocated )
   \                     ??ZDO_ProcessMatchDescReq_1:
   \   0000CC   D1B30100     BIT.B   #0x1, 0x1(SP)
   \   0000D0   0328         JNC     ??ZDO_ProcessMatchDescReq_0
    912                {
    913                  osal_mem_free( sDesc );
   \   0000D2   0C47         MOV.W   R7, R12
   \   0000D4   ........     CALLA   #osal_mem_free
    914                }
    915              }
    916              epDesc = epDesc->nextDesc;
   \                     ??ZDO_ProcessMatchDescReq_0:
   \   0000D8   2646         MOV.W   @R6, R6
   \                     ??ZDO_ProcessMatchDescReq_12:
   \   0000DA   0693         CMP.W   #0x0, R6
   \   0000DC   6A24         JEQ     ??ZDO_ProcessMatchDescReq_13
   \   0000DE   17460200     MOV.W   0x2(R6), R7
   \   0000E2   C7930000     CMP.B   #0x0, 0(R7)
   \   0000E6   F827         JEQ     ??ZDO_ProcessMatchDescReq_0
   \   0000E8   D6B30A00     BIT.B   #0x1, 0xa(R6)
   \   0000EC   F52B         JNC     ??ZDO_ProcessMatchDescReq_0
   \   0000EE   1E460400     MOV.W   0x4(R6), R14
   \   0000F2   1F460600     MOV.W   0x6(R6), R15
   \   0000F6   0D4E         MOV.W   R14, R13
   \   0000F8   0DDF         BIS.W   R15, R13
   \   0000FA   0D93         CMP.W   #0x0, R13
   \   0000FC   0824         JEQ     ??ZDO_ProcessMatchDescReq_14
   \   0000FE   6D47         MOV.B   @R7, R13
   \   000100   5C43         MOV.B   #0x1, R12
   \   000102   ........     CALLA   #?IndCallR15
   \   000106   074C         MOV.W   R12, R7
   \   000108   D1430100     MOV.B   #0x1, 0x1(SP)
   \   00010C   043C         JMP     ??ZDO_ProcessMatchDescReq_15
   \                     ??ZDO_ProcessMatchDescReq_14:
   \   00010E   17470400     MOV.W   0x4(R7), R7
   \   000112   C1430100     MOV.B   #0x0, 0x1(SP)
   \                     ??ZDO_ProcessMatchDescReq_15:
   \   000116   0793         CMP.W   #0x0, R7
   \   000118   D927         JEQ     ??ZDO_ProcessMatchDescReq_1
   \   00011A   979104000200 CMP.W   0x4(SP), 0x2(R7)
   \   000120   D523         JNE     ??ZDO_ProcessMatchDescReq_1
   \   000122   1F470800     MOV.W   0x8(R7), R15
   \   000126   5E470700     MOV.B   0x7(R7), R14
   \   00012A   0D48         MOV.W   R8, R13
   \   00012C   4C44         MOV.B   R4, R12
   \   00012E   ........     CALLA   #ZDO_AnyClusterMatches
   \   000132   4C93         CMP.B   #0x0, R12
   \   000134   0A20         JNE     ??ZDO_ProcessMatchDescReq_16
   \   000136   1F470C00     MOV.W   0xc(R7), R15
   \   00013A   5E470A00     MOV.B   0xa(R7), R14
   \   00013E   0D49         MOV.W   R9, R13
   \   000140   4C4A         MOV.B   R10, R12
   \   000142   ........     CALLA   #ZDO_AnyClusterMatches
   \   000146   4C93         CMP.B   #0x0, R12
   \   000148   C127         JEQ     ??ZDO_ProcessMatchDescReq_1
   \                     ??ZDO_ProcessMatchDescReq_16:
   \   00014A   4C4A         MOV.B   R10, R12
   \   00014C   4C54         ADD.B   R4, R12
   \   00014E   4C5C         RLA.B   R12
   \   000150   7C500C00     ADD.B   #0xc, R12
   \   000154   ........     CALLA   #osal_msg_allocate
   \   000158   054C         MOV.W   R12, R5
   \   00015A   0C93         CMP.W   #0x0, R12
   \   00015C   B027         JEQ     ??ZDO_ProcessMatchDescReq_2
   \   00015E   FC40D2000000 MOV.B   #0xd2, 0(R12)
   \   000164   9C4B02000200 MOV.W   0x2(R11), 0x2(R12)
   \   00016A   CC440400     MOV.B   R4, 0x4(R12)
   \   00016E   CC4A0800     MOV.B   R10, 0x8(R12)
   \   000172   4493         CMP.B   #0x0, R4
   \   000174   0C24         JEQ     ??ZDO_ProcessMatchDescReq_17
   \   000176   0F4C         MOV.W   R12, R15
   \   000178   3F500C00     ADD.W   #0xc, R15
   \   00017C   8C4F0600     MOV.W   R15, 0x6(R12)
   \   000180   4E44         MOV.B   R4, R14
   \   000182   0E5E         RLA.W   R14
   \   000184   0D48         MOV.W   R8, R13
   \   000186   0C4F         MOV.W   R15, R12
   \   000188   ........     CALLA   #osal_memcpy
   \   00018C   023C         JMP     ??ZDO_ProcessMatchDescReq_18
   \                     ??ZDO_ProcessMatchDescReq_17:
   \   00018E   8C430600     MOV.W   #0x0, 0x6(R12)
   \                     ??ZDO_ProcessMatchDescReq_18:
   \   000192   4A93         CMP.B   #0x0, R10
   \   000194   8A27         JEQ     ??ZDO_ProcessMatchDescReq_3
   \   000196   4F44         MOV.B   R4, R15
   \   000198   0F5F         RLA.W   R15
   \   00019A   0C45         MOV.W   R5, R12
   \   00019C   0C5F         ADD.W   R15, R12
   \   00019E   3C500C00     ADD.W   #0xc, R12
   \   0001A2   854C0A00     MOV.W   R12, 0xa(R5)
   \   0001A6   4E4A         MOV.B   R10, R14
   \   0001A8   0E5E         RLA.W   R14
   \   0001AA   0D49         MOV.W   R9, R13
   \   0001AC   ........     CALLA   #osal_memcpy
   \   0001B0   7E3F         JMP     ??ZDO_ProcessMatchDescReq_4
    917            }
    918          
    919            if ( epCnt )
   \                     ??ZDO_ProcessMatchDescReq_13:
   \   0001B2   C1930000     CMP.B   #0x0, 0(SP)
   \   0001B6   1024         JEQ     ??ZDO_ProcessMatchDescReq_19
    920            {
    921              // Send the message if at least one match found.
    922              if ( ZSuccess == ZDP_MatchDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_SUCCESS,
    923                        ZDAppNwkAddr.addr.shortAddr, epCnt, (uint8 *)ZDOBuildBuf, inMsg->SecurityUse ) )
   \   0001B8   5B121000     PUSH.B  0x10(R11)
   \   0001BC   3012....     PUSH.W  #ZDOBuildBuf
   \   0001C0   51120600     PUSH.B  0x6(SP)
   \   0001C4   1212....     PUSH.W  &ZDAppNwkAddr
   \   0001C8   ........     CALLA   #?Subroutine17
   \                     ??CrossCallReturnLabel_82:
   \   0001CC   3152         ADD.W   #0x8, SP
   \   0001CE   4C93         CMP.B   #0x0, R12
   \   0001D0   1E20         JNE     ??ZDO_ProcessMatchDescReq_20
    924              {
    925          #if defined( LCD_SUPPORTED )
    926                HalLcdWriteScreen( "Match Desc Req", "Rsp Sent" );
   \   0001D2   3D40....     MOV.W   #`?<Constant "Rsp Sent">`, R13
   \   0001D6   173C         JMP     ??ZDO_ProcessMatchDescReq_21
    927          #endif
    928              }
    929            }
    930            else
    931            {
    932              // No match found
    933              if (ADDR_NOT_BCAST == NLME_IsAddressBroadcast(aoi))
   \                     ??ZDO_ProcessMatchDescReq_19:
   \   0001D8   ........     CALLA   #?Subroutine25
   \                     ??CrossCallReturnLabel_38:
   \   0001DC   4C93         CMP.B   #0x0, R12
   \   0001DE   1120         JNE     ??ZDO_ProcessMatchDescReq_22
    934              {
    935                // send response message with match length = 0
    936                ZDP_MatchDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_SUCCESS,
    937                                  ZDAppNwkAddr.addr.shortAddr, 0, (uint8 *)ZDOBuildBuf, inMsg->SecurityUse );
   \   0001E0   5B121000     PUSH.B  0x10(R11)
   \   0001E4   3012....     PUSH.W  #ZDOBuildBuf
   \   0001E8   4312         PUSH.B  #0x0
   \   0001EA   1212....     PUSH.W  &ZDAppNwkAddr
   \   0001EE   ........     CALLA   #?Subroutine17
    938          #if defined( LCD_SUPPORTED )
    939                HalLcdWriteScreen( "Match Desc Req", "Rsp Non Matched" );
   \                     ??CrossCallReturnLabel_81:
   \   0001F2   3D40....     MOV.W   #`?<Constant "Rsp Non Matched">`, R13
   \   0001F6   3C40....     MOV.W   #`?<Constant "Match Desc Req">`, R12
   \   0001FA   ........     CALLA   #HalLcdWriteScreen
   \   0001FE   3152         ADD.W   #0x8, SP
   \   000200   063C         JMP     ??ZDO_ProcessMatchDescReq_20
    940          #endif
    941              }
    942              else
    943              {
    944                // no response mesage for broadcast message
    945          #if defined( LCD_SUPPORTED )
    946                HalLcdWriteScreen( "Match Desc Req", "Non Matched" );
   \                     ??ZDO_ProcessMatchDescReq_22:
   \   000202   3D40....     MOV.W   #`?<Constant "Non Matched">`, R13
   \                     ??ZDO_ProcessMatchDescReq_21:
   \   000206   3C40....     MOV.W   #`?<Constant "Match Desc Req">`, R12
   \   00020A   ........     CALLA   #HalLcdWriteScreen
    947          #endif
    948              }
    949            }
    950          
    951            if ( inClusters != NULL )
   \                     ??ZDO_ProcessMatchDescReq_20:
   \   00020E   0893         CMP.W   #0x0, R8
   \   000210   0324         JEQ     ??ZDO_ProcessMatchDescReq_23
    952            {
    953              osal_mem_free( inClusters );
   \   000212   0C48         MOV.W   R8, R12
   \   000214   ........     CALLA   #osal_mem_free
    954            }
    955          
    956            if ( outClusters != NULL )
   \                     ??ZDO_ProcessMatchDescReq_23:
   \   000218   0993         CMP.W   #0x0, R9
   \   00021A   0324         JEQ     ??ZDO_ProcessMatchDescReq_5
    957            {
    958              osal_mem_free( outClusters );
   \   00021C   0C49         MOV.W   R9, R12
   \   00021E   ........     CALLA   #osal_mem_free
    959            }
    960          }
   \                     ??ZDO_ProcessMatchDescReq_5:
   \   000222   31500600     ADD.W   #0x6, SP
   \   000226   7417         POPM.W  #0x8, R11
   \   000228   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine25:
   \   000000   1C410600     MOV.W   0x6(SP), R12
   \   000004   ........     BRA     #NLME_IsAddressBroadcast

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine17:
   \   000000   4F43         MOV.B   #0x0, R15
   \   000002                REQUIRE ??Subroutine33_0
   \   000002                // Fall through to label ??Subroutine33_0

   \                                 In  segment CODE, align 2
   \                     ??Subroutine33_0:
   \   000000   0E4B         MOV.W   R11, R14
   \   000002   2E53         ADD.W   #0x2, R14
   \   000004   5D4B1100     MOV.B   0x11(R11), R13
   \   000008   3C400680     MOV.W   #0x8006, R12
   \   00000C   ........     BRA     #ZDP_EPRsp
    961          
    962          /*********************************************************************
    963           * @fn      ZDO_ProcessBindUnbindReq()
    964           *
    965           * @brief   Called to process a Bind or Unbind Request message.
    966           *
    967           * @param   inMsg  - incoming message (request)
    968           * @param   pReq - place to put parsed information
    969           *
    970           * @return  none
    971           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine15:
   \   000000   0D4A         MOV.W   R10, R13
   \   000002   2D53         ADD.W   #0x2, R13
   \   000004   3A501100     ADD.W   #0x11, R10
   \   000008                REQUIRE ??Subroutine31_0
   \   000008                // Fall through to label ??Subroutine31_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine31_0:
   \   000000   0C4A         MOV.W   R10, R12
   \   000002   ........     BRA     #ZDP_SendData

   \                                 In  segment CODE, align 2
    972          void ZDO_ProcessBindUnbindReq( zdoIncomingMsg_t *inMsg, ZDO_BindUnbindReq_t *pReq )
   \                     ZDO_ProcessBindUnbindReq:
    973          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31800E00     SUB.W   #0xe, SP
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0B4D         MOV.W   R13, R11
    974            zAddrType_t SourceAddr;       // Binding Source addres
    975            byte bindStat;
    976          
    977            SourceAddr.addrMode = Addr64Bit;
   \   00000A   78400300     MOV.B   #0x3, R8
   \   00000E   C1480C00     MOV.B   R8, 0xc(SP)
    978            osal_cpyExtAddr( SourceAddr.addr.extAddr, pReq->srcAddress );
   \   000012   0C41         MOV.W   SP, R12
   \   000014   2C52         ADD.W   #0x4, R12
   \   000016   ........     CALLA   #sAddrExtCpy
    979          
    980            // If the local device is not the primary binding cache
    981            // check the src address of the bind request.
    982            // If it is not the local device's extended address
    983            // discard the request.
    984            if ( !osal_ExtAddrEqual( SourceAddr.addr.extAddr, NLME_GetExtAddr()) ||
    985                  (pReq->dstAddress.addrMode != Addr64Bit &&
    986                   pReq->dstAddress.addrMode != AddrGroup) )
   \   00001A   ........     CALLA   #NLME_GetExtAddr
   \   00001E   0D4C         MOV.W   R12, R13
   \   000020   0C41         MOV.W   SP, R12
   \   000022   2C52         ADD.W   #0x4, R12
   \   000024   ........     CALLA   #sAddrExtCmp
   \   000028   4C93         CMP.B   #0x0, R12
   \   00002A   0624         JEQ     ??ZDO_ProcessBindUnbindReq_0
   \   00002C   5E4B1400     MOV.B   0x14(R11), R14
   \   000030   4E98         CMP.B   R8, R14
   \   000032   0624         JEQ     ??ZDO_ProcessBindUnbindReq_1
   \   000034   5E93         CMP.B   #0x1, R14
   \   000036   0424         JEQ     ??ZDO_ProcessBindUnbindReq_1
    987            {
    988              bindStat = ZDP_NOT_SUPPORTED;
   \                     ??ZDO_ProcessBindUnbindReq_0:
   \   000038   F14084000000 MOV.B   #0x84, 0(SP)
   \   00003E   4F3C         JMP     ??ZDO_ProcessBindUnbindReq_2
    989            }
    990            else
    991            {
    992              // Check source & destination endpoints
    993              if ( (pReq->srcEndpoint == 0 || pReq->srcEndpoint > MAX_ENDPOINTS)
    994                  || (( pReq->dstAddress.addrMode == Addr64Bit ) &&
    995                      (pReq->dstEndpoint == 0 || pReq->dstEndpoint > MAX_ENDPOINTS)) )
   \                     ??ZDO_ProcessBindUnbindReq_1:
   \   000040   5C4B0800     MOV.B   0x8(R11), R12
   \   000044   4C93         CMP.B   #0x0, R12
   \   000046   0C24         JEQ     ??ZDO_ProcessBindUnbindReq_3
   \   000048   7C90F100     CMP.B   #0xf1, R12
   \   00004C   092C         JC      ??ZDO_ProcessBindUnbindReq_3
   \   00004E   4E98         CMP.B   R8, R14
   \   000050   0B20         JNE     ??ZDO_ProcessBindUnbindReq_4
   \   000052   5E4B1600     MOV.B   0x16(R11), R14
   \   000056   4E93         CMP.B   #0x0, R14
   \   000058   0324         JEQ     ??ZDO_ProcessBindUnbindReq_3
   \   00005A   7E90F100     CMP.B   #0xf1, R14
   \   00005E   0428         JNC     ??ZDO_ProcessBindUnbindReq_4
    996              {
    997                bindStat = ZDP_INVALID_EP;
   \                     ??ZDO_ProcessBindUnbindReq_3:
   \   000060   F14082000000 MOV.B   #0x82, 0(SP)
   \   000066   3B3C         JMP     ??ZDO_ProcessBindUnbindReq_2
    998              }
   \                     ??ZDO_ProcessBindUnbindReq_4:
   \   000068   094B         MOV.W   R11, R9
   \   00006A   39500C00     ADD.W   #0xc, R9
   \   00006E   BA9021000E00 CMP.W   #0x21, 0xe(R10)
   \   000074   2320         JNE     ??ZDO_ProcessBindUnbindReq_5
    999              else
   1000              {
   1001                if ( inMsg->clusterID == Bind_req )
   1002                {
   1003                  // Assume the table is full
   1004                  bindStat = ZDP_TABLE_FULL;
   \   000076   F1408C000000 MOV.B   #0x8c, 0(SP)
   1005          
   1006          #if defined( APP_TP ) || defined( APP_TP2 )
   1007                  // For ZigBee Conformance Testing
   1008                  if ( bindNumOfEntries() < gNWK_MAX_BINDING_ENTRIES )
   1009          #endif
   1010                  {
   1011                    if ( APSME_BindRequest( pReq->srcEndpoint, pReq->clusterID,
   1012                                   &(pReq->dstAddress), pReq->dstEndpoint ) == ZSuccess )
   \   00007C   5F4B1600     MOV.B   0x16(R11), R15
   \   000080   0E49         MOV.W   R9, R14
   \   000082   1D4B0A00     MOV.W   0xa(R11), R13
   \   000086   5C4B0800     MOV.B   0x8(R11), R12
   \   00008A   ........     CALLA   #APSME_BindRequest
   \   00008E   4C93         CMP.B   #0x0, R12
   \   000090   2620         JNE     ??ZDO_ProcessBindUnbindReq_2
   1013                    {
   1014                      uint16 nwkAddr;
   1015          
   1016                      // valid entry
   1017                      bindStat = ZDP_SUCCESS;
   \   000092   C1430000     MOV.B   #0x0, 0(SP)
   1018          
   1019                      // Notify to save info into NV
   1020                      ZDApp_NVUpdate();
   \   000096   ........     CALLA   #ZDApp_NVUpdate
   1021          
   1022                      // Check for the destination address
   1023                      if ( pReq->dstAddress.addrMode == Addr64Bit )
   \   00009A   CB981400     CMP.B   R8, 0x14(R11)
   \   00009E   1F20         JNE     ??ZDO_ProcessBindUnbindReq_2
   1024                      {
   1025                        if ( APSME_LookupNwkAddr( pReq->dstAddress.addr.extAddr, &nwkAddr ) == FALSE )
   \   0000A0   0D41         MOV.W   SP, R13
   \   0000A2   2D53         ADD.W   #0x2, R13
   \   0000A4   0C49         MOV.W   R9, R12
   \   0000A6   ........     CALLA   #APSME_LookupNwkAddr
   \   0000AA   4C93         CMP.B   #0x0, R12
   \   0000AC   1820         JNE     ??ZDO_ProcessBindUnbindReq_2
   1026                        {
   1027                          ZDP_NwkAddrReq( pReq->dstAddress.addr.extAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   0000AE   4F43         MOV.B   #0x0, R15
   \   0000B0   4E43         MOV.B   #0x0, R14
   \   0000B2   4D43         MOV.B   #0x0, R13
   \   0000B4   0C49         MOV.W   R9, R12
   \   0000B6   ........     CALLA   #ZDP_NwkAddrReq
   \   0000BA   113C         JMP     ??ZDO_ProcessBindUnbindReq_2
   1028                        }
   1029                      }
   1030                    }
   1031                  }
   1032                }
   1033                else // Unbind_req
   1034                {
   1035                  if ( APSME_UnBindRequest( pReq->srcEndpoint, pReq->clusterID,
   1036                                 &(pReq->dstAddress), pReq->dstEndpoint ) == ZSuccess )
   \                     ??ZDO_ProcessBindUnbindReq_5:
   \   0000BC   5F4B1600     MOV.B   0x16(R11), R15
   \   0000C0   0E49         MOV.W   R9, R14
   \   0000C2   1D4B0A00     MOV.W   0xa(R11), R13
   \   0000C6   ........     CALLA   #APSME_UnBindRequest
   \   0000CA   4C93         CMP.B   #0x0, R12
   \   0000CC   0520         JNE     ??ZDO_ProcessBindUnbindReq_6
   1037                  {
   1038                    bindStat = ZDP_SUCCESS;
   \   0000CE   C1430000     MOV.B   #0x0, 0(SP)
   1039          
   1040                    // Notify to save info into NV
   1041                    ZDApp_NVUpdate();
   \   0000D2   ........     CALLA   #ZDApp_NVUpdate
   \   0000D6   033C         JMP     ??ZDO_ProcessBindUnbindReq_2
   1042                  }
   1043                  else
   1044                    bindStat = ZDP_NO_ENTRY;
   \                     ??ZDO_ProcessBindUnbindReq_6:
   \   0000D8   F14088000000 MOV.B   #0x88, 0(SP)
   1045                }
   1046              }
   1047            }
   1048          
   1049            // Send back a response message
   1050            ZDP_SendData( &(inMsg->TransSeq), &(inMsg->srcAddr),
   1051                         (inMsg->clusterID | ZDO_RESPONSE_BIT), 1, &bindStat,
   1052                         inMsg->SecurityUse );
   \                     ??ZDO_ProcessBindUnbindReq_2:
   \   0000DE   5A121000     PUSH.B  0x10(R10)
   \   0000E2   0F41         MOV.W   SP, R15
   \   0000E4   2F53         ADD.W   #0x2, R15
   \   0000E6   0F12         PUSH.W  R15
   \   0000E8   5F43         MOV.B   #0x1, R15
   \   0000EA   1E4A0E00     MOV.W   0xe(R10), R14
   \   0000EE   3ED00080     BIS.W   #0x8000, R14
   \   0000F2   ........     CALLA   #?Subroutine15
   1053          }
   \                     ??CrossCallReturnLabel_73:
   \   0000F6   31501200     ADD.W   #0x12, SP
   \   0000FA   3817         POPM.W  #0x4, R11
   \   0000FC   1001         RETA
   1054          
   1055          /*********************************************************************
   1056           * @fn      ZDO_UpdateAddrManager
   1057           *
   1058           * @brief   Update the Address Manager.
   1059           *
   1060           * @param   nwkAddr - network address
   1061           * @param   extAddr - extended address
   1062           *
   1063           * @return  none
   1064           */

   \                                 In  segment CODE, align 2
   1065          void ZDO_UpdateAddrManager( uint16 nwkAddr, uint8 *extAddr )
   \                     ZDO_UpdateAddrManager:
   1066          {
   \   000000   31800E00     SUB.W   #0xe, SP
   1067            AddrMgrEntry_t addrEntry;
   1068          
   1069            // Update the address manager
   1070            addrEntry.user = ADDRMGR_USER_DEFAULT;
   \   000004   C1430000     MOV.B   #0x0, 0(SP)
   1071            addrEntry.nwkAddr = nwkAddr;
   \   000008   814C0200     MOV.W   R12, 0x2(SP)
   1072            AddrMgrExtAddrSet( addrEntry.extAddr, extAddr );
   \   00000C   0C41         MOV.W   SP, R12
   \   00000E   2C52         ADD.W   #0x4, R12
   \   000010   ........     CALLA   #AddrMgrExtAddrSet
   1073            AddrMgrEntryUpdate( &addrEntry );
   \   000014   0C41         MOV.W   SP, R12
   \   000016   0C53         ADD.W   #0x0, R12
   \   000018   ........     CALLA   #AddrMgrEntryUpdate
   1074          }
   \   00001C   31500E00     ADD.W   #0xe, SP
   \   000020   1001         RETA
   1075          
   1076          /*********************************************************************
   1077           * @fn      ZDO_ProcessServerDiscReq
   1078           *
   1079           * @brief   Process the Server_Discovery_req message.
   1080           *
   1081           * @param   inMsg  - incoming message (request)
   1082           *
   1083           * @return  none
   1084           */

   \                                 In  segment CODE, align 2, keep-with-next
   1085          void ZDO_ProcessServerDiscReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessServerDiscReq:
   1086          {
   1087            uint16 serverMask = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   1088            uint16 matchMask = serverMask & ZDO_Config_Node_Descriptor.ServerMask;
   \   000000   1F4C1600     MOV.W   0x16(R12), R15
   \   000004   6E4F         MOV.B   @R15, R14
   \   000006   5F4F0100     MOV.B   0x1(R15), R15
   \   00000A   ........     CALLA   #??Subroutine27_1
   \                     ??CrossCallReturnLabel_49:
   \   00000E   1EF2....     AND.W   &ZDO_Config_Node_Descriptor + 8, R14
   1089          
   1090            if ( matchMask )
   \   000012   0D24         JEQ     ??ZDO_ProcessServerDiscReq_0
   1091            {
   1092              ZDP_ServerDiscRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZSUCCESS,
   1093                          ZDAppNwkAddr.addr.shortAddr, matchMask, inMsg->SecurityUse );
   \   000014   5C121000     PUSH.B  0x10(R12)
   \   000018   0E12         PUSH.W  R14
   \   00001A   1F42....     MOV.W   &ZDAppNwkAddr, R15
   \   00001E   4E43         MOV.B   #0x0, R14
   \   000020   0D4C         MOV.W   R12, R13
   \   000022   2D53         ADD.W   #0x2, R13
   \   000024   5C4C1100     MOV.B   0x11(R12), R12
   \   000028   ........     CALLA   #ZDP_ServerDiscRsp
   \   00002C   2152         ADD.W   #0x4, SP
   1094            }
   1095          }
   \                     ??ZDO_ProcessServerDiscReq_0:
   \   00002E   1001         RETA
   1096          
   1097          /*********************************************************************
   1098           * Call Back Functions from APS  - API
   1099           */
   1100          
   1101          /*********************************************************************
   1102           * @fn          ZDO_EndDeviceTimeoutCB
   1103           *
   1104           * @brief       This function handles the binding timer for the End
   1105           *              Device Bind command.
   1106           *
   1107           * @param       none
   1108           *
   1109           * @return      none
   1110           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   0C93         CMP.W   #0x0, R12
   \   000002   0224         JEQ     ??ZDO_CopyMatchInfo_3
   \   000004   ........     CALLA   #osal_mem_free
   \                     ??ZDO_CopyMatchInfo_3:
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1111          void ZDO_EndDeviceTimeoutCB( void )
   \                     ZDO_EndDeviceTimeoutCB:
   1112          {
   \   000000   2183         SUB.W   #0x2, SP
   1113          #if defined ( REFLECTOR )
   1114            byte stat;
   1115            if ( ZDO_EDBind )
   \   000002   1D42....     MOV.W   &ZDO_EDBind, R13
   \   000006   0D93         CMP.W   #0x0, R13
   \   000008   3824         JEQ     ??ZDO_EndDeviceTimeoutCB_4
   \   00000A   D14D1B000000 MOV.B   0x1b(R13), 0(SP)
   \   000010   E14D0100     MOV.B   @R13, 0x1(SP)
   1116            {
   1117              stat = ZDO_EDBind->status;
   1118          
   1119              // Send the response message to the first sent
   1120              ZDO_SendEDBindRsp( ZDO_EDBind->SrcTransSeq, &(ZDO_EDBind->SrcAddr),
   1121                                  stat, ZDO_EDBind->SecurityUse );
   \   000014   5D121A00     PUSH.B  0x1a(R13)
   \   000018   0F41         MOV.W   SP, R15
   \   00001A   2F53         ADD.W   #0x2, R15
   \   00001C   0F12         PUSH.W  R15
   \   00001E   5F43         MOV.B   #0x1, R15
   \   000020   3E402080     MOV.W   #0x8020, R14
   \   000024   2D53         ADD.W   #0x2, R13
   \   000026   0C41         MOV.W   SP, R12
   \   000028   3C500500     ADD.W   #0x5, R12
   \   00002C   ........     CALLA   #ZDP_SendData
   \   000030   5D43         MOV.B   #0x1, R13
   \   000032   3C40....     MOV.W   #`?<Constant "End Device Bind">`, R12
   \   000036   ........     CALLA   #HalLcdWriteString
   \   00003A   2152         ADD.W   #0x4, SP
   \   00003C   C1930000     CMP.B   #0x0, 0(SP)
   \   000040   6D43         MOV.B   #0x2, R13
   \   000042   0320         JNE     ??ZDO_EndDeviceTimeoutCB_5
   \   000044   3C40....     MOV.W   #`?<Constant "Success Sent">`, R12
   \   000048   023C         JMP     ??ZDO_EndDeviceTimeoutCB_6
   \                     ??ZDO_EndDeviceTimeoutCB_5:
   \   00004A   3C40....     MOV.W   #`?<Constant "Timeout">`, R12
   \                     ??ZDO_EndDeviceTimeoutCB_6:
   \   00004E   ........     CALLA   #HalLcdWriteString
   1122          
   1123              ZDO_RemoveEndDeviceBind();
   \   000052   1F42....     MOV.W   &ZDO_EDBind, R15
   \   000056   0F93         CMP.W   #0x0, R15
   \   000058   1024         JEQ     ??ZDO_EndDeviceTimeoutCB_4
   \   00005A   1C4F1400     MOV.W   0x14(R15), R12
   \   00005E   ........     CALLA   #?Subroutine7
   1124            }
   \                     ??CrossCallReturnLabel_13:
   \   000062   1F42....     MOV.W   &ZDO_EDBind, R15
   \   000066   1C4F1800     MOV.W   0x18(R15), R12
   \   00006A   ........     CALLA   #?Subroutine7
   \                     ??CrossCallReturnLabel_14:
   \   00006E   1C42....     MOV.W   &ZDO_EDBind, R12
   \   000072   ........     CALLA   #osal_mem_free
   \   000076   8243....     MOV.W   #0x0, &ZDO_EDBind
   1125          #endif  // REFLECTOR
   1126          }
   \                     ??ZDO_EndDeviceTimeoutCB_4:
   \   00007A   2153         ADD.W   #0x2, SP
   \   00007C   1001         RETA
   1127          
   1128          /*********************************************************************
   1129           * Optional Management Messages
   1130           */
   1131          
   1132          /*********************************************************************
   1133           * @fn          ZDO_ProcessMgmtLqiReq
   1134           *
   1135           * @brief       This function handles parsing the incoming Management
   1136           *              LQI request and generate the response.
   1137           *
   1138           *   Note:      This function will limit the number of items returned
   1139           *              to ZDO_MAX_LQI_ITEMS items.
   1140           *
   1141           * @param       inMsg - incoming message (request)
   1142           *
   1143           * @return      none
   1144           */

   \                                 In  segment CODE, align 2, keep-with-next
   1145          void ZDO_ProcessMgmtLqiReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessMgmtLqiReq:
   1146          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   0C12         PUSH.W  R12
   \   000004   31802800     SUB.W   #0x28, SP
   1147            byte x;
   1148            byte index;
   1149            byte numItems;
   1150            byte maxItems;
   1151            ZDP_MgmtLqiItem_t* table = NULL;
   \   000008   0443         MOV.W   #0x0, R4
   1152            ZDP_MgmtLqiItem_t* item;
   1153            neighborEntry_t    entry;
   1154            byte aItems;
   1155            associated_devices_t *aDevice;
   1156            AddrMgrEntry_t  nwkEntry;
   1157            uint8 StartIndex = inMsg->asdu[0];
   \   00000A   1F412800     MOV.W   0x28(SP), R15
   \   00000E   1F4F1600     MOV.W   0x16(R15), R15
   \   000012   684F         MOV.B   @R15, R8
   1158          
   1159            // Get the number of neighbor items
   1160            NLME_GetRequest( nwkNumNeighborTableEntries, 0, &maxItems );
   \   000014   0E41         MOV.W   SP, R14
   \   000016   0E53         ADD.W   #0x0, R14
   \   000018   0D43         MOV.W   #0x0, R13
   \   00001A   7C409C00     MOV.B   #0x9c, R12
   \   00001E   ........     CALLA   #NLME_GetRequest
   1161          
   1162            // Get the number of associated items
   1163            aItems = (uint8)AssocCount( PARENT, CHILD_FFD_RX_IDLE );
   \   000022   6D42         MOV.B   #0x4, R13
   \   000024   4C43         MOV.B   #0x0, R12
   \   000026   ........     CALLA   #AssocCount
   \   00002A   454C         MOV.B   R12, R5
   1164          
   1165            // Total number of items
   1166            maxItems += aItems;
   \   00002C   4A4C         MOV.B   R12, R10
   \   00002E   6A51         ADD.B   @SP, R10
   \   000030   C14A0000     MOV.B   R10, 0(SP)
   1167          
   1168            // Start with the supplied index
   1169            if ( maxItems > StartIndex )
   \   000034   489A         CMP.B   R10, R8
   \   000036   A82C         JC      ??ZDO_ProcessMgmtLqiReq_6
   1170            {
   1171              numItems = maxItems - StartIndex;
   \   000038   4A88         SUB.B   R8, R10
   \   00003A   6A92         CMP.B   #0x4, R10
   \   00003C   0228         JNC     ??ZDO_ProcessMgmtLqiReq_7
   1172          
   1173              // limit the size of the list
   1174              if ( numItems > ZDO_MAX_LQI_ITEMS )
   1175                numItems = ZDO_MAX_LQI_ITEMS;
   \   00003E   7A400300     MOV.B   #0x3, R10
   1176          
   1177              // Allocate the memory to build the table
   1178              table = (ZDP_MgmtLqiItem_t*)osal_mem_alloc( (short)
   1179                        ( numItems * sizeof( ZDP_MgmtLqiItem_t ) ) );
   \                     ??ZDO_ProcessMgmtLqiReq_7:
   \   000042   4C4A         MOV.B   R10, R12
   \   000044   0C5C         RLA.W   R12
   \   000046   0F4C         MOV.W   R12, R15
   \   000048   5C06         RLAM.W  #0x2, R12
   \   00004A   0F5C         ADD.W   R12, R15
   \   00004C   0C5C         RLA.W   R12
   \   00004E   0C5F         ADD.W   R15, R12
   \   000050   ........     CALLA   #osal_mem_alloc
   \   000054   044C         MOV.W   R12, R4
   1180          
   1181              if ( table != NULL )
   \   000056   0C93         CMP.W   #0x0, R12
   \   000058   9824         JEQ     ??ZDO_ProcessMgmtLqiReq_8
   1182              {
   1183                x = 0;
   \   00005A   4943         MOV.B   #0x0, R9
   1184                item = table;
   \   00005C   074C         MOV.W   R12, R7
   1185                index = StartIndex;
   \   00005E   4B48         MOV.B   R8, R11
   \   000060   113C         JMP     ??ZDO_ProcessMgmtLqiReq_9
   1186          
   1187                // Loop through associated items and build list
   1188                for ( ; x < numItems; x++ )
   1189                {
   1190                  if ( index < aItems )
   1191                  {
   1192                    // get next associated device
   1193                    aDevice = AssocFindDevice( index++ );
   1194          
   1195                    // set basic fields
   1196                    item->panID   = _NIB.nwkPanId;
   1197                    osal_cpyExtAddr( item->extPanID, _NIB.extendedPANID );
   1198                    item->nwkAddr = aDevice->shortAddr;
   1199                    item->permit  = ZDP_MGMT_BOOL_UNKNOWN;
   1200                    item->depth   = 0xFF;
   1201                    item->lqi     = aDevice->linkInfo.rxLqi;
   1202          
   1203                    // set extented address
   1204                    nwkEntry.user    = ADDRMGR_USER_DEFAULT;
   1205                    nwkEntry.nwkAddr = aDevice->shortAddr;
   1206          
   1207                    if ( AddrMgrEntryLookupNwk( &nwkEntry ) == TRUE )
   1208                    {
   1209                      osal_cpyExtAddr( item->extAddr, nwkEntry.extAddr );
   1210                    }
   1211                    else
   1212                    {
   1213                      osal_memset( item->extAddr, 0xFF, Z_EXTADDR_LEN );
   1214                    }
   1215          
   1216                    // use association info to set other fields
   1217                    if ( aDevice->nodeRelation == PARENT )
   1218                    {
   1219                      if (  aDevice->shortAddr == 0 )
   1220                      {
   1221                        item->devType = ZDP_MGMT_DT_COORD;
   1222                        item->depth = 0;
   1223                      }
   1224                      else
   1225                      {
   1226                        item->devType = ZDP_MGMT_DT_ROUTER;
   1227                        item->depth = _NIB.nodeDepth - 1;
   1228                      }
   1229          
   1230                      item->rxOnIdle = ZDP_MGMT_BOOL_UNKNOWN;
   1231                      item->relation = ZDP_MGMT_REL_PARENT;
   1232                    }
   1233                    else
   1234                    {
   1235                      // If not parent, then it's a child
   1236                      item->depth = _NIB.nodeDepth + 1;
   1237          
   1238                      if ( aDevice->nodeRelation < CHILD_FFD )
   1239                      {
   1240                        item->devType = ZDP_MGMT_DT_ENDDEV;
   1241          
   1242                        if ( aDevice->nodeRelation == CHILD_RFD )
   1243                        {
   1244                          item->rxOnIdle = FALSE;
   1245                        }
   1246                        else
   1247                        {
   1248                          item->rxOnIdle = TRUE;
   1249                        }
   1250                      }
   1251                      else
   1252                      {
   1253                        item->devType = ZDP_MGMT_DT_ROUTER;
   \                     ??ZDO_ProcessMgmtLqiReq_1:
   \   000062   D7431400     MOV.B   #0x1, 0x14(R7)
   1254          
   1255                        if ( aDevice->nodeRelation == CHILD_FFD )
   \   000066   F69003000400 CMP.B   #0x3, 0x4(R6)
   \                     ??ZDO_ProcessMgmtLqiReq_17:
   \   00006C   0224         JEQ     ??ZDO_ProcessMgmtLqiReq_10
   \   00006E   5E43         MOV.B   #0x1, R14
   \   000070   013C         JMP     ??ZDO_ProcessMgmtLqiReq_4
   \                     ??ZDO_ProcessMgmtLqiReq_10:
   \   000072   4E43         MOV.B   #0x0, R14
   1256                        {
   1257                          item->rxOnIdle = FALSE;
   1258                        }
   1259                        else
   1260                        {
   1261                          item->rxOnIdle = TRUE;
   1262                        }
   1263                      }
   1264          
   1265                      item->relation = ZDP_MGMT_REL_CHILD;
   \                     ??ZDO_ProcessMgmtLqiReq_4:
   \   000074   5F43         MOV.B   #0x1, R15
   \                     ??ZDO_ProcessMgmtLqiReq_0:
   \   000076   C74F1600     MOV.B   R15, 0x16(R7)
   \   00007A   C74E1500     MOV.B   R14, 0x15(R7)
   1266                    }
   1267          
   1268                    item++;
   \   00007E   37501A00     ADD.W   #0x1a, R7
   \   000082   5953         ADD.B   #0x1, R9
   \                     ??ZDO_ProcessMgmtLqiReq_9:
   \   000084   499A         CMP.B   R10, R9
   \   000086   532C         JC      ??ZDO_ProcessMgmtLqiReq_3
   \   000088   4B95         CMP.B   R5, R11
   \   00008A   4A2C         JC      ??ZDO_ProcessMgmtLqiReq_11
   \   00008C   4C4B         MOV.B   R11, R12
   \   00008E   ........     CALLA   #AssocFindDevice
   \   000092   064C         MOV.W   R12, R6
   \   000094   5B53         ADD.B   #0x1, R11
   \   000096   9742....0000 MOV.W   &_NIB + 36, 0(R7)
   \   00009C   ........     CALLA   #?Subroutine16
   \                     ??CrossCallReturnLabel_79:
   \   0000A0   A7461200     MOV.W   @R6, 0x12(R7)
   \   0000A4   E7431700     MOV.B   #0x2, 0x17(R7)
   \   0000A8   F7431800     MOV.B   #0xff, 0x18(R7)
   \   0000AC   D7460A001900 MOV.B   0xa(R6), 0x19(R7)
   \   0000B2   C1430200     MOV.B   #0x0, 0x2(SP)
   \   0000B6   A1460400     MOV.W   @R6, 0x4(SP)
   \   0000BA   0C41         MOV.W   SP, R12
   \   0000BC   2C53         ADD.W   #0x2, R12
   \   0000BE   ........     CALLA   #AddrMgrEntryLookupNwk
   \   0000C2   5C93         CMP.B   #0x1, R12
   \   0000C4   0920         JNE     ??ZDO_ProcessMgmtLqiReq_12
   \   0000C6   0D41         MOV.W   SP, R13
   \   0000C8   3D500600     ADD.W   #0x6, R13
   \   0000CC   0C47         MOV.W   R7, R12
   \   0000CE   3C500A00     ADD.W   #0xa, R12
   \   0000D2   ........     CALLA   #sAddrExtCpy
   \   0000D6   023C         JMP     ??ZDO_ProcessMgmtLqiReq_13
   \                     ??ZDO_ProcessMgmtLqiReq_12:
   \   0000D8   ........     CALLA   #?Subroutine24
   \                     ??ZDO_ProcessMgmtLqiReq_13:
   \   0000DC   C6930400     CMP.B   #0x0, 0x4(R6)
   \   0000E0   1120         JNE     ??ZDO_ProcessMgmtLqiReq_14
   \   0000E2   86930000     CMP.W   #0x0, 0(R6)
   \   0000E6   0420         JNE     ??ZDO_ProcessMgmtLqiReq_15
   \   0000E8   C7431400     MOV.B   #0x0, 0x14(R7)
   \   0000EC   4E43         MOV.B   #0x0, R14
   \   0000EE   053C         JMP     ??ZDO_ProcessMgmtLqiReq_16
   \                     ??ZDO_ProcessMgmtLqiReq_15:
   \   0000F0   D7431400     MOV.B   #0x1, 0x14(R7)
   \   0000F4   5E42....     MOV.B   &_NIB + 56, R14
   \   0000F8   7E53         ADD.B   #0xff, R14
   \                     ??ZDO_ProcessMgmtLqiReq_16:
   \   0000FA   C74E1800     MOV.B   R14, 0x18(R7)
   \   0000FE   6E43         MOV.B   #0x2, R14
   \   000100   4F43         MOV.B   #0x0, R15
   \   000102   B93F         JMP     ??ZDO_ProcessMgmtLqiReq_0
   \                     ??ZDO_ProcessMgmtLqiReq_14:
   \   000104   5E42....     MOV.B   &_NIB + 56, R14
   \   000108   5E53         ADD.B   #0x1, R14
   \   00010A   C74E1800     MOV.B   R14, 0x18(R7)
   \   00010E   F69003000400 CMP.B   #0x3, 0x4(R6)
   \   000114   A62F         JC      ??ZDO_ProcessMgmtLqiReq_1
   \   000116   E7431400     MOV.B   #0x2, 0x14(R7)
   \   00011A   D6930400     CMP.B   #0x1, 0x4(R6)
   \   00011E   A63F         JMP     ??ZDO_ProcessMgmtLqiReq_17
   1269                  }
   1270                  else
   1271                  {
   1272                    if ( StartIndex <= aItems )
   \                     ??ZDO_ProcessMgmtLqiReq_11:
   \   000120   4598         CMP.B   R8, R5
   \   000122   032C         JC      ??ZDO_ProcessMgmtLqiReq_18
   \   000124   4B48         MOV.B   R8, R11
   \   000126   4B85         SUB.B   R5, R11
   \   000128   043C         JMP     ??ZDO_ProcessMgmtLqiReq_19
   \                     ??ZDO_ProcessMgmtLqiReq_18:
   \   00012A   4B43         MOV.B   #0x0, R11
   \   00012C   023C         JMP     ??ZDO_ProcessMgmtLqiReq_19
   1273                      // Start with 1st neighbor
   1274                      index = 0;
   1275                    else
   1276                      // Start with >1st neighbor
   1277                      index = StartIndex - aItems;
   1278                    break;
   1279                  }
   1280                }
   1281          
   1282                // Loop through neighbor items and finish list
   1283                for ( ; x < numItems; x++ )
   \                     ??ZDO_ProcessMgmtLqiReq_3:
   \   00012E   499A         CMP.B   R10, R9
   \   000130   2C2C         JC      ??ZDO_ProcessMgmtLqiReq_8
   1284                {
   1285                  // Add next neighbor table item
   1286                  NLME_GetRequest( nwkNeighborTable, index++, &entry );
   \                     ??ZDO_ProcessMgmtLqiReq_19:
   \   000132   0E41         MOV.W   SP, R14
   \   000134   3E501000     ADD.W   #0x10, R14
   \   000138   4D4B         MOV.B   R11, R13
   \   00013A   7C408700     MOV.B   #0x87, R12
   \   00013E   ........     CALLA   #NLME_GetRequest
   \   000142   5B53         ADD.B   #0x1, R11
   1287          
   1288                  // set ZDP_MgmtLqiItem_t fields
   1289                  item->panID    = entry.panId;
   \   000144   97411A000000 MOV.W   0x1a(SP), 0(R7)
   1290                  osal_cpyExtAddr( item->extPanID, _NIB.extendedPANID );
   \   00014A   ........     CALLA   #?Subroutine16
   1291                  osal_memset( item->extAddr, 0xFF, Z_EXTADDR_LEN );
   \                     ??CrossCallReturnLabel_78:
   \   00014E   ........     CALLA   #?Subroutine24
   1292                  item->nwkAddr  = entry.neighborAddress;
   \                     ??CrossCallReturnLabel_37:
   \   000152   974110001200 MOV.W   0x10(SP), 0x12(R7)
   1293                  item->rxOnIdle = ZDP_MGMT_BOOL_UNKNOWN;
   \   000158   E7431500     MOV.B   #0x2, 0x15(R7)
   1294                  item->relation = ZDP_MGMT_REL_UNKNOWN;
   \   00015C   F74003001600 MOV.B   #0x3, 0x16(R7)
   1295                  item->permit   = ZDP_MGMT_BOOL_UNKNOWN;
   \   000162   E7431700     MOV.B   #0x2, 0x17(R7)
   1296                  item->depth    = 0xFF;
   \   000166   F7431800     MOV.B   #0xff, 0x18(R7)
   1297                  item->lqi      = entry.linkInfo.rxLqi;
   \   00016A   D74120001900 MOV.B   0x20(SP), 0x19(R7)
   1298          
   1299                  if ( item->nwkAddr == 0 )
   \   000170   87931200     CMP.W   #0x0, 0x12(R7)
   \   000174   0224         JEQ     ??ZDO_ProcessMgmtLqiReq_20
   \   000176   5E43         MOV.B   #0x1, R14
   \   000178   013C         JMP     ??ZDO_ProcessMgmtLqiReq_21
   \                     ??ZDO_ProcessMgmtLqiReq_20:
   \   00017A   4E43         MOV.B   #0x0, R14
   \                     ??ZDO_ProcessMgmtLqiReq_21:
   \   00017C   C74E1400     MOV.B   R14, 0x14(R7)
   1300                  {
   1301                    item->devType = ZDP_MGMT_DT_COORD;
   1302                  }
   1303                  else
   1304                  {
   1305                    item->devType = ZDP_MGMT_DT_ROUTER;
   1306                  }
   1307          
   1308                  item++;
   \   000180   37501A00     ADD.W   #0x1a, R7
   1309                }
   \   000184   5953         ADD.B   #0x1, R9
   \   000186   D33F         JMP     ??ZDO_ProcessMgmtLqiReq_3
   1310              }
   1311            }
   1312            else
   1313            {
   1314              numItems = 0;
   \                     ??ZDO_ProcessMgmtLqiReq_6:
   \   000188   4A43         MOV.B   #0x0, R10
   1315            }
   1316          
   1317            // Send response
   1318            ZDP_MgmtLqiRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZSuccess, maxItems,
   1319                            StartIndex, numItems, table, false );
   \                     ??ZDO_ProcessMgmtLqiReq_8:
   \   00018A   4312         PUSH.B  #0x0
   \   00018C   0412         PUSH.W  R4
   \   00018E   4A12         PUSH.B  R10
   \   000190   4812         PUSH.B  R8
   \   000192   5F410800     MOV.B   0x8(SP), R15
   \   000196   4E43         MOV.B   #0x0, R14
   \   000198   1D413000     MOV.W   0x30(SP), R13
   \   00019C   2D53         ADD.W   #0x2, R13
   \   00019E   1B413000     MOV.W   0x30(SP), R11
   \   0001A2   5C4B1100     MOV.B   0x11(R11), R12
   \   0001A6   ........     CALLA   #ZDP_MgmtLqiRsp
   1320          
   1321            if ( table )
   \   0001AA   3152         ADD.W   #0x8, SP
   \   0001AC   0493         CMP.W   #0x0, R4
   \   0001AE   0324         JEQ     ??ZDO_ProcessMgmtLqiReq_22
   1322            {
   1323              osal_mem_free( table );
   \   0001B0   0C44         MOV.W   R4, R12
   \   0001B2   ........     CALLA   #osal_mem_free
   1324            }
   1325          }
   \                     ??ZDO_ProcessMgmtLqiReq_22:
   \   0001B6   31502A00     ADD.W   #0x2a, SP
   \   0001BA   7417         POPM.W  #0x8, R11
   \   0001BC   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine24:
   \   000000   3E42         MOV.W   #0x8, R14
   \   000002   7D43         MOV.B   #0xff, R13
   \   000004   0C47         MOV.W   R7, R12
   \   000006   3C500A00     ADD.W   #0xa, R12
   \   00000A   ........     BRA     #osal_memset

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine16:
   \   000000   3D40....     MOV.W   #_NIB + 57, R13
   \   000004   0C47         MOV.W   R7, R12
   \   000006                REQUIRE ??Subroutine32_0
   \   000006                // Fall through to label ??Subroutine32_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine32_0:
   \   000000   2C53         ADD.W   #0x2, R12
   \   000002   ........     BRA     #sAddrExtCpy
   1326          
   1327          /*********************************************************************
   1328           * @fn          ZDO_ProcessMgmtNwkDiscReq
   1329           *
   1330           * @brief       This function handles parsing the incoming Management
   1331           *              Network Discover request and starts the request.
   1332           *
   1333           * @param       inMsg - incoming message (request)
   1334           *
   1335           * @return      none
   1336           */

   \                                 In  segment CODE, align 2, keep-with-next
   1337          void ZDO_ProcessMgmtNwkDiscReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessMgmtNwkDiscReq:
   1338          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0A4C         MOV.W   R12, R10
   1339            NLME_ScanFields_t scan;
   1340            uint8             index;
   1341            uint8             *msg;
   1342          
   1343            msg = inMsg->asdu;
   \   000006   ........     CALLA   #?Subroutine4
   1344            scan.channels = osal_build_uint32( msg, 4 );
   \                     ??CrossCallReturnLabel_2:
   \   00000A   814C0000     MOV.W   R12, 0(SP)
   \   00000E   814D0200     MOV.W   R13, 0x2(SP)
   1345            msg += 4;
   \   000012   2B52         ADD.W   #0x4, R11
   1346            scan.duration = *msg++;
   \   000014   F14B0400     MOV.B   @R11+, 0x4(SP)
   1347            index         = *msg;
   \   000018   6E4B         MOV.B   @R11, R14
   1348            scan.scanType = ZMAC_ACTIVE_SCAN;
   \   00001A   D1430500     MOV.B   #0x1, 0x5(SP)
   1349            scan.scanApp  = NLME_DISC_SCAN;
   \   00001E   D1430600     MOV.B   #0x1, 0x6(SP)
   1350          
   1351            // Save off the information to be used for the response
   1352            zdappMgmtNwkDiscReqInProgress          = true;
   \   000022   D243....     MOV.B   #0x1, &zdappMgmtNwkDiscReqInProgress
   1353            zdappMgmtNwkDiscRspAddr.addrMode       = Addr16Bit;
   \   000026   E243....     MOV.B   #0x2, &zdappMgmtNwkDiscRspAddr + 8
   1354            zdappMgmtNwkDiscRspAddr.addr.shortAddr = inMsg->srcAddr.addr.shortAddr;
   \   00002A   924A0200.... MOV.W   0x2(R10), &zdappMgmtNwkDiscRspAddr
   1355            zdappMgmtNwkDiscStartIndex             = index;
   \   000030   C24E....     MOV.B   R14, &zdappMgmtNwkDiscStartIndex
   1356            zdappMgmtNwkDiscRspTransSeq            = inMsg->TransSeq;
   \   000034   D24A1100.... MOV.B   0x11(R10), &zdappMgmtNwkDiscRspTransSeq
   1357          
   1358            if ( NLME_NwkDiscReq2( &scan ) != ZSuccess )
   \   00003A   0C41         MOV.W   SP, R12
   \   00003C   0C53         ADD.W   #0x0, R12
   \   00003E   ........     CALLA   #NLME_NwkDiscReq2
   \   000042   4C93         CMP.B   #0x0, R12
   \   000044   0224         JEQ     ??ZDO_ProcessMgmtNwkDiscReq_0
   1359            {
   1360              NLME_NwkDiscTerm();
   \   000046   ........     CALLA   #NLME_NwkDiscTerm
   1361          
   1362              // zdappMgmtNwkDiscReqInProgress will be reset in the confirm callback
   1363            }
   1364          }
   \                     ??ZDO_ProcessMgmtNwkDiscReq_0:
   \   00004A   3152         ADD.W   #0x8, SP
   \   00004C   1A17         POPM.W  #0x2, R11
   \   00004E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   1B4C1600     MOV.W   0x16(R12), R11
   \   000004   6D42         MOV.B   #0x4, R13
   \   000006   0C4B         MOV.W   R11, R12
   \   000008   ........     BRA     #osal_build_uint32
   1365          
   1366          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
   1367          /*********************************************************************
   1368           * @fn          ZDO_FinishProcessingMgmtNwkDiscReq
   1369           *
   1370           * @brief       This function finishes the processing of the Management
   1371           *              Network Discover Request and generates the response.
   1372           *
   1373           *   Note:      This function will limit the number of items returned
   1374           *              to ZDO_MAX_NWKDISC_ITEMS items.
   1375           *
   1376           * @param       ResultCountSrcAddr - source of the request
   1377           * @param       msg - pointer to incoming message
   1378           * @param       SecurityUse -
   1379           *
   1380           * @return      none
   1381           */
   1382          void ZDO_FinishProcessingMgmtNwkDiscReq( void )
   1383          {
   1384            byte count, i, ResultCount = 0;
   1385            networkDesc_t *newDesc = NULL, *pList, *NetworkList;
   1386          
   1387            NetworkList = nwk_getNwkDescList();
   1388          
   1389            // Count the number of nwk descriptors in the list
   1390            pList = nwk_getNwkDescList();
   1391            while (pList)
   1392            {
   1393              ResultCount++;
   1394              pList = pList->nextDesc;
   1395            }
   1396          
   1397            if ( ZSTACK_ROUTER_BUILD )
   1398            {
   1399              // Look for my PanID.
   1400              pList = nwk_getNwkDescList();
   1401              while ( pList )
   1402              {
   1403                if ( pList->panId == _NIB.nwkPanId )
   1404                {
   1405                  break;
   1406                }
   1407          
   1408          
   1409                if ( !pList->nextDesc )
   1410                {
   1411                  break;
   1412                }
   1413                pList = pList->nextDesc;
   1414              }
   1415          
   1416          
   1417              // If my Pan not present (query to a star network ZC or an isolated ZR?),
   1418              // prepend it.
   1419              if ( !pList || (pList->panId != _NIB.nwkPanId) )
   1420              {
   1421                newDesc = (networkDesc_t *)osal_mem_alloc( sizeof( networkDesc_t ) );
   1422                if ( newDesc )
   1423                {
   1424                  byte pJoin;
   1425          
   1426                  newDesc->panId = _NIB.nwkPanId;
   1427                  newDesc->logicalChannel = _NIB.nwkLogicalChannel;
   1428                  newDesc->version = NLME_GetProtocolVersion();
   1429                  newDesc->stackProfile = zgStackProfile;
   1430          
   1431                  //Extended PanID
   1432                  osal_cpyExtAddr( newDesc->extendedPANID, _NIB.extendedPANID);
   1433          
   1434                  ZMacGetReq( ZMacAssociationPermit, &pJoin );
   1435                  newDesc->chosenRouter = ((pJoin) ? ZDAppNwkAddr.addr.shortAddr :
   1436                                                     INVALID_NODE_ADDR);
   1437          
   1438                  newDesc->nextDesc = NetworkList;
   1439                  NetworkList = newDesc;
   1440                  ResultCount++;
   1441                }
   1442              }
   1443            }
   1444          
   1445            // Calc the count and apply a max count.
   1446            if ( zdappMgmtNwkDiscStartIndex > ResultCount )
   1447            {
   1448              count = 0;
   1449            }
   1450            else
   1451            {
   1452              count = ResultCount - zdappMgmtNwkDiscStartIndex;
   1453              if ( count > ZDO_MAX_NWKDISC_ITEMS )
   1454              {
   1455                count = ZDO_MAX_NWKDISC_ITEMS;
   1456              }
   1457          
   1458              // Move the list pointer up to the start index.
   1459              for ( i = 0; i < zdappMgmtNwkDiscStartIndex; i++ )
   1460              {
   1461                NetworkList = NetworkList->nextDesc;
   1462              }
   1463            }
   1464          
   1465            ZDP_MgmtNwkDiscRsp( zdappMgmtNwkDiscRspTransSeq,
   1466                               &zdappMgmtNwkDiscRspAddr, ZSuccess, ResultCount,
   1467                                zdappMgmtNwkDiscStartIndex,
   1468                                count,
   1469                                NetworkList,
   1470                                false );
   1471          
   1472            if ( ZSTACK_ROUTER_BUILD )
   1473            {
   1474              if ( newDesc != NULL )
   1475              {
   1476                osal_mem_free( newDesc );
   1477              }
   1478            }
   1479          
   1480            NLME_NwkDiscTerm();
   1481          }
   1482          #endif
   1483          
   1484          /*********************************************************************
   1485           * @fn          ZDO_ProcessMgmtRtgReq
   1486           *
   1487           * @brief       This function finishes the processing of the Management
   1488           *              Routing Request and generates the response.
   1489           *
   1490           *   Note:      This function will limit the number of items returned
   1491           *              to ZDO_MAX_RTG_ITEMS items.
   1492           *
   1493           * @param       inMsg - incoming message (request)
   1494           *
   1495           * @return      none
   1496           */

   \                                 In  segment CODE, align 2, keep-with-next
   1497          void ZDO_ProcessMgmtRtgReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessMgmtRtgReq:
   1498          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   084C         MOV.W   R12, R8
   1499            byte x;
   1500            byte maxNumItems;
   1501            byte numItems = 0;
   \   000006   4A43         MOV.B   #0x0, R10
   1502            uint8 *pBuf = NULL;
   \   000008   0943         MOV.W   #0x0, R9
   1503            rtgItem_t *pList;
   1504            uint8 StartIndex = inMsg->asdu[0];
   \   00000A   1F4C1600     MOV.W   0x16(R12), R15
   \   00000E   664F         MOV.B   @R15, R6
   1505          
   1506            // Get the number of table items
   1507            NLME_GetRequest( nwkNumRoutingTableEntries, 0, &maxNumItems );
   \   000010   0E41         MOV.W   SP, R14
   \   000012   0E53         ADD.W   #0x0, R14
   \   000014   0D43         MOV.W   #0x0, R13
   \   000016   7C409D00     MOV.B   #0x9d, R12
   \   00001A   ........     CALLA   #NLME_GetRequest
   1508          
   1509            if ( maxNumItems > StartIndex )
   \   00001E   6691         CMP.B   @SP, R6
   \   000020   302C         JC      ??ZDO_ProcessMgmtRtgReq_2
   1510            {
   1511              numItems = maxNumItems - StartIndex;    // Start at the passed in index
   \   000022   6A41         MOV.B   @SP, R10
   \   000024   4A86         SUB.B   R6, R10
   1512          
   1513              // limit the size of the list
   1514              if ( numItems > ZDO_MAX_RTG_ITEMS )
   \   000026   7A900B00     CMP.B   #0xb, R10
   \   00002A   0228         JNC     ??ZDO_ProcessMgmtRtgReq_3
   1515              {
   1516                numItems = ZDO_MAX_RTG_ITEMS;
   \   00002C   7A400A00     MOV.B   #0xa, R10
   1517              }
   1518          
   1519              // Allocate the memory to build the table
   1520              pBuf = osal_mem_alloc( (short)(sizeof( rtgItem_t ) * numItems) );
   \                     ??ZDO_ProcessMgmtRtgReq_3:
   \   000030   4C4A         MOV.B   R10, R12
   \   000032   5C0A         RLAM.W  #0x3, R12
   \   000034   ........     CALLA   #osal_mem_alloc
   \   000038   094C         MOV.W   R12, R9
   1521          
   1522              if ( pBuf != NULL )
   \   00003A   0C93         CMP.W   #0x0, R12
   \   00003C   2124         JEQ     ??ZDO_ProcessMgmtRtgReq_4
   1523              {
   1524                // Convert buffer to list
   1525                pList = (rtgItem_t *)pBuf;
   \   00003E   074C         MOV.W   R12, R7
   1526          
   1527                // Loop through items and build list
   1528                for ( x = 0; x < numItems; x++ )
   \   000040   4B43         MOV.B   #0x0, R11
   \   000042   063C         JMP     ??ZDO_ProcessMgmtRtgReq_5
   1529                {
   1530                  NLME_GetRequest( nwkRoutingTable, (uint16)(x + StartIndex), (void*)pList );
   1531          
   1532                  // Remap the status to the RoutingTableList Record Format defined in the ZigBee spec
   1533                  switch( pList->status )
   1534                  {
   1535                    case RT_ACTIVE:
   1536                      pList->status = ZDO_MGMT_RTG_ENTRY_ACTIVE;
   1537                      break;
   1538          
   1539                    case RT_DISC:
   1540                      pList->status = ZDO_MGMT_RTG_ENTRY_DISCOVERY_UNDERWAY;
   1541                      break;
   1542          
   1543                    case RT_LINK_FAIL:
   1544                      pList->status = ZDO_MGMT_RTG_ENTRY_DISCOVERY_FAILED;
   1545                      break;
   1546          
   1547                    case RT_INIT:
   1548                    case RT_REPAIR:
   1549                    default:
   1550                      pList->status = ZDO_MGMT_RTG_ENTRY_INACTIVE;
   \                     ??ZDO_ProcessMgmtRtgReq_0:
   \   000044   7E400300     MOV.B   #0x3, R14
   1551                      break;
   \                     ??ZDO_ProcessMgmtRtgReq_1:
   \   000048   C74E0500     MOV.B   R14, 0x5(R7)
   1552                  }
   1553          
   1554                  // Increment pointer to next record
   1555                  pList++;
   \   00004C   3752         ADD.W   #0x8, R7
   \   00004E   5B53         ADD.B   #0x1, R11
   \                     ??ZDO_ProcessMgmtRtgReq_5:
   \   000050   4B9A         CMP.B   R10, R11
   \   000052   172C         JC      ??ZDO_ProcessMgmtRtgReq_2
   \   000054   0E47         MOV.W   R7, R14
   \   000056   4D4B         MOV.B   R11, R13
   \   000058   0D56         ADD.W   R6, R13
   \   00005A   7C408B00     MOV.B   #0x8b, R12
   \   00005E   ........     CALLA   #NLME_GetRequest
   \   000062   5E470500     MOV.B   0x5(R7), R14
   \   000066   5E83         SUB.B   #0x1, R14
   \   000068   0524         JEQ     ??ZDO_ProcessMgmtRtgReq_6
   \   00006A   5E83         SUB.B   #0x1, R14
   \   00006C   0524         JEQ     ??ZDO_ProcessMgmtRtgReq_7
   \   00006E   5E83         SUB.B   #0x1, R14
   \   000070   0524         JEQ     ??ZDO_ProcessMgmtRtgReq_8
   \   000072   E83F         JMP     ??ZDO_ProcessMgmtRtgReq_0
   \                     ??ZDO_ProcessMgmtRtgReq_6:
   \   000074   4E43         MOV.B   #0x0, R14
   \   000076   E83F         JMP     ??ZDO_ProcessMgmtRtgReq_1
   \                     ??ZDO_ProcessMgmtRtgReq_7:
   \   000078   5E43         MOV.B   #0x1, R14
   \   00007A   E63F         JMP     ??ZDO_ProcessMgmtRtgReq_1
   \                     ??ZDO_ProcessMgmtRtgReq_8:
   \   00007C   6E43         MOV.B   #0x2, R14
   \   00007E   E43F         JMP     ??ZDO_ProcessMgmtRtgReq_1
   1556                }
   1557              }
   1558              else
   1559              {
   1560                numItems = 0;
   \                     ??ZDO_ProcessMgmtRtgReq_4:
   \   000080   4A43         MOV.B   #0x0, R10
   1561              }
   1562            }
   1563          
   1564            // Send response
   1565            ZDP_MgmtRtgRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZSuccess, maxNumItems, StartIndex, numItems,
   1566                                  (rtgItem_t *)pBuf, false );
   \                     ??ZDO_ProcessMgmtRtgReq_2:
   \   000082   4312         PUSH.B  #0x0
   \   000084   0912         PUSH.W  R9
   \   000086   4A12         PUSH.B  R10
   \   000088   4612         PUSH.B  R6
   \   00008A   5F410800     MOV.B   0x8(SP), R15
   \   00008E   4E43         MOV.B   #0x0, R14
   \   000090   0D48         MOV.W   R8, R13
   \   000092   2D53         ADD.W   #0x2, R13
   \   000094   5C481100     MOV.B   0x11(R8), R12
   \   000098   ........     CALLA   #ZDP_MgmtRtgRsp
   1567          
   1568            if ( pBuf != NULL )
   \   00009C   3152         ADD.W   #0x8, SP
   \   00009E   0993         CMP.W   #0x0, R9
   \   0000A0   0324         JEQ     ??ZDO_ProcessMgmtRtgReq_9
   1569            {
   1570              osal_mem_free( pBuf );
   \   0000A2   0C49         MOV.W   R9, R12
   \   0000A4   ........     CALLA   #osal_mem_free
   1571            }
   1572          }
   \                     ??ZDO_ProcessMgmtRtgReq_9:
   \   0000A8   2153         ADD.W   #0x2, SP
   \   0000AA   5617         POPM.W  #0x6, R11
   \   0000AC   1001         RETA
   1573          
   1574          /*********************************************************************
   1575           * @fn          ZDO_ProcessMgmtBindReq
   1576           *
   1577           * @brief       This function finishes the processing of the Management
   1578           *              Bind Request and generates the response.
   1579           *
   1580           *   Note:      This function will limit the number of items returned
   1581           *              to ZDO_MAX_BIND_ITEMS items.
   1582           *
   1583           * @param       inMsg - incoming message (request)
   1584           *
   1585           * @return      none
   1586           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   2153         ADD.W   #0x2, SP
   \   000002   7417         POPM.W  #0x8, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1587          void ZDO_ProcessMgmtBindReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessMgmtBindReq:
   1588          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   094C         MOV.W   R12, R9
   1589          #if defined ( REFLECTOR )
   1590            byte x;
   1591            uint16 maxNumItems;
   1592            uint16 numItems;
   1593            uint8 *pBuf = NULL;
   \   000006   0643         MOV.W   #0x0, R6
   1594            apsBindingItem_t *pList;
   1595            uint8 StartIndex = inMsg->asdu[0];
   \   000008   1F4C1600     MOV.W   0x16(R12), R15
   \   00000C   6B4F         MOV.B   @R15, R11
   1596            uint8 status;
   1597          
   1598            // Get the number of table items
   1599            APSME_GetRequest( apsNumBindingTableEntries, 0, (byte*)(&maxNumItems) );
   \   00000E   0E41         MOV.W   SP, R14
   \   000010   0E53         ADD.W   #0x0, R14
   \   000012   0D43         MOV.W   #0x0, R13
   \   000014   7C40A300     MOV.B   #0xa3, R12
   \   000018   ........     CALLA   #APSME_GetRequest
   1600          
   1601            if ( maxNumItems > StartIndex )
   \   00001C   4F4B         MOV.B   R11, R15
   \   00001E   2F91         CMP.W   @SP, R15
   \   000020   232C         JC      ??ZDO_ProcessMgmtBindReq_1
   1602            {
   1603              numItems = maxNumItems - StartIndex;    // Start at the passed in index
   \   000022   2741         MOV.W   @SP, R7
   \   000024   078F         SUB.W   R15, R7
   1604            }
   1605            else
   1606            {
   1607              numItems = 0;
   1608            }
   1609          
   1610            // limit the size of the list
   1611            if ( numItems > ZDO_MAX_BIND_ITEMS )
   \   000026   2792         CMP.W   #0x4, R7
   \   000028   0328         JNC     ??ZDO_ProcessMgmtBindReq_2
   1612            {
   1613              numItems = ZDO_MAX_BIND_ITEMS;
   \   00002A   37400300     MOV.W   #0x3, R7
   \   00002E   023C         JMP     ??ZDO_ProcessMgmtBindReq_3
   1614            }
   1615          
   1616            // Allocate the memory to build the table
   1617            if ( numItems && (pBuf = osal_mem_alloc( sizeof( apsBindingItem_t ) * numItems )) )
   \                     ??ZDO_ProcessMgmtBindReq_2:
   \   000030   0793         CMP.W   #0x0, R7
   \   000032   1A24         JEQ     ??ZDO_ProcessMgmtBindReq_1
   \                     ??ZDO_ProcessMgmtBindReq_3:
   \   000034   0C47         MOV.W   R7, R12
   \   000036   5C0A         RLAM.W  #0x3, R12
   \   000038   0F4C         MOV.W   R12, R15
   \   00003A   0C5C         RLA.W   R12
   \   00003C   0C5F         ADD.W   R15, R12
   \   00003E   ........     CALLA   #osal_mem_alloc
   \   000042   064C         MOV.W   R12, R6
   \   000044   0C93         CMP.W   #0x0, R12
   \   000046   1024         JEQ     ??ZDO_ProcessMgmtBindReq_1
   1618            {
   1619              status = ZSuccess;
   \   000048   4843         MOV.B   #0x0, R8
   1620          
   1621              // Convert buffer to list
   1622              pList = (apsBindingItem_t *)pBuf;
   \   00004A   044C         MOV.W   R12, R4
   1623          
   1624              // Loop through items and build list
   1625              for ( x = 0; x < numItems; x++ )
   \   00004C   4A43         MOV.B   #0x0, R10
   \                     ??ZDO_ProcessMgmtBindReq_0:
   \   00004E   0A97         CMP.W   R7, R10
   \   000050   0E2C         JC      ??ZDO_ProcessMgmtBindReq_4
   1626              {
   1627                APSME_GetRequest( apsBindingTable, (x + StartIndex), (void*)pList );
   \   000052   0E44         MOV.W   R4, R14
   \   000054   4D4A         MOV.B   R10, R13
   \   000056   0D5B         ADD.W   R11, R13
   \   000058   7C40A200     MOV.B   #0xa2, R12
   \   00005C   ........     CALLA   #APSME_GetRequest
   1628                pList++;
   \   000060   34501800     ADD.W   #0x18, R4
   1629              }
   \   000064   5A53         ADD.B   #0x1, R10
   \   000066   F33F         JMP     ??ZDO_ProcessMgmtBindReq_0
   1630          
   1631            }
   1632            else
   1633            {
   1634              status = ZDP_NOT_PERMITTED;
   \                     ??ZDO_ProcessMgmtBindReq_1:
   \   000068   78408B00     MOV.B   #0x8b, R8
   1635              numItems = 0;
   \   00006C   4743         MOV.B   #0x0, R7
   1636            }
   1637          
   1638            // Send response
   1639            ZDP_MgmtBindRsp( inMsg->TransSeq, &(inMsg->srcAddr), status, (byte)maxNumItems, StartIndex,
   1640                             (byte)numItems, (apsBindingItem_t *)pBuf, false );
   \                     ??ZDO_ProcessMgmtBindReq_4:
   \   00006E   4312         PUSH.B  #0x0
   \   000070   0612         PUSH.W  R6
   \   000072   4712         PUSH.B  R7
   \   000074   4B12         PUSH.B  R11
   \   000076   5F410800     MOV.B   0x8(SP), R15
   \   00007A   4E48         MOV.B   R8, R14
   \   00007C   0D49         MOV.W   R9, R13
   \   00007E   2D53         ADD.W   #0x2, R13
   \   000080   5C491100     MOV.B   0x11(R9), R12
   \   000084   ........     CALLA   #ZDP_MgmtBindRsp
   1641          
   1642            if ( pBuf )
   \   000088   3152         ADD.W   #0x8, SP
   \   00008A   0693         CMP.W   #0x0, R6
   \   00008C   0324         JEQ     ??ZDO_ProcessMgmtBindReq_5
   1643            {
   1644              osal_mem_free( pBuf );
   \   00008E   0C46         MOV.W   R6, R12
   \   000090   ........     CALLA   #osal_mem_free
   1645            }
   1646          #else
   1647            (void)inMsg;
   1648          #endif
   1649          }
   \                     ??ZDO_ProcessMgmtBindReq_5:
   \   000094   ........     BRA     #?Subroutine1
   1650          
   1651          /*********************************************************************
   1652           * @fn          ZDO_ProcessMgmtDirectJoinReq
   1653           *
   1654           * @brief       This function finishes the processing of the Management
   1655           *              Direct Join Request and generates the response.
   1656           *
   1657           * @param       inMsg - incoming message (request)
   1658           *
   1659           * @return      none
   1660           */

   \                                 In  segment CODE, align 2, keep-with-next
   1661          void ZDO_ProcessMgmtDirectJoinReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessMgmtDirectJoinReq:
   1662          {
   \   000000   0A12         PUSH.W  R10
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4C         MOV.W   R12, R10
   1663            uint8 *deviceAddr;
   1664            uint8 capInfo;
   1665            uint8 stat;
   1666          
   1667            // Parse the message
   1668            deviceAddr = inMsg->asdu;
   1669            capInfo = inMsg->asdu[Z_EXTADDR_LEN];
   1670          
   1671            stat = (byte) NLME_DirectJoinRequest( deviceAddr, capInfo );
   \   000006   1C4A1600     MOV.W   0x16(R10), R12
   \   00000A   5D4C0800     MOV.B   0x8(R12), R13
   \   00000E   ........     CALLA   #NLME_DirectJoinRequest
   \   000012   C14C0000     MOV.B   R12, 0(SP)
   1672          
   1673            ZDP_MgmtDirectJoinRsp( inMsg->TransSeq, &(inMsg->srcAddr), stat, false );
   \   000016   4312         PUSH.B  #0x0
   \   000018   0F41         MOV.W   SP, R15
   \   00001A   2F53         ADD.W   #0x2, R15
   \   00001C   0F12         PUSH.W  R15
   \   00001E   5F43         MOV.B   #0x1, R15
   \   000020   3E403580     MOV.W   #0x8035, R14
   \   000024   ........     CALLA   #?Subroutine15
   1674          }
   \                     ??CrossCallReturnLabel_74:
   \   000028   31500600     ADD.W   #0x6, SP
   \   00002C   3A41         POP.W   R10
   \   00002E   1001         RETA
   1675          
   1676          /*********************************************************************
   1677           * @fn          ZDO_ProcessMgmtLeaveReq
   1678           *
   1679           * @brief       This function processes a Management Leave Request
   1680           *              and generates the response.
   1681           *
   1682           * @param       inMsg - incoming message (request)
   1683           *
   1684           * @return      none
   1685           */

   \                                 In  segment CODE, align 2, keep-with-next
   1686          void ZDO_ProcessMgmtLeaveReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessMgmtLeaveReq:
   1687          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0A4C         MOV.W   R12, R10
   1688            NLME_LeaveReq_t req;
   1689            ZStatus_t       status;
   1690            uint8           option;
   1691            uint8 *msg = inMsg->asdu;
   \   000006   1B4C1600     MOV.W   0x16(R12), R11
   1692          
   1693            if ( ( AddrMgrExtAddrValid( msg ) == FALSE                 ) ||
   1694                 ( osal_ExtAddrEqual( msg, NLME_GetExtAddr() ) == TRUE )    )
   \   00000A   0C4B         MOV.W   R11, R12
   \   00000C   ........     CALLA   #AddrMgrExtAddrValid
   \   000010   4C93         CMP.B   #0x0, R12
   \   000012   0824         JEQ     ??ZDO_ProcessMgmtLeaveReq_0
   \   000014   ........     CALLA   #NLME_GetExtAddr
   \   000018   0D4C         MOV.W   R12, R13
   \   00001A   0C4B         MOV.W   R11, R12
   \   00001C   ........     CALLA   #sAddrExtCmp
   \   000020   5C93         CMP.B   #0x1, R12
   \   000022   0320         JNE     ??ZDO_ProcessMgmtLeaveReq_1
   1695            {
   1696              // Remove this device
   1697              req.extAddr = NULL;
   \                     ??ZDO_ProcessMgmtLeaveReq_0:
   \   000024   81430200     MOV.W   #0x0, 0x2(SP)
   \   000028   023C         JMP     ??ZDO_ProcessMgmtLeaveReq_2
   1698            }
   1699            else
   1700            {
   1701              // Remove child device
   1702              req.extAddr = msg;
   \                     ??ZDO_ProcessMgmtLeaveReq_1:
   \   00002A   814B0200     MOV.W   R11, 0x2(SP)
   1703            }
   1704          
   1705            option = msg[Z_EXTADDR_LEN];
   \                     ??ZDO_ProcessMgmtLeaveReq_2:
   \   00002E   5E4B0800     MOV.B   0x8(R11), R14
   1706            if ( option & ZDP_MGMT_LEAVE_REQ_RC )
   \   000032   7EB04000     BIT.B   #0x40, R14
   \   000036   0228         JNC     ??ZDO_ProcessMgmtLeaveReq_3
   1707            {
   1708              req.removeChildren = TRUE;
   \   000038   D1430400     MOV.B   #0x1, 0x4(SP)
   1709            }
   1710          
   1711            if ( option & ZDP_MGMT_LEAVE_REQ_REJOIN )
   \                     ??ZDO_ProcessMgmtLeaveReq_3:
   \   00003C   4E93         CMP.B   #0x0, R14
   \   00003E   0234         JGE     ??ZDO_ProcessMgmtLeaveReq_4
   1712            {
   1713               req.rejoin = TRUE;
   \   000040   D1430500     MOV.B   #0x1, 0x5(SP)
   1714            }
   1715          
   1716            req.silent = FALSE;
   \                     ??ZDO_ProcessMgmtLeaveReq_4:
   \   000044   C1430600     MOV.B   #0x0, 0x6(SP)
   1717          
   1718            status = NLME_LeaveReq( &req );
   \   000048   0C41         MOV.W   SP, R12
   \   00004A   2C53         ADD.W   #0x2, R12
   \   00004C   ........     CALLA   #NLME_LeaveReq
   \   000050   C14C0000     MOV.B   R12, 0(SP)
   1719          
   1720            ZDP_MgmtLeaveRsp( inMsg->TransSeq, &(inMsg->srcAddr), status, FALSE );
   \   000054   4312         PUSH.B  #0x0
   \   000056   0F41         MOV.W   SP, R15
   \   000058   2F53         ADD.W   #0x2, R15
   \   00005A   0F12         PUSH.W  R15
   \   00005C   5F43         MOV.B   #0x1, R15
   \   00005E   3E403480     MOV.W   #0x8034, R14
   \   000062   ........     CALLA   #?Subroutine15
   1721          }
   \                     ??CrossCallReturnLabel_75:
   \   000066   31500C00     ADD.W   #0xc, SP
   \   00006A   1A17         POPM.W  #0x2, R11
   \   00006C   1001         RETA
   1722          
   1723          
   1724          /*********************************************************************
   1725           * @fn          ZDO_ProcessMgmtPermitJoinReq
   1726           *
   1727           * @brief       This function processes a Management Permit Join Request
   1728           *              and generates the response.
   1729           *
   1730           * @param       inMsg - incoming message (request)
   1731           *
   1732           * @return      none
   1733           */

   \                                 In  segment CODE, align 2, keep-with-next
   1734          void ZDO_ProcessMgmtPermitJoinReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessMgmtPermitJoinReq:
   1735          {
   \   000000   0A12         PUSH.W  R10
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4C         MOV.W   R12, R10
   1736            uint8 stat;
   1737            uint8 duration;
   1738            uint8 tcsig;
   1739          
   1740            duration = inMsg->asdu[ZDP_MGMT_PERMIT_JOIN_REQ_DURATION];
   1741            tcsig    = inMsg->asdu[ZDP_MGMT_PERMIT_JOIN_REQ_TC_SIG];
   1742          
   1743            // Set the network layer permit join duration
   1744            stat = (byte) NLME_PermitJoiningRequest( duration );
   \   000006   1F4C1600     MOV.W   0x16(R12), R15
   \   00000A   6C4F         MOV.B   @R15, R12
   \   00000C   ........     CALLA   #NLME_PermitJoiningRequest
   \   000010   C14C0000     MOV.B   R12, 0(SP)
   1745          
   1746            // Handle the Trust Center Significance
   1747            if ( ZG_SECURE_ENABLED && ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
   1748            {
   1749              if ( tcsig == TRUE )
   1750              {
   1751                ZDSecMgrPermitJoining( duration );
   1752              }
   1753            }
   1754          
   1755            // Send a response if unicast
   1756            if ( !inMsg->wasBroadcast )
   \   000014   CA930C00     CMP.B   #0x0, 0xc(R10)
   \   000018   0A20         JNE     ??ZDO_ProcessMgmtPermitJoinReq_0
   1757            {
   1758              ZDP_MgmtPermitJoinRsp( inMsg->TransSeq, &(inMsg->srcAddr), stat, false );
   \   00001A   4312         PUSH.B  #0x0
   \   00001C   0F41         MOV.W   SP, R15
   \   00001E   2F53         ADD.W   #0x2, R15
   \   000020   0F12         PUSH.W  R15
   \   000022   5F43         MOV.B   #0x1, R15
   \   000024   3E403680     MOV.W   #0x8036, R14
   \   000028   ........     CALLA   #?Subroutine15
   1759            }
   \                     ??CrossCallReturnLabel_76:
   \   00002C   2152         ADD.W   #0x4, SP
   1760          }
   \                     ??ZDO_ProcessMgmtPermitJoinReq_0:
   \   00002E   2153         ADD.W   #0x2, SP
   \   000030   3A41         POP.W   R10
   \   000032   1001         RETA
   1761          
   1762          /*
   1763           * This function stub allows the next higher layer to be notified of
   1764           * a permit joining timeout.
   1765           */
   1766          /*********************************************************************
   1767           * @fn          ZDO_ProcessMgmtPermitJoinTimeout
   1768           *
   1769           * @brief       This function stub allows the next higher layer to be
   1770           *              notified of a permit joining timeout. Currently, this
   1771           *              directly bypasses the APS layer.
   1772           *
   1773           * @param       none
   1774           *
   1775           * @return      none
   1776           */

   \                                 In  segment CODE, align 2, keep-with-next
   1777          void ZDO_ProcessMgmtPermitJoinTimeout( void )
   \                     NLME_PermitJoiningTimeout:
   1778          {
   1779            #if defined( ZDO_MGMT_PERMIT_JOIN_RESPONSE )
   1780            // Currently, only the ZDSecMgr needs to be notified
   1781            if ( ZG_SECURE_ENABLED && ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
   1782            {
   1783              ZDSecMgrPermitJoiningTimeout();
   1784            }
   1785            #endif
   1786          }
   \   000000   1001         RETA
   1787          
   1788          /*********************************************************************
   1789           * @fn          ZDO_ProcessUserDescReq
   1790           *
   1791           * @brief       This function finishes the processing of the User
   1792           *              Descriptor Request and generates the response.
   1793           *
   1794           * @param       inMsg - incoming message (request)
   1795           *
   1796           * @return      none
   1797           */

   \                                 In  segment CODE, align 2, keep-with-next
   1798          void ZDO_ProcessUserDescReq( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessUserDescReq:
   1799          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31801200     SUB.W   #0x12, SP
   \   000006   0B4C         MOV.W   R12, R11
   1800            uint16 aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   \   000008   1F4C1600     MOV.W   0x16(R12), R15
   \   00000C   6A4F         MOV.B   @R15, R10
   \   00000E   ........     CALLA   #?Subroutine28
   \                     ??CrossCallReturnLabel_41:
   \   000012   0A5F         ADD.W   R15, R10
   1801            UserDescriptorFormat_t userDesc;
   1802          
   1803            if ( (aoi == ZDAppNwkAddr.addr.shortAddr) && (ZSUCCESS == osal_nv_read(
   1804                       ZCD_NV_USERDESC, 0, sizeof(UserDescriptorFormat_t), &userDesc )) )
   \   000014   1A92....     CMP.W   &ZDAppNwkAddr, R10
   \   000018   1720         JNE     ??ZDO_ProcessUserDescReq_0
   \   00001A   0F41         MOV.W   SP, R15
   \   00001C   0F53         ADD.W   #0x0, R15
   \   00001E   3E401100     MOV.W   #0x11, R14
   \   000022   0D43         MOV.W   #0x0, R13
   \   000024   3C408100     MOV.W   #0x81, R12
   \   000028   ........     CALLA   #osal_nv_read
   \   00002C   4C93         CMP.B   #0x0, R12
   \   00002E   0C20         JNE     ??ZDO_ProcessUserDescReq_0
   1805            {
   1806              ZDP_UserDescRsp( inMsg->TransSeq, &(inMsg->srcAddr), aoi, &userDesc, false );
   \   000030   4312         PUSH.B  #0x0
   \   000032   0F41         MOV.W   SP, R15
   \   000034   2F53         ADD.W   #0x2, R15
   \   000036   0E4A         MOV.W   R10, R14
   \   000038   0D4B         MOV.W   R11, R13
   \   00003A   2D53         ADD.W   #0x2, R13
   \   00003C   5C4B1100     MOV.B   0x11(R11), R12
   \   000040   ........     CALLA   #ZDP_UserDescRsp
   \   000044   2153         ADD.W   #0x2, SP
   \   000046   0E3C         JMP     ??ZDO_ProcessUserDescReq_1
   1807            }
   1808            else
   1809            {
   1810              ZDP_GenericRsp(inMsg->TransSeq, &(inMsg->srcAddr),
   1811                     ZDP_NOT_SUPPORTED, aoi, User_Desc_rsp, inMsg->SecurityUse );
   \                     ??ZDO_ProcessUserDescReq_0:
   \   000048   5B121000     PUSH.B  0x10(R11)
   \   00004C   30121180     PUSH.W  #0x8011
   \   000050   0F4A         MOV.W   R10, R15
   \   000052   7E408400     MOV.B   #0x84, R14
   \   000056   0D4B         MOV.W   R11, R13
   \   000058   2D53         ADD.W   #0x2, R13
   \   00005A   5C4B1100     MOV.B   0x11(R11), R12
   \   00005E   ........     CALLA   #ZDP_GenericRsp
   \   000062   2152         ADD.W   #0x4, SP
   1812            }
   1813          }
   \                     ??ZDO_ProcessUserDescReq_1:
   \   000064   31501200     ADD.W   #0x12, SP
   \   000068   1A17         POPM.W  #0x2, R11
   \   00006A   1001         RETA
   1814          
   1815          /*********************************************************************
   1816           * @fn          ZDO_ProcessUserDescSet
   1817           *
   1818           * @brief       This function finishes the processing of the User
   1819           *              Descriptor Set and generates the response.
   1820           *
   1821           * @param       inMsg - incoming message (request)
   1822           *
   1823           * @return      none
   1824           */

   \                                 In  segment CODE, align 2, keep-with-next
   1825          void ZDO_ProcessUserDescSet( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessUserDescSet:
   1826          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31801400     SUB.W   #0x14, SP
   \   000006   0B4C         MOV.W   R12, R11
   1827            uint8 *msg;
   1828            uint16 aoi;
   1829            UserDescriptorFormat_t userDesc;
   1830            uint8 outMsg[3];
   1831            uint8 status;
   1832          
   1833            msg = inMsg->asdu;
   \   000008   1D4C1600     MOV.W   0x16(R12), R13
   1834            aoi = BUILD_UINT16( msg[0], msg[1] );
   \   00000C   6A4D         MOV.B   @R13, R10
   \   00000E   5F4D0100     MOV.B   0x1(R13), R15
   \   000012                RPT     #0x8
   \   000012   47180F5F     RLAX.W  R15
   \   000016   0A5F         ADD.W   R15, R10
   1835          
   1836            if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \   000018   1A92....     CMP.W   &ZDAppNwkAddr, R10
   \   00001C   2520         JNE     ??ZDO_ProcessUserDescSet_2
   1837            {
   1838              userDesc.len = (msg[2] < AF_MAX_USER_DESCRIPTOR_LEN) ? msg[2] : AF_MAX_USER_DESCRIPTOR_LEN;
   \   00001E   5E4D0200     MOV.B   0x2(R13), R14
   \   000022   7E901000     CMP.B   #0x10, R14
   \   000026   0228         JNC     ??ZDO_ProcessUserDescSet_1
   \   000028   7E401000     MOV.B   #0x10, R14
   \                     ??ZDO_ProcessUserDescSet_1:
   \   00002C   C14E0300     MOV.B   R14, 0x3(SP)
   1839              msg ++;  // increment one for the length field
   1840          
   1841              osal_memcpy( userDesc.desc, &msg[2], userDesc.len );
   \   000030   3D500300     ADD.W   #0x3, R13
   \   000034   0C41         MOV.W   SP, R12
   \   000036   2C52         ADD.W   #0x4, R12
   \   000038   ........     CALLA   #osal_memcpy
   1842              osal_nv_write( ZCD_NV_USERDESC, 0, sizeof(UserDescriptorFormat_t), &userDesc );
   \   00003C   0F41         MOV.W   SP, R15
   \   00003E   3F500300     ADD.W   #0x3, R15
   \   000042   3E401100     MOV.W   #0x11, R14
   \   000046   0D43         MOV.W   #0x0, R13
   \   000048   3C408100     MOV.W   #0x81, R12
   \   00004C   ........     CALLA   #osal_nv_write
   1843              if ( userDesc.len != 0 )
   \   000050   C1930300     CMP.B   #0x0, 0x3(SP)
   \   000054   0424         JEQ     ??ZDO_ProcessUserDescSet_3
   1844              {
   1845                ZDO_Config_Node_Descriptor.UserDescAvail = TRUE;
   \   000056   F2D01000.... BIS.B   #0x10, &ZDO_Config_Node_Descriptor
   \   00005C   033C         JMP     ??ZDO_ProcessUserDescSet_4
   1846              }
   1847              else
   1848              {
   1849                ZDO_Config_Node_Descriptor.UserDescAvail = FALSE;
   \                     ??ZDO_ProcessUserDescSet_3:
   \   00005E   F2C01000.... BIC.B   #0x10, &ZDO_Config_Node_Descriptor
   1850              }
   1851          
   1852              status = ZDP_SUCCESS;
   \                     ??ZDO_ProcessUserDescSet_4:
   \   000064   4E43         MOV.B   #0x0, R14
   \   000066   023C         JMP     ??ZDO_ProcessUserDescSet_5
   1853            }
   1854            else
   1855            {
   1856              status =  ZDP_NOT_SUPPORTED;
   \                     ??ZDO_ProcessUserDescSet_2:
   \   000068   7E408400     MOV.B   #0x84, R14
   1857            }
   1858          
   1859            outMsg[0] = status;
   \                     ??ZDO_ProcessUserDescSet_5:
   \   00006C   C14E0000     MOV.B   R14, 0(SP)
   1860            outMsg[1] = LO_UINT16( aoi );
   \   000070   C14A0100     MOV.B   R10, 0x1(SP)
   1861            outMsg[2] = LO_UINT16( aoi );
   \   000074   C14A0200     MOV.B   R10, 0x2(SP)
   1862          
   1863            ZDP_SendData( &(inMsg->TransSeq), &(inMsg->srcAddr), User_Desc_conf, 3, outMsg,
   1864                         inMsg->SecurityUse );
   \   000078   5B121000     PUSH.B  0x10(R11)
   \   00007C   0F41         MOV.W   SP, R15
   \   00007E   2F53         ADD.W   #0x2, R15
   \   000080   0F12         PUSH.W  R15
   \   000082   7F400300     MOV.B   #0x3, R15
   \   000086   3E401480     MOV.W   #0x8014, R14
   \   00008A   0D4B         MOV.W   R11, R13
   \   00008C   2D53         ADD.W   #0x2, R13
   \   00008E   3B501100     ADD.W   #0x11, R11
   \   000092   0C4B         MOV.W   R11, R12
   \   000094   ........     CALLA   #ZDP_SendData
   1865          }
   \   000098   31501800     ADD.W   #0x18, SP
   \   00009C   1A17         POPM.W  #0x2, R11
   \   00009E   1001         RETA
   1866          
   1867          /*********************************************************************
   1868           * @fn          ZDO_ProcessDeviceAnnce
   1869           *
   1870           * @brief       This function processes a device annouce message.
   1871           *
   1872           * @param       inMsg - incoming message
   1873           *
   1874           * @return      none
   1875           */

   \                                 In  segment CODE, align 2, keep-with-next
   1876          void ZDO_ProcessDeviceAnnce( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ProcessDeviceAnnce:
   1877          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31802200     SUB.W   #0x22, SP
   \   000006   084C         MOV.W   R12, R8
   \   000008   0D41         MOV.W   SP, R13
   \   00000A   0D53         ADD.W   #0x0, R13
   1878            ZDO_DeviceAnnce_t Annce;
   1879            AddrMgrEntry_t addrEntry;
   1880            uint8 parentExt[Z_EXTADDR_LEN];
   1881          
   1882            // Parse incoming message
   1883            ZDO_ParseDeviceAnnce( inMsg, &Annce );
   \   00000C   ........     CALLA   #ZDO_ParseDeviceAnnce
   1884          
   1885            if ( ZSTACK_END_DEVICE_BUILD )
   1886            {
   1887              // Make sure the message didn't come from myself - end device only
   1888              if ( osal_ExtAddrEqual( NLME_GetExtAddr(), Annce.extAddr ) && Annce.nwkAddr == NLME_GetShortAddr() )
   1889              {
   1890                return;
   1891              }
   1892            }
   1893          
   1894          #if defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
   1895            // Clean up the neighbor table
   1896            nwkNeighborRemoveAllStranded();
   \   000010   ........     CALLA   #nwkNeighborRemoveAllStranded
   1897          
   1898            // If address conflict is detected, no need to update the address manager
   1899            if ( NLME_CheckNewAddrSet( Annce.nwkAddr, Annce.extAddr )== ZFailure )
   \   000014   0A41         MOV.W   SP, R10
   \   000016   2A53         ADD.W   #0x2, R10
   \   000018   0D4A         MOV.W   R10, R13
   \   00001A   2C41         MOV.W   @SP, R12
   \   00001C   ........     CALLA   #NLME_CheckNewAddrSet
   \   000020   5C93         CMP.B   #0x1, R12
   \   000022   6B24         JEQ     ??ZDO_ProcessDeviceAnnce_0
   1900            {
   1901              return;
   1902            }
   1903          #endif
   1904          
   1905          #if defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
   1906            // Check for parent's address
   1907            NLME_GetCoordExtAddr( parentExt );
   \   000024   0B41         MOV.W   SP, R11
   \   000026   3B501A00     ADD.W   #0x1a, R11
   \   00002A   0C4B         MOV.W   R11, R12
   \   00002C   ........     CALLA   #NLME_GetCoordExtAddr
   1908            if ( osal_ExtAddrEqual( parentExt, Annce.extAddr ) )
   \   000030   0D4A         MOV.W   R10, R13
   \   000032   0C4B         MOV.W   R11, R12
   \   000034   ........     CALLA   #sAddrExtCmp
   \   000038   4C93         CMP.B   #0x0, R12
   \   00003A   0D24         JEQ     ??ZDO_ProcessDeviceAnnce_2
   1909            {
   1910              if ( Annce.nwkAddr != NLME_GetCoordShortAddr() )
   \   00003C   ........     CALLA   #NLME_GetCoordShortAddr
   \   000040   819C0000     CMP.W   R12, 0(SP)
   \   000044   0824         JEQ     ??ZDO_ProcessDeviceAnnce_2
   1911              {
   1912                // Set the Parent's MAC's new short address
   1913                _NIB.nwkCoordAddress = Annce.nwkAddr;
   \   000046   A241....     MOV.W   @SP, &_NIB + 26
   1914                ZMacSetReq( ZMacCoordShortAddress, (byte*)&(_NIB.nwkCoordAddress) );
   \   00004A   3D40....     MOV.W   #_NIB + 26, R13
   \   00004E   7C404B00     MOV.B   #0x4b, R12
   \   000052   ........     CALLA   #ZMacSetReq
   1915              }
   1916            }
   1917          
   1918            if ( ZSTACK_ROUTER_BUILD )
   1919            {
   1920              // If the device annce comes from a end device child that has moved
   1921              // to another parent, remove it from associated device list
   1922          
   1923              // If the dev annce is coming from other device's children,
   1924              // (The dev annce from its own children shall be unicast to itself,
   1925              // So check the mac destination address)
   1926              // Remove it from the associated device list. If it is not
   1927              // a child, no action will be taken in AssocRemove() anyway.
   1928              if ( inMsg->macDestAddr != NLME_GetShortAddr() )
   \                     ??ZDO_ProcessDeviceAnnce_2:
   \   000056   ........     CALLA   #NLME_GetShortAddr
   \   00005A   889C1400     CMP.W   R12, 0x14(R8)
   \   00005E   0E24         JEQ     ??ZDO_ProcessDeviceAnnce_3
   1929              {
   1930                associated_devices_t *dev_ptr;
   1931          
   1932                // If it's an end device child
   1933                dev_ptr = AssocGetWithExt( Annce.extAddr );
   \   000060   0C4A         MOV.W   R10, R12
   \   000062   ........     CALLA   #AssocGetWithExt
   1934                if ( dev_ptr )
   \   000066   0C93         CMP.W   #0x0, R12
   \   000068   0924         JEQ     ??ZDO_ProcessDeviceAnnce_3
   1935                {
   1936                  if ( dev_ptr->nodeRelation == CHILD_RFD ||
   1937                       dev_ptr->nodeRelation == CHILD_RFD_RX_IDLE )
   \   00006A   5E4C0400     MOV.B   0x4(R12), R14
   \   00006E   5E93         CMP.B   #0x1, R14
   \   000070   0224         JEQ     ??ZDO_ProcessDeviceAnnce_4
   \   000072   6E93         CMP.B   #0x2, R14
   \   000074   0320         JNE     ??ZDO_ProcessDeviceAnnce_3
   1938                  {
   1939                    AssocRemove( Annce.extAddr );
   \                     ??ZDO_ProcessDeviceAnnce_4:
   \   000076   0C4A         MOV.W   R10, R12
   \   000078   ........     CALLA   #AssocRemove
   1940                  }
   1941                }
   1942              }
   1943          
   1944              if ( Annce.nwkAddr != NLME_GetShortAddr() )
   \                     ??ZDO_ProcessDeviceAnnce_3:
   \   00007C   ........     CALLA   #NLME_GetShortAddr
   \   000080   819C0000     CMP.W   R12, 0(SP)
   \   000084   0824         JEQ     ??ZDO_ProcessDeviceAnnce_5
   1945              {
   1946                // If an associated device is found with matched extended Address,
   1947                // update its short address
   1948                if ( AssocChangeNwkAddr( Annce.nwkAddr, Annce.extAddr ) )
   \   000086   0D4A         MOV.W   R10, R13
   \   000088   2C41         MOV.W   @SP, R12
   \   00008A   ........     CALLA   #AssocChangeNwkAddr
   \   00008E   4C93         CMP.B   #0x0, R12
   \   000090   0224         JEQ     ??ZDO_ProcessDeviceAnnce_5
   1949                {
   1950                  // Set event to save NV
   1951                  ZDApp_NVUpdate();
   \   000092   ........     CALLA   #ZDApp_NVUpdate
   1952                }
   1953              }
   1954            }
   1955          
   1956            // Update the neighbor table
   1957            nwkNeighborUpdateNwkAddr( Annce.nwkAddr, Annce.extAddr );
   \                     ??ZDO_ProcessDeviceAnnce_5:
   \   000096   0D4A         MOV.W   R10, R13
   \   000098   2C41         MOV.W   @SP, R12
   \   00009A   ........     CALLA   #nwkNeighborUpdateNwkAddr
   1958          
   1959            // Assume that the device has moved, remove existing routing entries
   1960            RTG_RemoveRtgEntry( Annce.nwkAddr, 0 );
   \   00009E   4D43         MOV.B   #0x0, R13
   \   0000A0   2C41         MOV.W   @SP, R12
   \   0000A2   ........     CALLA   #RTG_RemoveRtgEntry
   1961          
   1962          #endif // ZIGBEE_STOCHASTIC_ADDRESSING
   1963          
   1964            // Fill in the extended address in address manager if we don't have it already.
   1965            addrEntry.user = ADDRMGR_USER_DEFAULT;
   \   0000A6   C1430C00     MOV.B   #0x0, 0xc(SP)
   1966            addrEntry.nwkAddr = Annce.nwkAddr;
   \   0000AA   A1410E00     MOV.W   @SP, 0xe(SP)
   1967            if ( AddrMgrEntryLookupNwk( &addrEntry ) )
   \   0000AE   0841         MOV.W   SP, R8
   \   0000B0   38500C00     ADD.W   #0xc, R8
   \   0000B4   0C48         MOV.W   R8, R12
   \   0000B6   ........     CALLA   #AddrMgrEntryLookupNwk
   \   0000BA   4C93         CMP.B   #0x0, R12
   \   0000BC   1024         JEQ     ??ZDO_ProcessDeviceAnnce_6
   1968            {
   1969              osal_memset( parentExt, 0, Z_EXTADDR_LEN );
   \   0000BE   3E42         MOV.W   #0x8, R14
   \   0000C0   4D43         MOV.B   #0x0, R13
   \   0000C2   0C4B         MOV.W   R11, R12
   \   0000C4   ........     CALLA   #osal_memset
   1970              if ( osal_ExtAddrEqual( parentExt, addrEntry.extAddr ) )
   \   0000C8   0D48         MOV.W   R8, R13
   \   0000CA   2D52         ADD.W   #0x4, R13
   \   0000CC   0C4B         MOV.W   R11, R12
   \   0000CE   ........     CALLA   #sAddrExtCmp
   \   0000D2   4C93         CMP.B   #0x0, R12
   \   0000D4   0424         JEQ     ??ZDO_ProcessDeviceAnnce_6
   1971              {
   1972                AddrMgrExtAddrSet( addrEntry.extAddr, Annce.extAddr );
   \   0000D6   ........     CALLA   #?Subroutine21
   1973                AddrMgrEntryUpdate( &addrEntry );
   1974              }
   1975            }
   \                     ??CrossCallReturnLabel_33:
   \   0000DA   ........     CALLA   #AddrMgrEntryUpdate
   1976          
   1977            // Update the short address in address manager if it's been changed
   1978            AddrMgrExtAddrSet( addrEntry.extAddr, Annce.extAddr );
   \                     ??ZDO_ProcessDeviceAnnce_6:
   \   0000DE   ........     CALLA   #?Subroutine21
   1979            if ( AddrMgrEntryLookupExt( &addrEntry ) )
   \                     ??CrossCallReturnLabel_34:
   \   0000E2   ........     CALLA   #AddrMgrEntryLookupExt
   \   0000E6   4C93         CMP.B   #0x0, R12
   \   0000E8   0824         JEQ     ??ZDO_ProcessDeviceAnnce_0
   1980            {
   1981              if ( addrEntry.nwkAddr != Annce.nwkAddr )
   \   0000EA   A1910E00     CMP.W   @SP, 0xe(SP)
   \   0000EE   0524         JEQ     ??ZDO_ProcessDeviceAnnce_0
   1982              {
   1983                addrEntry.nwkAddr = Annce.nwkAddr;
   \   0000F0   A1410E00     MOV.W   @SP, 0xe(SP)
   1984                AddrMgrEntryUpdate( &addrEntry );
   \   0000F4   0C48         MOV.W   R8, R12
   \   0000F6   ........     CALLA   #AddrMgrEntryUpdate
   1985              }
   1986            }
   1987          }
   \                     ??ZDO_ProcessDeviceAnnce_0:
   \   0000FA   31502200     ADD.W   #0x22, SP
   \   0000FE   3817         POPM.W  #0x4, R11
   \   000100   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine21:
   \   000000   0D4A         MOV.W   R10, R13
   \   000002   0C48         MOV.W   R8, R12
   \   000004   2C52         ADD.W   #0x4, R12
   \   000006   ........     CALLA   #AddrMgrExtAddrSet
   \   00000A   0C48         MOV.W   R8, R12
   \   00000C   1001         RETA
   1988          
   1989          /*********************************************************************
   1990           * @fn          ZDO_BuildSimpleDescBuf
   1991           *
   1992           * @brief       Build a byte sequence representation of a Simple Descriptor.
   1993           *
   1994           * @param       buf  - pointer to a byte array big enough for data.
   1995           * @param       desc - SimpleDescriptionFormat_t *
   1996           *
   1997           * @return      none
   1998           */

   \                                 In  segment CODE, align 2, keep-with-next
   1999          void ZDO_BuildSimpleDescBuf( uint8 *buf, SimpleDescriptionFormat_t *desc )
   \                     ZDO_BuildSimpleDescBuf:
   2000          {
   \   000000   0A12         PUSH.W  R10
   2001            byte cnt;
   2002            uint16 *ptr;
   2003          
   2004            *buf++ = desc->EndPoint;
   \   000002   EC4D0000     MOV.B   @R13, 0(R12)
   \   000006   1C53         ADD.W   #0x1, R12
   2005            *buf++ = HI_UINT16( desc->AppProfId );
   \   000008   DC4D03000000 MOV.B   0x3(R13), 0(R12)
   \   00000E   1C53         ADD.W   #0x1, R12
   2006            *buf++ = LO_UINT16( desc->AppProfId );
   \   000010   DC4D02000000 MOV.B   0x2(R13), 0(R12)
   \   000016   1C53         ADD.W   #0x1, R12
   2007            *buf++ = HI_UINT16( desc->AppDeviceId );
   \   000018   DC4D05000000 MOV.B   0x5(R13), 0(R12)
   \   00001E   1C53         ADD.W   #0x1, R12
   2008            *buf++ = LO_UINT16( desc->AppDeviceId );
   \   000020   DC4D04000000 MOV.B   0x4(R13), 0(R12)
   \   000026   1C53         ADD.W   #0x1, R12
   2009          
   2010            *buf++ = (byte)(desc->AppDevVer << 4);
   \   000028   5E4D0600     MOV.B   0x6(R13), R14
   \   00002C                RPT     #0x4
   \   00002C   43184E5E     RLAX.B  R14
   \   000030   CC4E0000     MOV.B   R14, 0(R12)
   \   000034   1C53         ADD.W   #0x1, R12
   2011          
   2012            *buf++ = desc->AppNumInClusters;
   \   000036   DC4D07000000 MOV.B   0x7(R13), 0(R12)
   \   00003C   1C53         ADD.W   #0x1, R12
   2013            ptr = desc->pAppInClusterList;
   \   00003E   1F4D0800     MOV.W   0x8(R13), R15
   2014            for ( cnt = 0; cnt < desc->AppNumInClusters; ptr++, cnt++ )
   \   000042   4A43         MOV.B   #0x0, R10
   \   000044   023C         JMP     ??ZDO_BuildSimpleDescBuf_2
   2015            {
   2016              *buf++ = HI_UINT16( *ptr );
   \                     ??ZDO_BuildSimpleDescBuf_0:
   \   000046   ........     CALLA   #?Subroutine23
   2017              *buf++ = LO_UINT16( *ptr );
   2018            }
   \                     ??ZDO_BuildSimpleDescBuf_2:
   \   00004A   5A9D0700     CMP.B   0x7(R13), R10
   \   00004E   FB2B         JNC     ??ZDO_BuildSimpleDescBuf_0
   2019          
   2020            *buf++ = desc->AppNumOutClusters;
   \   000050   DC4D0A000000 MOV.B   0xa(R13), 0(R12)
   \   000056   1C53         ADD.W   #0x1, R12
   2021            ptr = desc->pAppOutClusterList;
   \   000058   1F4D0C00     MOV.W   0xc(R13), R15
   2022            for ( cnt = 0; cnt < desc->AppNumOutClusters; ptr++, cnt++ )
   \   00005C   4A43         MOV.B   #0x0, R10
   \   00005E   023C         JMP     ??ZDO_BuildSimpleDescBuf_3
   2023            {
   2024              *buf++ = HI_UINT16( *ptr );
   \                     ??ZDO_BuildSimpleDescBuf_1:
   \   000060   ........     CALLA   #?Subroutine23
   2025              *buf++ = LO_UINT16( *ptr );
   2026            }
   \                     ??ZDO_BuildSimpleDescBuf_3:
   \   000064   5A9D0A00     CMP.B   0xa(R13), R10
   \   000068   FB2B         JNC     ??ZDO_BuildSimpleDescBuf_1
   2027          }
   \   00006A   3A41         POP.W   R10
   \   00006C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine23:
   \   000000   DC4F01000000 MOV.B   0x1(R15), 0(R12)
   \   000006   1C53         ADD.W   #0x1, R12
   \   000008   3E4F         MOV.W   @R15+, R14
   \   00000A   CC4E0000     MOV.B   R14, 0(R12)
   \   00000E   1C53         ADD.W   #0x1, R12
   \   000010   5A53         ADD.B   #0x1, R10
   \   000012   1001         RETA
   2028          
   2029          /*********************************************************************
   2030           * @fn      ZDO_MatchEndDeviceBind()
   2031           *
   2032           * @brief
   2033           *
   2034           *   Called to match end device binding requests
   2035           *
   2036           * @param  bindReq  - binding request information
   2037           * @param  SecurityUse - Security enable/disable
   2038           *
   2039           * @return  none
   2040           */

   \                                 In  segment CODE, align 2, keep-with-next
   2041          void ZDO_MatchEndDeviceBind( ZDEndDeviceBind_t *bindReq )
   \                     ZDO_MatchEndDeviceBind:
   2042          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   31800C00     SUB.W   #0xc, SP
   \   000006   0A4C         MOV.W   R12, R10
   2043            zAddrType_t dstAddr;
   2044            uint8 sendRsp = FALSE;
   \   000008   4943         MOV.B   #0x0, R9
   2045            uint8 status;
   2046          
   2047            // Is this the first request?
   2048            if ( matchED == NULL )
   \   00000A   1F42....     MOV.W   &matchED, R15
   \   00000E   78408800     MOV.B   #0x88, R8
   \   000012   3B40....     MOV.W   #matchED, R11
   \   000016   0F93         CMP.W   #0x0, R15
   \   000018   1C20         JNE     ??ZDO_MatchEndDeviceBind_0
   2049            {
   2050              // Create match info structure
   2051              matchED = (ZDMatchEndDeviceBind_t *)osal_mem_alloc( sizeof ( ZDMatchEndDeviceBind_t ) );
   \   00001A   3C403E00     MOV.W   #0x3e, R12
   \   00001E   ........     CALLA   #osal_mem_alloc
   \   000022   824C....     MOV.W   R12, &matchED
   2052              if ( matchED )
   \   000026   0C93         CMP.W   #0x0, R12
   \   000028   0B24         JEQ     ??ZDO_MatchEndDeviceBind_1
   2053              {
   2054                // Clear the structure
   2055                osal_memset( (uint8 *)matchED, 0, sizeof ( ZDMatchEndDeviceBind_t ) );
   \   00002A   3E403E00     MOV.W   #0x3e, R14
   \   00002E   4D43         MOV.B   #0x0, R13
   \   000030   ........     CALLA   #osal_memset
   2056          
   2057                // Copy the first request's information
   2058                if ( !ZDO_CopyMatchInfo( &(matchED->ed1), bindReq ) )
   \   000034   0D4A         MOV.W   R10, R13
   \   000036   2C4B         MOV.W   @R11, R12
   \   000038   ........     CALLA   #ZDO_CopyMatchInfo
   \   00003C   4C93         CMP.B   #0x0, R12
   \   00003E   0320         JNE     ??ZDO_MatchEndDeviceBind_2
   2059                {
   2060                  status = ZDP_NO_ENTRY;
   2061                  sendRsp = TRUE;
   2062                }
   2063              }
   2064              else
   2065              {
   2066                status = ZDP_NO_ENTRY;
   \                     ??ZDO_MatchEndDeviceBind_1:
   \   000040   C1480000     MOV.B   R8, 0(SP)
   2067                sendRsp = TRUE;
   \   000044   713C         JMP     ??ZDO_MatchEndDeviceBind_3
   2068              }
   2069          
   2070              if ( !sendRsp )
   2071              {
   2072                // Set into the correct state
   2073                matchED->state = ZDMATCH_WAIT_REQ;
   \                     ??ZDO_MatchEndDeviceBind_2:
   \   000046   2F4B         MOV.W   @R11, R15
   \   000048   DF433400     MOV.B   #0x1, 0x34(R15)
   2074          
   2075                // Setup the timeout
   2076                APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceBindMatchTimeoutCB );
   \   00004C   ........     CALLA   #?Subroutine20
   2077              }
   2078            }
   \                     ??CrossCallReturnLabel_31:
   \   000050   903C         JMP     ??ZDO_MatchEndDeviceBind_4
   2079            else
   2080            {
   2081                matchED->state = ZDMATCH_SENDING_BINDS;
   \                     ??ZDO_MatchEndDeviceBind_0:
   \   000052   EF433400     MOV.B   #0x2, 0x34(R15)
   2082          
   2083                // Copy the 2nd request's information
   2084                if ( !ZDO_CopyMatchInfo( &(matchED->ed2), bindReq ) )
   \   000056   0D4C         MOV.W   R12, R13
   \   000058   2C4B         MOV.W   @R11, R12
   \   00005A   3C501A00     ADD.W   #0x1a, R12
   \   00005E   ........     CALLA   #ZDO_CopyMatchInfo
   \   000062   4C93         CMP.B   #0x0, R12
   \   000064   0320         JNE     ??ZDO_MatchEndDeviceBind_5
   2085                {
   2086                  status = ZDP_NO_ENTRY;
   \   000066   C1480000     MOV.B   R8, 0(SP)
   2087                  sendRsp = TRUE;
   \   00006A   5943         MOV.B   #0x1, R9
   2088                }
   2089          
   2090                // Make a source match for ed1
   2091                matchED->ed1numMatched = ZDO_CompareClusterLists(
   2092                            matchED->ed1.numOutClusters, matchED->ed1.outClusters,
   2093                            matchED->ed2.numInClusters, matchED->ed2.inClusters, ZDOBuildBuf );
   \                     ??ZDO_MatchEndDeviceBind_5:
   \   00006C   2C4B         MOV.W   @R11, R12
   \   00006E   3640....     MOV.W   #ZDOBuildBuf, R6
   \   000072   0612         PUSH.W  R6
   \   000074   1F4C2E00     MOV.W   0x2e(R12), R15
   \   000078   5E4C2C00     MOV.B   0x2c(R12), R14
   \   00007C   1D4C1800     MOV.W   0x18(R12), R13
   \   000080   5C4C1600     MOV.B   0x16(R12), R12
   \   000084   ........     CALLA   #ZDO_CompareClusterLists
   \   000088   2F4B         MOV.W   @R11, R15
   \   00008A   CF4C3700     MOV.B   R12, 0x37(R15)
   \   00008E   2F4B         MOV.W   @R11, R15
   \   000090   5C4F3700     MOV.B   0x37(R15), R12
   \   000094   2153         ADD.W   #0x2, SP
   \   000096   4C93         CMP.B   #0x0, R12
   \   000098   1124         JEQ     ??ZDO_MatchEndDeviceBind_6
   2094                if ( matchED->ed1numMatched )
   2095                {
   2096                  // Save the match list
   2097                  matchED->ed1Matched = osal_mem_alloc( (short)(matchED->ed1numMatched * sizeof ( uint16 )) );
   \   00009A   ........     CALLA   #??Subroutine13_0
   \                     ??CrossCallReturnLabel_64:
   \   00009E   2F4B         MOV.W   @R11, R15
   \   0000A0   8F4C3800     MOV.W   R12, 0x38(R15)
   2098                  if ( matchED->ed1Matched )
   \   0000A4   0C93         CMP.W   #0x0, R12
   \   0000A6   0724         JEQ     ??ZDO_MatchEndDeviceBind_7
   2099                  {
   2100                    osal_memcpy( matchED->ed1Matched, ZDOBuildBuf, (matchED->ed1numMatched * sizeof ( uint16 )) );
   \   0000A8   5E4F3700     MOV.B   0x37(R15), R14
   \   0000AC   0E5E         RLA.W   R14
   \   0000AE   0D46         MOV.W   R6, R13
   \   0000B0   ........     CALLA   #osal_memcpy
   \   0000B4   033C         JMP     ??ZDO_MatchEndDeviceBind_6
   2101                  }
   2102                  else
   2103                  {
   2104                    // Allocation error, stop
   2105                    status = ZDP_NO_ENTRY;
   \                     ??ZDO_MatchEndDeviceBind_7:
   \   0000B6   C1480000     MOV.B   R8, 0(SP)
   2106                    sendRsp = TRUE;
   \   0000BA   5943         MOV.B   #0x1, R9
   2107                  }
   2108                }
   2109          
   2110                // Make a source match for ed2
   2111                matchED->ed2numMatched = ZDO_CompareClusterLists(
   2112                            matchED->ed2.numOutClusters, matchED->ed2.outClusters,
   2113                            matchED->ed1.numInClusters, matchED->ed1.inClusters, ZDOBuildBuf );
   \                     ??ZDO_MatchEndDeviceBind_6:
   \   0000BC   2C4B         MOV.W   @R11, R12
   \   0000BE   0612         PUSH.W  R6
   \   0000C0   1F4C1400     MOV.W   0x14(R12), R15
   \   0000C4   5E4C1200     MOV.B   0x12(R12), R14
   \   0000C8   1D4C3200     MOV.W   0x32(R12), R13
   \   0000CC   5C4C3000     MOV.B   0x30(R12), R12
   \   0000D0   ........     CALLA   #ZDO_CompareClusterLists
   \   0000D4   2F4B         MOV.W   @R11, R15
   \   0000D6   CF4C3A00     MOV.B   R12, 0x3a(R15)
   \   0000DA   2F4B         MOV.W   @R11, R15
   \   0000DC   5C4F3A00     MOV.B   0x3a(R15), R12
   \   0000E0   2153         ADD.W   #0x2, SP
   \   0000E2   4C93         CMP.B   #0x0, R12
   \   0000E4   0D24         JEQ     ??ZDO_MatchEndDeviceBind_8
   2114                if ( matchED->ed2numMatched )
   2115                {
   2116                  // Save the match list
   2117                  matchED->ed2Matched = osal_mem_alloc( (short)(matchED->ed2numMatched * sizeof ( uint16 )) );
   \   0000E6   ........     CALLA   #??Subroutine13_0
   \                     ??CrossCallReturnLabel_63:
   \   0000EA   2F4B         MOV.W   @R11, R15
   \   0000EC   8F4C3C00     MOV.W   R12, 0x3c(R15)
   2118                  if ( matchED->ed2Matched )
   \   0000F0   0C93         CMP.W   #0x0, R12
   \   0000F2   1524         JEQ     ??ZDO_MatchEndDeviceBind_9
   2119                  {
   2120                    osal_memcpy( matchED->ed2Matched, ZDOBuildBuf, (matchED->ed2numMatched * sizeof ( uint16 )) );
   \   0000F4   5E4F3A00     MOV.B   0x3a(R15), R14
   \   0000F8   0E5E         RLA.W   R14
   \   0000FA   0D46         MOV.W   R6, R13
   \   0000FC   ........     CALLA   #osal_memcpy
   2121                  }
   2122                  else
   2123                  {
   2124                    // Allocation error, stop
   2125                    status = ZDP_NO_ENTRY;
   2126                    sendRsp = TRUE;
   2127                  }
   2128                }
   2129          
   2130                if ( (sendRsp == FALSE) && (matchED->ed1numMatched || matchED->ed2numMatched) )
   \                     ??ZDO_MatchEndDeviceBind_8:
   \   000100   59B3         BIT.B   #0x1, R9
   \   000102   0F2C         JC      ??ZDO_MatchEndDeviceBind_10
   \   000104   2F4B         MOV.W   @R11, R15
   \   000106   CF933700     CMP.B   #0x0, 0x37(R15)
   \   00010A   0320         JNE     ??ZDO_MatchEndDeviceBind_11
   \   00010C   CF933A00     CMP.B   #0x0, 0x3a(R15)
   \   000110   0824         JEQ     ??ZDO_MatchEndDeviceBind_10
   2131                {
   2132                  // Do the first unbind/bind state
   2133                  ZDMatchSendState( ZDMATCH_REASON_START, ZDP_SUCCESS, 0 );
   \                     ??ZDO_MatchEndDeviceBind_11:
   \   000112   4E43         MOV.B   #0x0, R14
   \   000114   4D43         MOV.B   #0x0, R13
   \   000116   4C43         MOV.B   #0x0, R12
   \   000118   ........     CALLA   #ZDMatchSendState
   2134                }
   2135                else
   2136                {
   2137                  status = ZDP_NO_MATCH;
   2138                  sendRsp = TRUE;
   2139                }
   2140            }
   2141          
   2142            if ( sendRsp )
   \   00011C   2A3C         JMP     ??ZDO_MatchEndDeviceBind_4
   \                     ??ZDO_MatchEndDeviceBind_9:
   \   00011E   C1480000     MOV.B   R8, 0(SP)
   \                     ??ZDO_MatchEndDeviceBind_10:
   \   000122   F14086000000 MOV.B   #0x86, 0(SP)
   2143            {
   2144              // send response to this requester
   2145              dstAddr.addrMode = Addr16Bit;
   \                     ??ZDO_MatchEndDeviceBind_3:
   \   000128   E1430A00     MOV.B   #0x2, 0xa(SP)
   2146              dstAddr.addr.shortAddr = bindReq->srcAddr;
   \   00012C   914A02000200 MOV.W   0x2(R10), 0x2(SP)
   2147              ZDP_EndDeviceBindRsp( bindReq->TransSeq, &dstAddr, status, bindReq->SecurityUse );
   \   000132   5A120100     PUSH.B  0x1(R10)
   \   000136   0F41         MOV.W   SP, R15
   \   000138   2F53         ADD.W   #0x2, R15
   \   00013A   0F12         PUSH.W  R15
   \   00013C   ........     CALLA   #?Subroutine22
   \                     ??CrossCallReturnLabel_35:
   \   000140   ........     CALLA   #??Subroutine31_0
   2148          
   2149              if ( matchED->state == ZDMATCH_SENDING_BINDS )
   \                     ??CrossCallReturnLabel_72:
   \   000144   2F4B         MOV.W   @R11, R15
   \   000146   2152         ADD.W   #0x4, SP
   \   000148   EF933400     CMP.B   #0x2, 0x34(R15)
   \   00014C   1020         JNE     ??ZDO_MatchEndDeviceBind_12
   2150              {
   2151                // send response to first requester
   2152                dstAddr.addrMode = Addr16Bit;
   \   00014E   E1430A00     MOV.B   #0x2, 0xa(SP)
   2153                dstAddr.addr.shortAddr = matchED->ed1.srcAddr;
   \   000152   914F02000200 MOV.W   0x2(R15), 0x2(SP)
   2154                ZDP_EndDeviceBindRsp( matchED->ed1.TransSeq, &dstAddr, status, matchED->ed1.SecurityUse );
   \   000158   5F120100     PUSH.B  0x1(R15)
   \   00015C   0F41         MOV.W   SP, R15
   \   00015E   2F53         ADD.W   #0x2, R15
   \   000160   0F12         PUSH.W  R15
   \   000162   ........     CALLA   #?Subroutine22
   2155              }
   \                     ??CrossCallReturnLabel_36:
   \   000166   2C4B         MOV.W   @R11, R12
   \   000168   ........     CALLA   #ZDP_SendData
   \   00016C   2152         ADD.W   #0x4, SP
   2156          
   2157              // Process ended - release memory used
   2158              ZDO_RemoveMatchMemory();
   \                     ??ZDO_MatchEndDeviceBind_12:
   \   00016E   ........     CALLA   #ZDO_RemoveMatchMemory
   2159            }
   2160          }
   \                     ??ZDO_MatchEndDeviceBind_4:
   \   000172   31500C00     ADD.W   #0xc, SP
   \   000176   5617         POPM.W  #0x6, R11
   \   000178   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine22:
   \   000000   5F43         MOV.B   #0x1, R15
   \   000002   3E402080     MOV.W   #0x8020, R14
   \   000006   0D41         MOV.W   SP, R13
   \   000008   3D500A00     ADD.W   #0xa, R13
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine20:
   \   000000   3E40....     MOV.W   #LWRD(ZDO_EndDeviceBindMatchTimeoutCB), R14
   \   000004   3F40....     MOV.W   #HWRD(ZDO_EndDeviceBindMatchTimeoutCB), R15
   \   000008   1C42....     MOV.W   &AIB_MaxBindingTime, R12
   \   00000C   ........     BRA     #APS_SetEndDeviceBindTimeout
   2161          
   2162          /*********************************************************************
   2163           * @fn      ZDO_RemoveMatchMemory()
   2164           *
   2165           * @brief   Called to clear the memory used for the end device bind.
   2166           *
   2167           * @param  none
   2168           *
   2169           * @return  none
   2170           */

   \                                 In  segment CODE, align 2, keep-with-next
   2171          static void ZDO_RemoveMatchMemory( void )
   \                     ZDO_RemoveMatchMemory:
   2172          {
   \   000000   0A12         PUSH.W  R10
   2173            if ( matchED != NULL )
   \   000002   1F42....     MOV.W   &matchED, R15
   \   000006   0F93         CMP.W   #0x0, R15
   \   000008   1F24         JEQ     ??ZDO_RemoveMatchMemory_7
   2174            {
   2175              if ( matchED->ed2Matched != NULL )
   \   00000A   3A40....     MOV.W   #matchED, R10
   \   00000E   1C4F3C00     MOV.W   0x3c(R15), R12
   \   000012   ........     CALLA   #?Subroutine6
   2176              {
   2177                osal_mem_free( matchED->ed2Matched );
   \                     ??CrossCallReturnLabel_6:
   \   000016   1C4F3800     MOV.W   0x38(R15), R12
   \   00001A   ........     CALLA   #?Subroutine6
   2178              }
   2179              if ( matchED->ed1Matched != NULL )
   2180              {
   2181                osal_mem_free( matchED->ed1Matched );
   \                     ??CrossCallReturnLabel_7:
   \   00001E   1C4F1400     MOV.W   0x14(R15), R12
   \   000022   ........     CALLA   #?Subroutine6
   2182              }
   2183              if ( matchED->ed1.inClusters != NULL )
   2184              {
   2185                osal_mem_free( matchED->ed1.inClusters );
   \                     ??CrossCallReturnLabel_8:
   \   000026   1C4F1800     MOV.W   0x18(R15), R12
   \   00002A   ........     CALLA   #?Subroutine6
   2186              }
   2187              if ( matchED->ed1.outClusters != NULL )
   2188              {
   2189                osal_mem_free( matchED->ed1.outClusters );
   \                     ??CrossCallReturnLabel_9:
   \   00002E   1C4F2E00     MOV.W   0x2e(R15), R12
   \   000032   ........     CALLA   #?Subroutine6
   2190              }
   2191              if ( matchED->ed2.inClusters != NULL )
   2192              {
   2193                osal_mem_free( matchED->ed2.inClusters );
   \                     ??CrossCallReturnLabel_10:
   \   000036   1C4F3200     MOV.W   0x32(R15), R12
   \   00003A   ........     CALLA   #?Subroutine7
   2194              }
   2195              if ( matchED->ed2.outClusters != NULL )
   2196              {
   2197                osal_mem_free( matchED->ed2.outClusters );
   2198              }
   2199          
   2200              osal_mem_free( matchED );
   \                     ??CrossCallReturnLabel_12:
   \   00003E   2C4A         MOV.W   @R10, R12
   \   000040   ........     CALLA   #osal_mem_free
   2201              matchED = (ZDMatchEndDeviceBind_t *)NULL;
   \   000044   8243....     MOV.W   #0x0, &matchED
   2202            }
   2203          }
   \                     ??ZDO_RemoveMatchMemory_7:
   \   000048   3A41         POP.W   R10
   \   00004A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   0C93         CMP.W   #0x0, R12
   \   000002   0224         JEQ     ??ZDO_RemoveMatchMemory_0
   \   000004   ........     CALLA   #osal_mem_free
   \                     ??ZDO_RemoveMatchMemory_0:
   \   000008   2F4A         MOV.W   @R10, R15
   \   00000A   1001         RETA
   2204          
   2205          /*********************************************************************
   2206           * @fn      ZDO_CopyMatchInfo()
   2207           *
   2208           * @brief   Called to copy memory used for the end device bind.
   2209           *
   2210           * @param  srcReq - source information
   2211           * @param  dstReq - destination location
   2212           *
   2213           * @return  TRUE if copy was successful.
   2214           */

   \                                 In  segment CODE, align 2, keep-with-next
   2215          static uint8 ZDO_CopyMatchInfo( ZDEndDeviceBind_t *destReq, ZDEndDeviceBind_t *srcReq )
   \                     ZDO_CopyMatchInfo:
   2216          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0B4C         MOV.W   R12, R11
   \   000004   084D         MOV.W   R13, R8
   2217            uint8 allOK = TRUE;
   \   000006   5A43         MOV.B   #0x1, R10
   2218          
   2219            // Copy bind information into the match info structure
   2220            osal_memcpy( (uint8 *)destReq, srcReq, sizeof ( ZDEndDeviceBind_t ) );
   \   000008   3E401A00     MOV.W   #0x1a, R14
   \   00000C   ........     CALLA   #osal_memcpy
   2221          
   2222            // Initialize the destination cluster pointers
   2223            destReq->inClusters = NULL;
   \   000010   8B431400     MOV.W   #0x0, 0x14(R11)
   2224            destReq->outClusters = NULL;
   \   000014   8B431800     MOV.W   #0x0, 0x18(R11)
   2225          
   2226            // Copy input cluster IDs
   2227            if ( srcReq->numInClusters )
   \   000018   5C481200     MOV.B   0x12(R8), R12
   \   00001C   4C93         CMP.B   #0x0, R12
   \   00001E   0F24         JEQ     ??ZDO_CopyMatchInfo_5
   2228            {
   2229              destReq->inClusters = osal_mem_alloc( (short)(srcReq->numInClusters * sizeof ( uint16 )) );
   \   000020   ........     CALLA   #??Subroutine13_0
   \                     ??CrossCallReturnLabel_66:
   \   000024   8B4C1400     MOV.W   R12, 0x14(R11)
   2230              if ( destReq->inClusters )
   \   000028   0C93         CMP.W   #0x0, R12
   \   00002A   0824         JEQ     ??ZDO_CopyMatchInfo_6
   2231              {
   2232                // Copy the clusters
   2233                osal_memcpy( (uint8*)(destReq->inClusters), (uint8 *)(srcReq->inClusters),
   2234                                (srcReq->numInClusters * sizeof ( uint16 )) );
   \   00002C   5E481200     MOV.B   0x12(R8), R14
   \   000030   0E5E         RLA.W   R14
   \   000032   1D481400     MOV.W   0x14(R8), R13
   \   000036   ........     CALLA   #osal_memcpy
   \   00003A   013C         JMP     ??ZDO_CopyMatchInfo_5
   2235              }
   2236              else
   2237              {
   2238                allOK = FALSE;
   \                     ??ZDO_CopyMatchInfo_6:
   \   00003C   4A43         MOV.B   #0x0, R10
   2239              }
   2240            }
   2241          
   2242            // Copy output cluster IDs
   2243            if ( srcReq->numOutClusters )
   \                     ??ZDO_CopyMatchInfo_5:
   \   00003E   5C481600     MOV.B   0x16(R8), R12
   \   000042   4C93         CMP.B   #0x0, R12
   \   000044   0D24         JEQ     ??ZDO_CopyMatchInfo_7
   2244            {
   2245              destReq->outClusters = osal_mem_alloc( (short)(srcReq->numOutClusters * sizeof ( uint16 )) );
   \   000046   ........     CALLA   #??Subroutine13_0
   \                     ??CrossCallReturnLabel_65:
   \   00004A   8B4C1800     MOV.W   R12, 0x18(R11)
   2246              if ( destReq->outClusters )
   \   00004E   0C93         CMP.W   #0x0, R12
   \   000050   1424         JEQ     ??ZDO_CopyMatchInfo_8
   2247              {
   2248                // Copy the clusters
   2249                osal_memcpy( (uint8 *)(destReq->outClusters), (uint8 *)(srcReq->outClusters),
   2250                                (srcReq->numOutClusters * sizeof ( uint16 )) );
   \   000052   5E481600     MOV.B   0x16(R8), R14
   \   000056   0E5E         RLA.W   R14
   \   000058   1D481800     MOV.W   0x18(R8), R13
   \   00005C   ........     CALLA   #osal_memcpy
   2251              }
   2252              else
   2253              {
   2254                allOK = FALSE;
   2255              }
   2256            }
   2257          
   2258            if ( allOK == FALSE )
   \                     ??ZDO_CopyMatchInfo_7:
   \   000060   5AB3         BIT.B   #0x1, R10
   \   000062   082C         JC      ??ZDO_CopyMatchInfo_2
   2259            {
   2260              if ( destReq->inClusters != NULL )
   \                     ??ZDO_CopyMatchInfo_0:
   \   000064   1C4B1400     MOV.W   0x14(R11), R12
   \   000068   ........     CALLA   #?Subroutine7
   2261              {
   2262                osal_mem_free( destReq->inClusters );
   2263              }
   2264              if ( destReq->outClusters != NULL )
   \                     ??CrossCallReturnLabel_11:
   \   00006C   1C4B1800     MOV.W   0x18(R11), R12
   \   000070   ........     CALLA   #?Subroutine7
   2265              {
   2266                osal_mem_free( destReq->outClusters );
   2267              }
   2268            }
   2269          
   2270            return ( allOK );
   \                     ??ZDO_CopyMatchInfo_2:
   \   000074   4C4A         MOV.B   R10, R12
   \   000076   3817         POPM.W  #0x4, R11
   \   000078   1001         RETA
   \                     ??ZDO_CopyMatchInfo_8:
   \   00007A   4A43         MOV.B   #0x0, R10
   \   00007C   F33F         JMP     ??ZDO_CopyMatchInfo_0
   2271          }
   2272          
   2273          /*********************************************************************
   2274           * @fn      ZDMatchSendState()
   2275           *
   2276           * @brief   State machine for the End device match message algorithm.
   2277           *
   2278           * @param  reason - state of algoritm
   2279           * @param  status - initial message status
   2280           * @param  TransSeq - next transaction sequence number
   2281           *
   2282           * @return  FALSE if error and we are not currently matching, TRUE
   2283           *          if success.
   2284           */

   \                                 In  segment CODE, align 2, keep-with-next
   2285          uint8 ZDMatchSendState( uint8 reason, uint8 status, uint8 TransSeq )
   \                     ZDMatchSendState:
   2286          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   31801600     SUB.W   #0x16, SP
   \   000006   4A4C         MOV.B   R12, R10
   \   000008   444D         MOV.B   R13, R4
   2287            uint8 *dstIEEEAddr = NULL;
   \   00000A   0943         MOV.W   #0x0, R9
   2288            uint8 dstEP = 0xFF;
   \   00000C   7643         MOV.B   #0xff, R6
   2289            zAddrType_t dstAddr;
   2290            zAddrType_t destinationAddr;
   2291            uint16 msgType;
   2292            uint16 clusterID = 0xFFFF;
   \   00000E   3743         MOV.W   #0xffff, R7
   2293            ZDEndDeviceBind_t *ed = NULL;
   \   000010   0843         MOV.W   #0x0, R8
   2294            uint8 rspStatus = ZDP_SUCCESS;
   \   000012   C1430000     MOV.B   #0x0, 0(SP)
   2295          
   2296            if ( matchED == NULL )
   \   000016   1F42....     MOV.W   &matchED, R15
   \   00001A   0F93         CMP.W   #0x0, R15
   \   00001C   0A24         JEQ     ??ZDMatchSendState_0
   2297            {
   2298              return ( FALSE );
   2299            }
   2300          
   2301            // Check sequence number
   2302            if ( reason == ZDMATCH_REASON_BIND_RSP || reason == ZDMATCH_REASON_UNBIND_RSP )
   \   00001E   3B40....     MOV.W   #matchED, R11
   \   000022   7C900300     CMP.B   #0x3, R12
   \   000026   0224         JEQ     ??ZDMatchSendState_1
   \   000028   6C93         CMP.B   #0x2, R12
   \   00002A   0520         JNE     ??ZDMatchSendState_2
   2303            {
   2304              if ( TransSeq != matchED->transSeq )
   \                     ??ZDMatchSendState_1:
   \   00002C   5E9F3600     CMP.B   0x36(R15), R14
   \   000030   0224         JEQ     ??ZDMatchSendState_2
   2305              {
   2306                return( FALSE ); // ignore the message
   \                     ??ZDMatchSendState_0:
   \   000032   4C43         MOV.B   #0x0, R12
   \   000034   B83C         JMP     ??ZDMatchSendState_3
   2307              }
   2308            }
   2309          
   2310            // turn off timer
   2311            APS_SetEndDeviceBindTimeout( 0, ZDO_EndDeviceBindMatchTimeoutCB );
   \                     ??ZDMatchSendState_2:
   \   000036   3E40....     MOV.W   #LWRD(ZDO_EndDeviceBindMatchTimeoutCB), R14
   \   00003A   3F40....     MOV.W   #HWRD(ZDO_EndDeviceBindMatchTimeoutCB), R15
   \   00003E   0C43         MOV.W   #0x0, R12
   \   000040   ........     CALLA   #APS_SetEndDeviceBindTimeout
   2312          
   2313            if ( reason == ZDMATCH_REASON_TIMEOUT )
   \   000044   5A93         CMP.B   #0x1, R10
   \   000046   0420         JNE     ??ZDMatchSendState_4
   \   000048   F14085000000 MOV.B   #0x85, 0(SP)
   \   00004E   1B3C         JMP     ??ZDMatchSendState_5
   2314            {
   2315              rspStatus = ZDP_TIMEOUT;    // The process will stop
   2316            }
   2317          
   2318            if ( reason == ZDMATCH_REASON_START || reason == ZDMATCH_REASON_BIND_RSP )
   \                     ??ZDMatchSendState_4:
   \   000050   4A93         CMP.B   #0x0, R10
   \   000052   0420         JNE     ??ZDMatchSendState_6
   \   000054   2F4B         MOV.W   @R11, R15
   \   000056   DF433500     MOV.B   #0x1, 0x35(R15)
   2319            {
   2320              matchED->sending = ZDMATCH_SENDING_UNBIND;
   2321          
   2322              if ( reason == ZDMATCH_REASON_BIND_RSP && status != ZDP_SUCCESS )
   2323              {
   2324                rspStatus = status;
   2325              }
   2326            }
   2327            else if ( reason == ZDMATCH_REASON_UNBIND_RSP )
   2328            {
   2329              if ( status == ZDP_SUCCESS )
   2330              {
   2331                matchED->sending = ZDMATCH_SENDING_UNBIND;
   2332              }
   2333              else
   2334              {
   2335                matchED->sending = ZDMATCH_SENDING_BIND;
   2336              }
   2337            }
   2338          
   2339            if ( reason != ZDMATCH_REASON_START && matchED->sending == ZDMATCH_SENDING_UNBIND )
   \   00005A   243C         JMP     ??ZDMatchSendState_7
   \                     ??ZDMatchSendState_6:
   \   00005C   7A900300     CMP.B   #0x3, R10
   \   000060   0820         JNE     ??ZDMatchSendState_8
   \   000062   2F4B         MOV.W   @R11, R15
   \   000064   DF433500     MOV.B   #0x1, 0x35(R15)
   \   000068   4493         CMP.B   #0x0, R4
   \   00006A   0D24         JEQ     ??ZDMatchSendState_5
   \   00006C   C1440000     MOV.B   R4, 0(SP)
   \   000070   0A3C         JMP     ??ZDMatchSendState_5
   \                     ??ZDMatchSendState_8:
   \   000072   6A93         CMP.B   #0x2, R10
   \   000074   0820         JNE     ??ZDMatchSendState_5
   \   000076   4493         CMP.B   #0x0, R4
   \   000078   0224         JEQ     ??ZDMatchSendState_9
   \   00007A   6E43         MOV.B   #0x2, R14
   \   00007C   013C         JMP     ??ZDMatchSendState_10
   \                     ??ZDMatchSendState_9:
   \   00007E   5E43         MOV.B   #0x1, R14
   \                     ??ZDMatchSendState_10:
   \   000080   2F4B         MOV.W   @R11, R15
   \   000082   CF4E3500     MOV.B   R14, 0x35(R15)
   \                     ??ZDMatchSendState_5:
   \   000086   2F4B         MOV.W   @R11, R15
   \   000088   DF933500     CMP.B   #0x1, 0x35(R15)
   \   00008C   0B20         JNE     ??ZDMatchSendState_7
   2340            {
   2341              // Move to the next cluster ID
   2342              if ( matchED->ed1numMatched )
   \   00008E   CF933700     CMP.B   #0x0, 0x37(R15)
   \   000092   0324         JEQ     ??ZDMatchSendState_11
   2343              {
   2344                matchED->ed1numMatched--;
   \   000094   FF533700     ADD.B   #0xff, 0x37(R15)
   \   000098   053C         JMP     ??ZDMatchSendState_7
   2345              }
   2346              else if ( matchED->ed2numMatched )
   \                     ??ZDMatchSendState_11:
   \   00009A   CF933A00     CMP.B   #0x0, 0x3a(R15)
   \   00009E   0224         JEQ     ??ZDMatchSendState_7
   2347              {
   2348                matchED->ed2numMatched--;
   \   0000A0   FF533A00     ADD.B   #0xff, 0x3a(R15)
   2349              }
   2350            }
   2351          
   2352            // What message do we send now
   2353            if ( matchED->ed1numMatched )
   \                     ??ZDMatchSendState_7:
   \   0000A4   2F4B         MOV.W   @R11, R15
   \   0000A6   5E4F3700     MOV.B   0x37(R15), R14
   \   0000AA   4E93         CMP.B   #0x0, R14
   \   0000AC   0D24         JEQ     ??ZDMatchSendState_12
   2354            {
   2355              ed = &(matchED->ed1);
   \   0000AE   084F         MOV.W   R15, R8
   2356              clusterID = matchED->ed1Matched[matchED->ed1numMatched-1];
   \   0000B0   174F3800     MOV.W   0x38(R15), R7
   \   0000B4   0E5E         RLA.W   R14
   \   0000B6   075E         ADD.W   R14, R7
   \   0000B8   1747FEFF     MOV.W   0xfffe(R7), R7
   2357              dstIEEEAddr = matchED->ed2.ieeeAddr;
   \   0000BC   094F         MOV.W   R15, R9
   \   0000BE   39502000     ADD.W   #0x20, R9
   2358              dstEP = matchED->ed2.endpoint;
   \   0000C2   564F2800     MOV.B   0x28(R15), R6
   \   0000C6   123C         JMP     ??ZDMatchSendState_13
   2359            }
   2360            else if ( matchED->ed2numMatched )
   \                     ??ZDMatchSendState_12:
   \   0000C8   5E4F3A00     MOV.B   0x3a(R15), R14
   \   0000CC   4E93         CMP.B   #0x0, R14
   \   0000CE   0E24         JEQ     ??ZDMatchSendState_13
   2361            {
   2362              ed = &(matchED->ed2);
   \   0000D0   084F         MOV.W   R15, R8
   \   0000D2   38501A00     ADD.W   #0x1a, R8
   2363              clusterID = matchED->ed2Matched[matchED->ed2numMatched-1];
   \   0000D6   174F3C00     MOV.W   0x3c(R15), R7
   \   0000DA   0E5E         RLA.W   R14
   \   0000DC   075E         ADD.W   R14, R7
   \   0000DE   1747FEFF     MOV.W   0xfffe(R7), R7
   2364              dstIEEEAddr = matchED->ed1.ieeeAddr;
   \   0000E2   094F         MOV.W   R15, R9
   \   0000E4   39500600     ADD.W   #0x6, R9
   2365              dstEP = matchED->ed1.endpoint;
   \   0000E8   564F0E00     MOV.B   0xe(R15), R6
   2366            }
   2367          
   2368            dstAddr.addrMode = Addr16Bit;
   \                     ??ZDMatchSendState_13:
   \   0000EC   E1430A00     MOV.B   #0x2, 0xa(SP)
   2369          
   2370            // Send the next message
   2371            if ( (rspStatus == ZDP_SUCCESS) && ed )
   \   0000F0   0A41         MOV.W   SP, R10
   \   0000F2   2A53         ADD.W   #0x2, R10
   \   0000F4   C1930000     CMP.B   #0x0, 0(SP)
   \   0000F8   2E20         JNE     ??ZDMatchSendState_14
   \   0000FA   0893         CMP.W   #0x0, R8
   \   0000FC   2C24         JEQ     ??ZDMatchSendState_14
   2372            {
   2373              // Send unbind/bind message to source
   2374              if ( matchED->sending == ZDMATCH_SENDING_UNBIND )
   \   0000FE   DF933500     CMP.B   #0x1, 0x35(R15)
   \   000102   0324         JEQ     ??ZDMatchSendState_15
   \   000104   3B402100     MOV.W   #0x21, R11
   \   000108   023C         JMP     ??ZDMatchSendState_16
   \                     ??ZDMatchSendState_15:
   \   00010A   3B402200     MOV.W   #0x22, R11
   2375              {
   2376                msgType = Unbind_req;
   2377              }
   2378              else
   2379              {
   2380                msgType = Bind_req;
   2381              }
   2382          
   2383              dstAddr.addr.shortAddr = ed->srcAddr;
   \                     ??ZDMatchSendState_16:
   \   00010E   914802000200 MOV.W   0x2(R8), 0x2(SP)
   2384          
   2385              // Save off the transaction sequence number
   2386              matchED->transSeq = ZDP_TransID;
   \   000114   DF42....3600 MOV.B   &ZDP_TransID, 0x36(R15)
   2387          
   2388              destinationAddr.addrMode = Addr64Bit;
   \   00011A   F14003001400 MOV.B   #0x3, 0x14(SP)
   2389              osal_cpyExtAddr( destinationAddr.addr.extAddr, dstIEEEAddr );
   \   000120   0D49         MOV.W   R9, R13
   \   000122   0C41         MOV.W   SP, R12
   \   000124   3C500C00     ADD.W   #0xc, R12
   \   000128   ........     CALLA   #sAddrExtCpy
   2390          
   2391              ZDP_BindUnbindReq( msgType, &dstAddr, ed->ieeeAddr, ed->endpoint, clusterID,
   2392                  &destinationAddr, dstEP, ed->SecurityUse );
   \   00012C   58120100     PUSH.B  0x1(R8)
   \   000130   4612         PUSH.B  R6
   \   000132   0F41         MOV.W   SP, R15
   \   000134   3F501000     ADD.W   #0x10, R15
   \   000138   0F12         PUSH.W  R15
   \   00013A   0712         PUSH.W  R7
   \   00013C   5F480E00     MOV.B   0xe(R8), R15
   \   000140   38500600     ADD.W   #0x6, R8
   \   000144   0E48         MOV.W   R8, R14
   \   000146   0D4A         MOV.W   R10, R13
   \   000148   0C4B         MOV.W   R11, R12
   \   00014A   ........     CALLA   #ZDP_BindUnbindReq
   2393          
   2394              // Set timeout for response
   2395              APS_SetEndDeviceBindTimeout( AIB_MaxBindingTime, ZDO_EndDeviceBindMatchTimeoutCB );
   \   00014E   ........     CALLA   #?Subroutine20
   2396            }
   \                     ??CrossCallReturnLabel_32:
   \   000152   3152         ADD.W   #0x8, SP
   \   000154   273C         JMP     ??ZDMatchSendState_17
   2397            else
   2398            {
   2399              // Send the response messages to requesting devices
   2400              // send response to first requester
   2401              dstAddr.addr.shortAddr = matchED->ed1.srcAddr;
   \                     ??ZDMatchSendState_14:
   \   000156   914F02000200 MOV.W   0x2(R15), 0x2(SP)
   2402              ZDP_EndDeviceBindRsp( matchED->ed1.TransSeq, &dstAddr, rspStatus, matchED->ed1.SecurityUse );
   \   00015C   5F120100     PUSH.B  0x1(R15)
   \   000160   0F41         MOV.W   SP, R15
   \   000162   2F53         ADD.W   #0x2, R15
   \   000164   0F12         PUSH.W  R15
   \   000166   5F43         MOV.B   #0x1, R15
   \   000168   3E402080     MOV.W   #0x8020, R14
   \   00016C   0D4A         MOV.W   R10, R13
   \   00016E   2C4B         MOV.W   @R11, R12
   \   000170   ........     CALLA   #ZDP_SendData
   2403          
   2404              // send response to second requester
   2405              if ( matchED->state == ZDMATCH_SENDING_BINDS )
   \   000174   2C4B         MOV.W   @R11, R12
   \   000176   2152         ADD.W   #0x4, SP
   \   000178   EC933400     CMP.B   #0x2, 0x34(R12)
   \   00017C   1120         JNE     ??ZDMatchSendState_18
   2406              {
   2407                dstAddr.addr.shortAddr = matchED->ed2.srcAddr;
   \   00017E   914C1C000200 MOV.W   0x1c(R12), 0x2(SP)
   2408                ZDP_EndDeviceBindRsp( matchED->ed2.TransSeq, &dstAddr, rspStatus, matchED->ed2.SecurityUse );
   \   000184   5C121B00     PUSH.B  0x1b(R12)
   \   000188   0F41         MOV.W   SP, R15
   \   00018A   2F53         ADD.W   #0x2, R15
   \   00018C   0F12         PUSH.W  R15
   \   00018E   5F43         MOV.B   #0x1, R15
   \   000190   3E402080     MOV.W   #0x8020, R14
   \   000194   0D4A         MOV.W   R10, R13
   \   000196   3C501A00     ADD.W   #0x1a, R12
   \   00019A   ........     CALLA   #ZDP_SendData
   \   00019E   2152         ADD.W   #0x4, SP
   2409              }
   2410          
   2411              // Process ended - release memory used
   2412              ZDO_RemoveMatchMemory();
   \                     ??ZDMatchSendState_18:
   \   0001A0   ........     CALLA   #ZDO_RemoveMatchMemory
   2413            }
   2414          
   2415            return ( TRUE );
   \                     ??ZDMatchSendState_17:
   \   0001A4   5C43         MOV.B   #0x1, R12
   \                     ??ZDMatchSendState_3:
   \   0001A6   31501600     ADD.W   #0x16, SP
   \   0001AA   7417         POPM.W  #0x8, R11
   \   0001AC   1001         RETA
   2416          }
   2417          
   2418          /*********************************************************************
   2419           * @fn      ZDO_EndDeviceBindMatchTimeoutCB()
   2420           *
   2421           * @brief   End device bind timeout.
   2422           *
   2423           * @param  none
   2424           *
   2425           * @return  none
   2426           */

   \                                 In  segment CODE, align 2, keep-with-next
   2427          static void ZDO_EndDeviceBindMatchTimeoutCB( void )
   \                     ZDO_EndDeviceBindMatchTimeoutCB:
   2428          {
   2429            ZDMatchSendState( ZDMATCH_REASON_TIMEOUT, ZDP_TIMEOUT, 0 );
   \   000000   4E43         MOV.B   #0x0, R14
   \   000002   7D408500     MOV.B   #0x85, R13
   \   000006   5C43         MOV.B   #0x1, R12
   \   000008   ........     BRA     #ZDMatchSendState
   2430          }
   2431          
   2432          /*********************************************************************
   2433           * ZDO MESSAGE PARSING API FUNCTIONS
   2434           */
   2435          
   2436          /*********************************************************************
   2437           * @fn          ZDO_ParseEndDeviceBindReq
   2438           *
   2439           * @brief       This function parses the End_Device_Bind_req message.
   2440           *
   2441           *     NOTE:  The clusters lists in bindReq are allocated in this
   2442           *            function and must be freed by that calling function.
   2443           *
   2444           * @param       inMsg  - incoming message (request)
   2445           * @param       bindReq - pointer to place to parse message to
   2446           *
   2447           * @return      none
   2448           */

   \                                 In  segment CODE, align 2, keep-with-next
   2449          void ZDO_ParseEndDeviceBindReq( zdoIncomingMsg_t *inMsg, ZDEndDeviceBind_t *bindReq )
   \                     ZDO_ParseEndDeviceBindReq:
   2450          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4D         MOV.W   R13, R10
   2451            uint8 *msg;
   2452          
   2453            // Parse the message
   2454            bindReq->TransSeq = inMsg->TransSeq;
   \   000004   DD4C11000000 MOV.B   0x11(R12), 0(R13)
   2455            bindReq->srcAddr = inMsg->srcAddr.addr.shortAddr;
   \   00000A   9D4C02000200 MOV.W   0x2(R12), 0x2(R13)
   2456            bindReq->SecurityUse = inMsg->SecurityUse;
   \   000010   DD4C10000100 MOV.B   0x10(R12), 0x1(R13)
   2457            msg = inMsg->asdu;
   \   000016   ........     CALLA   #?Subroutine3
   2458          
   2459            bindReq->localCoordinator = BUILD_UINT16( msg[0], msg[1] );
   \                     ??CrossCallReturnLabel_0:
   \   00001A   8D4E0400     MOV.W   R14, 0x4(R13)
   2460            msg += 2;
   \   00001E   2B53         ADD.W   #0x2, R11
   2461          
   2462            osal_cpyExtAddr( bindReq->ieeeAddr, msg );
   \   000020   0D4B         MOV.W   R11, R13
   \   000022   0C4A         MOV.W   R10, R12
   \   000024   3C500600     ADD.W   #0x6, R12
   \   000028   ........     CALLA   #sAddrExtCpy
   2463            msg += Z_EXTADDR_LEN;
   \   00002C   3B52         ADD.W   #0x8, R11
   2464          
   2465            bindReq->endpoint = *msg++;
   \   00002E   FA4B0E00     MOV.B   @R11+, 0xe(R10)
   2466            bindReq->profileID = BUILD_UINT16( msg[0], msg[1] );
   \   000032   ........     CALLA   #?Subroutine27
   \                     ??CrossCallReturnLabel_61:
   \   000036   8A4E1000     MOV.W   R14, 0x10(R10)
   2467            msg += 2;
   \   00003A   2B53         ADD.W   #0x2, R11
   2468          
   2469            bindReq->inClusters = NULL;
   \   00003C   8A431400     MOV.W   #0x0, 0x14(R10)
   2470            bindReq->outClusters = NULL;
   \   000040   8A431800     MOV.W   #0x0, 0x18(R10)
   2471          
   2472            if ((bindReq->numInClusters = *msg++) &&
   2473                (bindReq->inClusters = (uint16*)osal_mem_alloc( (bindReq->numInClusters * sizeof( uint16 )))))
   \   000044   7C4B         MOV.B   @R11+, R12
   \   000046   CA4C1200     MOV.B   R12, 0x12(R10)
   \   00004A   4C93         CMP.B   #0x0, R12
   \   00004C   0E24         JEQ     ??ZDO_ParseEndDeviceBindReq_0
   \   00004E   ........     CALLA   #??Subroutine13_0
   \                     ??CrossCallReturnLabel_68:
   \   000052   8A4C1400     MOV.W   R12, 0x14(R10)
   \   000056   0E4C         MOV.W   R12, R14
   \   000058   0C93         CMP.W   #0x0, R12
   \   00005A   0724         JEQ     ??ZDO_ParseEndDeviceBindReq_0
   2474            {
   2475              msg = ZDO_ConvertOTAClusters( bindReq->numInClusters, msg, bindReq->inClusters );
   \   00005C   0D4B         MOV.W   R11, R13
   \   00005E   5C4A1200     MOV.B   0x12(R10), R12
   \   000062   ........     CALLA   #ZDO_ConvertOTAClusters
   \   000066   0B4C         MOV.W   R12, R11
   \   000068   023C         JMP     ??ZDO_ParseEndDeviceBindReq_1
   2476            }
   2477            else
   2478            {
   2479              bindReq->numInClusters = 0;
   \                     ??ZDO_ParseEndDeviceBindReq_0:
   \   00006A   CA431200     MOV.B   #0x0, 0x12(R10)
   2480            }
   2481          
   2482            if ((bindReq->numOutClusters = *msg++) &&
   2483                (bindReq->outClusters = (uint16*)osal_mem_alloc((bindReq->numOutClusters * sizeof(uint16)))))
   \                     ??ZDO_ParseEndDeviceBindReq_1:
   \   00006E   7C4B         MOV.B   @R11+, R12
   \   000070   CA4C1600     MOV.B   R12, 0x16(R10)
   \   000074   4C93         CMP.B   #0x0, R12
   \   000076   0D24         JEQ     ??ZDO_ParseEndDeviceBindReq_2
   \   000078   ........     CALLA   #??Subroutine13_0
   \                     ??CrossCallReturnLabel_67:
   \   00007C   8A4C1800     MOV.W   R12, 0x18(R10)
   \   000080   0E4C         MOV.W   R12, R14
   \   000082   0C93         CMP.W   #0x0, R12
   \   000084   0624         JEQ     ??ZDO_ParseEndDeviceBindReq_2
   2484            {
   2485              msg = ZDO_ConvertOTAClusters( bindReq->numOutClusters, msg, bindReq->outClusters );
   \   000086   0D4B         MOV.W   R11, R13
   \   000088   5C4A1600     MOV.B   0x16(R10), R12
   \   00008C   ........     CALLA   #ZDO_ConvertOTAClusters
   \   000090   023C         JMP     ??ZDO_ParseEndDeviceBindReq_3
   2486            }
   2487            else
   2488            {
   2489              bindReq->numOutClusters = 0;
   \                     ??ZDO_ParseEndDeviceBindReq_2:
   \   000092   CA431600     MOV.B   #0x0, 0x16(R10)
   2490            }
   2491          }
   \                     ??ZDO_ParseEndDeviceBindReq_3:
   \   000096   1A17         POPM.W  #0x2, R11
   \   000098   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   1B4C1600     MOV.W   0x16(R12), R11
   \   000004                REQUIRE ?Subroutine27
   \   000004                // Fall through to label ?Subroutine27

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine27:
   \   000000   6E4B         MOV.B   @R11, R14
   \   000002   5F4B0100     MOV.B   0x1(R11), R15
   \   000006                REQUIRE ??Subroutine27_1
   \   000006                // Fall through to label ??Subroutine27_1
   2492          
   2493          /*********************************************************************
   2494           * @fn          ZDO_ParseBindUnbindReq
   2495           *
   2496           * @brief       This function parses the Bind_req or Unbind_req message.
   2497           *
   2498           * @param       inMsg  - incoming message (request)
   2499           * @param       pReq - place to put parsed information
   2500           *
   2501           * @return      none
   2502           */

   \                                 In  segment CODE, align 2, keep-with-next
   2503          void ZDO_ParseBindUnbindReq( zdoIncomingMsg_t *inMsg, ZDO_BindUnbindReq_t *pReq )
   \                     ZDO_ParseBindUnbindReq:
   2504          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4D         MOV.W   R13, R10
   2505            uint8 *msg;
   2506          
   2507            msg = inMsg->asdu;
   \   000004   1B4C1600     MOV.W   0x16(R12), R11
   2508            osal_cpyExtAddr( pReq->srcAddress, msg );
   \   000008   0D4B         MOV.W   R11, R13
   \   00000A   0C4A         MOV.W   R10, R12
   \   00000C   ........     CALLA   #sAddrExtCpy
   2509            msg += Z_EXTADDR_LEN;
   \   000010   3B52         ADD.W   #0x8, R11
   2510            pReq->srcEndpoint = *msg++;
   \   000012   FA4B0800     MOV.B   @R11+, 0x8(R10)
   2511            pReq->clusterID = BUILD_UINT16( msg[0], msg[1] );
   \   000016   ........     CALLA   #?Subroutine27
   \                     ??CrossCallReturnLabel_59:
   \   00001A   8A4E0A00     MOV.W   R14, 0xa(R10)
   2512            msg += 2;
   \   00001E   2B53         ADD.W   #0x2, R11
   2513            pReq->dstAddress.addrMode = *msg++;
   \   000020   FA4B1400     MOV.B   @R11+, 0x14(R10)
   2514            if ( pReq->dstAddress.addrMode == Addr64Bit )
   \   000024   FA9003001400 CMP.B   #0x3, 0x14(R10)
   \   00002A   0A20         JNE     ??ZDO_ParseBindUnbindReq_0
   2515            {
   2516              osal_cpyExtAddr( pReq->dstAddress.addr.extAddr, msg );
   \   00002C   0D4B         MOV.W   R11, R13
   \   00002E   0C4A         MOV.W   R10, R12
   \   000030   3C500C00     ADD.W   #0xc, R12
   \   000034   ........     CALLA   #sAddrExtCpy
   2517              msg += Z_EXTADDR_LEN;
   2518              pReq->dstEndpoint = *msg;
   \   000038   DA4B08001600 MOV.B   0x8(R11), 0x16(R10)
   \   00003E   043C         JMP     ??ZDO_ParseBindUnbindReq_1
   2519            }
   2520            else
   2521            {
   2522              // copy group address
   2523              pReq->dstAddress.addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   \                     ??ZDO_ParseBindUnbindReq_0:
   \   000040   ........     CALLA   #?Subroutine27
   2524            }
   \                     ??CrossCallReturnLabel_60:
   \   000044   8A4E0C00     MOV.W   R14, 0xc(R10)
   2525          }
   \                     ??ZDO_ParseBindUnbindReq_1:
   \   000048   1A17         POPM.W  #0x2, R11
   \   00004A   1001         RETA
   2526          
   2527          /*********************************************************************
   2528           * @fn      ZDO_ParseAddrRsp
   2529           *
   2530           * @brief   Turns the inMsg (incoming message) into the out parsed
   2531           *          structure.
   2532           *
   2533           * @param   inMsg - incoming message
   2534           *
   2535           * @return  pointer to parsed structures.  This structure was
   2536           *          allocated using osal_mem_alloc, so it must be freed
   2537           *          by the calling function [osal_mem_free()].
   2538           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine12:
   \   000000   ........     CALLA   #osal_mem_alloc
   \   000004   0B4C         MOV.W   R12, R11
   \   000006   0C93         CMP.W   #0x0, R12
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2539          ZDO_NwkIEEEAddrResp_t *ZDO_ParseAddrRsp( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ParseAddrRsp:
   2540          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   084C         MOV.W   R12, R8
   2541            ZDO_NwkIEEEAddrResp_t *rsp;
   2542            uint8 *msg;
   2543            byte cnt = 0;
   \   000004   4A43         MOV.B   #0x0, R10
   2544          
   2545            // Calculate the number of items in the list
   2546            if ( inMsg->asduLen > (1 + Z_EXTADDR_LEN + 2) )
   \   000006   FC900C001200 CMP.B   #0xc, 0x12(R12)
   \   00000C   0428         JNC     ??ZDO_ParseAddrRsp_1
   2547            {
   2548              cnt = inMsg->asdu[1 + Z_EXTADDR_LEN + 2];
   \   00000E   1F4C1600     MOV.W   0x16(R12), R15
   \   000012   5A4F0B00     MOV.B   0xb(R15), R10
   2549            }
   2550            else
   2551            {
   2552              cnt = 0;
   2553            }
   2554          
   2555            // Make buffer
   2556            rsp = (ZDO_NwkIEEEAddrResp_t *)osal_mem_alloc( sizeof(ZDO_NwkIEEEAddrResp_t) + (cnt * sizeof ( uint16 )) );
   \                     ??ZDO_ParseAddrRsp_1:
   \   000016   4C4A         MOV.B   R10, R12
   \   000018   0C5C         RLA.W   R12
   \   00001A   3C500E00     ADD.W   #0xe, R12
   \   00001E   ........     CALLA   #?Subroutine12
   2557          
   2558            if ( rsp )
   \                     ??CrossCallReturnLabel_26:
   \   000022   2424         JEQ     ??ZDO_ParseAddrRsp_2
   2559            {
   2560              msg = inMsg->asdu;
   \   000024   18481600     MOV.W   0x16(R8), R8
   2561          
   2562              rsp->status = *msg++;
   \   000028   FC480000     MOV.B   @R8+, 0(R12)
   2563              if ( rsp->status == ZDO_SUCCESS )
   \   00002C   CC930000     CMP.B   #0x0, 0(R12)
   \   000030   1D20         JNE     ??ZDO_ParseAddrRsp_2
   2564              {
   2565                osal_cpyExtAddr( rsp->extAddr, msg );
   \   000032   0D48         MOV.W   R8, R13
   \   000034   2C52         ADD.W   #0x4, R12
   \   000036   ........     CALLA   #sAddrExtCpy
   2566                msg += Z_EXTADDR_LEN;
   \   00003A   3852         ADD.W   #0x8, R8
   2567                rsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   \   00003C   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_22:
   \   000040   8B4E0200     MOV.W   R14, 0x2(R11)
   2568          
   2569                msg += 2;
   \   000044   2853         ADD.W   #0x2, R8
   2570                rsp->numAssocDevs = 0;
   \   000046   CB430C00     MOV.B   #0x0, 0xc(R11)
   2571          
   2572                // StartIndex field is only present if NumAssocDev field is non-zero.
   2573                if ( cnt > 0 )
   \   00004A   4A93         CMP.B   #0x0, R10
   \   00004C   0F24         JEQ     ??ZDO_ParseAddrRsp_2
   2574                {
   2575                  uint16 *pList = &(rsp->devList[0]);
   \   00004E   0D4B         MOV.W   R11, R13
   \   000050   3D500E00     ADD.W   #0xe, R13
   2576                  byte n = cnt;
   2577          
   2578                  rsp->numAssocDevs = *msg++;
   \   000054   FB480C00     MOV.B   @R8+, 0xc(R11)
   2579                  rsp->startIndex = *msg++;
   \   000058   FB480D00     MOV.B   @R8+, 0xd(R11)
   2580          
   2581                  while ( n != 0 )
   2582                  {
   2583                    *pList++ = BUILD_UINT16( msg[0], msg[1] );
   \                     ??ZDO_ParseAddrRsp_0:
   \   00005C   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_23:
   \   000060   8D4E0000     MOV.W   R14, 0(R13)
   \   000064   2D53         ADD.W   #0x2, R13
   2584                    msg += sizeof( uint16 );
   \   000066   2853         ADD.W   #0x2, R8
   2585                    n--;
   \   000068   7A53         ADD.B   #0xff, R10
   2586                  }
   \   00006A   F823         JNE     ??ZDO_ParseAddrRsp_0
   2587                }
   2588              }
   2589            }
   2590          
   2591            return ( rsp );
   \                     ??ZDO_ParseAddrRsp_2:
   \   00006C   0C4B         MOV.W   R11, R12
   \   00006E   3817         POPM.W  #0x4, R11
   \   000070   1001         RETA
   2592          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine11:
   \   000000   6E48         MOV.B   @R8, R14
   \   000002   5F480100     MOV.B   0x1(R8), R15
   \   000006   ........     BRA     #??Subroutine27_1
   2593          
   2594          /*********************************************************************
   2595           * @fn          ZDO_ParseNodeDescRsp
   2596           *
   2597           * @brief       This function parses the Node_Desc_rsp message.
   2598           *
   2599           * @param       inMsg - incoming message
   2600           * @param       pNDRsp - place to parse the message into
   2601           *
   2602           * @return      none
   2603           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   1C4C1600     MOV.W   0x16(R12), R12
   \   000004   FD4C0000     MOV.B   @R12+, 0(R13)
   \   000008   6E4C         MOV.B   @R12, R14
   \   00000A   5F4C0100     MOV.B   0x1(R12), R15
   \   00000E   ........     CALLA   #??Subroutine27_1
   \                     ??CrossCallReturnLabel_53:
   \   000012   8D4E0200     MOV.W   R14, 0x2(R13)
   \   000016   CD930000     CMP.B   #0x0, 0(R13)
   \   00001A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2604          void ZDO_ParseNodeDescRsp( zdoIncomingMsg_t *inMsg, ZDO_NodeDescRsp_t *pNDRsp )
   \                     ZDO_ParseNodeDescRsp:
   2605          {
   \   000000   0A12         PUSH.W  R10
   2606            uint8 *msg;
   2607          
   2608            msg = inMsg->asdu;
   \   000002   ........     CALLA   #?Subroutine9
   2609          
   2610            pNDRsp->status = *msg++;
   2611            pNDRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2612          
   2613            if ( pNDRsp->status == ZDP_SUCCESS )
   \                     ??CrossCallReturnLabel_17:
   \   000006   4C20         JNE     ??ZDO_ParseNodeDescRsp_0
   2614            {
   2615              msg += 2;
   \   000008   2C53         ADD.W   #0x2, R12
   \   00000A   6E4C         MOV.B   @R12, R14
   \   00000C   7EF00700     AND.B   #0x7, R14
   \   000010   5F4D0400     MOV.B   0x4(R13), R15
   \   000014   7FF0F800     AND.B   #0xf8, R15
   \   000018   4FDE         BIS.B   R14, R15
   \   00001A   CD4F0400     MOV.B   R15, 0x4(R13)
   2616              pNDRsp->nodeDesc.LogicalType = *msg & 0x07;
   2617          
   2618              pNDRsp->nodeDesc.ComplexDescAvail = ( *msg & 0x08 ) >> 3;
   \   00001E   FCB20000     BIT.B   #0x8, 0(R12)
   \   000022   032C         JC      ??ZDO_ParseNodeDescRsp_1
   \   000024   FDC20400     BIC.B   #0x8, 0x4(R13)
   \   000028   023C         JMP     ??ZDO_ParseNodeDescRsp_2
   \                     ??ZDO_ParseNodeDescRsp_1:
   \   00002A   FDD20400     BIS.B   #0x8, 0x4(R13)
   2619              pNDRsp->nodeDesc.UserDescAvail = ( *msg & 0x10 ) >> 4;
   \                     ??ZDO_ParseNodeDescRsp_2:
   \   00002E   7E4C         MOV.B   @R12+, R14
   \   000030                RPT     #0x4
   \   000030   43194E10     RRUX.B  R14
   \   000034   5EF3         AND.B   #0x1, R14
   \   000036                RPT     #0x4
   \   000036   43184E5E     RLAX.B  R14
   \   00003A   5F4D0400     MOV.B   0x4(R13), R15
   \   00003E   7FF0EF00     AND.B   #0xef, R15
   \   000042   4FDE         BIS.B   R14, R15
   \   000044   CD4F0400     MOV.B   R15, 0x4(R13)
   2620          
   2621              msg++;  // Reserved bits.
   2622              pNDRsp->nodeDesc.FrequencyBand = (*msg >> 3) & 0x1f;
   \   000048   6F4C         MOV.B   @R12, R15
   \   00004A   7FF0F800     AND.B   #0xf8, R15
   \   00004E   5E4D0500     MOV.B   0x5(R13), R14
   \   000052   7EF00700     AND.B   #0x7, R14
   \   000056   4EDF         BIS.B   R15, R14
   \   000058   CD4E0500     MOV.B   R14, 0x5(R13)
   2623              pNDRsp->nodeDesc.APSFlags = *msg++ & 0x07;
   \   00005C   7F4C         MOV.B   @R12+, R15
   \   00005E   7FF00700     AND.B   #0x7, R15
   \   000062   7EF0F800     AND.B   #0xf8, R14
   \   000066   4EDF         BIS.B   R15, R14
   \   000068   CD4E0500     MOV.B   R14, 0x5(R13)
   2624              pNDRsp->nodeDesc.CapabilityFlags = *msg++;
   \   00006C   FD4C0600     MOV.B   @R12+, 0x6(R13)
   2625              pNDRsp->nodeDesc.ManufacturerCode[0] = *msg++;
   \   000070   FD4C0700     MOV.B   @R12+, 0x7(R13)
   2626              pNDRsp->nodeDesc.ManufacturerCode[1] = *msg++;
   \   000074   FD4C0800     MOV.B   @R12+, 0x8(R13)
   2627              pNDRsp->nodeDesc.MaxBufferSize = *msg++;
   \   000078   FD4C0900     MOV.B   @R12+, 0x9(R13)
   2628              pNDRsp->nodeDesc.MaxInTransferSize[0] = *msg++;
   \   00007C   FD4C0A00     MOV.B   @R12+, 0xa(R13)
   2629              pNDRsp->nodeDesc.MaxInTransferSize[1] = *msg++;
   \   000080   FD4C0B00     MOV.B   @R12+, 0xb(R13)
   2630              pNDRsp->nodeDesc.ServerMask = BUILD_UINT16( msg[0], msg[1] );
   \   000084   6E4C         MOV.B   @R12, R14
   \   000086   5F4C0100     MOV.B   0x1(R12), R15
   \   00008A   ........     CALLA   #??Subroutine27_1
   \                     ??CrossCallReturnLabel_48:
   \   00008E   8D4E0C00     MOV.W   R14, 0xc(R13)
   2631              msg += 2;
   \   000092   2C53         ADD.W   #0x2, R12
   2632              pNDRsp->nodeDesc.MaxOutTransferSize[0] = *msg++;
   \   000094   FD4C0E00     MOV.B   @R12+, 0xe(R13)
   2633              pNDRsp->nodeDesc.MaxOutTransferSize[1] = *msg++;
   \   000098   FD4C0F00     MOV.B   @R12+, 0xf(R13)
   2634              pNDRsp->nodeDesc.DescriptorCapability = *msg;
   \   00009C   ED4C1000     MOV.B   @R12, 0x10(R13)
   2635            }
   2636          }
   \                     ??ZDO_ParseNodeDescRsp_0:
   \   0000A0   3A41         POP.W   R10
   \   0000A2   1001         RETA
   2637          
   2638          /*********************************************************************
   2639           * @fn          ZDO_ParesPowerDescRsp
   2640           *
   2641           * @brief       This function parses the Power_Desc_rsp message.
   2642           *
   2643           * @param       inMsg  - incoming message
   2644           * @param       pNPRsp - place to parse the message into
   2645           *
   2646           * @return      none
   2647           */

   \                                 In  segment CODE, align 2, keep-with-next
   2648          void ZDO_ParsePowerDescRsp( zdoIncomingMsg_t *inMsg, ZDO_PowerRsp_t *pNPRsp )
   \                     ZDO_ParsePowerDescRsp:
   2649          {
   \   000000   0A12         PUSH.W  R10
   2650            uint8 *msg;
   2651          
   2652            msg = inMsg->asdu;
   \   000002   ........     CALLA   #?Subroutine9
   2653            pNPRsp->status = *msg++;
   2654            pNPRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2655          
   2656            if ( pNPRsp->status == ZDP_SUCCESS )
   \                     ??CrossCallReturnLabel_16:
   \   000006   2020         JNE     ??ZDO_ParsePowerDescRsp_0
   2657            {
   2658              msg += 2;
   \   000008   2C53         ADD.W   #0x2, R12
   \   00000A   6F4C         MOV.B   @R12, R15
   \   00000C                RPT     #0x4
   \   00000C   43194F10     RRUX.B  R15
   \   000010   5F0E         RLAM.W  #0x4, R15
   \   000012   1A4D0400     MOV.W   0x4(R13), R10
   \   000016   3AF00FFF     AND.W   #0xff0f, R10
   \   00001A   ........     CALLA   #?Subroutine19
   2659              pNPRsp->pwrDesc.AvailablePowerSources = *msg >> 4;
   2660              pNPRsp->pwrDesc.PowerMode = *msg++ & 0x0F;
   \                     ??CrossCallReturnLabel_29:
   \   00001E   3AF0F0FF     AND.W   #0xfff0, R10
   \   000022   0ADE         BIS.W   R14, R10
   \   000024   8D4A0400     MOV.W   R10, 0x4(R13)
   2661              pNPRsp->pwrDesc.CurrentPowerSourceLevel = *msg >> 4;
   \   000028   6F4C         MOV.B   @R12, R15
   \   00002A                RPT     #0x4
   \   00002A   43194F10     RRUX.B  R15
   \   00002E                RPT     #0xc
   \   00002E   4B180F5F     RLAX.W  R15
   \   000032   3AF0FF0F     AND.W   #0xfff, R10
   \   000036   ........     CALLA   #?Subroutine19
   2662              pNPRsp->pwrDesc.CurrentPowerSource = *msg++ & 0x0F;
   2663            }
   \                     ??CrossCallReturnLabel_30:
   \   00003A                RPT     #0x8
   \   00003A   47180E5E     RLAX.W  R14
   \   00003E   3AF0FFF0     AND.W   #0xf0ff, R10
   \   000042   0ADE         BIS.W   R14, R10
   \   000044   8D4A0400     MOV.W   R10, 0x4(R13)
   2664          }
   \                     ??ZDO_ParsePowerDescRsp_0:
   \   000048   3A41         POP.W   R10
   \   00004A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine19:
   \   000000   0ADF         BIS.W   R15, R10
   \   000002   8D4A0400     MOV.W   R10, 0x4(R13)
   \   000006   7E4C         MOV.B   @R12+, R14
   \   000008   3EF00F00     AND.W   #0xf, R14
   \   00000C   1001         RETA
   2665          
   2666          /*********************************************************************
   2667           * @fn          ZDO_ParseSimpleDescRsp
   2668           *
   2669           * @brief       This function parse the Simple_Desc_rsp message.
   2670           *
   2671           *   NOTE: The pAppInClusterList and pAppOutClusterList fields
   2672           *         in the SimpleDescriptionFormat_t structure are allocated
   2673           *         and the calling function needs to free [osal_msg_free()]
   2674           *         these buffers.
   2675           *
   2676           * @param       inMsg  - incoming message
   2677           * @param       pSimpleDescRsp - place to parse the message into
   2678           *
   2679           * @return      none
   2680           */

   \                                 In  segment CODE, align 2, keep-with-next
   2681          void ZDO_ParseSimpleDescRsp( zdoIncomingMsg_t *inMsg, ZDO_SimpleDescRsp_t *pSimpleDescRsp )
   \                     ZDO_ParseSimpleDescRsp:
   2682          {
   2683            uint8 *msg;
   2684          
   2685            msg = inMsg->asdu;
   \   000000   ........     CALLA   #?Subroutine9
   2686            pSimpleDescRsp->status = *msg++;
   2687            pSimpleDescRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   2688            msg += sizeof ( uint16 );
   2689            msg++; // Skip past the length field.
   2690          
   2691            if ( pSimpleDescRsp->status == ZDP_SUCCESS )
   \                     ??CrossCallReturnLabel_15:
   \   000004   0520         JNE     ??ZDO_ParseSimpleDescRsp_0
   2692            {
   2693              ZDO_ParseSimpleDescBuf( msg, &(pSimpleDescRsp->simpleDesc) );
   \   000006   2D52         ADD.W   #0x4, R13
   \   000008   3C500300     ADD.W   #0x3, R12
   \   00000C   ........     CALLA   #ZDO_ParseSimpleDescBuf
   2694            }
   2695          }
   \                     ??ZDO_ParseSimpleDescRsp_0:
   \   000010   1001         RETA
   2696          
   2697          /*********************************************************************
   2698           * @fn          ZDO_ParseEPListRsp
   2699           *
   2700           * @brief       This parse the Active_EP_rsp or Match_Desc_rsp message.
   2701           *
   2702           * @param       inMsg  - incoming message
   2703           *
   2704           * @return      none
   2705           */

   \                                 In  segment CODE, align 2, keep-with-next
   2706          ZDO_ActiveEndpointRsp_t *ZDO_ParseEPListRsp( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ParseEPListRsp:
   2707          {
   \   000000   5B15         PUSHM.W #0x6, R11
   2708            ZDO_ActiveEndpointRsp_t *pRsp;
   2709            uint8 *msg;
   2710            uint8 Status;
   2711            uint8 cnt;
   2712          
   2713            msg = inMsg->asdu;
   \   000002   184C1600     MOV.W   0x16(R12), R8
   2714            Status = *msg++;
   \   000006   7648         MOV.B   @R8+, R6
   2715            cnt = msg[2];
   \   000008   5A480200     MOV.B   0x2(R8), R10
   2716          
   2717            pRsp = (ZDO_ActiveEndpointRsp_t *)osal_mem_alloc( sizeof(  ZDO_ActiveEndpointRsp_t ) + cnt );
   \   00000C   ........     CALLA   #?Subroutine5
   2718            if ( pRsp )
   \                     ??CrossCallReturnLabel_5:
   \   000010   0C24         JEQ     ??ZDO_ParseEPListRsp_0
   2719            {
   2720              pRsp->status = Status;
   \   000012   CC460000     MOV.B   R6, 0(R12)
   2721              pRsp->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   \   000016   6E48         MOV.B   @R8, R14
   \   000018   5F480100     MOV.B   0x1(R8), R15
   \   00001C   ........     CALLA   #?Subroutine10
   2722              msg += sizeof( uint16 );
   2723              pRsp->cnt = cnt;
   2724              msg++; // pass cnt
   2725              osal_memcpy( pRsp->epList, msg, cnt );
   \                     ??CrossCallReturnLabel_19:
   \   000020   0E4B         MOV.W   R11, R14
   \   000022   38500300     ADD.W   #0x3, R8
   \   000026   ........     CALLA   #?Subroutine14
   2726            }
   2727          
   2728            return ( pRsp );
   \                     ??ZDO_ParseEPListRsp_0:
   \   00002A   0C49         MOV.W   R9, R12
   \   00002C   5617         POPM.W  #0x6, R11
   \   00002E   1001         RETA
   2729          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine14:
   \   000000   0D48         MOV.W   R8, R13
   \   000002   3C500500     ADD.W   #0x5, R12
   \   000006   ........     BRA     #osal_memcpy

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine10:
   \   000000   ........     CALLA   #??Subroutine27_1
   \                     ??CrossCallReturnLabel_54:
   \   000004   8C4E0200     MOV.W   R14, 0x2(R12)
   \   000008   CC4A0400     MOV.B   R10, 0x4(R12)
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   4B4A         MOV.B   R10, R11
   \   000002   0C4B         MOV.W   R11, R12
   \   000004   3C500600     ADD.W   #0x6, R12
   \   000008   ........     CALLA   #osal_mem_alloc
   \   00000C   094C         MOV.W   R12, R9
   \   00000E   0C93         CMP.W   #0x0, R12
   \   000010   1001         RETA
   2730          
   2731          /*********************************************************************
   2732           * @fn          ZDO_ParseServerDiscRsp
   2733           *
   2734           * @brief       Parse the Server_Discovery_rsp message.
   2735           *
   2736           * @param       inMsg - incoming message.
   2737           * @param       pRsp - place to put the parsed information.
   2738           *
   2739           * @return      none
   2740           */

   \                                 In  segment CODE, align 2, keep-with-next
   2741          void ZDO_ParseServerDiscRsp( zdoIncomingMsg_t *inMsg, ZDO_ServerDiscRsp_t *pRsp )
   \                     ZDO_ParseServerDiscRsp:
   2742          {
   \   000000   1F4C1600     MOV.W   0x16(R12), R15
   \   000004   ED4F0000     MOV.B   @R15, 0(R13)
   2743            pRsp->status = inMsg->asdu[0];
   2744            pRsp->serverMask = BUILD_UINT16( inMsg->asdu[1], inMsg->asdu[2] );
   \   000008   1F4C1600     MOV.W   0x16(R12), R15
   \   00000C   5E4F0100     MOV.B   0x1(R15), R14
   \   000010   5F4F0200     MOV.B   0x2(R15), R15
   \   000014   ........     CALLA   #??Subroutine27_1
   \                     ??CrossCallReturnLabel_47:
   \   000018   8D4E0200     MOV.W   R14, 0x2(R13)
   2745          }
   \   00001C   1001         RETA
   2746          
   2747          /*********************************************************************
   2748           * @fn          ZDO_ParseMgmtLqiRsp
   2749           *
   2750           * @brief       This function parses the incoming Management
   2751           *              LQI response
   2752           *
   2753           * @param       inMsg - incoming message
   2754           *
   2755           * @return      a pointer to parsed response structure (NULL if not allocated).
   2756           *          This structure was allocated using osal_mem_alloc, so it must be freed
   2757           *          by the calling function [osal_mem_free()].
   2758           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   0C4B         MOV.W   R11, R12
   \   000002   7417         POPM.W  #0x8, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2759          ZDO_MgmtLqiRsp_t *ZDO_ParseMgmtLqiRsp( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ParseMgmtLqiRsp:
   2760          {
   \   000000   7B15         PUSHM.W #0x8, R11
   2761            ZDO_MgmtLqiRsp_t *pRsp;
   2762            uint8 status;
   2763            uint8 startIndex = 0;
   \   000002   4943         MOV.B   #0x0, R9
   2764            uint8 neighborLqiCount = 0;
   \   000004   4A43         MOV.B   #0x0, R10
   2765            uint8 neighborLqiEntries = 0;
   \   000006   4743         MOV.B   #0x0, R7
   2766            uint8 *msg;
   2767          
   2768            msg = inMsg->asdu;
   \   000008   164C1600     MOV.W   0x16(R12), R6
   2769          
   2770            status = *msg++;
   \   00000C   7446         MOV.B   @R6+, R4
   2771            if ( status == ZSuccess )
   \   00000E   4493         CMP.B   #0x0, R4
   \   000010   0320         JNE     ??ZDO_ParseMgmtLqiRsp_1
   2772            {
   2773              neighborLqiEntries = *msg++;
   \   000012   7746         MOV.B   @R6+, R7
   2774              startIndex = *msg++;
   \   000014   7946         MOV.B   @R6+, R9
   2775              neighborLqiCount = *msg++;
   \   000016   7A46         MOV.B   @R6+, R10
   2776            }
   2777          
   2778            // Allocate a buffer big enough to handle the list.
   2779            pRsp = (ZDO_MgmtLqiRsp_t *)osal_mem_alloc(
   2780                      sizeof( ZDO_MgmtLqiRsp_t ) + (neighborLqiCount * sizeof( neighborLqiItem_t )) );
   \                     ??ZDO_ParseMgmtLqiRsp_1:
   \   000018   2C42         MOV.W   #0x4, R12
   \   00001A                RPT     #0xe
   \   00001A   4D180C5A     ADDX.W  R10, R12
   \   00001E   ........     CALLA   #?Subroutine12
   2781            if ( pRsp )
   \                     ??CrossCallReturnLabel_25:
   \   000022   2524         JEQ     ??ZDO_ParseMgmtLqiRsp_2
   2782            {
   2783              uint8 x;
   2784              neighborLqiItem_t *pList = pRsp->list;
   \   000024   084C         MOV.W   R12, R8
   \   000026   2852         ADD.W   #0x4, R8
   2785              pRsp->status = status;
   \   000028   CC440000     MOV.B   R4, 0(R12)
   2786              pRsp->neighborLqiEntries = neighborLqiEntries;
   \   00002C   CC470100     MOV.B   R7, 0x1(R12)
   2787              pRsp->startIndex = startIndex;
   \   000030   CC490200     MOV.B   R9, 0x2(R12)
   2788              pRsp->neighborLqiCount = neighborLqiCount;
   \   000034   CC4A0300     MOV.B   R10, 0x3(R12)
   2789          
   2790              for ( x = 0; x < neighborLqiCount; x++ )
   \   000038   4943         MOV.B   #0x0, R9
   \   00003A   173C         JMP     ??ZDO_ParseMgmtLqiRsp_3
   2791              {
   2792                osal_cpyExtAddr(pList->extPANId, msg);   //Copy extended PAN ID
   \                     ??ZDO_ParseMgmtLqiRsp_0:
   \   00003C   0D46         MOV.W   R6, R13
   \   00003E   0C48         MOV.W   R8, R12
   \   000040   2C52         ADD.W   #0x4, R12
   \   000042   ........     CALLA   #sAddrExtCpy
   2793                msg += Z_EXTADDR_LEN;
   2794          
   2795                msg += Z_EXTADDR_LEN;  // Throwing away IEEE.
   \   000046   36501000     ADD.W   #0x10, R6
   2796                pList->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   \   00004A   6E46         MOV.B   @R6, R14
   \   00004C   5F460100     MOV.B   0x1(R6), R15
   \   000050   ........     CALLA   #??Subroutine27_1
   \                     ??CrossCallReturnLabel_46:
   \   000054   884E0000     MOV.W   R14, 0(R8)
   2797                msg += 2 + 1 + 1 + 1;      // Skip DeviceType, RxOnIdle, Rlationship, PermitJoining and Depth
   \   000058   36500500     ADD.W   #0x5, R6
   2798                pList->rxLqi = *msg++;
   \   00005C   F8460D00     MOV.B   @R6+, 0xd(R8)
   2799                pList->txQuality = 0;  // This is not specified OTA by ZigBee 1.1.
   \   000060   C8430C00     MOV.B   #0x0, 0xc(R8)
   2800                pList++;
   \   000064   38500E00     ADD.W   #0xe, R8
   2801              }
   \   000068   5953         ADD.B   #0x1, R9
   \                     ??ZDO_ParseMgmtLqiRsp_3:
   \   00006A   499A         CMP.B   R10, R9
   \   00006C   E72B         JNC     ??ZDO_ParseMgmtLqiRsp_0
   2802            }
   2803          
   2804            return ( pRsp );
   \                     ??ZDO_ParseMgmtLqiRsp_2:
   \   00006E   ....         JMP     ?Subroutine2
   2805          }
   2806          
   2807          /*********************************************************************
   2808           * @fn          ZDO_ParseMgmNwkDiscRsp
   2809           *
   2810           * @brief       This function parses the incoming Management
   2811           *              Network Discover response.
   2812           *
   2813           * @param       inMsg - incoming message
   2814           *
   2815           * @return      pointer to parsed response.  This structure was
   2816           *          allocated using osal_mem_alloc, so it must be freed
   2817           *          by the calling function [osal_mem_free()].
   2818           */

   \                                 In  segment CODE, align 2, keep-with-next
   2819          ZDO_MgmNwkDiscRsp_t *ZDO_ParseMgmNwkDiscRsp( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ParseMgmNwkDiscRsp:
   2820          {
   \   000000   5B15         PUSHM.W #0x6, R11
   2821            ZDO_MgmNwkDiscRsp_t *pRsp;
   2822            uint8 status;
   2823            uint8 networkCount = 0;
   \   000002   4943         MOV.B   #0x0, R9
   2824            uint8 startIndex = 0;
   \   000004   4643         MOV.B   #0x0, R6
   2825            uint8 networkListCount = 0;
   \   000006   4A43         MOV.B   #0x0, R10
   2826            uint8 *msg;
   2827          
   2828            msg = inMsg->asdu;
   \   000008   1B4C1600     MOV.W   0x16(R12), R11
   2829            status = *msg++;
   \   00000C   774B         MOV.B   @R11+, R7
   2830          
   2831            if ( status == ZSuccess )
   \   00000E   4793         CMP.B   #0x0, R7
   \   000010   0320         JNE     ??ZDO_ParseMgmNwkDiscRsp_1
   2832            {
   2833              networkCount = *msg++;
   \   000012   794B         MOV.B   @R11+, R9
   2834              startIndex = *msg++;
   \   000014   764B         MOV.B   @R11+, R6
   2835              networkListCount = *msg++;
   \   000016   7A4B         MOV.B   @R11+, R10
   2836            }
   2837          
   2838            // Allocate a buffer big enough to handle the list.
   2839            pRsp = (ZDO_MgmNwkDiscRsp_t *)osal_mem_alloc( sizeof( ZDO_MgmNwkDiscRsp_t )
   2840                                            + (networkListCount * sizeof( mgmtNwkDiscItem_t )) );
   \                     ??ZDO_ParseMgmNwkDiscRsp_1:
   \   000018   4C4A         MOV.B   R10, R12
   \   00001A   5C0E         RLAM.W  #0x4, R12
   \   00001C   2C52         ADD.W   #0x4, R12
   \   00001E   ........     CALLA   #osal_mem_alloc
   \   000022   084C         MOV.W   R12, R8
   2841            if ( pRsp )
   \   000024   0C93         CMP.W   #0x0, R12
   \   000026   3224         JEQ     ??ZDO_ParseMgmNwkDiscRsp_2
   2842            {
   2843              uint8 x;
   2844              mgmtNwkDiscItem_t *pList;
   2845          
   2846              pRsp->status = status;
   \   000028   CC470000     MOV.B   R7, 0(R12)
   2847              pRsp->networkCount = networkCount;
   \   00002C   CC490100     MOV.B   R9, 0x1(R12)
   2848              pRsp->startIndex = startIndex;
   \   000030   CC460200     MOV.B   R6, 0x2(R12)
   2849              pRsp->networkListCount = networkListCount;
   \   000034   CC4A0300     MOV.B   R10, 0x3(R12)
   2850              pList = pRsp->list;
   \   000038   094C         MOV.W   R12, R9
   \   00003A   2952         ADD.W   #0x4, R9
   2851          
   2852              for ( x = 0; x < networkListCount; x++ )
   \   00003C   4643         MOV.B   #0x0, R6
   \   00003E   243C         JMP     ??ZDO_ParseMgmNwkDiscRsp_3
   2853              {
   2854                osal_cpyExtAddr(pList->extendedPANID, msg);   //Copy extended PAN ID
   \                     ??ZDO_ParseMgmNwkDiscRsp_0:
   \   000040   0D4B         MOV.W   R11, R13
   \   000042   0C49         MOV.W   R9, R12
   \   000044   ........     CALLA   #sAddrExtCpy
   2855                pList->PANId = BUILD_UINT16( msg[0], msg[1] );
   \   000048   ........     CALLA   #?Subroutine27
   \                     ??CrossCallReturnLabel_58:
   \   00004C   894E0800     MOV.W   R14, 0x8(R9)
   2856                msg += Z_EXTADDR_LEN;
   \   000050   3B52         ADD.W   #0x8, R11
   2857          
   2858                pList->logicalChannel = *msg++;
   \   000052   F94B0A00     MOV.B   @R11+, 0xa(R9)
   2859                pList->stackProfile = (*msg) & 0x0F;
   \   000056   6E4B         MOV.B   @R11, R14
   \   000058   7EF00F00     AND.B   #0xf, R14
   \   00005C   C94E0B00     MOV.B   R14, 0xb(R9)
   2860                pList->version = (*msg++ >> 4) & 0x0F;
   \   000060   7E4B         MOV.B   @R11+, R14
   \   000062                RPT     #0x4
   \   000062   43194E10     RRUX.B  R14
   \   000066   C94E0C00     MOV.B   R14, 0xc(R9)
   2861                pList->beaconOrder = (*msg) & 0x0F;
   \   00006A   6E4B         MOV.B   @R11, R14
   \   00006C   7EF00F00     AND.B   #0xf, R14
   \   000070   C94E0D00     MOV.B   R14, 0xd(R9)
   2862                pList->superFrameOrder = (*msg++ >> 4) & 0x0F;
   \   000074   7E4B         MOV.B   @R11+, R14
   \   000076                RPT     #0x4
   \   000076   43194E10     RRUX.B  R14
   \   00007A   C94E0E00     MOV.B   R14, 0xe(R9)
   2863                pList->permitJoining = *msg++;
   \   00007E   F94B0F00     MOV.B   @R11+, 0xf(R9)
   2864                pList++;
   \   000082   39501000     ADD.W   #0x10, R9
   2865              }
   \   000086   5653         ADD.B   #0x1, R6
   \                     ??ZDO_ParseMgmNwkDiscRsp_3:
   \   000088   469A         CMP.B   R10, R6
   \   00008A   DA2B         JNC     ??ZDO_ParseMgmNwkDiscRsp_0
   2866            }
   2867          
   2868            return ( pRsp );
   \                     ??ZDO_ParseMgmNwkDiscRsp_2:
   \   00008C   0C48         MOV.W   R8, R12
   \   00008E   5617         POPM.W  #0x6, R11
   \   000090   1001         RETA
   2869          }
   2870          
   2871          /*********************************************************************
   2872           * @fn          ZDO_ParseMgmtRtgRsp
   2873           *
   2874           * @brief       This function parses the incoming Management
   2875           *              Routing response.
   2876           *
   2877           * @param       inMsg - incoming message
   2878           *
   2879           * @return      a pointer to parsed response structure (NULL if not allocated).
   2880           *          This structure was allocated using osal_mem_alloc, so it must be freed
   2881           *          by the calling function [osal_mem_free()].
   2882           */

   \                                 In  segment CODE, align 2, keep-with-next
   2883          ZDO_MgmtRtgRsp_t *ZDO_ParseMgmtRtgRsp( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ParseMgmtRtgRsp:
   2884          {
   \   000000   5B15         PUSHM.W #0x6, R11
   2885            ZDO_MgmtRtgRsp_t *pRsp;
   2886            uint8 status;
   2887            uint8 rtgCount = 0;
   \   000002   4843         MOV.B   #0x0, R8
   2888            uint8 startIndex = 0;
   \   000004   4943         MOV.B   #0x0, R9
   2889            uint8 rtgListCount = 0;
   \   000006   4A43         MOV.B   #0x0, R10
   2890            uint8 *msg;
   2891          
   2892            msg = inMsg->asdu;
   \   000008   1B4C1600     MOV.W   0x16(R12), R11
   2893          
   2894            status = *msg++;
   \   00000C   764B         MOV.B   @R11+, R6
   2895            if ( status == ZSuccess )
   \   00000E   4693         CMP.B   #0x0, R6
   \   000010   0320         JNE     ??ZDO_ParseMgmtRtgRsp_1
   2896            {
   2897              rtgCount = *msg++;
   \   000012   784B         MOV.B   @R11+, R8
   2898              startIndex = *msg++;
   \   000014   794B         MOV.B   @R11+, R9
   2899              rtgListCount = *msg++;
   \   000016   7A4B         MOV.B   @R11+, R10
   2900            }
   2901          
   2902            // Allocate a buffer big enough to handle the list
   2903            pRsp = (ZDO_MgmtRtgRsp_t *)osal_mem_alloc(
   2904                    sizeof( ZDO_MgmtRtgRsp_t ) + (rtgListCount * sizeof( rtgItem_t )) );
   \                     ??ZDO_ParseMgmtRtgRsp_1:
   \   000018   4C4A         MOV.B   R10, R12
   \   00001A   5C0A         RLAM.W  #0x3, R12
   \   00001C   2C52         ADD.W   #0x4, R12
   \   00001E   ........     CALLA   #osal_mem_alloc
   2905            if ( pRsp )
   \   000022   0C93         CMP.W   #0x0, R12
   \   000024   1C24         JEQ     ??ZDO_ParseMgmtRtgRsp_2
   2906            {
   2907              uint8 x;
   2908              rtgItem_t *pList = pRsp->list;
   \   000026   0D4C         MOV.W   R12, R13
   \   000028   2D52         ADD.W   #0x4, R13
   2909              pRsp->status = status;
   \   00002A   CC460000     MOV.B   R6, 0(R12)
   2910              pRsp->rtgCount = rtgCount;
   \   00002E   CC480100     MOV.B   R8, 0x1(R12)
   2911              pRsp->startIndex = startIndex;
   \   000032   CC490200     MOV.B   R9, 0x2(R12)
   2912              pRsp->rtgListCount = rtgListCount;
   \   000036   CC4A0300     MOV.B   R10, 0x3(R12)
   2913          
   2914              for ( x = 0; x < rtgListCount; x++ )
   \   00003A   4843         MOV.B   #0x0, R8
   \   00003C   0E3C         JMP     ??ZDO_ParseMgmtRtgRsp_3
   2915              {
   2916                pList->dstAddress = BUILD_UINT16( msg[0], msg[1] );
   \                     ??ZDO_ParseMgmtRtgRsp_0:
   \   00003E   ........     CALLA   #?Subroutine27
   \                     ??CrossCallReturnLabel_56:
   \   000042   8D4E0000     MOV.W   R14, 0(R13)
   2917                msg += 2;
   \   000046   2B53         ADD.W   #0x2, R11
   2918                pList->status = *msg++;
   \   000048   FD4B0500     MOV.B   @R11+, 0x5(R13)
   2919                pList->nextHopAddress = BUILD_UINT16( msg[0], msg[1] );
   \   00004C   ........     CALLA   #?Subroutine27
   \                     ??CrossCallReturnLabel_57:
   \   000050   8D4E0200     MOV.W   R14, 0x2(R13)
   2920                msg += 2;
   \   000054   2B53         ADD.W   #0x2, R11
   2921                pList++;
   \   000056   3D52         ADD.W   #0x8, R13
   2922              }
   \   000058   5853         ADD.B   #0x1, R8
   \                     ??ZDO_ParseMgmtRtgRsp_3:
   \   00005A   489A         CMP.B   R10, R8
   \   00005C   F02B         JNC     ??ZDO_ParseMgmtRtgRsp_0
   2923            }
   2924          
   2925            return ( pRsp );
   \                     ??ZDO_ParseMgmtRtgRsp_2:
   \   00005E   5617         POPM.W  #0x6, R11
   \   000060   1001         RETA
   2926          }
   2927          
   2928          /*********************************************************************
   2929           * @fn          ZDO_ParseMgmtBindRsp
   2930           *
   2931           * @brief       This function parses the incoming Management
   2932           *              Binding response.
   2933           *
   2934           * @param       inMsg - pointer to message to parse
   2935           *
   2936           * @return      a pointer to parsed response structure (NULL if not allocated).
   2937           *          This structure was allocated using osal_mem_alloc, so it must be freed
   2938           *          by the calling function [osal_mem_free()].
   2939           */

   \                                 In  segment CODE, align 2, keep-with-next
   2940          ZDO_MgmtBindRsp_t *ZDO_ParseMgmtBindRsp( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ParseMgmtBindRsp:
   2941          {
   \   000000   7B15         PUSHM.W #0x8, R11
   2942            ZDO_MgmtBindRsp_t *pRsp;
   2943            uint8 status;
   2944            uint8 bindingCount = 0;
   \   000002   4943         MOV.B   #0x0, R9
   2945            uint8 startIndex = 0;
   \   000004   4743         MOV.B   #0x0, R7
   2946            uint8 bindingListCount = 0;
   \   000006   4A43         MOV.B   #0x0, R10
   2947            uint8 *msg;
   2948          
   2949            msg = inMsg->asdu;
   \   000008   164C1600     MOV.W   0x16(R12), R6
   2950          
   2951            status = *msg++;
   \   00000C   7446         MOV.B   @R6+, R4
   2952            if ( status == ZSuccess )
   \   00000E   4493         CMP.B   #0x0, R4
   \   000010   0320         JNE     ??ZDO_ParseMgmtBindRsp_2
   2953            {
   2954              bindingCount = *msg++;
   \   000012   7946         MOV.B   @R6+, R9
   2955              startIndex = *msg++;
   \   000014   7746         MOV.B   @R6+, R7
   2956              bindingListCount = *msg++;
   \   000016   7A46         MOV.B   @R6+, R10
   2957            }
   2958          
   2959            // Allocate a buffer big enough to handle the list
   2960            pRsp = (ZDO_MgmtBindRsp_t *)osal_mem_alloc(
   2961                    (sizeof ( ZDO_MgmtBindRsp_t ) + (bindingListCount * sizeof( apsBindingItem_t ))) );
   \                     ??ZDO_ParseMgmtBindRsp_2:
   \   000018   4C4A         MOV.B   R10, R12
   \   00001A   5C0A         RLAM.W  #0x3, R12
   \   00001C   0F4C         MOV.W   R12, R15
   \   00001E   0C5C         RLA.W   R12
   \   000020   0C5F         ADD.W   R15, R12
   \   000022   2C52         ADD.W   #0x4, R12
   \   000024   ........     CALLA   #?Subroutine12
   2962            if ( pRsp )
   \                     ??CrossCallReturnLabel_24:
   \   000028   3824         JEQ     ??ZDO_ParseMgmtBindRsp_3
   2963            {
   2964              uint8 x;
   2965              apsBindingItem_t *pList = pRsp->list;
   \   00002A   084C         MOV.W   R12, R8
   \   00002C   2852         ADD.W   #0x4, R8
   2966              pRsp->status = status;
   \   00002E   CC440000     MOV.B   R4, 0(R12)
   2967              pRsp->bindingCount = bindingCount;
   \   000032   CC490100     MOV.B   R9, 0x1(R12)
   2968              pRsp->startIndex = startIndex;
   \   000036   CC470200     MOV.B   R7, 0x2(R12)
   2969              pRsp->bindingListCount = bindingListCount;
   \   00003A   CC4A0300     MOV.B   R10, 0x3(R12)
   2970          
   2971              for ( x = 0; x < bindingListCount; x++ )
   \   00003E   4943         MOV.B   #0x0, R9
   \   000040   0B3C         JMP     ??ZDO_ParseMgmtBindRsp_4
   2972              {
   2973                osal_cpyExtAddr( pList->srcAddr, msg );
   2974                msg += Z_EXTADDR_LEN;
   2975                pList->srcEP = *msg++;
   2976          
   2977                // Get the Cluster ID
   2978          
   2979                pList->clusterID = BUILD_UINT16( msg[0], msg[1] );
   2980                msg += 2;
   2981                pList->dstAddr.addrMode = *msg++;
   2982                if ( pList->dstAddr.addrMode == Addr64Bit )
   2983                {
   2984                  osal_cpyExtAddr( pList->dstAddr.addr.extAddr, msg );
   2985                  msg += Z_EXTADDR_LEN;
   2986                  pList->dstEP = *msg++;
   2987                }
   2988                else
   2989                {
   2990                  pList->dstAddr.addr.shortAddr = BUILD_UINT16( msg[0], msg[1] );
   \                     ??ZDO_ParseMgmtBindRsp_0:
   \   000042   6E46         MOV.B   @R6, R14
   \   000044   5F460100     MOV.B   0x1(R6), R15
   \   000048   ........     CALLA   #??Subroutine27_1
   \                     ??CrossCallReturnLabel_44:
   \   00004C   884E0C00     MOV.W   R14, 0xc(R8)
   2991                  msg += 2;
   \   000050   2653         ADD.W   #0x2, R6
   2992                }
   2993          
   2994                pList++;
   \                     ??ZDO_ParseMgmtBindRsp_1:
   \   000052   38501800     ADD.W   #0x18, R8
   \   000056   5953         ADD.B   #0x1, R9
   \                     ??ZDO_ParseMgmtBindRsp_4:
   \   000058   499A         CMP.B   R10, R9
   \   00005A   1F2C         JC      ??ZDO_ParseMgmtBindRsp_3
   \   00005C   0D46         MOV.W   R6, R13
   \   00005E   0C48         MOV.W   R8, R12
   \   000060   ........     CALLA   #sAddrExtCpy
   \   000064   3652         ADD.W   #0x8, R6
   \   000066   F8460800     MOV.B   @R6+, 0x8(R8)
   \   00006A   6E46         MOV.B   @R6, R14
   \   00006C   5F460100     MOV.B   0x1(R6), R15
   \   000070   ........     CALLA   #??Subroutine27_1
   \                     ??CrossCallReturnLabel_45:
   \   000074   884E0A00     MOV.W   R14, 0xa(R8)
   \   000078   2653         ADD.W   #0x2, R6
   \   00007A   F8461400     MOV.B   @R6+, 0x14(R8)
   \   00007E   F89003001400 CMP.B   #0x3, 0x14(R8)
   \   000084   DE23         JNE     ??ZDO_ParseMgmtBindRsp_0
   \   000086   0D46         MOV.W   R6, R13
   \   000088   0C48         MOV.W   R8, R12
   \   00008A   3C500C00     ADD.W   #0xc, R12
   \   00008E   ........     CALLA   #sAddrExtCpy
   \   000092   3652         ADD.W   #0x8, R6
   \   000094   F8461600     MOV.B   @R6+, 0x16(R8)
   \   000098   DC3F         JMP     ??ZDO_ParseMgmtBindRsp_1
   2995              }
   2996            }
   2997          
   2998            return ( pRsp );
   \                     ??ZDO_ParseMgmtBindRsp_3:
   \   00009A                REQUIRE ?Subroutine2
   \   00009A                // Fall through to label ?Subroutine2
   2999          }
   3000          
   3001          /*********************************************************************
   3002           * @fn          ZDO_ParseUserDescRsp
   3003           *
   3004           * @brief       This function parses the incoming User
   3005           *              Descriptor Response.
   3006           *
   3007           * @param       inMsg - incoming response message
   3008           *
   3009           * @return      a pointer to parsed response structure (NULL if not allocated).
   3010           *          This structure was allocated using osal_mem_alloc, so it must be freed
   3011           *          by the calling function [osal_mem_free()].
   3012           */

   \                                 In  segment CODE, align 2, keep-with-next
   3013          ZDO_UserDescRsp_t *ZDO_ParseUserDescRsp( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ParseUserDescRsp:
   3014          {
   \   000000   3B15         PUSHM.W #0x4, R11
   3015            ZDO_UserDescRsp_t *pRsp;
   3016            uint8 *msg;
   3017            uint8 descLen = 0;
   \   000002   4A43         MOV.B   #0x0, R10
   3018          
   3019            msg = inMsg->asdu;
   \   000004   184C1600     MOV.W   0x16(R12), R8
   3020          
   3021            if ( msg[0] == ZSuccess )
   \   000008   C8930000     CMP.B   #0x0, 0(R8)
   \   00000C   0220         JNE     ??ZDO_ParseUserDescRsp_0
   3022            {
   3023              descLen = msg[3];
   \   00000E   5A480300     MOV.B   0x3(R8), R10
   3024            }
   3025          
   3026            pRsp = (ZDO_UserDescRsp_t *)osal_mem_alloc( sizeof ( ZDO_UserDescRsp_t ) + descLen );
   \                     ??ZDO_ParseUserDescRsp_0:
   \   000012   ........     CALLA   #?Subroutine5
   3027            if ( pRsp )
   \                     ??CrossCallReturnLabel_4:
   \   000016   0E24         JEQ     ??ZDO_ParseUserDescRsp_1
   3028            {
   3029              pRsp->status = msg[0];
   \   000018   EC480000     MOV.B   @R8, 0(R12)
   3030              pRsp->nwkAddr = BUILD_UINT16( msg[1], msg[2] );
   \   00001C   5E480100     MOV.B   0x1(R8), R14
   \   000020   5F480200     MOV.B   0x2(R8), R15
   \   000024   ........     CALLA   #?Subroutine10
   3031              pRsp->length = descLen;
   3032              if ( descLen )
   \                     ??CrossCallReturnLabel_18:
   \   000028   4A93         CMP.B   #0x0, R10
   \   00002A   0424         JEQ     ??ZDO_ParseUserDescRsp_1
   3033              {
   3034                osal_memcpy( pRsp->desc, &msg[4], descLen );
   \   00002C   0E4B         MOV.W   R11, R14
   \   00002E   2852         ADD.W   #0x4, R8
   \   000030   ........     CALLA   #?Subroutine14
   3035              }
   3036            }
   3037          
   3038            return ( pRsp );
   \                     ??ZDO_ParseUserDescRsp_1:
   \   000034   0C49         MOV.W   R9, R12
   \   000036   3817         POPM.W  #0x4, R11
   \   000038   1001         RETA
   3039          }
   3040          
   3041          /*********************************************************************
   3042           * @fn          ZDO_ParseSimpleDescBuf
   3043           *
   3044           * @brief       Parse a byte sequence representation of a Simple Descriptor.
   3045           *
   3046           * @param       buf  - pointer to a byte array representing a Simple Desc.
   3047           * @param       desc - SimpleDescriptionFormat_t *
   3048           *
   3049           *              This routine allocates storage for the cluster IDs because
   3050           *              they are 16-bit and need to be aligned to be properly processed.
   3051           *              This routine returns non-zero if an allocation fails.
   3052           *
   3053           *              NOTE: This means that the caller or user of the input structure
   3054           *                    is responsible for freeing the memory
   3055           *
   3056           * @return      0: success
   3057           *              1: failure due to malloc failure.
   3058           */

   \                                 In  segment CODE, align 2, keep-with-next
   3059          uint8 ZDO_ParseSimpleDescBuf( uint8 *buf, SimpleDescriptionFormat_t *desc )
   \                     ZDO_ParseSimpleDescBuf:
   3060          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   084C         MOV.W   R12, R8
   \   000004   0B4D         MOV.W   R13, R11
   3061            uint8 num, i;
   3062          
   3063            desc->EndPoint = *buf++;
   \   000006   FD480000     MOV.B   @R8+, 0(R13)
   3064            desc->AppProfId = BUILD_UINT16( buf[0], buf[1] );
   \   00000A   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_20:
   \   00000E   8D4E0200     MOV.W   R14, 0x2(R13)
   3065            buf += 2;
   \   000012   2853         ADD.W   #0x2, R8
   3066            desc->AppDeviceId = BUILD_UINT16( buf[0], buf[1] );
   \   000014   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_21:
   \   000018   8D4E0400     MOV.W   R14, 0x4(R13)
   3067            buf += 2;
   \   00001C   2853         ADD.W   #0x2, R8
   3068            desc->AppDevVer = *buf >> 4;
   \   00001E   7E48         MOV.B   @R8+, R14
   \   000020                RPT     #0x4
   \   000020   43194E10     RRUX.B  R14
   3069          
   3070            desc->Reserved = 0;
   \   000024   CD4E0600     MOV.B   R14, 0x6(R13)
   3071            buf++;
   3072          
   3073            // move in input cluster list (if any). allocate aligned memory.
   3074            num = desc->AppNumInClusters = *buf++;
   \   000028   7A48         MOV.B   @R8+, R10
   \   00002A   CD4A0700     MOV.B   R10, 0x7(R13)
   3075            if ( num )
   \   00002E   4A93         CMP.B   #0x0, R10
   \   000030   1824         JEQ     ??ZDO_ParseSimpleDescBuf_2
   3076            {
   3077              if (!(desc->pAppInClusterList = (uint16 *)osal_mem_alloc(num*sizeof(uint16))))
   \   000032   ........     CALLA   #?Subroutine13
   \                     ??CrossCallReturnLabel_71:
   \   000036   8B4C0800     MOV.W   R12, 0x8(R11)
   \   00003A   0C93         CMP.W   #0x0, R12
   \   00003C   2524         JEQ     ??ZDO_ParseSimpleDescBuf_3
   3078              {
   3079                // malloc failed. we're done.
   3080                return 1;
   3081              }
   3082              for (i=0; i<num; ++i)
   \   00003E   4E43         MOV.B   #0x0, R14
   \   000040   0E3C         JMP     ??ZDO_ParseSimpleDescBuf_4
   3083              {
   3084                desc->pAppInClusterList[i] = BUILD_UINT16( buf[0], buf[1] );
   \                     ??ZDO_ParseSimpleDescBuf_0:
   \   000042   6D48         MOV.B   @R8, R13
   \   000044   5F480100     MOV.B   0x1(R8), R15
   \   000048                RPT     #0x8
   \   000048   47180F5F     RLAX.W  R15
   \   00004C   0D5F         ADD.W   R15, R13
   \   00004E   494E         MOV.B   R14, R9
   \   000050   0959         RLA.W   R9
   \   000052   0F4C         MOV.W   R12, R15
   \   000054   0F59         ADD.W   R9, R15
   \   000056   8F4D0000     MOV.W   R13, 0(R15)
   3085                buf += 2;
   \   00005A   2853         ADD.W   #0x2, R8
   3086              }
   \   00005C   5E53         ADD.B   #0x1, R14
   \                     ??ZDO_ParseSimpleDescBuf_4:
   \   00005E   4E9A         CMP.B   R10, R14
   \   000060   F02B         JNC     ??ZDO_ParseSimpleDescBuf_0
   3087            }
   3088          
   3089            // move in output cluster list (if any). allocate aligned memory.
   3090            num = desc->AppNumOutClusters = *buf++;
   \                     ??ZDO_ParseSimpleDescBuf_2:
   \   000062   7A48         MOV.B   @R8+, R10
   \   000064   CB4A0A00     MOV.B   R10, 0xa(R11)
   3091            if (num)
   \   000068   4A93         CMP.B   #0x0, R10
   \   00006A   2224         JEQ     ??ZDO_ParseSimpleDescBuf_5
   3092            {
   3093              if (!(desc->pAppOutClusterList = (uint16 *)osal_mem_alloc(num*sizeof(uint16))))
   \   00006C   ........     CALLA   #?Subroutine13
   \                     ??CrossCallReturnLabel_70:
   \   000070   8B4C0C00     MOV.W   R12, 0xc(R11)
   \   000074   0C93         CMP.W   #0x0, R12
   \   000076   0A20         JNE     ??ZDO_ParseSimpleDescBuf_6
   3094              {
   3095                // malloc failed. free input cluster list memory if there is any
   3096                if ( desc->pAppInClusterList != NULL )
   \   000078   1C4B0800     MOV.W   0x8(R11), R12
   \   00007C   0C93         CMP.W   #0x0, R12
   \   00007E   0424         JEQ     ??ZDO_ParseSimpleDescBuf_3
   3097                {
   3098                  osal_mem_free(desc->pAppInClusterList);
   \   000080   ........     CALLA   #osal_mem_free
   3099          
   3100                  desc->pAppInClusterList = NULL;
   \   000084   8B430800     MOV.W   #0x0, 0x8(R11)
   3101                }
   3102                return 1;
   \                     ??ZDO_ParseSimpleDescBuf_3:
   \   000088   5C43         MOV.B   #0x1, R12
   \   00008A   133C         JMP     ??ZDO_ParseSimpleDescBuf_7
   3103              }
   3104              for (i=0; i<num; ++i)
   \                     ??ZDO_ParseSimpleDescBuf_6:
   \   00008C   4E43         MOV.B   #0x0, R14
   \   00008E   0E3C         JMP     ??ZDO_ParseSimpleDescBuf_8
   3105              {
   3106                desc->pAppOutClusterList[i] = BUILD_UINT16( buf[0], buf[1] );
   \                     ??ZDO_ParseSimpleDescBuf_1:
   \   000090   6B48         MOV.B   @R8, R11
   \   000092   5F480100     MOV.B   0x1(R8), R15
   \   000096                RPT     #0x8
   \   000096   47180F5F     RLAX.W  R15
   \   00009A   0B5F         ADD.W   R15, R11
   \   00009C   494E         MOV.B   R14, R9
   \   00009E   0959         RLA.W   R9
   \   0000A0   0F4C         MOV.W   R12, R15
   \   0000A2   0F59         ADD.W   R9, R15
   \   0000A4   8F4B0000     MOV.W   R11, 0(R15)
   3107                buf += 2;
   \   0000A8   2853         ADD.W   #0x2, R8
   3108              }
   \   0000AA   5E53         ADD.B   #0x1, R14
   \                     ??ZDO_ParseSimpleDescBuf_8:
   \   0000AC   4E9A         CMP.B   R10, R14
   \   0000AE   F02B         JNC     ??ZDO_ParseSimpleDescBuf_1
   3109            }
   3110            return 0;
   \                     ??ZDO_ParseSimpleDescBuf_5:
   \   0000B0   4C43         MOV.B   #0x0, R12
   \                     ??ZDO_ParseSimpleDescBuf_7:
   \   0000B2   3817         POPM.W  #0x4, R11
   \   0000B4   1001         RETA
   3111          }
   3112          
   3113          /*********************************************************************
   3114           * @fn          ZDO_ParseDeviceAnnce
   3115           *
   3116           * @brief       Parse a Device Announce message.
   3117           *
   3118           * @param       inMsg - Incoming message
   3119           * @param       pAnnce - place to put the parsed information
   3120           *
   3121           * @return      none
   3122           */

   \                                 In  segment CODE, align 2, keep-with-next
   3123          void ZDO_ParseDeviceAnnce( zdoIncomingMsg_t *inMsg, ZDO_DeviceAnnce_t *pAnnce )
   \                     ZDO_ParseDeviceAnnce:
   3124          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4D         MOV.W   R13, R10
   3125            uint8 *msg;
   3126          
   3127            // Parse incoming message
   3128            msg = inMsg->asdu;
   \   000004   ........     CALLA   #?Subroutine3
   3129            pAnnce->nwkAddr = BUILD_UINT16( msg[0], msg[1] );
   \                     ??CrossCallReturnLabel_1:
   \   000008   8D4E0000     MOV.W   R14, 0(R13)
   3130            msg += 2;
   \   00000C   2B53         ADD.W   #0x2, R11
   3131            osal_cpyExtAddr( pAnnce->extAddr, msg );
   \   00000E   0D4B         MOV.W   R11, R13
   \   000010   0C4A         MOV.W   R10, R12
   \   000012   ........     CALLA   #??Subroutine32_0
   3132            msg += Z_EXTADDR_LEN;
   3133            pAnnce->capabilities = *msg;
   \                     ??CrossCallReturnLabel_77:
   \   000016   DA4B08000A00 MOV.B   0x8(R11), 0xa(R10)
   3134          }
   \   00001C   1A17         POPM.W  #0x2, R11
   \   00001E   1001         RETA
   3135          
   3136          /*********************************************************************
   3137           * @fn          ZDO_ParseMgmtNwkUpdateNotify
   3138           *
   3139           * @brief       This function handles parsing of the incoming Management
   3140           *              Network Update notify.
   3141           *
   3142           * @param       inMsg - incoming message (request)
   3143           *
   3144           * @return      a pointer to parsed response structure (NULL if not allocated).
   3145           *          This structure was allocated using osal_mem_alloc, so it must be freed
   3146           *          by the calling function [osal_mem_free()].
   3147           */

   \                                 In  segment CODE, align 2, keep-with-next
   3148          ZDO_MgmtNwkUpdateNotify_t *ZDO_ParseMgmtNwkUpdateNotify( zdoIncomingMsg_t *inMsg )
   \                     ZDO_ParseMgmtNwkUpdateNotify:
   3149          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   2183         SUB.W   #0x2, SP
   3150            uint8 status;
   3151            uint32 scannedChannels = 0;
   \   000004   0A43         MOV.W   #0x0, R10
   \   000006   0B43         MOV.W   #0x0, R11
   3152            uint16 totalTransmissions = 0;
   \   000008   0643         MOV.W   #0x0, R6
   3153            uint16 transmissionFailures = 0;
   \   00000A   0743         MOV.W   #0x0, R7
   3154            uint8 listCount = 0;
   \   00000C   4843         MOV.B   #0x0, R8
   3155            uint8 *msg = inMsg->asdu;
   \   00000E   194C1600     MOV.W   0x16(R12), R9
   3156            ZDO_MgmtNwkUpdateNotify_t *pRsp;
   3157          
   3158            status = *msg++;
   \   000012   F1490000     MOV.B   @R9+, 0(SP)
   3159            if ( status == ZSuccess )
   \   000016   C1930000     CMP.B   #0x0, 0(SP)
   \   00001A   1620         JNE     ??ZDO_ParseMgmtNwkUpdateNotify_0
   3160            {
   3161              scannedChannels = osal_build_uint32( msg, 4 );
   \   00001C   6D42         MOV.B   #0x4, R13
   \   00001E   0C49         MOV.W   R9, R12
   \   000020   ........     CALLA   #osal_build_uint32
   \   000024   0A4C         MOV.W   R12, R10
   \   000026   0B4D         MOV.W   R13, R11
   3162              msg += 4;
   \   000028   2952         ADD.W   #0x4, R9
   3163              totalTransmissions = BUILD_UINT16( msg[0], msg[1] );
   \   00002A   6649         MOV.B   @R9, R6
   \   00002C   5F490100     MOV.B   0x1(R9), R15
   \   000030                RPT     #0x8
   \   000030   47180F5F     RLAX.W  R15
   \   000034   065F         ADD.W   R15, R6
   3164              msg += 2;
   \   000036   2953         ADD.W   #0x2, R9
   3165              transmissionFailures = BUILD_UINT16( msg[0], msg[1] );
   \   000038   6749         MOV.B   @R9, R7
   \   00003A   5F490100     MOV.B   0x1(R9), R15
   \   00003E                RPT     #0x8
   \   00003E   47180F5F     RLAX.W  R15
   \   000042   075F         ADD.W   R15, R7
   3166              msg += 2;
   \   000044   2953         ADD.W   #0x2, R9
   3167              listCount = *msg++;
   \   000046   7849         MOV.B   @R9+, R8
   3168            }
   3169          
   3170            pRsp = (ZDO_MgmtNwkUpdateNotify_t *)osal_mem_alloc( sizeof ( ZDO_MgmtNwkUpdateNotify_t ) + listCount );
   \                     ??ZDO_ParseMgmtNwkUpdateNotify_0:
   \   000048   4448         MOV.B   R8, R4
   \   00004A   0C44         MOV.W   R4, R12
   \   00004C   3C500C00     ADD.W   #0xc, R12
   \   000050   ........     CALLA   #osal_mem_alloc
   \   000054   054C         MOV.W   R12, R5
   3171          
   3172            if ( pRsp )
   \   000056   0C93         CMP.W   #0x0, R12
   \   000058   1424         JEQ     ??ZDO_ParseMgmtNwkUpdateNotify_1
   3173            {
   3174              pRsp->status = status;
   \   00005A   EC410000     MOV.B   @SP, 0(R12)
   3175              pRsp->scannedChannels = scannedChannels;
   \   00005E   8C4A0200     MOV.W   R10, 0x2(R12)
   \   000062   8C4B0400     MOV.W   R11, 0x4(R12)
   3176              pRsp->totalTransmissions = totalTransmissions;
   \   000066   8C460600     MOV.W   R6, 0x6(R12)
   3177              pRsp->transmissionFailures = transmissionFailures;
   \   00006A   8C470800     MOV.W   R7, 0x8(R12)
   3178              pRsp->listCount = listCount;
   \   00006E   CC480A00     MOV.B   R8, 0xa(R12)
   3179          
   3180              // Allocate a buffer big enough to handle the list.
   3181              if ( listCount > 0 )
   \   000072   4893         CMP.B   #0x0, R8
   \   000074   0624         JEQ     ??ZDO_ParseMgmtNwkUpdateNotify_1
   3182              {
   3183                osal_memcpy( pRsp->energyValues, msg, listCount );
   \   000076   0E44         MOV.W   R4, R14
   \   000078   0D49         MOV.W   R9, R13
   \   00007A   3C500B00     ADD.W   #0xb, R12
   \   00007E   ........     CALLA   #osal_memcpy
   3184              }
   3185            }
   3186          
   3187            return ( pRsp );
   \                     ??ZDO_ParseMgmtNwkUpdateNotify_1:
   \   000082   0C45         MOV.W   R5, R12
   \   000084                REQUIRE ?Subroutine1
   \   000084                // Fall through to label ?Subroutine1
   3188          }
   3189          
   3190          /*********************************************************************
   3191           * @fn          ZDO_ParseMgmtNwkUpdateReq
   3192           *
   3193           * @brief       This function handles parsing the incoming Management
   3194           *              Network Update request and starts the request (if needed).
   3195           *
   3196           * @param       inMsg - incoming message (request)
   3197           * @param       pReq - pointer to place to parse message to
   3198           *
   3199           * @return      none
   3200           */

   \                                 In  segment CODE, align 2
   3201          void ZDO_ParseMgmtNwkUpdateReq( zdoIncomingMsg_t *inMsg, ZDO_MgmtNwkUpdateReq_t *pReq )
   \                     ZDO_ParseMgmtNwkUpdateReq:
   3202          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4D         MOV.W   R13, R10
   3203            uint8 *msg = inMsg->asdu;
   \   000004   ........     CALLA   #?Subroutine4
   3204          
   3205            pReq->channelMask = osal_build_uint32( msg, 4 );
   \                     ??CrossCallReturnLabel_3:
   \   000008   8A4C0000     MOV.W   R12, 0(R10)
   \   00000C   8A4D0200     MOV.W   R13, 0x2(R10)
   3206            msg += 4;
   \   000010   2B52         ADD.W   #0x4, R11
   3207            pReq->scanDuration = *msg++;
   \   000012   FA4B0400     MOV.B   @R11+, 0x4(R10)
   3208          
   3209            if ( pReq->scanDuration <= 0x05 )
   \   000016   5E4A0400     MOV.B   0x4(R10), R14
   \   00001A   7E900600     CMP.B   #0x6, R14
   \   00001E   032C         JC      ??ZDO_ParseMgmtNwkUpdateReq_0
   3210            {
   3211              // Request is to scan over channelMask
   3212              pReq->scanCount = *msg;
   \   000020   EA4B0500     MOV.B   @R11, 0x5(R10)
   \   000024   0E3C         JMP     ??ZDO_ParseMgmtNwkUpdateReq_1
   3213            }
   3214            else if ( ( pReq->scanDuration == 0xFE ) || ( pReq->scanDuration == 0xFF ) )
   \                     ??ZDO_ParseMgmtNwkUpdateReq_0:
   \   000026   7E90FE00     CMP.B   #0xfe, R14
   \   00002A   0224         JEQ     ??ZDO_ParseMgmtNwkUpdateReq_2
   \   00002C   7E93         CMP.B   #0xff, R14
   \   00002E   0920         JNE     ??ZDO_ParseMgmtNwkUpdateReq_1
   3215            {
   3216              // Request is to change Channel (0xFE) or apsChannelMask and NwkManagerAddr (0xFF)
   3217              pReq->nwkUpdateId = *msg++;
   \                     ??ZDO_ParseMgmtNwkUpdateReq_2:
   \   000030   FA4B0600     MOV.B   @R11+, 0x6(R10)
   3218          
   3219              if ( pReq->scanDuration == 0xFF )
   \   000034   FA930400     CMP.B   #0xff, 0x4(R10)
   \   000038   0420         JNE     ??ZDO_ParseMgmtNwkUpdateReq_1
   3220              {
   3221                pReq->nwkManagerAddr = BUILD_UINT16( msg[0], msg[1] );
   \   00003A   ........     CALLA   #?Subroutine27
   3222              }
   3223            }
   \                     ??CrossCallReturnLabel_55:
   \   00003E   8A4E0800     MOV.W   R14, 0x8(R10)
   3224          }
   \                     ??ZDO_ParseMgmtNwkUpdateReq_1:
   \   000042   1A17         POPM.W  #0x2, R11
   \   000044   1001         RETA

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "StartDevice ERR">`:
   \   000000   537461727444 DC8 "StartDevice ERR"
   \            657669636520
   \            45525200    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "MODE unknown">`:
   \   000000   4D4F44452075 DC8 "MODE unknown"
   \            6E6B6E6F776E
   \            00          

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "End Device Bind">`:
   \   000000   456E64204465 DC8 "End Device Bind"
   \            766963652042
   \            696E6400    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Success Sent">`:
   \   000000   537563636573 DC8 "Success Sent"
   \            732053656E74
   \            00          

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Timeout">`:
   \   000000   54696D656F75 DC8 "Timeout"
   \            7400        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Match Desc Req">`:
   \   000000   4D6174636820 DC8 "Match Desc Req"
   \            446573632052
   \            657100      

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Rsp Sent">`:
   \   000000   527370205365 DC8 "Rsp Sent"
   \            6E7400      

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Rsp Non Matched">`:
   \   000000   527370204E6F DC8 "Rsp Non Matched"
   \            6E204D617463
   \            68656400    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Non Matched">`:
   \   000000   4E6F6E204D61 DC8 "Non Matched"
   \            746368656400
   3225          
   3226          /*********************************************************************
   3227          *********************************************************************/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   NLME_PermitJoiningTimeout
     50   ZDMatchSendState
       42   -> APS_SetEndDeviceBindTimeout
       50   -> APS_SetEndDeviceBindTimeout
       42   -> ZDO_RemoveMatchMemory
       50   -> ZDP_BindUnbindReq
       46   -> ZDP_SendData
       42   -> sAddrExtCpy
     16   ZDO_AnyClusterMatches
      6   ZDO_BuildSimpleDescBuf
     20   ZDO_CompareClusterLists
     12   ZDO_ConvertOTAClusters
     12   ZDO_CopyMatchInfo
       12   -> osal_mem_alloc
       12   -> osal_mem_free
       12   -> osal_memcpy
      4   ZDO_EndDeviceBindMatchTimeoutCB
        4   -> ZDMatchSendState
     10   ZDO_EndDeviceTimeoutCB
       10   -> HalLcdWriteString
        6   -> HalLcdWriteString
       10   -> ZDP_SendData
        6   -> osal_mem_free
      4   ZDO_Init
        4   -> APS_ReflectorInit
        4   -> NLME_DeviceJoiningInit
        4   -> sAddrExtCpy
     32   ZDO_MatchEndDeviceBind
       28   -> APS_SetEndDeviceBindTimeout
       28   -> ZDMatchSendState
       30   -> ZDO_CompareClusterLists
       28   -> ZDO_CopyMatchInfo
       28   -> ZDO_RemoveMatchMemory
       32   -> ZDP_SendData
       28   -> osal_mem_alloc
       28   -> osal_memcpy
       28   -> osal_memset
     12   ZDO_ParseAddrRsp
       12   -> osal_mem_alloc
       12   -> sAddrExtCpy
      8   ZDO_ParseBindUnbindReq
        8   -> sAddrExtCpy
      8   ZDO_ParseDeviceAnnce
        8   -> sAddrExtCpy
     16   ZDO_ParseEPListRsp
       16   -> osal_mem_alloc
       16   -> osal_memcpy
      8   ZDO_ParseEndDeviceBindReq
        8   -> ZDO_ConvertOTAClusters
        8   -> osal_mem_alloc
        8   -> sAddrExtCpy
     16   ZDO_ParseMgmNwkDiscRsp
       16   -> osal_mem_alloc
       16   -> sAddrExtCpy
     20   ZDO_ParseMgmtBindRsp
       20   -> osal_mem_alloc
       20   -> sAddrExtCpy
     20   ZDO_ParseMgmtLqiRsp
       20   -> osal_mem_alloc
       20   -> sAddrExtCpy
     22   ZDO_ParseMgmtNwkUpdateNotify
       22   -> osal_build_uint32
       22   -> osal_mem_alloc
       22   -> osal_memcpy
      8   ZDO_ParseMgmtNwkUpdateReq
        8   -> osal_build_uint32
     16   ZDO_ParseMgmtRtgRsp
       16   -> osal_mem_alloc
      6   ZDO_ParseNodeDescRsp
      6   ZDO_ParsePowerDescRsp
      4   ZDO_ParseServerDiscRsp
     12   ZDO_ParseSimpleDescBuf
       12   -> osal_mem_alloc
       12   -> osal_mem_free
      4   ZDO_ParseSimpleDescRsp
        4   -> ZDO_ParseSimpleDescBuf
     12   ZDO_ParseUserDescRsp
       12   -> osal_mem_alloc
       12   -> osal_memcpy
     20   ZDO_ProcessActiveEPReq
       12   -> NLME_GetShortAddr
       20   -> ZDP_EPRsp
       12   -> afEndPoints
       12   -> afNumEndPoints
     30   ZDO_ProcessBindUnbindReq
       26   -> APSME_BindRequest
       26   -> APSME_LookupNwkAddr
       26   -> APSME_UnBindRequest
       26   -> NLME_GetExtAddr
       26   -> ZDApp_NVUpdate
       26   -> ZDP_NwkAddrReq
       30   -> ZDP_SendData
       26   -> sAddrExtCmp
       26   -> sAddrExtCpy
     46   ZDO_ProcessDeviceAnnce
       46   -> AddrMgrEntryLookupExt
       46   -> AddrMgrEntryLookupNwk
       46   -> AddrMgrEntryUpdate
       46   -> AddrMgrExtAddrSet
       46   -> AssocChangeNwkAddr
       46   -> AssocGetWithExt
       46   -> AssocRemove
       46   -> NLME_CheckNewAddrSet
       46   -> NLME_GetCoordExtAddr
       46   -> NLME_GetCoordShortAddr
       46   -> NLME_GetShortAddr
       46   -> RTG_RemoveRtgEntry
       46   -> ZDApp_NVUpdate
       46   -> ZDO_ParseDeviceAnnce
       46   -> ZMacSetReq
       46   -> nwkNeighborRemoveAllStranded
       46   -> nwkNeighborUpdateNwkAddr
       46   -> osal_memset
       46   -> sAddrExtCmp
     34   ZDO_ProcessMatchDescReq
       26   -- Indirect call
       26   -> HalLcdWriteScreen
       34   -> HalLcdWriteScreen
       26   -> NLME_IsAddressBroadcast
       26   -> ZDO_AnyClusterMatches
       26   -> ZDO_ConvertOTAClusters
       34   -> ZDP_EPRsp
       26   -> osal_mem_alloc
       26   -> osal_mem_free
       26   -> osal_memcpy
       26   -> osal_msg_allocate
       26   -> osal_msg_send
     30   ZDO_ProcessMgmtBindReq
       22   -> APSME_GetRequest
       30   -> ZDP_MgmtBindRsp
       22   -> osal_mem_alloc
       22   -> osal_mem_free
     12   ZDO_ProcessMgmtDirectJoinReq
        8   -> NLME_DirectJoinRequest
       12   -> ZDP_SendData
     20   ZDO_ProcessMgmtLeaveReq
       16   -> AddrMgrExtAddrValid
       16   -> NLME_GetExtAddr
       16   -> NLME_LeaveReq
       20   -> ZDP_SendData
       16   -> sAddrExtCmp
     70   ZDO_ProcessMgmtLqiReq
       62   -> AddrMgrEntryLookupNwk
       62   -> AssocCount
       62   -> AssocFindDevice
       62   -> NLME_GetRequest
       70   -> ZDP_MgmtLqiRsp
       62   -> osal_mem_alloc
       62   -> osal_mem_free
       62   -> osal_memset
       62   -> sAddrExtCpy
     16   ZDO_ProcessMgmtNwkDiscReq
       16   -> NLME_NwkDiscReq2
       16   -> NLME_NwkDiscTerm
       16   -> osal_build_uint32
     12   ZDO_ProcessMgmtPermitJoinReq
        8   -> NLME_PermitJoiningRequest
       12   -> ZDP_SendData
     26   ZDO_ProcessMgmtRtgReq
       18   -> NLME_GetRequest
       26   -> ZDP_MgmtRtgRsp
       18   -> osal_mem_alloc
       18   -> osal_mem_free
      8   ZDO_ProcessNodeDescReq
        8   -> ZDP_GenericRsp
        4   -> ZDP_NodeDescMsg
      8   ZDO_ProcessPowerDescReq
        8   -> ZDP_GenericRsp
        4   -> ZDP_PowerDescMsg
      8   ZDO_ProcessServerDiscReq
        8   -> ZDP_ServerDiscRsp
     14   ZDO_ProcessSimpleDescReq
       14   -> ZDP_SimpleDescMsg
       14   -> afFindSimpleDesc
       14   -> osal_mem_free
     30   ZDO_ProcessUserDescReq
       30   -> ZDP_GenericRsp
       28   -> ZDP_UserDescRsp
       26   -> osal_nv_read
     32   ZDO_ProcessUserDescSet
       32   -> ZDP_SendData
       28   -> osal_memcpy
       28   -> osal_nv_write
      6   ZDO_RemoveMatchMemory
        6   -> osal_mem_free
     18   ZDO_StartDevice
       18   -> HalLcdWriteScreen
       18   -> NLME_NetworkDiscoveryRequest
       18   -> NLME_OrphanJoinRequest
       18   -> nwk_ScanJoiningOrphan
       18   -> osal_start_timerEx
     18   ZDO_UpdateAddrManager
       18   -> AddrMgrEntryUpdate
       18   -> AddrMgrExtAddrSet
      8   ZDO_UpdateNwkStatus
        8   -> NLME_GetExtAddr
        8   -> NLME_GetShortAddr
        8   -> zdoSendStateChangeMsg
      8   zdoSendStateChangeMsg
        8   -> osal_msg_allocate
        8   -> osal_msg_find
        8   -> osal_msg_send
        8   -> osal_set_event


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "End Device Bind">
      13  ?<Constant "MODE unknown">
      15  ?<Constant "Match Desc Req">
      12  ?<Constant "Non Matched">
      16  ?<Constant "Rsp Non Matched">
       9  ?<Constant "Rsp Sent">
      16  ?<Constant "StartDevice ERR">
      13  ?<Constant "Success Sent">
       8  ?<Constant "Timeout">
       6  ??Subroutine13_0
       8  ??Subroutine27_1
       6  ??Subroutine31_0
       6  ??Subroutine32_0
      16  ??Subroutine33_0
      22  ?Subroutine0
       6  ?Subroutine1
      14  ?Subroutine10
      10  ?Subroutine11
      10  ?Subroutine12
       2  ?Subroutine13
      10  ?Subroutine14
       8  ?Subroutine15
       6  ?Subroutine16
       2  ?Subroutine17
      18  ?Subroutine18
      14  ?Subroutine19
       6  ?Subroutine2
      16  ?Subroutine20
      14  ?Subroutine21
      14  ?Subroutine22
      20  ?Subroutine23
      14  ?Subroutine24
       8  ?Subroutine25
      14  ?Subroutine26
       6  ?Subroutine27
      10  ?Subroutine28
       4  ?Subroutine3
      12  ?Subroutine4
      18  ?Subroutine5
      12  ?Subroutine6
      10  ?Subroutine7
      28  ?Subroutine9
       2  NLME_PermitJoiningTimeout
     430  ZDMatchSendState
      52  ZDOBuildBuf
      52  ZDO_AnyClusterMatches
     110  ZDO_BuildSimpleDescBuf
      76  ZDO_CompareClusterLists
      44  ZDO_ConvertOTAClusters
     126  ZDO_CopyMatchInfo
       2  ZDO_EDBind
      12  ZDO_EndDeviceBindMatchTimeoutCB
     126  ZDO_EndDeviceTimeoutCB
      36  ZDO_Init
     378  ZDO_MatchEndDeviceBind
     114  ZDO_ParseAddrRsp
      76  ZDO_ParseBindUnbindReq
      32  ZDO_ParseDeviceAnnce
      48  ZDO_ParseEPListRsp
     154  ZDO_ParseEndDeviceBindReq
     146  ZDO_ParseMgmNwkDiscRsp
     154  ZDO_ParseMgmtBindRsp
     112  ZDO_ParseMgmtLqiRsp
     132  ZDO_ParseMgmtNwkUpdateNotify
      70  ZDO_ParseMgmtNwkUpdateReq
      98  ZDO_ParseMgmtRtgRsp
     164  ZDO_ParseNodeDescRsp
      76  ZDO_ParsePowerDescRsp
      30  ZDO_ParseServerDiscRsp
     182  ZDO_ParseSimpleDescBuf
      18  ZDO_ParseSimpleDescRsp
      58  ZDO_ParseUserDescRsp
      88  ZDO_ProcessActiveEPReq
     254  ZDO_ProcessBindUnbindReq
     258  ZDO_ProcessDeviceAnnce
     554  ZDO_ProcessMatchDescReq
     152  ZDO_ProcessMgmtBindReq
      48  ZDO_ProcessMgmtDirectJoinReq
     110  ZDO_ProcessMgmtLeaveReq
     446  ZDO_ProcessMgmtLqiReq
      80  ZDO_ProcessMgmtNwkDiscReq
      52  ZDO_ProcessMgmtPermitJoinReq
     174  ZDO_ProcessMgmtRtgReq
      24  ZDO_ProcessNodeDescReq
      22  ZDO_ProcessPowerDescReq
      48  ZDO_ProcessServerDiscReq
     112  ZDO_ProcessSimpleDescReq
     108  ZDO_ProcessUserDescReq
     160  ZDO_ProcessUserDescSet
      76  ZDO_RemoveMatchMemory
     198  ZDO_StartDevice
      34  ZDO_UpdateAddrManager
      54  ZDO_UpdateNwkStatus
       4  apsChannelMask
       1  discRetries
       2  matchED
       1  scanCnt
      72  zdoSendStateChangeMsg

 
 6 550 bytes in segment CODE
   118 bytes in segment DATA16_C
    62 bytes in segment DATA16_Z
 
 6 550 bytes of CODE  memory
   118 bytes of CONST memory
    62 bytes of DATA  memory

Errors: none
Warnings: none

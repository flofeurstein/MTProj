###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       10/Jun/2013  16:24:36 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\ma #
#                     c\low_level\srf04\mac_tx.c                              #
#    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleLight\CC2520DB\..\..\..\Too #
#                     ls\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0       #
#                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                       #
#                     -DDEFAULT_CHANLIST=0x00000800                           #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100      #
#                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                   #
#                     -DBEACON_REQUEST_DELAY=100                              #
#                     -DBEACON_REQ_DELAY_MASK=0x00FF                          #
#                     -DLINK_STATUS_JITTER_MASK=0x007F                        #
#                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED= #
#                     3000 -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8  #
#                     -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2     #
#                     -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9              #
#                     -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40                #
#                     -DNWK_MAX_BINDING_ENTRIES=4                             #
#                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,       #
#                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,   #
#                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                    #
#                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=2 #
#                     0 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000           #
#                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100         #
#                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\f8 #
#                     wCoord.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE=TRUE #
#                      -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8             #
#                     -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK) -f      #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\..\..\..\Tools\ #
#                     MSP2618\f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE             #
#                     -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF                 #
#                     -DZCL_KEY_ESTABLISH -DZCL_KEY_ESTABLISHMENT_KEY_GENERAT #
#                     E_TIMEOUT=4 -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOU #
#                     T=10 -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10   #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)                #
#                     -DZCL_DEVICE_MGMT "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_lev #
#                     el\srf04\mac_tx.c" -D MSP430F2618 -D ZTOOL_P1 -D        #
#                     MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED  #
#                     -lC "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects #
#                     \zstack\HomeAutomation\SampleLight\CC2520DB\Coordinator #
#                     \List\" -lA "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ #
#                     Projects\zstack\HomeAutomation\SampleLight\CC2520DB\Coo #
#                     rdinator\List\" --remarks --diag_suppress               #
#                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\Coordinator\Obj\"         #
#                     --debug -D__MSP430F2618__ -e --double=32 --clib -I      #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\" -I "C:\Texas  #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\Source\" -I "C:\Texas  #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\Source\" -I         #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\..\..\..\ZMain\ #
#                     MSP2618\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1 #
#                     \Projects\zstack\HomeAutomation\SampleLight\CC2520DB\.. #
#                     \..\..\..\..\Components\hal\include\" -I "C:\Texas      #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \hal\target\MSP2618CC2520\" -I "C:\Texas                #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\include\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\high_level\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\low_level\srf04\" -I "C:\Texas                     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\low_level\srf04\dual_chip\" -I "C:\Texas           #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pro #
#                     jects\zstack\HomeAutomation\SampleLight\CC2520DB\..\..\ #
#                     ..\..\..\Components\osal\include\" -I "C:\Texas         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \osal\mcu\msp430\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \services\saddr\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \services\sdata\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\af\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5 #
#                     .1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB\ #
#                     ..\..\..\..\..\Components\stack\nwk\" -I "C:\Texas      #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\sec\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\stack\sapi\" -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\sys\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\stack\zcl\" -I "C:\Texas     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\zdo\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\zmac\" -I "C:\Texas          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \zmac\f8w\" --core=430X --data_model=small -Ohz         #
#                     --multiplier=16s --require_prototypes                   #
#    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleLight\CC2520DB\Coordinator\List #
#                     \mac_tx.lst                                             #
#    Object file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleLight\CC2520DB\Coordinator\Obj\ #
#                     mac_tx.r43                                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_level\srf04\mac_tx.c
      1          /**************************************************************************************************
      2            Filename:       mac_tx.c
      3            Revised:        $Date: 2007-10-15 14:56:36 -0700 (Mon, 15 Oct 2007) $
      4            Revision:       $Revision: 15687 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_types.h"
     47          #include "hal_defs.h"
     48          #include "hal_mcu.h"
     49          #include "hal_mac_cfg.h"
     50          
     51          /* high-level */
     52          #include "mac_spec.h"
     53          #include "mac_pib.h"
     54          
     55          /* exported low-level */
     56          #include "mac_low_level.h"
     57          
     58          /* low-level specific */
     59          #include "mac_tx.h"
     60          #include "mac_backoff_timer.h"
     61          #include "mac_rx.h"
     62          #include "mac_rx_onoff.h"
     63          #include "mac_radio.h"
     64          #include "mac_sleep.h"
     65          
     66          /* target specific */
     67          #include "mac_radio_defs.h"
     68          
     69          /* debug */
     70          #include "mac_assert.h"
     71          
     72          
     73          /* ------------------------------------------------------------------------------------------------
     74           *                                            Defines
     75           * ------------------------------------------------------------------------------------------------
     76           */
     77          #define MFR_LEN                   MAC_FCS_FIELD_LEN
     78          #define PREPENDED_BYTE_LEN        1
     79          
     80          
     81          /* ------------------------------------------------------------------------------------------------
     82           *                                         Global Constants
     83           * ------------------------------------------------------------------------------------------------
     84           */
     85          
     86          /*
     87           *  This is the time, in backoffs, required to set up a slotted transmit.
     88           *  It is exported to high level so that code can schedule enough time
     89           *  for slotted transmits.
     90           *
     91           *  A default is provided if a value is not specified.  If the default
     92           *  is not appropriate, a #define should be added within hal_mac_cfg.h.
     93           */
     94          #ifndef HAL_MAC_TX_SLOTTED_DELAY
     95          #define HAL_MAC_TX_SLOTTED_DELAY    3
     96          #endif

   \                                 In  segment DATA16_C, align 1, align-sorted
     97          uint8 const macTxSlottedDelay = HAL_MAC_TX_SLOTTED_DELAY;
   \                     macTxSlottedDelay:
   \   000000   03           DC8 3
     98          
     99          
    100          /* ------------------------------------------------------------------------------------------------
    101           *                                         Global Variables
    102           * ------------------------------------------------------------------------------------------------
    103           */

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    104          uint8 macTxActive;
   \                     macTxActive:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    105          uint8 macTxType;
   \                     macTxType:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    106          uint8 macTxBe;
   \                     macTxBe:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    107          uint8 macTxCsmaBackoffDelay;
   \                     macTxCsmaBackoffDelay:
   \   000000                DS8 1
    108          
    109          
    110          /* ------------------------------------------------------------------------------------------------
    111           *                                         Local Variables
    112           * ------------------------------------------------------------------------------------------------
    113           */

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    114          static uint8 nb;
   \                     nb:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    115          static uint8 txSeqn;
   \                     txSeqn:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    116          static uint8 txAckReq;
   \                     txAckReq:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    117          static uint8 txRetransmitFlag;
   \                     txRetransmitFlag:
   \   000000                DS8 1
    118          
    119          
    120          /* ------------------------------------------------------------------------------------------------
    121           *                                         Local Prototypes
    122           * ------------------------------------------------------------------------------------------------
    123           */
    124          static void txCsmaPrep(void);
    125          static void txGo(void);
    126          static void txCsmaGo(void);
    127          static void txComplete(uint8 status);
    128          
    129          
    130          /**************************************************************************************************
    131           * @fn          macTxInit
    132           *
    133           * @brief       Initialize variables for tx module.
    134           *
    135           * @param       none
    136           *
    137           * @return      none
    138           **************************************************************************************************
    139           */

   \                                 In  segment CODE, align 2
    140          MAC_INTERNAL_API void macTxInit(void)
   \                     macTxInit:
    141          {
    142            macTxActive      = MAC_TX_ACTIVE_NO_ACTIVITY;
   \   000000   C243....     MOV.B   #0x0, &macTxActive
    143            txRetransmitFlag = 0;
   \   000004   C243....     MOV.B   #0x0, &txRetransmitFlag
    144          }
   \   000008   1001         RETA
    145          
    146          
    147          /**************************************************************************************************
    148           * @fn          macTxHaltCleanup
    149           *
    150           * @brief       -
    151           *
    152           * @param       none
    153           *
    154           * @return      none
    155           **************************************************************************************************
    156           */

   \                                 In  segment CODE, align 2
    157          MAC_INTERNAL_API void macTxHaltCleanup(void)
   \                     macTxHaltCleanup:
    158          {
    159            MAC_RADIO_TX_RESET();
   \   000000   ........     CALLA   #macDualchipTxReset
    160            macTxInit();
   \   000004   ........     BRA     #macTxInit
    161          }
    162          
    163          
    164          /**************************************************************************************************
    165           * @fn          macTxFrame
    166           *
    167           * @brief       Transmit the frame pointed to by pMacDataTx with the specified type.
    168           *              NOTE! It is not legal to call this function from interrupt context.
    169           *
    170           * @param       txType - type of transmit
    171           *
    172           * @return      none
    173           **************************************************************************************************
    174           */

   \                                 In  segment CODE, align 2
    175          MAC_INTERNAL_API void macTxFrame(uint8 txType)
   \                     macTxFrame:
    176          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   4A4C         MOV.B   R12, R10
    177            MAC_ASSERT(!macTxActive);            /* transmit on top of transmit */
   \   000004   C293....     CMP.B   #0x0, &macTxActive
   \   000008   0224         JEQ     ??macTxFrame_1
   \   00000A   ........     CALLA   #halAssertHandler
    178          
    179            /* mark transmit as active */
    180            macTxActive = MAC_TX_ACTIVE_INITIALIZE;
   \                     ??macTxFrame_1:
   \   00000E   D243....     MOV.B   #0x1, &macTxActive
    181          
    182            /*
    183             *  The MAC will not enter sleep mode if there is an active transmit.  However, if macSleep() is
    184             *  ever called from interrupt context, it possible to enter sleep state after a transmit is
    185             *  intiated but before macTxActive is set.  To recover from this, the transmit must be aborted
    186             *  and proper notificiation given to high-level.
    187             */
    188            if (macSleepState != MAC_SLEEP_STATE_AWAKE)
   \   000012   C293....     CMP.B   #0x0, &macSleepState
   \   000016   0524         JEQ     ??macTxFrame_2
    189            {
    190              /* notify high-level that transmit had to be aborted */
    191              txComplete(MAC_TX_ABORTED);
   \   000018   7C401D00     MOV.B   #0x1d, R12
   \   00001C   ........     CALLA   #txComplete
    192          
    193              /* exit from transmit logic */
    194              return;
   \   000020   633C         JMP     ??macTxFrame_0
    195            }
    196          
    197            /* save transmit type */
    198            macTxType = txType;
   \                     ??macTxFrame_2:
   \   000022   C24A....     MOV.B   R10, &macTxType
    199          
    200            /*-------------------------------------------------------------------------------
    201             *  Prepare for transmit.
    202             */
    203            if (macTxType == MAC_TX_TYPE_SLOTTED)
   \   000026   6A93         CMP.B   #0x2, R10
   \   000028   0320         JNE     ??macTxFrame_3
    204            {
    205              MAC_RADIO_TX_PREP_SLOTTED();
   \   00002A   ........     CALLA   #macDualchipTxPrepSlotted
   \   00002E   213C         JMP     ??macTxFrame_4
    206            }
    207            else
    208            {
    209              MAC_ASSERT((macTxType == MAC_TX_TYPE_SLOTTED_CSMA) || (macTxType == MAC_TX_TYPE_UNSLOTTED_CSMA));
   \                     ??macTxFrame_3:
   \   000030   4A93         CMP.B   #0x0, R10
   \   000032   0424         JEQ     ??macTxFrame_5
   \   000034   5A93         CMP.B   #0x1, R10
   \   000036   0224         JEQ     ??macTxFrame_5
   \   000038   ........     CALLA   #halAssertHandler
    210          
    211              nb = 0;
   \                     ??macTxFrame_5:
   \   00003C   C243....     MOV.B   #0x0, &nb
    212              macTxBe = (pMacDataTx->internal.txOptions & MAC_TXOPTION_ALT_BE) ? macPib.altBe : macPib.minBe;
   \   000040   1F42....     MOV.W   &pMacDataTx, R15
   \   000044   FFB040000F00 BIT.B   #0x40, 0xf(R15)
   \   00004A   0328         JNC     ??macTxFrame_6
   \   00004C   5E42....     MOV.B   &macPib + 64, R14
   \   000050   023C         JMP     ??macTxFrame_7
   \                     ??macTxFrame_6:
   \   000052   5E42....     MOV.B   &macPib + 31, R14
    213          
    214              if ((macTxType == MAC_TX_TYPE_SLOTTED_CSMA) && (macPib.battLifeExt))
   \                     ??macTxFrame_7:
   \   000056   C293....     CMP.B   #0x0, &macTxType
   \   00005A   0720         JNE     ??macTxFrame_8
   \   00005C   C293....     CMP.B   #0x0, &macPib + 3
   \   000060   0424         JEQ     ??macTxFrame_8
    215              {
    216                macTxBe = MIN(2, macTxBe);
   \   000062   7E900300     CMP.B   #0x3, R14
   \   000066   0128         JNC     ??macTxFrame_8
   \   000068   6E43         MOV.B   #0x2, R14
   \                     ??macTxFrame_8:
   \   00006A   C24E....     MOV.B   R14, &macTxBe
    217              }
    218          
    219              txCsmaPrep();
   \   00006E   ........     CALLA   #txCsmaPrep
    220            }
    221          
    222            /*-------------------------------------------------------------------------------
    223             *  Load transmit FIFO unless this is a retransmit.  No need to write
    224             *  the FIFO again in that case.
    225             */
    226            if (!txRetransmitFlag)
   \                     ??macTxFrame_4:
   \   000072   C293....     CMP.B   #0x0, &txRetransmitFlag
   \   000076   2520         JNE     ??macTxFrame_9
    227            {
    228              uint8 * p;
    229              uint8   lenMhrMsdu;
    230          
    231              MAC_ASSERT(pMacDataTx != NULL); /* must have data to transmit */
   \   000078   8293....     CMP.W   #0x0, &pMacDataTx
   \   00007C   0220         JNE     ??macTxFrame_10
   \   00007E   ........     CALLA   #halAssertHandler
    232          
    233              /* save needed parameters */
    234              txAckReq = MAC_ACK_REQUEST(pMacDataTx->msdu.p);
   \                     ??macTxFrame_10:
   \   000082   1F42....     MOV.W   &pMacDataTx, R15
   \   000086   1B4F0200     MOV.W   0x2(R15), R11
   \   00008A   6E4B         MOV.B   @R11, R14
   \   00008C   7EF02000     AND.B   #0x20, R14
   \   000090   C24E....     MOV.B   R14, &txAckReq
    235              txSeqn   = MAC_SEQ_NUMBER(pMacDataTx->msdu.p);
   \   000094   1B4F0200     MOV.W   0x2(R15), R11
   \   000098   D24B0200.... MOV.B   0x2(R11), &txSeqn
    236          
    237              /* set length of frame (note: use of term msdu is a misnomer, here it's actually mhr + msdu) */
    238              lenMhrMsdu = pMacDataTx->msdu.len;
   \   00009E   5A4F0400     MOV.B   0x4(R15), R10
    239          
    240              /* calling code guarantees an unused prepended byte  */
    241              p = pMacDataTx->msdu.p - PREPENDED_BYTE_LEN;
   \   0000A2   1B4F0200     MOV.W   0x2(R15), R11
   \   0000A6   3B53         ADD.W   #0xffff, R11
    242          
    243              /* first byte of buffer is length of MPDU */
    244              *p = lenMhrMsdu + MFR_LEN;
   \   0000A8   4E4A         MOV.B   R10, R14
   \   0000AA   6E53         ADD.B   #0x2, R14
   \   0000AC   CB4E0000     MOV.B   R14, 0(R11)
    245          
    246              /*
    247               *  Flush the TX FIFO.  This is necessary in case the previous transmit was never
    248               *  actually sent (e.g. CSMA failed without strobing TXON).  If bytes are written to
    249               *  the FIFO but not transmitted, they remain in the FIFO to be transmitted whenever
    250               *  a strobe of TXON does happen.
    251               */
    252              MAC_RADIO_FLUSH_TX_FIFO();
   \   0000B0   7C404800     MOV.B   #0x48, R12
   \   0000B4   ........     CALLA   #macSpiCmdStrobe
    253          
    254              /* write bytes to FIFO, prepended byte is included, MFR is not (it's generated by hardware) */
    255              MAC_RADIO_WRITE_TX_FIFO(p, PREPENDED_BYTE_LEN + lenMhrMsdu);
   \   0000B8   5A53         ADD.B   #0x1, R10
   \   0000BA   4D4A         MOV.B   R10, R13
   \   0000BC   0C4B         MOV.W   R11, R12
   \   0000BE   ........     CALLA   #macSpiWriteTxFifo
    256            }
    257          
    258            /*-------------------------------------------------------------------------------
    259             *  If not receiving, start the transmit.  If receive is active
    260             *  queue up the transmit.
    261             *
    262             *  Critical sections around the state change prevents any sort of race condition
    263             *  with  macTxStartQueuedFrame().  This guarantees function txGo() will only be
    264             *  called once.
    265             */
    266            {
    267              halIntState_t  s;
    268          
    269              HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macTxFrame_9:
   \   0000C2   0F42         MOV.W   SR, R15
   \   0000C4   32C2         dint
   \   0000C6   0343         nop
    270              if (!macRxActive && !macRxOutgoingAckFlag)
   \   0000C8   C293....     CMP.B   #0x0, &macRxActive
   \   0000CC   0A20         JNE     ??macTxFrame_11
   \   0000CE   C293....     CMP.B   #0x0, &macRxOutgoingAckFlag
   \   0000D2   0720         JNE     ??macTxFrame_11
    271              {
    272                macTxActive = MAC_TX_ACTIVE_GO;
   \   0000D4   F2408300.... MOV.B   #0x83, &macTxActive
    273                HAL_EXIT_CRITICAL_SECTION(s);
   \   0000DA   024F         MOV.W   R15, SR
    274                txGo();
   \   0000DC   ........     CALLA   #txGo
   \   0000E0   033C         JMP     ??macTxFrame_0
    275              }
    276              else
    277              {
    278                macTxActive = MAC_TX_ACTIVE_QUEUED;
   \                     ??macTxFrame_11:
   \   0000E2   E243....     MOV.B   #0x2, &macTxActive
    279                HAL_EXIT_CRITICAL_SECTION(s);
   \   0000E6   024F         MOV.W   R15, SR
    280              }
    281            }
    282          }
   \                     ??macTxFrame_0:
   \   0000E8   1A17         POPM.W  #0x2, R11
   \   0000EA   1001         RETA
    283          
    284          
    285          /*=================================================================================================
    286           * @fn          txCsmaPrep
    287           *
    288           * @brief       Prepare/initialize for a CSMA transmit.
    289           *
    290           * @param       none
    291           *
    292           * @return      none
    293           *=================================================================================================
    294           */

   \                                 In  segment CODE, align 2
    295          static void txCsmaPrep(void)
   \                     txCsmaPrep:
    296          {
    297            macTxCsmaBackoffDelay = macRadioRandomByte() & ((1 << macTxBe) - 1);
   \   000000   ........     CALLA   #macRadioRandomByte
   \   000004   1E43         MOV.W   #0x1, R14
   \   000006   5F42....     MOV.B   &macTxBe, R15
   \   00000A   5F83         SUB.B   #0x1, R15
   \   00000C   0230         JN      ??txCsmaPrep_0
   \   00000E                RPT     R15
   \   00000E   CF180E5E     RLAX.W  R14
   \                     ??txCsmaPrep_0:
   \   000012   7E53         ADD.B   #0xff, R14
   \   000014   4CFE         AND.B   R14, R12
   \   000016   C24C....     MOV.B   R12, &macTxCsmaBackoffDelay
    298          
    299            if (macTxType == MAC_TX_TYPE_SLOTTED_CSMA)
   \   00001A   C293....     CMP.B   #0x0, &macTxType
   \   00001E   0220         JNE     ??txCsmaPrep_1
    300            {
    301              MAC_RADIO_TX_PREP_CSMA_SLOTTED();
   \   000020   ........     CALLA   #macDualchipTxPrepCsmaSlotted
    302            }
    303            else
    304            {
    305              MAC_RADIO_TX_PREP_CSMA_UNSLOTTED();
    306            }
    307          }
   \                     ??txCsmaPrep_1:
   \   000024   1001         RETA
    308          
    309          
    310          /*=================================================================================================
    311           * @fn          txGo
    312           *
    313           * @brief       Start a transmit going.
    314           *
    315           * @param       none
    316           *
    317           * @return      none
    318           *=================================================================================================
    319           */

   \                                 In  segment CODE, align 2
    320          static void txGo(void)
   \                     txGo:
    321          {
    322            /*
    323             *  If execution has reached this point, any transmitted ACK has long since completed.  It is
    324             *  possible though that there is still a pending callback.  If so, it is irrelevant and needs to
    325             *  be canceled at this point.
    326             */
    327            MAC_RADIO_CANCEL_ACK_TX_DONE_CALLBACK();
    328            macRxOutgoingAckFlag = 0;
   \   000000   C243....     MOV.B   #0x0, &macRxOutgoingAckFlag
    329          
    330            /* based on type of transmit, call the correct "go" functionality */
    331            if (macTxType == MAC_TX_TYPE_SLOTTED)
   \   000004   E293....     CMP.B   #0x2, &macTxType
   \   000008   0220         JNE     ??txGo_0
    332            {
    333              MAC_RADIO_TX_GO_SLOTTED();
   \   00000A   ........     BRA     #macDualchipTxGoSlotted
    334            }
    335            else
    336            {
    337              txCsmaGo();
   \                     ??txGo_0:
   \   00000E   ........     BRA     #txCsmaGo
    338            }
    339          }
    340          
    341          
    342          /*=================================================================================================
    343           * @fn          txCsmaGo
    344           *
    345           * @brief       Start a CSMA transmit going.
    346           *
    347           * @param       none
    348           *
    349           * @return      none
    350           *=================================================================================================
    351           */

   \                                 In  segment CODE, align 2
    352          static void txCsmaGo(void)
   \                     txCsmaGo:
    353          {
    354            /* The CSMA needs to be performed at normal CCA threshold.
    355             * Turn off the CC2591 compression workaround. 
    356             */
    357            COMPRESSION_WORKAROUND_OFF();
    358          
    359            if (macTxType == MAC_TX_TYPE_SLOTTED_CSMA)
   \   000000   C293....     CMP.B   #0x0, &macTxType
   \   000004   0B20         JNE     ??txCsmaGo_1
    360            {
    361              if (macTxCsmaBackoffDelay >= macDataTxTimeAvailable())
   \   000006   ........     CALLA   #macDataTxTimeAvailable
   \   00000A   C29C....     CMP.B   R12, &macTxCsmaBackoffDelay
   \   00000E   0428         JNC     ??txCsmaGo_2
    362              {
    363                txComplete(MAC_NO_TIME);
   \   000010   7C401C00     MOV.B   #0x1c, R12
   \   000014   ........     BRA     #txComplete
    364                return;
    365              }
    366              MAC_RADIO_TX_GO_SLOTTED_CSMA();
   \                     ??txCsmaGo_2:
   \   000018   ........     BRA     #macDualchipTxGoSlottedCsma
    367            }
    368            else
    369            {
    370              MAC_RADIO_TX_GO_CSMA();
   \                     ??txCsmaGo_1:
   \   00001C   ........     BRA     #macDualchipTxGoCsma
    371            }
    372          }
    373          
    374          
    375          /**************************************************************************************************
    376           * @fn          macTxFrameRetransmit
    377           *
    378           * @brief       Retransmit the last frame.
    379           *
    380           * @param       none
    381           *
    382           * @return      none
    383           **************************************************************************************************
    384           */

   \                                 In  segment CODE, align 2
    385          MAC_INTERNAL_API void macTxFrameRetransmit(void)
   \                     macTxFrameRetransmit:
    386          {
    387            txRetransmitFlag = 1;
   \   000000   D243....     MOV.B   #0x1, &txRetransmitFlag
    388            macTxFrame(macTxType);
   \   000004   5C42....     MOV.B   &macTxType, R12
   \   000008   ........     BRA     #macTxFrame
    389          }
    390          
    391          
    392          /**************************************************************************************************
    393           * @fn          macTxStartQueuedFrame
    394           *
    395           * @brief       See if there is a queued frame waiting to transmit.  If so, initiate
    396           *              the transmit now.
    397           *
    398           * @param       none
    399           *
    400           * @return      none
    401           **************************************************************************************************
    402           */

   \                                 In  segment CODE, align 2
    403          MAC_INTERNAL_API void macTxStartQueuedFrame(void)
   \                     macTxStartQueuedFrame:
    404          {
    405            halIntState_t  s;
    406          
    407            MAC_ASSERT(!macRxActive && !macRxOutgoingAckFlag); /* queued frames should not transmit in middle of a receive */
   \   000000   C293....     CMP.B   #0x0, &macRxActive
   \   000004   0320         JNE     ??macTxStartQueuedFrame_0
   \   000006   C293....     CMP.B   #0x0, &macRxOutgoingAckFlag
   \   00000A   0224         JEQ     ??macTxStartQueuedFrame_1
   \                     ??macTxStartQueuedFrame_0:
   \   00000C   ........     CALLA   #halAssertHandler
    408          
    409            /*
    410             *  Critical sections around the state change prevents any sort of race condition
    411             *  with macTxFrame().  This guarantees function txGo() will only be be called once.
    412             */
    413            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macTxStartQueuedFrame_1:
   \   000010   0F42         MOV.W   SR, R15
   \   000012   32C2         dint
   \   000014   0343         nop
    414            if (macTxActive == MAC_TX_ACTIVE_QUEUED)
   \   000016   E293....     CMP.B   #0x2, &macTxActive
   \   00001A   0620         JNE     ??macTxStartQueuedFrame_2
    415            {
    416              macTxActive = MAC_TX_ACTIVE_GO;
   \   00001C   F2408300.... MOV.B   #0x83, &macTxActive
    417              HAL_EXIT_CRITICAL_SECTION(s);
   \   000022   024F         MOV.W   R15, SR
    418              txGo();
   \   000024   ........     BRA     #txGo
    419            }
    420            else
    421            {
    422              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macTxStartQueuedFrame_2:
   \   000028   024F         MOV.W   R15, SR
    423            }
    424          }
   \   00002A   1001         RETA
    425          
    426          
    427          /**************************************************************************************************
    428           * @fn          macTxChannelBusyCallback
    429           *
    430           * @brief       This callback is executed if a CSMA transmit was attempted but the channel
    431           *              was busy.
    432           *
    433           * @param       none
    434           *
    435           * @return      none
    436           **************************************************************************************************
    437           */

   \                                 In  segment CODE, align 2
    438          MAC_INTERNAL_API void macTxChannelBusyCallback(void)
   \                     macTxChannelBusyCallback:
    439          {
    440            MAC_ASSERT((macTxType == MAC_TX_TYPE_SLOTTED_CSMA) || (macTxType == MAC_TX_TYPE_UNSLOTTED_CSMA));
   \   000000   C293....     CMP.B   #0x0, &macTxType
   \   000004   0524         JEQ     ??macTxChannelBusyCallback_1
   \   000006   D293....     CMP.B   #0x1, &macTxType
   \   00000A   0224         JEQ     ??macTxChannelBusyCallback_1
   \   00000C   ........     CALLA   #halAssertHandler
    441          
    442            /* turn off receiver if allowed */
    443            macTxActive = MAC_TX_ACTIVE_CHANNEL_BUSY;
   \                     ??macTxChannelBusyCallback_1:
   \   000010   E242....     MOV.B   #0x4, &macTxActive
    444            macRxOffRequest();
   \   000014   ........     CALLA   #macRxOffRequest
    445          
    446            /*  clear channel assement failed, follow through with CSMA algorithm */
    447            nb++;
   \   000018   D253....     ADD.B   #0x1, &nb
    448            if (nb > macPib.maxCsmaBackoffs)
   \   00001C   D292........ CMP.B   &nb, &macPib + 30
   \   000022   042C         JC      ??macTxChannelBusyCallback_2
    449            {
    450              txComplete(MAC_CHANNEL_ACCESS_FAILURE);
   \   000024   7C40E100     MOV.B   #0xe1, R12
   \   000028   ........     BRA     #txComplete
    451            }
    452            else
    453            {
    454              macTxBe = MIN(macTxBe+1, macPib.maxBe);
   \                     ??macTxChannelBusyCallback_2:
   \   00002C   5F42....     MOV.B   &macPib + 43, R15
   \   000030   5E42....     MOV.B   &macTxBe, R14
   \   000034   1E53         ADD.W   #0x1, R14
   \   000036   0E9F         CMP.W   R15, R14
   \   000038   0334         JGE     ??macTxChannelBusyCallback_0
   \   00003A   5F42....     MOV.B   &macTxBe, R15
   \   00003E   5F53         ADD.B   #0x1, R15
   \                     ??macTxChannelBusyCallback_0:
   \   000040   C24F....     MOV.B   R15, &macTxBe
    455              txCsmaPrep();
   \   000044   ........     CALLA   #txCsmaPrep
    456              macTxActive = MAC_TX_ACTIVE_GO;
   \   000048   F2408300.... MOV.B   #0x83, &macTxActive
    457              txCsmaGo();
   \   00004E   ........     BRA     #txCsmaGo
    458            }
    459          }
    460          
    461          
    462          /**************************************************************************************************
    463           * @fn          macTxDoneCallback
    464           *
    465           * @brief       This callback is executed when transmit completes.
    466           *
    467           * @param       none
    468           *
    469           * @return      none
    470           **************************************************************************************************
    471           */

   \                                 In  segment CODE, align 2
    472          MAC_INTERNAL_API void macTxDoneCallback(void)
   \                     macTxDoneCallback:
    473          {
   \   000000   0A12         PUSH.W  R10
    474            halIntState_t  s;
    475          
    476            /*
    477             *  There is a small chance this function could be called twice for a single transmit.
    478             *  To prevent logic from executing twice, the state variable macTxActive is used as
    479             *  a gating mechanism to guarantee single time execution.
    480             */
    481            HAL_ENTER_CRITICAL_SECTION(s);
   \   000002   0A42         MOV.W   SR, R10
   \   000004   32C2         dint
   \   000006   0343         nop
    482            if (macTxActive == MAC_TX_ACTIVE_GO)
   \   000008   F2908300.... CMP.B   #0x83, &macTxActive
   \   00000E   1020         JNE     ??macTxDoneCallback_0
    483            {
    484              /* see if ACK was requested */
    485              if (!txAckReq)
   \   000010   C293....     CMP.B   #0x0, &txAckReq
   \   000014   0820         JNE     ??macTxDoneCallback_1
    486              {
    487                macTxActive = MAC_TX_ACTIVE_DONE;
   \   000016   F2408500.... MOV.B   #0x85, &macTxActive
    488                HAL_EXIT_CRITICAL_SECTION(s);
   \   00001C   024A         MOV.W   R10, SR
    489          
    490                /* ACK was not requested, transmit is complete */
    491                txComplete(MAC_SUCCESS);
   \   00001E   4C43         MOV.B   #0x0, R12
   \   000020   ........     CALLA   #txComplete
   \   000024   063C         JMP     ??macTxDoneCallback_2
    492              }
    493              else
    494              {
    495                /*
    496                 *  ACK was requested - must wait to receive it.  A timer is set
    497                 *  to expire after the timeout duration for waiting for an ACK.
    498                 *  If an ACK is received, the function macTxAckReceived() is called.
    499                 *  If an ACK is not received within the timeout period,
    500                 *  the function macTxAckNotReceivedCallback() is called.
    501                 */
    502                macTxActive = MAC_TX_ACTIVE_LISTEN_FOR_ACK;
   \                     ??macTxDoneCallback_1:
   \   000026   F2408600.... MOV.B   #0x86, &macTxActive
    503                MAC_RADIO_TX_REQUEST_ACK_TIMEOUT_CALLBACK();
   \   00002C   ........     CALLA   #macDualchipTxRequestAckTimeoutCallback
    504                HAL_EXIT_CRITICAL_SECTION(s);
    505              }
    506            }
    507            else
    508            {
    509              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macTxDoneCallback_0:
   \   000030   024A         MOV.W   R10, SR
    510            }
    511          }
   \                     ??macTxDoneCallback_2:
   \   000032   3A41         POP.W   R10
   \   000034   1001         RETA
    512          
    513          
    514          /**************************************************************************************************
    515           * @fn          macTxAckReceivedCallback
    516           *
    517           * @brief       This function is called by the receive logic when an ACK is received and
    518           *              transmit logic is listening for an ACK.
    519           *
    520           * @param       seqn        - sequence number of received ACK
    521           * @param       pendingFlag - set if pending flag of ACK is set, cleared otherwise
    522           *
    523           * @return      none
    524           **************************************************************************************************
    525           */

   \                                 In  segment CODE, align 2
    526          MAC_INTERNAL_API void macTxAckReceivedCallback(uint8 seqn, uint8 pendingFlag)
   \                     macTxAckReceivedCallback:
    527          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
    528            halIntState_t  s;
    529          
    530            /* only process if listening for an ACK; critical section prevents race condition problems */
    531            HAL_ENTER_CRITICAL_SECTION(s);
   \   000006   0842         MOV.W   SR, R8
   \   000008   32C2         dint
   \   00000A   0343         nop
    532            if (macTxActive == MAC_TX_ACTIVE_LISTEN_FOR_ACK)
   \   00000C   F2908600.... CMP.B   #0x86, &macTxActive
   \   000012   1220         JNE     ??macTxAckReceivedCallback_1
    533            {
    534              macTxActive = MAC_TX_ACTIVE_POST_ACK;
   \   000014   ........     CALLA   #?Subroutine0
    535              MAC_RADIO_TX_CANCEL_ACK_TIMEOUT_CALLBACK();
    536              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??CrossCallReturnLabel_0:
   \   000018   0248         MOV.W   R8, SR
    537          
    538              /* see if the sequence number of received ACK matches sequence number of packet just sent */
    539              if (seqn == txSeqn)
   \   00001A   5A92....     CMP.B   &txSeqn, R10
   \   00001E   0720         JNE     ??macTxAckReceivedCallback_2
    540              {
    541                /*
    542                 *  Sequence numbers match so transmit is successful.  Return appropriate
    543                 *  status based on the pending flag of the received ACK.
    544                 */
    545                if (pendingFlag)
   \   000020   4B93         CMP.B   #0x0, R11
   \   000022   0324         JEQ     ??macTxAckReceivedCallback_3
    546                {
    547                  txComplete(MAC_ACK_PENDING);
   \   000024   7C401B00     MOV.B   #0x1b, R12
   \   000028   043C         JMP     ??macTxAckReceivedCallback_0
    548                }
    549                else
    550                {
    551                  txComplete(MAC_SUCCESS);
   \                     ??macTxAckReceivedCallback_3:
   \   00002A   4C43         MOV.B   #0x0, R12
   \   00002C   023C         JMP     ??macTxAckReceivedCallback_0
    552                }
    553              }
    554              else
    555              {
    556                /* sequence number did not match; per spec, transmit failed at this point */
    557                txComplete(MAC_NO_ACK);
   \                     ??macTxAckReceivedCallback_2:
   \   00002E   7C40E900     MOV.B   #0xe9, R12
   \                     ??macTxAckReceivedCallback_0:
   \   000032   ........     CALLA   #txComplete
   \   000036   013C         JMP     ??macTxAckReceivedCallback_4
    558              }
    559            }
    560            else
    561            {
    562              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macTxAckReceivedCallback_1:
   \   000038   0248         MOV.W   R8, SR
    563            }
    564          }
   \                     ??macTxAckReceivedCallback_4:
   \   00003A   3817         POPM.W  #0x4, R11
   \   00003C   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   F2408700.... MOV.B   #0x87, &macTxActive
   \   000006   ........     BRA     #macDualchipTxCancelAckTimeoutCallback
    565          
    566          
    567          /**************************************************************************************************
    568           * @fn          macTxAckNotReceivedCallback
    569           *
    570           * @brief       This function is called by the receive logic when transmit is listening
    571           *              for an ACK but something else is received.  It is also called if the
    572           *              listen-for-ACK timeout is reached.
    573           *
    574           * @brief
    575           *
    576           * @param       none
    577           *
    578           * @return      none
    579           **************************************************************************************************
    580           */

   \                                 In  segment CODE, align 2
    581          MAC_INTERNAL_API void macTxAckNotReceivedCallback(void)
   \                     macTxAckNotReceivedCallback:
    582          {
   \   000000   0A12         PUSH.W  R10
    583            halIntState_t  s;
    584          
    585            /* only process if listening for an ACK; critical section prevents race condition problems */
    586            HAL_ENTER_CRITICAL_SECTION(s);
   \   000002   0A42         MOV.W   SR, R10
   \   000004   32C2         dint
   \   000006   0343         nop
    587            if (macTxActive == MAC_TX_ACTIVE_LISTEN_FOR_ACK)
   \   000008   F2908600.... CMP.B   #0x86, &macTxActive
   \   00000E   0820         JNE     ??macTxAckNotReceivedCallback_0
    588            {
    589              macTxActive = MAC_TX_ACTIVE_POST_ACK;
   \   000010   ........     CALLA   #?Subroutine0
    590              MAC_RADIO_TX_CANCEL_ACK_TIMEOUT_CALLBACK();
    591              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??CrossCallReturnLabel_1:
   \   000014   024A         MOV.W   R10, SR
    592          
    593              /* a non-ACK was received when expecting an ACK, per spec transmit is over at this point */
    594              txComplete(MAC_NO_ACK);
   \   000016   7C40E900     MOV.B   #0xe9, R12
   \   00001A   ........     CALLA   #txComplete
   \   00001E   013C         JMP     ??macTxAckNotReceivedCallback_1
    595            }
    596            else
    597            {
    598              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macTxAckNotReceivedCallback_0:
   \   000020   024A         MOV.W   R10, SR
    599            }
    600          }
   \                     ??macTxAckNotReceivedCallback_1:
   \   000022   3A41         POP.W   R10
   \   000024   1001         RETA
    601          
    602          
    603          /*=================================================================================================
    604           * @fn          txComplete
    605           *
    606           * @brief       Transmit has completed.  Perform needed maintenance and return status of
    607           *              the transmit via callback function.
    608           *
    609           * @param       status - status of the transmit that just went out
    610           *
    611           * @return      none
    612           *=================================================================================================
    613           */

   \                                 In  segment CODE, align 2
    614          static void txComplete(uint8 status)
   \                     txComplete:
    615          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
    616            /* reset the retransmit flag */
    617            txRetransmitFlag = 0;
   \   000004   C243....     MOV.B   #0x0, &txRetransmitFlag
    618          
    619            /* update tx state; turn off receiver if nothing is keeping it on */
    620            macTxActive = MAC_TX_ACTIVE_NO_ACTIVITY;
   \   000008   C243....     MOV.B   #0x0, &macTxActive
    621          
    622            /* turn off receive if allowed */
    623            macRxOffRequest();
   \   00000C   ........     CALLA   #macRxOffRequest
    624          
    625            /* update transmit power in case there was a change */
    626            macRadioUpdateTxPower();
   \   000010   ........     CALLA   #macRadioUpdateTxPower
    627          
    628            /*
    629             *  Channel cannot change during transmit so update it here.  (Channel *can* change during
    630             *  a receive.  The update function resets receive logic and any partially received
    631             *  frame is purged.)
    632             */
    633            macRadioUpdateChannel();
   \   000014   ........     CALLA   #macRadioUpdateChannel
    634          
    635            /* return status of transmit via callback function */
    636            macTxCompleteCallback(status);
   \   000018   4C4A         MOV.B   R10, R12
   \   00001A   ........     CALLA   #macTxCompleteCallback
    637          }
   \   00001E   3A41         POP.W   R10
   \   000020   1001         RETA
    638          
    639          
    640          /**************************************************************************************************
    641           * @fn          macTxTimestampCallback
    642           *
    643           * @brief       This callback function records the timestamp into the receive data structure.
    644           *              It should be called as soon as possible after there is a valid timestamp.
    645           *
    646           * @param       none
    647           *
    648           * @return      none
    649           **************************************************************************************************
    650           */

   \                                 In  segment CODE, align 2
    651          MAC_INTERNAL_API void macTxTimestampCallback(void)
   \                     macTxTimestampCallback:
    652          {
    653            MAC_ASSERT(pMacDataTx != NULL); /* transmit structure must be there */
   \   000000   8293....     CMP.W   #0x0, &pMacDataTx
   \   000004   0220         JNE     ??macTxTimestampCallback_0
   \   000006   ........     CALLA   #halAssertHandler
    654          
    655            pMacDataTx->internal.timestamp  = macBackoffTimerCapture();
   \                     ??macTxTimestampCallback_0:
   \   00000A   ........     CALLA   #macBackoffTimerCapture
   \   00000E   1F42....     MOV.W   &pMacDataTx, R15
   \   000012   8F4C0600     MOV.W   R12, 0x6(R15)
   \   000016   8F4D0800     MOV.W   R13, 0x8(R15)
    656            pMacDataTx->internal.timestamp2 = MAC_RADIO_TIMER_CAPTURE();
   \   00001A   ........     CALLA   #macMcuTimerTickCapture
   \   00001E   1F42....     MOV.W   &pMacDataTx, R15
   \   000022   8F4C0A00     MOV.W   R12, 0xa(R15)
    657          }
   \   000026   1001         RETA
    658          
    659          
    660          /**************************************************************************************************
    661           * @fn          macTxCollisionWithRxCallback
    662           *
    663           * @brief       Function called if transmit strobed on top of a receive.
    664           *
    665           * @param       none
    666           *
    667           * @return      none
    668           **************************************************************************************************
    669           */

   \                                 In  segment CODE, align 2
    670          MAC_INTERNAL_API void macTxCollisionWithRxCallback(void)
   \                     macTxCollisionWithRxCallback:
    671          {
    672            macRxHaltCleanup();
   \   000000   ........     BRA     #macRxHaltCleanup
    673          }
    674          
    675          
    676          
    677          /**************************************************************************************************
    678           *                                  Compile Time Integrity Checks
    679           **************************************************************************************************
    680           */
    681          #if (MAC_TX_ACTIVE_NO_ACTIVITY != 0x00)
    682          #error "ERROR! Zero is reserved value of macTxActive. Allows boolean operations, e.g !macTxActive."
    683          #endif
    684          
    685          /**************************************************************************************************
    686          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      6   macTxAckNotReceivedCallback
        6   -> macDualchipTxCancelAckTimeoutCallback
        6   -> txComplete
     12   macTxAckReceivedCallback
       12   -> macDualchipTxCancelAckTimeoutCallback
       12   -> txComplete
      4   macTxChannelBusyCallback
        4   -> halAssertHandler
        4   -> macRxOffRequest
        4   -> txComplete
        4   -> txCsmaGo
        4   -> txCsmaPrep
      4   macTxCollisionWithRxCallback
        4   -> macRxHaltCleanup
      6   macTxDoneCallback
        6   -> macDualchipTxRequestAckTimeoutCallback
        6   -> txComplete
      8   macTxFrame
        8   -> halAssertHandler
        8   -> macDualchipTxPrepSlotted
        8   -> macSpiCmdStrobe
        8   -> macSpiWriteTxFifo
        8   -> txComplete
        8   -> txCsmaPrep
        8   -> txGo
      4   macTxFrameRetransmit
        4   -> macTxFrame
      4   macTxHaltCleanup
        4   -> macDualchipTxReset
        4   -> macTxInit
      4   macTxInit
      4   macTxStartQueuedFrame
        4   -> halAssertHandler
        4   -> txGo
      4   macTxTimestampCallback
        4   -> halAssertHandler
        4   -> macBackoffTimerCapture
        4   -> macMcuTimerTickCapture
      6   txComplete
        6   -> macRadioUpdateChannel
        6   -> macRadioUpdateTxPower
        6   -> macRxOffRequest
        6   -> macTxCompleteCallback
      4   txCsmaGo
        4   -> macDataTxTimeAvailable
        4   -> macDualchipTxGoCsma
        4   -> macDualchipTxGoSlottedCsma
        4   -> txComplete
      4   txCsmaPrep
        4   -> macDualchipTxPrepCsmaSlotted
        4   -> macRadioRandomByte
      4   txGo
        4   -> macDualchipTxGoSlotted
        4   -> txCsmaGo


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?Subroutine0
      38  macTxAckNotReceivedCallback
      62  macTxAckReceivedCallback
       1  macTxActive
       1  macTxBe
      82  macTxChannelBusyCallback
       4  macTxCollisionWithRxCallback
       1  macTxCsmaBackoffDelay
      54  macTxDoneCallback
     236  macTxFrame
      12  macTxFrameRetransmit
       8  macTxHaltCleanup
      10  macTxInit
       1  macTxSlottedDelay
      44  macTxStartQueuedFrame
      40  macTxTimestampCallback
       1  macTxType
       1  nb
       1  txAckReq
      34  txComplete
      32  txCsmaGo
      38  txCsmaPrep
      18  txGo
       1  txRetransmitFlag
       1  txSeqn

 
 722 bytes in segment CODE
   1 byte  in segment DATA16_C
   8 bytes in segment DATA16_Z
 
 722 bytes of CODE  memory
   1 byte  of CONST memory
   8 bytes of DATA  memory

Errors: none
Warnings: none

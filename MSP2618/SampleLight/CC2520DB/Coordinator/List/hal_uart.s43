///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430      10/Jun/2013  16:24:34 /
// Copyright 1996-2013 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\h /
//                     al\target\MSP2618CC2520\hal_uart.c                     /
//    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleLight\CC2520DB\..\..\..\T /
//                     ools\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0    /
//                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                      /
//                     -DDEFAULT_CHANLIST=0x00000800                          /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100     /
//                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                  /
//                     -DBEACON_REQUEST_DELAY=100                             /
//                     -DBEACON_REQ_DELAY_MASK=0x00FF                         /
//                     -DLINK_STATUS_JITTER_MASK=0x007F                       /
//                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED /
//                     =3000 -DNWK_INDIRECT_MSG_TIMEOUT=7                     /
//                     -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3        /
//                     -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2  /
//                     -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16                      /
//                     -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4       /
//                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,      /
//                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,  /
//                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                   /
//                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS= /
//                     20 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000         /
//                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100        /
//                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\ /
//                     f8wCoord.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE=T /
//                     RUE -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         /
//                     -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK) -f     /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\..\..\..\Tool /
//                     s\MSP2618\f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE          /
//                     -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF                /
//                     -DZCL_KEY_ESTABLISH -DZCL_KEY_ESTABLISHMENT_KEY_GENERA /
//                     TE_TIMEOUT=4 -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIME /
//                     OUT=10 -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=1 /
//                     0 -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING             /
//                     -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING            /
//                     -DZCL_TOU) -DZCL_DEVICE_MGMT "C:\Texas                 /
//                     Instruments\ZStack-MSP2618-2.5.1\Components\hal\target /
//                     \MSP2618CC2520\hal_uart.c" -D MSP430F2618 -D ZTOOL_P1  /
//                     -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D            /
//                     LCD_SUPPORTED -lC "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\Coordinator\List\" -lA  /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\Coordinator\L /
//                     ist\" --remarks --diag_suppress                        /
//                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\Coordinator\Obj\"       /
//                     --debug -D__MSP430F2618__ -e --double=32 --clib -I     /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\" -I          /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\..\Source\"   /
//                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleLight\CC2520DB\..\..\Sour /
//                     ce\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pro /
//                     jects\zstack\HomeAutomation\SampleLight\CC2520DB\..\.. /
//                     \..\ZMain\MSP2618\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\hal\include\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\hal\target\MSP2618CC2520\" -I "C:\Texas             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\include\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\high_level\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\low_level\srf04\" -I "C:\Texas                  /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\low_level\srf04\dual_chip\" -I "C:\Texas        /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ /
//                     Projects\zstack\HomeAutomation\SampleLight\CC2520DB\.. /
//                     \..\..\..\..\Components\osal\include\" -I "C:\Texas    /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\osal\mcu\msp430\" -I "C:\Texas                      /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\services\saddr\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\services\sdata\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\af\" -I "C:\Texas                             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\nwk\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sec\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sapi\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sys\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\zcl\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\zdo\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5. /
//                     1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB\ /
//                     ..\..\..\..\..\Components\zmac\f8w\" --core=430X       /
//                     --data_model=small -Ohz --multiplier=16s               /
//                     --require_prototypes                                   /
//    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst /
//                     ack\HomeAutomation\SampleLight\CC2520DB\Coordinator\Li /
//                     st\hal_uart.s43                                        /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME hal_uart

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?cstart_init_copy
        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK `??halBoardUart1RxReadyIsr??INTVEC 46`
        PUBWEAK `??halBoardUart1TxReadyIsr??INTVEC 44`
        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC HalUARTClose
        FUNCTION HalUARTClose,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalUARTInit
        FUNCTION HalUARTInit,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalUARTOpen
        FUNCTION HalUARTOpen,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC HalUARTPoll
        FUNCTION HalUARTPoll,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalUARTRead
        FUNCTION HalUARTRead,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC HalUARTWrite
        FUNCTION HalUARTWrite,080203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        FUNCTION Hal_UART_BufferInit,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC Hal_UART_FlowControlSet
        FUNCTION Hal_UART_FlowControlSet,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC Hal_UART_RxBufLen
        FUNCTION Hal_UART_RxBufLen,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION Hal_UART_RxProcessEvent,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION Hal_UART_SendCallBack,041203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC Hal_UART_TxBufLen
        FUNCTION Hal_UART_TxBufLen,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION Hal_UART_TxProcessEvent,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBWEAK IE2
        PUBWEAK IFG2
        PUBWEAK P2DIR
        PUBWEAK P2OUT
        PUBWEAK P3SEL
        PUBLIC UBRRTable
        PUBWEAK UCA0BR0
        PUBWEAK UCA0BR1
        PUBWEAK UCA0CTL0
        PUBWEAK UCA0CTL1
        PUBWEAK UCA0RXBUF
        PUBWEAK UCA0TXBUF
        PUBLIC halBoardUart1RxReadyIsr
        FUNCTION halBoardUart1RxReadyIsr,021233H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC halBoardUart1TxReadyIsr
        FUNCTION halBoardUart1TxReadyIsr,021233H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC uartRecord
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        
          CFI Common cfiCommon2 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC or(load(2, DATA, add(CFA, literal(-2))), lshift(and(load(2, DATA, add(CFA, literal(-4))), 61440), 4))
          CFI SR Frame(CFA, -4)
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon2
        
halBoardUart1RxReadyIsr SYMBOL "halBoardUart1RxReadyIsr"
`??halBoardUart1RxReadyIsr??INTVEC 46` SYMBOL "??INTVEC 46", halBoardUart1RxReadyIsr
halBoardUart1TxReadyIsr SYMBOL "halBoardUart1TxReadyIsr"
`??halBoardUart1TxReadyIsr??INTVEC 44` SYMBOL "??INTVEC 44", halBoardUart1TxReadyIsr

        EXTERN osal_GetSystemClock
        FUNCTION osal_GetSystemClock,0202H
        EXTERN osal_mem_free
        FUNCTION osal_mem_free,0202H
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H

// C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\hal\target\MSP2618CC2520\hal_uart.c
//    1 /**************************************************************************************************
//    2   Filename:       hal_uart.c
//    3   Revised:        $Date: 2009-03-11 15:33:59 -0700 (Wed, 11 Mar 2009) $
//    4   Revision:       $Revision: 19383 $
//    5 
//    6   Description:    This file contains the interface to the UART.
//    7 
//    8 
//    9   Copyright 2007-2008 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 #include "hal_types.h"
//   44 #include "hal_uart.h"

        ASEGN DATA16_AN:DATA:NOROOT,01H
// unsigned char volatile IE2
IE2:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,03H
// unsigned char volatile IFG2
IFG2:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,029H
// unsigned char volatile P2OUT
P2OUT:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,02aH
// unsigned char volatile P2DIR
P2DIR:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,01bH
// unsigned char volatile P3SEL
P3SEL:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,060H
// unsigned char volatile UCA0CTL0
UCA0CTL0:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,061H
// unsigned char volatile UCA0CTL1
UCA0CTL1:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,062H
// unsigned char volatile UCA0BR0
UCA0BR0:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,063H
// unsigned char volatile UCA0BR1
UCA0BR1:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,066H
// unsigned char const volatile UCA0RXBUF
UCA0RXBUF:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,067H
// unsigned char volatile UCA0TXBUF
UCA0TXBUF:
        DS8 1
//   45 #include "osal.h"
//   46 #include "OSAL_Timers.h"
//   47 #include "hal_mcu.h"
//   48 
//   49 /*-------------------------------------------------------------------------------------------------
//   50                                                MACROS
//   51  ------------------------------------------------------------------------------------------------*/
//   52 
//   53 /* Get 1 byte from UART */
//   54 #define HAL_UART_GETBYTE() UCA0RXBUF
//   55 
//   56 /* Put 1 byte into the UART */
//   57 #define HAL_UART_PUTBYTE(x) UCA0TXBUF = x;
//   58 
//   59 /* Set Baud rate */
//   60 #define HAL_UART_SETBAUDRATE(baudrate) { UCA0BR1 = (baudrate) >> 8;  UCA0BR0 = (baudrate);}
//   61 
//   62 /* Set Source Clock */
//   63 #define HAL_UART_SET_SRC_CLK()         { UCA0CTL1 |= UCSSEL1; UCA0CTL1 &= ~UCSSEL0; } /* SMCLK */
//   64 
//   65 /* Setup TXD and RXD Port */
//   66 #define HAL_UART_PORT_CONFIG()         { P3SEL |= BV(4) | BV(5); }      /* P3.4, P3.5 - UCA0TXD and RXD */
//   67 
//   68 /* Setup format frame */
//   69 #define HAL_UART_FRAME_CONFIG()        { UCA0CTL0 &= ~UCPEN; UCA0CTL0 &= ~UCSPB; UCA0CTL0 &= ~UC7BIT; } /* 8N1 */
//   70 
//   71 /* Enable/Disable TX */
//   72 #define HAL_UART_TX_ENABLE()           /* N/A */
//   73 #define HAL_UART_TX_DISABLE()          /* N/A */
//   74 
//   75 /* Enable/Disable TX INT */
//   76 #define HAL_UART_TX_INT_ENABLE()       { IE2 |= UCA0TXIE; }
//   77 #define HAL_UART_TX_INT_DISABLE()      { IE2 &= ~UCA0TXIE; }
//   78 
//   79 /* Enable/Disable RX */
//   80 #define HAL_UART_RX_ENABLE()           /* N/A */
//   81 #define HAL_UART_RX_DISABLE()          /* N/A */
//   82 
//   83 /* Enable/Disable TX INT */
//   84 #define HAL_UART_RX_INT_ENABLE()       { IE2 |= UCA0RXIE; }
//   85 #define HAL_UART_RX_INT_DISABLE()      { IE2 &= ~UCA0RXIE; }
//   86 
//   87 /* Enable/Disable SWRST */
//   88 #define HAL_UART_SWRST_ENABLE()        { UCA0CTL1 |= UCSWRST; }
//   89 #define HAL_UART_SWRST_DISABLE()       { UCA0CTL1 &= ~UCSWRST; }
//   90 
//   91 /* Get Rx/Tx status bit */
//   92 #define HAL_UART_GET_RX_STATUS()      (IFG2 & UCA0RXIFG)
//   93 #define HAL_UART_GET_TX_STATUS()      (IFG2 & UCA0TXIFG)
//   94 #define HAL_UART_CLR_TX_STATUS()      (IFG2 &= ~UCA0TXIFG)
//   95 
//   96 /* UART CTS and RTS */
//   97 #define HAL_UART_CTS_PORT              P2OUT
//   98 #define HAL_UART_CTS_BIT               BV(6)
//   99 
//  100 #define HAL_UART_RTS_PORT              P2IN
//  101 #define HAL_UART_RTS_BIT               BV(7)
//  102 
//  103 #define HAL_UART_FLOWCONTROL_INIT()    {P2DIR |= HAL_UART_CTS_BIT; P2DIR &= ~HAL_UART_RTS_BIT;}
//  104 
//  105 
//  106 /*-------------------------------------------------------------------------------------------------
//  107                                           GLOBAL VARIABLES
//  108 -------------------------------------------------------------------------------------------------*/
//  109 

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  110 halUARTCfg_t uartRecord;
uartRecord:
        DS8 34
//  111 
//  112 #define HAL_GET_UBRR(BAUD_BPS)   ((uint32)(HAL_CPU_CLOCK_MHZ * 1000000) / (uint32)BAUD_BPS)
//  113 
//  114 /* UBRR table */

        RSEG DATA16_I:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_copy
//  115 uint16 UBRRTable[] = { HAL_GET_UBRR (9600),
UBRRTable:
        DS8 10
        REQUIRE `?<Initializer for UBRRTable>`
//  116                        HAL_GET_UBRR (19200),
//  117                        HAL_GET_UBRR (38400),
//  118                        HAL_GET_UBRR (57600),
//  119                        HAL_GET_UBRR (115200) };
//  120 
//  121 /*-------------------------------------------------------------------------------------------------
//  122                                          FUNCTIONS - LOCAL
//  123 -------------------------------------------------------------------------------------------------*/
//  124 
//  125 static void Hal_UART_BufferInit(void);
//  126 static void Hal_UART_RxProcessEvent(void);
//  127 static void Hal_UART_TxProcessEvent(void);
//  128 static void Hal_UART_SendCallBack(uint8 port, uint8 event);
//  129 
//  130 /*-------------------------------------------------------------------------------------------------
//  131                                   Application Level Functions
//  132 -------------------------------------------------------------------------------------------------*/
//  133 
//  134 /*************************************************************************************************
//  135  * @fn      HalUARTInit()
//  136  *
//  137  * @brief   Initialize the UART
//  138  *
//  139  * @param   none
//  140  *
//  141  * @return  none
//  142  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  143 void HalUARTInit ( void )
HalUARTInit:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function HalUARTInit
//  144 {
//  145   Hal_UART_BufferInit();
        FUNCALL HalUARTInit, Hal_UART_BufferInit
        LOCFRAME CSTACK, 4, STACK
        BRA     #Hal_UART_BufferInit
          CFI EndBlock cfiBlock0
//  146 }
//  147 
//  148 /*************************************************************************************************
//  149  * @fn      HalBufferInit()
//  150  *
//  151  * @brief   Initialize the UART Buffers
//  152  *
//  153  * @param   none
//  154  *
//  155  * @return  none
//  156  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  157 static void Hal_UART_BufferInit (void)
Hal_UART_BufferInit:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function Hal_UART_BufferInit
//  158 {
//  159   uartRecord.configured        = FALSE;
        MOV.B   #0x0, &uartRecord
//  160   uartRecord.rx.bufferHead     = 0;
        MOV.W   #0x0, &uartRecord + 8
//  161   uartRecord.rx.bufferTail     = 0;
        MOV.W   #0x0, &uartRecord + 10
//  162   uartRecord.rx.pBuffer        = (uint8 *)NULL;
        MOV.W   #0x0, &uartRecord + 14
//  163   uartRecord.tx.bufferHead     = 0;
        MOV.W   #0x0, &uartRecord + 16
//  164   uartRecord.tx.bufferTail     = 0;
        MOV.W   #0x0, &uartRecord + 18
//  165   uartRecord.tx.pBuffer        = (uint8 *)NULL;
        MOV.W   #0x0, &uartRecord + 22
//  166   uartRecord.rxChRvdTime       = 0;
        MOV.W   #0x0, &uartRecord + 26
        MOV.W   #0x0, &uartRecord + 28
//  167   uartRecord.intEnable         = FALSE;
        MOV.B   #0x0, &uartRecord + 24
//  168 }
        RETA
          CFI EndBlock cfiBlock1
//  169 
//  170 /*************************************************************************************************
//  171  * @fn      HalUARTOpen()
//  172  *
//  173  * @brief   Open a port based on the configuration
//  174  *
//  175  * @param   port   - UART port
//  176  *          config - contains configuration information
//  177  *          cBack  - Call back function where events will be reported back
//  178  *
//  179  * @return  Status of the function call
//  180  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  181 uint8 HalUARTOpen ( uint8 port, halUARTCfg_t *config )
HalUARTOpen:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function HalUARTOpen
//  182 {
        FUNCALL HalUARTOpen, Hal_UART_FlowControlSet
        LOCFRAME CSTACK, 6, STACK
        FUNCALL HalUARTOpen, osal_mem_alloc
        LOCFRAME CSTACK, 6, STACK
        FUNCALL HalUARTOpen, osal_mem_alloc
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.W   R13, R10
//  183   /* Save important information */
//  184   uartRecord.baudRate             = config->baudRate;
        MOV.B   0x1(R13), &uartRecord + 1
//  185   uartRecord.flowControl          = config->flowControl;
        MOV.B   0x2(R13), &uartRecord + 2
        MOV.W   0x4(R13), &uartRecord + 4
//  186   uartRecord.flowControlThreshold = config->flowControlThreshold;
//  187   uartRecord.rx.maxBufSize        = config->rx.maxBufSize;
        MOV.W   0xc(R13), &uartRecord + 12
//  188   uartRecord.tx.maxBufSize        = config->tx.maxBufSize;
        MOV.W   0x14(R13), &uartRecord + 20
//  189   uartRecord.idleTimeout          = config->idleTimeout;
        MOV.B   0x6(R13), &uartRecord + 6
//  190   uartRecord.intEnable            = config->intEnable;
        MOV.B   0x18(R13), &uartRecord + 24
//  191   uartRecord.callBackFunc         = config->callBackFunc;
        MOV.W   0x1e(R13), &uartRecord + 30
        MOV.W   0x20(R13), &uartRecord + 32
//  192 
//  193   /* Set SWRST - UART logic held in reset state */
//  194   HAL_UART_SWRST_ENABLE();
        BIS.B   #0x1, &0x61
//  195 
//  196   /* Setup GPIO */
//  197   HAL_UART_PORT_CONFIG();
        BIS.B   #0x30, &0x1b
//  198 
//  199   /* Set Frame Format */
//  200   HAL_UART_FRAME_CONFIG();
        BIC.B   #0x80, &0x60
        BIC.B   #0x8, &0x60
        BIC.B   #0x10, &0x60
//  201 
//  202   /* Set source clock */
//  203   HAL_UART_SET_SRC_CLK();
        BIS.B   #0x80, &0x61
        BIC.B   #0x40, &0x61
//  204 
//  205   /* Setup Baudrate */
//  206   if (config->baudRate > HAL_UART_BR_115200)
        MOV.B   0x1(R13), R15
        CMP.B   #0x5, R15
        JNC     ??HalUARTOpen_1
//  207   {
//  208     return HAL_UART_BAUDRATE_ERROR;
        MOV.B   #0x4, R12
        JMP     ??HalUARTOpen_2
//  209   }
//  210   else
//  211   {
//  212     HAL_UART_SETBAUDRATE(UBRRTable[config->baudRate]);  /* Set baud rate */
??HalUARTOpen_1:
        RLA.W   R15
        MOV.B   UBRRTable + 1(R15), &0x63
        MOV.B   0x1(R13), R15
        RLA.W   R15
        MOV.B   UBRRTable(R15), &0x62
//  213   }
//  214 
//  215   /* Setup Flow Control */
//  216   if (uartRecord.flowControl)
        CMP.B   #0x0, &uartRecord + 2
        JEQ     ??HalUARTOpen_3
//  217   {
//  218     HAL_UART_FLOWCONTROL_INIT();
        BIS.B   #0x40, &0x2a
        BIC.B   #0x80, &0x2a
//  219     Hal_UART_FlowControlSet (port, uartRecord.flowControl);
        MOV.B   &uartRecord + 2, R13
        CALLA   #Hal_UART_FlowControlSet
//  220   }
//  221 
//  222   /* Setup threshold */
//  223   if (config->flowControlThreshold > config->rx.maxBufSize)
??HalUARTOpen_3:
        MOV.W   0x4(R10), R15
        CMP.W   R15, 0xc(R10)
        JC      ??HalUARTOpen_0
//  224     uartRecord.flowControlThreshold = 0;
        MOV.W   #0x0, R15
//  225   else
//  226     uartRecord.flowControlThreshold = config->flowControlThreshold;
??HalUARTOpen_0:
        MOV.W   R15, &uartRecord + 4
//  227 
//  228   /* Allocate memory for Rx and Tx buffer */
//  229   uartRecord.rx.pBuffer = osal_mem_alloc (uartRecord.rx.maxBufSize);
        MOV.W   &uartRecord + 12, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, &uartRecord + 14
//  230   uartRecord.tx.pBuffer = osal_mem_alloc (uartRecord.tx.maxBufSize);
        MOV.W   &uartRecord + 20, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, &uartRecord + 22
//  231 
//  232   /* Validate buffers */
//  233   if ((uartRecord.rx.pBuffer) && (uartRecord.tx.pBuffer))
        CMP.W   #0x0, &uartRecord + 14
        JEQ     ??HalUARTOpen_4
        CMP.W   #0x0, R12
        JEQ     ??HalUARTOpen_4
//  234   {
//  235     /* Enable RX  Enable Rx Int */
//  236     HAL_UART_RX_ENABLE();
//  237 
//  238     /* Clear SWRST - releaset to operation */
//  239     HAL_UART_SWRST_DISABLE();
        BIC.B   #0x1, &0x61
//  240 
//  241     /* Enable interrupt (optional) */
//  242     if (config->intEnable)
        CMP.B   #0x0, 0x18(R10)
        JEQ     ??HalUARTOpen_5
//  243     {
//  244       HAL_UART_RX_INT_ENABLE();
        BIS.B   #0x1, &0x1
        JMP     ??HalUARTOpen_6
//  245     }
//  246     else
//  247     {
//  248       HAL_UART_RX_INT_DISABLE();
??HalUARTOpen_5:
        BIC.B   #0x1, &0x1
//  249     }
//  250 
//  251     HAL_UART_CLR_TX_STATUS();
??HalUARTOpen_6:
        BIC.B   #0x2, &0x3
//  252 
//  253     /* Mark record as "configured" */
//  254     uartRecord.configured = TRUE;
        MOV.B   #0x1, &uartRecord
//  255 
//  256     /* Ready to be used. */
//  257     return HAL_UART_SUCCESS;
        MOV.B   #0x0, R12
        JMP     ??HalUARTOpen_2
//  258   }
//  259   else
//  260   {
//  261     /* If memory allocation failed, not "configured" */
//  262     uartRecord.configured = FALSE;
??HalUARTOpen_4:
        MOV.B   #0x0, &uartRecord
//  263 
//  264     /* Failed to allocate Rx and Tx Buffer, end of the story */
//  265     return HAL_UART_MEM_FAIL;
        MOV.B   #0x3, R12
??HalUARTOpen_2:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
        REQUIRE UCA0CTL1
        REQUIRE P3SEL
        REQUIRE UCA0CTL0
        REQUIRE UCA0BR1
        REQUIRE UCA0BR0
        REQUIRE P2DIR
        REQUIRE IE2
        REQUIRE IFG2
//  266   }
//  267 }
//  268 
//  269 /*************************************************************************************************
//  270  * @fn      Hal_UARTPoll
//  271  *
//  272  * @brief   This routine simulate polling and has to be called by the main loop
//  273  *
//  274  * @param   void
//  275  *
//  276  * @return  void
//  277  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  278 void HalUARTPoll(void)
HalUARTPoll:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function HalUARTPoll
//  279 {
//  280   if (!uartRecord.configured)  // If port is not configured, no point to poll it.
        FUNCALL HalUARTPoll, Hal_UART_RxProcessEvent
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_TxProcessEvent
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_RxBufLen
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_SendCallBack
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, osal_GetSystemClock
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_SendCallBack
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_RxBufLen
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_SendCallBack
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_RxBufLen
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_FlowControlSet
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_FlowControlSet
        LOCFRAME CSTACK, 4, STACK
        CMP.B   #0x0, &uartRecord
        JEQ     ??HalUARTPoll_0
//  281   {
//  282     return;
//  283   }
//  284 
//  285   if (!uartRecord.intEnable)  // Check Port for items to process.
        CMP.B   #0x0, &uartRecord + 24
        JNE     ??HalUARTPoll_2
//  286   {
//  287     if (HAL_UART_GET_RX_STATUS())
        BIT.B   #0x1, &0x3
        JNC     ??HalUARTPoll_3
//  288     {
//  289       Hal_UART_RxProcessEvent();
        CALLA   #Hal_UART_RxProcessEvent
//  290     }
//  291 
//  292     if (HAL_UART_GET_TX_STATUS())
??HalUARTPoll_3:
        BIT.B   #0x2, &0x3
        JNC     ??HalUARTPoll_2
//  293     {
//  294       Hal_UART_TxProcessEvent();
        CALLA   #Hal_UART_TxProcessEvent
//  295     }
//  296   }
//  297 
//  298   if ((Hal_UART_RxBufLen(0) + 1) >= uartRecord.rx.maxBufSize)  // Report if Rx Buffer is full.
??HalUARTPoll_2:
        CALLA   #?Subroutine0
??CrossCallReturnLabel_2:
        ADD.W   #0x1, R12
        CMP.W   &uartRecord + 12, R12
        JNC     ??HalUARTPoll_4
//  299   {
//  300     Hal_UART_SendCallBack (0, HAL_UART_RX_FULL) ;
        MOV.B   #0x1, R13
        MOV.B   #0x0, R12
        CALLA   #Hal_UART_SendCallBack
//  301   }
//  302 
//  303   if ((uartRecord.rxChRvdTime != 0) &&  // Report if Rx Buffer is idled.
//  304      ((osal_GetSystemClock() - uartRecord.rxChRvdTime) > uartRecord.idleTimeout))
??HalUARTPoll_4:
        MOV.W   &uartRecord + 26, R15
        BIS.W   &uartRecord + 28, R15
        CMP.W   #0x0, R15
        JEQ     ??HalUARTPoll_5
        CALLA   #osal_GetSystemClock
        MOV.B   &uartRecord + 6, R14
        MOV.W   #0x0, R15
        SUB.W   &uartRecord + 26, R12
        SUBC.W  &uartRecord + 28, R13
        CMP.W   R13, R15
        JNC     ??HalUARTPoll_6
        JNE     ??HalUARTPoll_5
        CMP.W   R12, R14
        JC      ??HalUARTPoll_5
//  305   {
//  306     Hal_UART_SendCallBack (0, HAL_UART_RX_TIMEOUT) ;
??HalUARTPoll_6:
        MOV.B   #0x4, R13
        MOV.B   #0x0, R12
        CALLA   #Hal_UART_SendCallBack
//  307     uartRecord.rxChRvdTime = 0;
        MOV.W   #0x0, &uartRecord + 26
        MOV.W   #0x0, &uartRecord + 28
//  308   }
//  309 
//  310   /* Send back warning when buffer it threshold  and turn off flow */
//  311   if (Hal_UART_RxBufLen(0) >= uartRecord.rx.maxBufSize - uartRecord.flowControlThreshold)
??HalUARTPoll_5:
        CALLA   #?Subroutine0
??CrossCallReturnLabel_1:
        MOV.W   &uartRecord + 12, R15
        SUB.W   &uartRecord + 4, R15
        CMP.W   R15, R12
        JNC     ??HalUARTPoll_7
//  312   {
//  313     Hal_UART_SendCallBack (0, HAL_UART_RX_ABOUT_FULL) ;
        MOV.B   #0x2, R13
        MOV.B   #0x0, R12
        CALLA   #Hal_UART_SendCallBack
//  314   }
//  315 
//  316   if (uartRecord.flowControl)
??HalUARTPoll_7:
        CMP.B   #0x0, &uartRecord + 2
        JEQ     ??HalUARTPoll_0
//  317   {
//  318     if (Hal_UART_RxBufLen(0) > uartRecord.rx.maxBufSize / 2)
        CALLA   #?Subroutine0
??CrossCallReturnLabel_0:
        MOV.W   &uartRecord + 12, R15
        RRUM.W  #0x1, R15
        CMP.W   R12, R15
        JC      ??HalUARTPoll_8
//  319     {
//  320       Hal_UART_FlowControlSet (0, HAL_UART_FLOW_OFF);
        MOV.B   #0x0, R13
        MOV.B   #0x0, R12
        BRA     #Hal_UART_FlowControlSet
//  321     }
//  322     else
//  323     {
//  324       Hal_UART_FlowControlSet (0, HAL_UART_FLOW_ON);
??HalUARTPoll_8:
        MOV.B   #0x1, R13
        MOV.B   #0x0, R12
        CALLA   #Hal_UART_FlowControlSet
//  325     }
//  326   }
//  327 }
??HalUARTPoll_0:
        RETA
          CFI EndBlock cfiBlock3
        REQUIRE IFG2

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine0:
          CFI Block cfiCond4 Using cfiCommon0
          CFI Function HalUARTRead
          CFI Conditional ??CrossCallReturnLabel_3
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
          CFI Block cfiCond5 Using cfiCommon0
          CFI (cfiCond5) Function HalUARTPoll
          CFI (cfiCond5) Conditional ??CrossCallReturnLabel_2
          CFI (cfiCond5) CFA SP+8
          CFI Block cfiCond6 Using cfiCommon0
          CFI (cfiCond6) Function HalUARTPoll
          CFI (cfiCond6) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond6) CFA SP+8
          CFI Block cfiCond7 Using cfiCommon0
          CFI (cfiCond7) Function HalUARTPoll
          CFI (cfiCond7) Conditional ??CrossCallReturnLabel_0
          CFI (cfiCond7) CFA SP+8
          CFI Block cfiPicker8 Using cfiCommon1
          CFI (cfiPicker8) NoFunction
          CFI (cfiPicker8) Picker
        MOV.B   #0x0, R12
        BRA     #Hal_UART_RxBufLen
          CFI EndBlock cfiCond4
          CFI EndBlock cfiCond5
          CFI EndBlock cfiCond6
          CFI EndBlock cfiCond7
          CFI EndBlock cfiPicker8
//  328 
//  329 /*************************************************************************************************
//  330  * @fn      HalUARTClose()
//  331  *
//  332  * @brief   Close the UART
//  333  *
//  334  * @param   port - UART port (not used.)
//  335  *
//  336  * @return  none
//  337  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  338 void HalUARTClose ( uint8 port )
HalUARTClose:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function HalUARTClose
//  339 {
//  340   /* Disable Rx Int */
//  341   HAL_UART_RX_INT_DISABLE();
        FUNCALL HalUARTClose, osal_mem_free
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTClose, osal_mem_free
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTClose, Hal_UART_BufferInit
        LOCFRAME CSTACK, 4, STACK
        BIC.B   #0x1, &0x1
//  342 
//  343   /* Disable RX */
//  344   HAL_UART_RX_DISABLE();
//  345 
//  346   /* Deallocate Rx and Tx Buffers */
//  347   if (uartRecord.configured)
        CMP.B   #0x0, &uartRecord
        JEQ     ??HalUARTClose_0
//  348   {
//  349     /* Free Tx and Rx buffer */
//  350     osal_mem_free (uartRecord.rx.pBuffer);
        MOV.W   &uartRecord + 14, R12
        CALLA   #osal_mem_free
//  351     osal_mem_free (uartRecord.tx.pBuffer);
        MOV.W   &uartRecord + 22, R12
        CALLA   #osal_mem_free
//  352 
//  353     /* Re-Initialze buffers again */
//  354     Hal_UART_BufferInit();
        CALLA   #Hal_UART_BufferInit
//  355   }
//  356 }
??HalUARTClose_0:
        RETA
          CFI EndBlock cfiBlock9
        REQUIRE IE2
//  357 
//  358 /*************************************************************************************************
//  359  * @fn      HalUARTRead()
//  360  *
//  361  * @brief   Read a buffer from the UART
//  362  *
//  363  * @param   port - UART port (not used.)
//  364  *          ppBuffer - pointer to a pointer that points to the data that will be read
//  365  *          length - length of the requested buffer
//  366  *
//  367  * @return  length of buffer that was read
//  368  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  369 uint16 HalUARTRead ( uint8 port, uint8 *pBuffer, uint16 length )
HalUARTRead:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function HalUARTRead
//  370 {
        FUNCALL HalUARTRead, Hal_UART_RxBufLen
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
//  371   uint16 cnt, idx;
//  372 
//  373   if (!uartRecord.configured)  // If port is not configured, no point to read it.
        CMP.B   #0x0, &uartRecord
        JNE     ??HalUARTRead_1
//  374   {
//  375     return 0;
        MOV.W   #0x0, R12
        JMP     ??HalUARTRead_2
//  376   }
//  377 
//  378   // If requested length is bigger than what in buffer, re-adjust it to the buffer length.
//  379   cnt = Hal_UART_RxBufLen(0);
??HalUARTRead_1:
        CALLA   #?Subroutine0
//  380   if (cnt < length)
??CrossCallReturnLabel_3:
        CMP.W   R14, R12
        JC      ??HalUARTRead_3
//  381   {
//  382     length = cnt;
        MOV.W   R12, R14
//  383   }
//  384 
//  385   idx = uartRecord.rx.bufferHead;
??HalUARTRead_3:
        MOV.W   &uartRecord + 8, R10
//  386   for (cnt = 0; cnt < length; cnt++)
        MOV.W   #0x0, R12
        JMP     ??HalUARTRead_4
//  387   {
//  388     pBuffer[cnt] = uartRecord.rx.pBuffer[idx++];
??HalUARTRead_0:
        MOV.W   &uartRecord + 14, R11
        ADD.W   R10, R11
        MOV.W   R13, R15
        ADD.W   R12, R15
        MOV.B   @R11, 0(R15)
        ADD.W   #0x1, R10
//  389 
//  390     if (idx >= uartRecord.rx.maxBufSize)
        CMP.W   &uartRecord + 12, R10
        JNC     ??HalUARTRead_5
//  391     {
//  392       idx = 0;
        MOV.W   #0x0, R10
//  393     }
//  394   }
??HalUARTRead_5:
        ADD.W   #0x1, R12
??HalUARTRead_4:
        CMP.W   R14, R12
        JNC     ??HalUARTRead_0
//  395   uartRecord.rx.bufferHead = idx;
        MOV.W   R10, &uartRecord + 8
//  396 
//  397   return length;  // Return number of bytes read.
        MOV.W   R14, R12
??HalUARTRead_2:
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock10
//  398 }
//  399 
//  400 /*************************************************************************************************
//  401  * @fn      HalUARTWrite()
//  402  *
//  403  * @brief   Write a buffer to the UART
//  404  *
//  405  * @param   port    - UART port (not used.)
//  406  *          pBuffer - pointer to the buffer that will be written
//  407  *          length  - length of
//  408  *
//  409  * @return  length of the buffer that was sent
//  410  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  411 uint16 HalUARTWrite ( uint8 port, uint8 *pBuffer, uint16 length )
HalUARTWrite:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function HalUARTWrite
//  412 {
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
//  413   uint16 cnt, idx;
//  414   halIntState_t intState;
//  415 
//  416   if (!uartRecord.configured)
        CMP.B   #0x0, &uartRecord
        JEQ     ??HalUARTWrite_1
//  417   {
//  418     return 0;
//  419   }
//  420 
//  421   // Capture the value of the volatile variables.
//  422   idx = uartRecord.tx.bufferHead;
        MOV.W   &uartRecord + 16, R15
//  423   cnt = uartRecord.tx.bufferTail;
        MOV.W   &uartRecord + 18, R12
        MOV.W   &uartRecord + 20, R10
        CMP.W   R15, R12
        JNE     ??HalUARTWrite_2
//  424   if (cnt == idx)
//  425   {
//  426     cnt = uartRecord.tx.maxBufSize;
        MOV.W   R10, R15
        JMP     ??HalUARTWrite_3
//  427   }
//  428   else if (cnt > idx)
??HalUARTWrite_2:
        CMP.W   R12, R15
        JC      ??HalUARTWrite_4
//  429   {
//  430     cnt = uartRecord.tx.maxBufSize - cnt + idx;
        SUB.W   R12, R10
        ADD.W   R10, R15
        JMP     ??HalUARTWrite_3
//  431   }
//  432   else // (cnt < idx)
//  433   {
//  434     cnt = idx - cnt;
??HalUARTWrite_4:
        SUB.W   R12, R15
//  435   }
//  436    
//  437   // Accept "all-or-none" on write request.
//  438   if (cnt < length)
??HalUARTWrite_3:
        CMP.W   R14, R15
        JC      ??HalUARTWrite_5
//  439   {
//  440     return 0;
??HalUARTWrite_1:
        MOV.W   #0x0, R12
        JMP     ??HalUARTWrite_6
//  441   }
//  442 
//  443   idx = uartRecord.tx.bufferTail;
??HalUARTWrite_5:
        MOV.W   &uartRecord + 18, R10
//  444 
//  445   for (cnt = 0; cnt < length; cnt++)
        MOV.W   #0x0, R15
        JMP     ??HalUARTWrite_7
//  446   {
//  447     uartRecord.tx.pBuffer[idx++] = pBuffer[cnt];
??HalUARTWrite_0:
        MOV.W   R13, R12
        ADD.W   R15, R12
        MOV.W   &uartRecord + 22, R11
        ADD.W   R10, R11
        MOV.B   @R12, 0(R11)
        ADD.W   #0x1, R10
//  448 
//  449     if (idx >= uartRecord.tx.maxBufSize)
        CMP.W   &uartRecord + 20, R10
        JNC     ??HalUARTWrite_8
//  450     {
//  451       idx = 0;
        MOV.W   #0x0, R10
//  452     }
//  453   }
??HalUARTWrite_8:
        ADD.W   #0x1, R15
??HalUARTWrite_7:
        CMP.W   R14, R15
        JNC     ??HalUARTWrite_0
//  454 
//  455   HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
        MOV.W   SR, R15
        dint
        nop
//  456   cnt = uartRecord.tx.bufferTail;
        MOV.W   &uartRecord + 18, R13
//  457   if (cnt == uartRecord.tx.bufferHead)
        CMP.W   &uartRecord + 16, R13
        JNE     ??HalUARTWrite_9
//  458   {
//  459     if (uartRecord.intEnable)
        CMP.B   #0x0, &uartRecord + 24
        JEQ     ??HalUARTWrite_10
//  460     {
//  461       HAL_UART_TX_INT_ENABLE();
        BIS.B   #0x2, &0x1
//  462     }
//  463     HAL_UART_PUTBYTE(uartRecord.tx.pBuffer[uartRecord.tx.bufferHead]);  // Send a char to UART.
??HalUARTWrite_10:
        MOV.W   &uartRecord + 22, R11
        ADD.W   &uartRecord + 16, R11
        MOV.B   @R11, &0x67
//  464   }
//  465   uartRecord.tx.bufferTail = idx;
??HalUARTWrite_9:
        MOV.W   R10, &uartRecord + 18
//  466   HAL_EXIT_CRITICAL_SECTION(intState);  // Restore interrupt enable.
        MOV.W   R15, SR
//  467 
//  468   return length;  // Return the number of bytes actually put into the buffer.
        MOV.W   R14, R12
??HalUARTWrite_6:
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock11
        REQUIRE IE2
        REQUIRE UCA0TXBUF
//  469 }
//  470 
//  471 /*************************************************************************************************
//  472  * @fn      Hal_UART_RxBufLen()
//  473  *
//  474  * @brief   Calculate Rx Buffer length of a port
//  475  *
//  476  * @param   port - UART port (not used.)
//  477  *
//  478  * @return  length of current Rx Buffer
//  479  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  480 uint16 Hal_UART_RxBufLen (uint8 port)
Hal_UART_RxBufLen:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function Hal_UART_RxBufLen
//  481 {
//  482   int16 length = uartRecord.rx.bufferTail;
        MOV.W   &uartRecord + 10, R12
//  483 
//  484   length -= uartRecord.rx.bufferHead;
        SUB.W   &uartRecord + 8, R12
//  485   if  (length < 0)
        CMP.W   #0x0, R12
        JGE     ??Hal_UART_RxBufLen_0
//  486     length += uartRecord.rx.maxBufSize;
        ADD.W   &uartRecord + 12, R12
//  487 
//  488   return (uint16)length;
??Hal_UART_RxBufLen_0:
        RETA
          CFI EndBlock cfiBlock12
//  489 }
//  490 
//  491 /*************************************************************************************************
//  492  * @fn      Hal_UART_TxBufLen()
//  493  *
//  494  * @brief   Calculate Tx Buffer length of a port
//  495  *
//  496  * @param   port - UART port (not used.)
//  497  *
//  498  * @return  length of current Tx buffer
//  499  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  500 uint16 Hal_UART_TxBufLen ( uint8 port )
Hal_UART_TxBufLen:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function Hal_UART_TxBufLen
//  501 {
//  502   int16 length = uartRecord.tx.bufferTail;
        MOV.W   &uartRecord + 18, R12
//  503 
//  504   length -= uartRecord.tx.bufferHead;
        SUB.W   &uartRecord + 16, R12
//  505   if  (length < 0)
        CMP.W   #0x0, R12
        JGE     ??Hal_UART_TxBufLen_0
//  506     length += uartRecord.tx.maxBufSize;
        ADD.W   &uartRecord + 20, R12
//  507 
//  508   return (uint16)length;
??Hal_UART_TxBufLen_0:
        RETA
          CFI EndBlock cfiBlock13
//  509 }
//  510 
//  511 /*-------------------------------------------------------------------------------------------------
//  512                                            HELP FUNCTIONS
//  513 -------------------------------------------------------------------------------------------------*/
//  514 
//  515 /*************************************************************************************************
//  516  * @fn      HalUARTSendCallBack
//  517  *
//  518  * @brief   Send Callback back to the caller
//  519  *
//  520  * @param   port - UART port
//  521  *          event - event that causes the call back
//  522  *
//  523  * @return  None
//  524  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  525 static void Hal_UART_SendCallBack(uint8 port, uint8 event)
Hal_UART_SendCallBack:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function Hal_UART_SendCallBack
//  526 {
//  527   if (uartRecord.callBackFunc)
        FUNCALL Hal_UART_SendCallBack
        LOCFRAME CSTACK, 4, STACK
        MOV.W   &uartRecord + 30, R15
        BIS.W   &uartRecord + 32, R15
        CMP.W   #0x0, R15
        JEQ     ??Hal_UART_SendCallBack_0
//  528   {
//  529     (uartRecord.callBackFunc)(port, event);
        CALLA   &uartRecord + 30
//  530   }
//  531 }
??Hal_UART_SendCallBack_0:
        RETA
          CFI EndBlock cfiBlock14
//  532 
//  533 /*************************************************************************************************
//  534  * @fn      Hal_UART_ProcessRxEvent
//  535  *
//  536  * @brief   Process the Rx data by putting them in Rx Buffer. Callback will happen if idle timeout
//  537  *          or Rx buffer is full
//  538  *
//  539  * @param   void
//  540  *
//  541  * @return  void
//  542  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  543 static void Hal_UART_RxProcessEvent(void)
Hal_UART_RxProcessEvent:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function Hal_UART_RxProcessEvent
//  544 {
//  545   uint8 ch = HAL_UART_GETBYTE();
        FUNCALL Hal_UART_RxProcessEvent, osal_GetSystemClock
        LOCFRAME CSTACK, 4, STACK
        MOV.B   &0x66, R14
//  546 
//  547   uartRecord.rx.pBuffer[uartRecord.rx.bufferTail++] = ch;
        MOV.W   &uartRecord + 10, R15
        MOV.W   R15, R13
        ADD.W   #0x1, R13
        MOV.W   R13, &uartRecord + 10
        MOV.W   &uartRecord + 14, R13
        ADD.W   R15, R13
        MOV.B   R14, 0(R13)
//  548   if (uartRecord.rx.bufferTail >= uartRecord.rx.maxBufSize)
        CMP.W   &uartRecord + 12, &uartRecord + 10
        JNC     ??Hal_UART_RxProcessEvent_0
//  549   {
//  550     uartRecord.rx.bufferTail = 0;
        MOV.W   #0x0, &uartRecord + 10
//  551   }
//  552 
//  553   uartRecord.rxChRvdTime = osal_GetSystemClock();
??Hal_UART_RxProcessEvent_0:
        CALLA   #osal_GetSystemClock
        MOV.W   R12, &uartRecord + 26
        MOV.W   R13, &uartRecord + 28
//  554 }
        RETA
          CFI EndBlock cfiBlock15
        REQUIRE UCA0RXBUF
//  555 
//  556 /*************************************************************************************************
//  557  * @fn      Hal_UART_ProcessTxEvent
//  558  *
//  559  * @brief   Process Tx buffer and events
//  560  *
//  561  * @param   void
//  562  *
//  563  * @return  void
//  564  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  565 static void Hal_UART_TxProcessEvent(void)
Hal_UART_TxProcessEvent:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function Hal_UART_TxProcessEvent
//  566 {
//  567   uint16 tail = uartRecord.tx.bufferTail;
        MOV.W   &uartRecord + 18, R15
//  568 
//  569   if (++uartRecord.tx.bufferHead >= uartRecord.tx.maxBufSize)
        MOV.W   &uartRecord + 16, R14
        ADD.W   #0x1, R14
        MOV.W   R14, &uartRecord + 16
        CMP.W   &uartRecord + 20, R14
        JNC     ??Hal_UART_TxProcessEvent_0
//  570   {
//  571     uartRecord.tx.bufferHead = 0;
        MOV.W   #0x0, &uartRecord + 16
//  572   }
//  573 
//  574   if (uartRecord.tx.bufferHead != tail)
??Hal_UART_TxProcessEvent_0:
        CMP.W   R15, &uartRecord + 16
        JEQ     ??Hal_UART_TxProcessEvent_1
//  575   {
//  576     HAL_UART_PUTBYTE(uartRecord.tx.pBuffer[uartRecord.tx.bufferHead]);  // Send a char to UART.
        MOV.W   &uartRecord + 22, R15
        ADD.W   &uartRecord + 16, R15
        MOV.B   @R15, &0x67
        RETA
//  577   }
//  578   else
//  579   {
//  580     HAL_UART_TX_INT_DISABLE();
??Hal_UART_TxProcessEvent_1:
        BIC.B   #0x2, &0x1
//  581     HAL_UART_CLR_TX_STATUS();
        BIC.B   #0x2, &0x3
//  582   }
//  583 }
        RETA
          CFI EndBlock cfiBlock16
        REQUIRE UCA0TXBUF
        REQUIRE IE2
        REQUIRE IFG2
//  584 
//  585 /*************************************************************************************************
//  586  * @fn      Hal_UART_SetFlowControl
//  587  *
//  588  * @brief   Set UART Rx flow control
//  589  *
//  590  * @param   port: serial port (not used.)
//  591  *          on:   0=OFF, !0=ON
//  592  *
//  593  * @return  none
//  594  *
//  595  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  596 void Hal_UART_FlowControlSet( uint8 port, uint8 status )
Hal_UART_FlowControlSet:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function Hal_UART_FlowControlSet
//  597 {
//  598   if ( status == HAL_UART_FLOW_ON )
        CMP.B   #0x1, R13
        JNE     ??Hal_UART_FlowControlSet_0
//  599     HAL_UART_CTS_PORT &= ~HAL_UART_CTS_BIT;  /* Enable RX flow */
        BIC.B   #0x40, &0x29
        RETA
//  600   else
//  601     HAL_UART_CTS_PORT |= HAL_UART_CTS_BIT;   /* Disable RX flow */  
??Hal_UART_FlowControlSet_0:
        BIS.B   #0x40, &0x29
//  602 }
        RETA
          CFI EndBlock cfiBlock17
        REQUIRE P2OUT
//  603 
//  604 /*-------------------------------------------------------------------------------------------------
//  605                                     Interrupt Service Routines
//  606 -------------------------------------------------------------------------------------------------*/
//  607 
//  608 /*************************************************************************************************
//  609  * @fn      UART Rx/Tx ISR
//  610  *
//  611  * @brief   Called when a serial byte is ready to read and/or write.
//  612  *  NOTE:   Assumes that uartRecord.configured is TRUE if this interrupt is enabled.
//  613  *
//  614  * @param   void
//  615  *
//  616  * @return  void
//  617 **************************************************************************************************/
//  618 

        RSEG ISR_CODE:CODE:REORDER:NOROOT(1)
//  619 INTERRUPT_UART_RX_READY()
halBoardUart1RxReadyIsr:
          CFI Block cfiBlock18 Using cfiCommon2
          CFI Function halBoardUart1RxReadyIsr
//  620 {
        FUNCALL halBoardUart1RxReadyIsr, Hal_UART_RxProcessEvent
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R15
          CFI R12L Frame(CFA, -12)
          CFI R13L Frame(CFA, -10)
          CFI R14L Frame(CFA, -8)
          CFI R15L Frame(CFA, -6)
          CFI CFA SP+12
//  621   Hal_UART_RxProcessEvent();
        CALLA   #Hal_UART_RxProcessEvent
//  622 }
        POPM.W  #0x4, R15
          CFI R12L SameValue
          CFI R13L SameValue
          CFI R14L SameValue
          CFI R15L SameValue
          CFI CFA SP+4
        RETI
          CFI EndBlock cfiBlock18
//  623 
//  624 
//  625 /**************************************************************************************************
//  626  * @fn      INTERRUPT_UART0_TX_READY
//  627  *
//  628  * @brief   Called when xmtr shift register and buffer are both empty.
//  629  *
//  630  * @param   void
//  631  *
//  632  * @return  void
//  633  **************************************************************************************************/
//  634 

        RSEG ISR_CODE:CODE:REORDER:NOROOT(1)
//  635 INTERRUPT_UART_TX_READY()
halBoardUart1TxReadyIsr:
          CFI Block cfiBlock19 Using cfiCommon2
          CFI Function halBoardUart1TxReadyIsr
//  636 {
        FUNCALL halBoardUart1TxReadyIsr, Hal_UART_TxProcessEvent
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R15
          CFI R12L Frame(CFA, -12)
          CFI R13L Frame(CFA, -10)
          CFI R14L Frame(CFA, -8)
          CFI R15L Frame(CFA, -6)
          CFI CFA SP+12
//  637   Hal_UART_TxProcessEvent();
        CALLA   #Hal_UART_TxProcessEvent
//  638 }
        POPM.W  #0x4, R15
          CFI R12L SameValue
          CFI R13L SameValue
          CFI R14L SameValue
          CFI R15L SameValue
          CFI CFA SP+4
        RETI
          CFI EndBlock cfiBlock19

        COMMON INTVEC:CONST:ROOT(1)
        ORG 44
`??halBoardUart1TxReadyIsr??INTVEC 44`:
        DC16    halBoardUart1TxReadyIsr

        COMMON INTVEC:CONST:ROOT(1)
        ORG 46
`??halBoardUart1RxReadyIsr??INTVEC 46`:
        DC16    halBoardUart1RxReadyIsr

        RSEG DATA16_ID:CONST:SORT:NOROOT(1)
`?<Initializer for UBRRTable>`:
        DC16 625, 312, 156, 104, 52

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  639 
// 
// 890 bytes in segment CODE
//  11 bytes in segment DATA16_AN
//  10 bytes in segment DATA16_I
//  10 bytes in segment DATA16_ID
//  34 bytes in segment DATA16_Z
//   4 bytes in segment INTVEC
//  20 bytes in segment ISR_CODE
// 
// 910 bytes of CODE  memory
//  10 bytes of CONST memory (+  4 bytes shared)
//  44 bytes of DATA  memory (+ 11 bytes shared)
//
//Errors: none
//Warnings: none

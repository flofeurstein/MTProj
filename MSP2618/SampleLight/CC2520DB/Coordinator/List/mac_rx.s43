///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430      10/Jun/2013  16:24:35 /
// Copyright 1996-2013 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\m /
//                     ac\low_level\srf04\mac_rx.c                            /
//    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleLight\CC2520DB\..\..\..\T /
//                     ools\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0    /
//                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                      /
//                     -DDEFAULT_CHANLIST=0x00000800                          /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100     /
//                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                  /
//                     -DBEACON_REQUEST_DELAY=100                             /
//                     -DBEACON_REQ_DELAY_MASK=0x00FF                         /
//                     -DLINK_STATUS_JITTER_MASK=0x007F                       /
//                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED /
//                     =3000 -DNWK_INDIRECT_MSG_TIMEOUT=7                     /
//                     -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3        /
//                     -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2  /
//                     -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16                      /
//                     -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4       /
//                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,      /
//                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,  /
//                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                   /
//                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS= /
//                     20 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000         /
//                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100        /
//                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\ /
//                     f8wCoord.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE=T /
//                     RUE -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         /
//                     -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK) -f     /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\..\..\..\Tool /
//                     s\MSP2618\f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE          /
//                     -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF                /
//                     -DZCL_KEY_ESTABLISH -DZCL_KEY_ESTABLISHMENT_KEY_GENERA /
//                     TE_TIMEOUT=4 -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIME /
//                     OUT=10 -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=1 /
//                     0 -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING             /
//                     -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING            /
//                     -DZCL_TOU) -DZCL_DEVICE_MGMT "C:\Texas                 /
//                     Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_le /
//                     vel\srf04\mac_rx.c" -D MSP430F2618 -D ZTOOL_P1 -D      /
//                     MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D               /
//                     LCD_SUPPORTED -lC "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\Coordinator\List\" -lA  /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\Coordinator\L /
//                     ist\" --remarks --diag_suppress                        /
//                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\Coordinator\Obj\"       /
//                     --debug -D__MSP430F2618__ -e --double=32 --clib -I     /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\" -I          /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\..\Source\"   /
//                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleLight\CC2520DB\..\..\Sour /
//                     ce\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pro /
//                     jects\zstack\HomeAutomation\SampleLight\CC2520DB\..\.. /
//                     \..\ZMain\MSP2618\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\hal\include\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\hal\target\MSP2618CC2520\" -I "C:\Texas             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\include\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\high_level\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\low_level\srf04\" -I "C:\Texas                  /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\low_level\srf04\dual_chip\" -I "C:\Texas        /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ /
//                     Projects\zstack\HomeAutomation\SampleLight\CC2520DB\.. /
//                     \..\..\..\..\Components\osal\include\" -I "C:\Texas    /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\osal\mcu\msp430\" -I "C:\Texas                      /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\services\saddr\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\services\sdata\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\af\" -I "C:\Texas                             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\nwk\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sec\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sapi\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sys\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\zcl\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\zdo\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5. /
//                     1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB\ /
//                     ..\..\..\..\..\Components\zmac\f8w\" --core=430X       /
//                     --data_model=small -Ohz --multiplier=16s               /
//                     --require_prototypes                                   /
//    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst /
//                     ack\HomeAutomation\SampleLight\CC2520DB\Coordinator\Li /
//                     st\mac_rx.s43                                          /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME mac_rx

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBWEAK P1IE
        PUBWEAK P1IFG
        PUBWEAK P1IN
        PUBLIC macRxAckTxDoneCallback
        FUNCTION macRxAckTxDoneCallback,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macRxActive
        PUBLIC macRxFifoOverflowIsr
        FUNCTION macRxFifoOverflowIsr,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macRxFilter
        PUBLIC macRxHaltCleanup
        FUNCTION macRxHaltCleanup,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macRxInit
        FUNCTION macRxInit,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macRxOutgoingAckFlag
        PUBLIC macRxPromiscuousMode
        FUNCTION macRxPromiscuousMode,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macRxRadioPowerUpInit
        FUNCTION macRxRadioPowerUpInit,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macRxThresholdIsr
        FUNCTION macRxThresholdIsr,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macRxTxReset
        FUNCTION macRxTxReset,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION rxAddrIsr,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 26, STACK
        FUNCTION rxDiscardFrame,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION rxDiscardIsr,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        FUNCTION rxDone,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION rxFcsIsr,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 16, STACK
        FUNCTION rxHaltCleanupFinalStep,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION rxPayloadIsr,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION rxPostRxUpdates,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION rxPrepPayload,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION rxStartIsr,0a1603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 22, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        EXTERN macDualchipOrFRMFILT0
        FUNCTION macDualchipOrFRMFILT0,0202H
        EXTERN halAssertHandler
        FUNCTION halAssertHandler,0202H
        EXTERN macDualchipAndFRMFILT0
        FUNCTION macDualchipAndFRMFILT0,0202H
        EXTERN macSpiReadRxFifo
        FUNCTION macSpiReadRxFifo,0202H
        EXTERN macSpiWriteReg
        FUNCTION macSpiWriteReg,0202H
        EXTERN macRxOffRequest
        FUNCTION macRxOffRequest,0202H
        EXTERN macRadioUpdateTxPower
        FUNCTION macRadioUpdateTxPower,0202H
        EXTERN macTxStartQueuedFrame
        FUNCTION macTxStartQueuedFrame,0202H
        EXTERN macSpiCmdStrobe
        FUNCTION macSpiCmdStrobe,0202H
        EXTERN macSrcMatchIsEnabled
        EXTERN MAC_SrcMatchCheckResult
        FUNCTION MAC_SrcMatchCheckResult,0202H
        EXTERN macRadioComputeLQI
        FUNCTION macRadioComputeLQI,0202H
        EXTERN macRxCompleteCallback
        FUNCTION macRxCompleteCallback,0202H
        EXTERN macDataRxMemFree
        FUNCTION macDataRxMemFree,0202H
        EXTERN sAddrExtCpy
        FUNCTION sAddrExtCpy,0202H
        EXTERN macRxOnFlag
        EXTERN macChipVersion
        EXTERN macTxActive
        EXTERN pMacDataTx
        EXTERN macTxAckReceivedCallback
        FUNCTION macTxAckReceivedCallback,0202H
        EXTERN macTxAckNotReceivedCallback
        FUNCTION macTxAckNotReceivedCallback,0202H
        EXTERN macDataRxMemAlloc
        FUNCTION macDataRxMemAlloc,0202H
        EXTERN macRxCheckMACPendingCallback
        FUNCTION macRxCheckMACPendingCallback,0202H
        EXTERN MAC_SrcMatchCheckAllPending
        FUNCTION MAC_SrcMatchCheckAllPending,0202H
        EXTERN osal_memcpy
        FUNCTION osal_memcpy,0202H
        EXTERN macMcuTimerBackoffCapture
        FUNCTION macMcuTimerBackoffCapture,0202H
        EXTERN macMcuTimerTickCapture
        FUNCTION macMcuTimerTickCapture,0202H
        EXTERN macRxCheckPendingCallback
        FUNCTION macRxCheckPendingCallback,0202H
        EXTERN macRxHardDisable
        FUNCTION macRxHardDisable,0202H

// C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_level\srf04\mac_rx.c
//    1 /**************************************************************************************************
//    2   Filename:       mac_rx.c
//    3   Revised:        $Date: 2007-10-08 14:05:36 -0700 (Mon, 08 Oct 2007) $
//    4   Revision:       $Revision: 15624 $
//    5 
//    6   Description:    Describe the purpose and contents of the file.
//    7 
//    8 
//    9   Copyright 2006-2012 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /* ------------------------------------------------------------------------------------------------
//   41  *                                          Includes
//   42  * ------------------------------------------------------------------------------------------------
//   43  */
//   44 
//   45 /* hal */
//   46 #include "hal_defs.h"
//   47 #include "hal_types.h"
//   48 
//   49 /* OSAL */
//   50 #include "OSAL.h"
//   51 
//   52 /* high-level */
//   53 #include "mac_high_level.h"
//   54 #include "mac_spec.h"
//   55 
//   56 /* MAC security */
//   57 #include "mac_security.h"
//   58 
//   59 /* exported low-level */
//   60 #include "mac_low_level.h"
//   61 
//   62 /* low-level specific */
//   63 #include "mac_rx.h"
//   64 #include "mac_tx.h"
//   65 #include "mac_rx_onoff.h"
//   66 #include "mac_radio.h"
//   67 
//   68 /* target specific */
//   69 #include "mac_radio_defs.h"

        ASEGN DATA16_AN:DATA:NOROOT,020H
// unsigned char const volatile P1IN
P1IN:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,023H
// unsigned char volatile P1IFG
P1IFG:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,025H
// unsigned char volatile P1IE
P1IE:
        DS8 1
//   70 #include "mac_autopend.h"
//   71 
//   72 /* debug */
//   73 #include "mac_assert.h"
//   74 
//   75 
//   76 /* ------------------------------------------------------------------------------------------------
//   77  *                                            Defines
//   78  * ------------------------------------------------------------------------------------------------
//   79  */
//   80 #define MAX_PAYLOAD_BYTES_READ_PER_INTERRUPT   16   /* adjustable to tune performance */
//   81 
//   82 /* receive FIFO bytes needed to start a valid receive (see function rxStartIsr for details) */
//   83 #define RX_THRESHOLD_START_LEN    (MAC_PHY_PHR_LEN        +  \ 
//   84                                    MAC_FCF_FIELD_LEN      +  \ 
//   85                                    MAC_SEQ_NUM_FIELD_LEN  +  \ 
//   86                                    MAC_FCS_FIELD_LEN)
//   87 
//   88 /* maximum size of addressing fields (note: command frame identifier processed as part of address) */
//   89 #define MAX_ADDR_FIELDS_LEN  ((MAC_EXT_ADDR_FIELD_LEN + MAC_PAN_ID_FIELD_LEN) * 2)
//   90 
//   91 /* addressing mode reserved value */
//   92 #define ADDR_MODE_RESERVERED  1
//   93 
//   94 /* length of command frame identifier */
//   95 #define CMD_FRAME_ID_LEN      1
//   96 
//   97 /* packet size mask is equal to the maximum value */
//   98 #define PHY_PACKET_SIZE_MASK  0x7F
//   99 
//  100 /* value for promiscuous off, must not conflict with other mode variants from separate include files */
//  101 #define PROMISCUOUS_MODE_OFF  0x00
//  102 
//  103 /* bit of proprietary FCS format that indicates if the CRC is OK */
//  104 #define PROPRIETARY_FCS_CRC_OK_BIT  0x80
//  105 
//  106 /* dummy length value for unused entry in lookup table */
//  107 #define DUMMY_LEN   0xBE
//  108 
//  109 /* value for rxThresholdIntState */
//  110 #define RX_THRESHOLD_INT_STATE_INACTIVE   0
//  111 #define RX_THRESHOLD_INT_STATE_ACTIVE     1
//  112 #define RX_THRESHOLD_INT_STATE_RESET      2
//  113 
//  114 
//  115 /* ------------------------------------------------------------------------------------------------
//  116  *                                             Macros
//  117  * ------------------------------------------------------------------------------------------------
//  118  */
//  119 #define MEM_ALLOC(x)   macDataRxMemAlloc(x)
//  120 #define MEM_FREE(x)    macDataRxMemFree((uint8 **)x)
//  121 
//  122 /*
//  123  *  Macro for encoding frame control information into internal flags format.
//  124  *  Parameter is pointer to the frame.  NOTE!  If either the internal frame
//  125  *  format *or* the specification changes, this macro will need to be modified.
//  126  */
//  127 #define INTERNAL_FCF_FLAGS(p)  ((((p)[1] >> 4) & 0x03) | ((p)[0] & 0x78))
//  128 
//  129 /*
//  130  *  The radio replaces the actual FCS with different information.  This proprietary FCS is
//  131  *  the same length as the original and includes:
//  132  *    1) the RSSI value
//  133  *    2) the average correlation value (used for LQI)
//  134  *    3) a CRC passed bit
//  135  *
//  136  *  These macros decode the proprietary FCS.  The macro parameter is a pointer to the two byte FCS.
//  137  */
//  138 #define PROPRIETARY_FCS_RSSI(p)                 ((int8)((p)[0]))
//  139 #define PROPRIETARY_FCS_CRC_OK(p)               ((p)[1] & PROPRIETARY_FCS_CRC_OK_BIT)
//  140 #define PROPRIETARY_FCS_CORRELATION_VALUE(p)    ((p)[1] & ~PROPRIETARY_FCS_CRC_OK_BIT)
//  141 
//  142 /*
//  143  *  Macros for security control field.
//  144  */
//  145 #define SECURITY_LEVEL(s)                       (s & 0x07)
//  146 #define KEY_IDENTIFIER_MODE(s)                  ((s & 0x18) >> 3)
//  147 #define SECURITY_CONTROL_RESERVED(s)            ((s & 0xE0) >> 5)
//  148 
//  149 /* ------------------------------------------------------------------------------------------------
//  150  *                                       Global Variables
//  151  * ------------------------------------------------------------------------------------------------
//  152  */

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  153 uint8 macRxActive;
macRxActive:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  154 uint8 macRxFilter;
macRxFilter:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  155 uint8 macRxOutgoingAckFlag;
macRxOutgoingAckFlag:
        DS8 1
//  156 
//  157 
//  158 /* ------------------------------------------------------------------------------------------------
//  159  *                                       Local Constants
//  160  * ------------------------------------------------------------------------------------------------
//  161  */

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
//  162 static const uint8 CODE macRxAddrLen[] =
macRxAddrLen:
        DC8 0, 190, 4, 10
//  163 {
//  164   0,                                                /* no address */
//  165   DUMMY_LEN,                                        /* reserved */
//  166   MAC_PAN_ID_FIELD_LEN + MAC_SHORT_ADDR_FIELD_LEN,  /* short address + pan id */
//  167   MAC_PAN_ID_FIELD_LEN + MAC_EXT_ADDR_FIELD_LEN     /* extended address + pan id */
//  168 };
//  169 
//  170 
//  171 /* ------------------------------------------------------------------------------------------------
//  172  *                                       Local Prototypes
//  173  * ------------------------------------------------------------------------------------------------
//  174  */
//  175 static void rxHaltCleanupFinalStep(void);
//  176 
//  177 static void rxStartIsr(void);
//  178 static void rxAddrIsr(void);
//  179 
//  180 #ifdef MAC_SECURITY
//  181   static void rxSecurityHdrIsr(void);
//  182 #endif
//  183   
//  184 static void rxPayloadIsr(void);
//  185 static void rxDiscardIsr(void);
//  186 static void rxFcsIsr(void);
//  187 
//  188 static void rxPrepPayload(void);
//  189 static void rxDiscardFrame(void);
//  190 static void rxDone(void);
//  191 static void rxPostRxUpdates(void);
//  192 
//  193 
//  194 /* ------------------------------------------------------------------------------------------------
//  195  *                                         Local Variables
//  196  * ------------------------------------------------------------------------------------------------
//  197  */

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  198 static void    (* pFuncRxState)(void);
pFuncRxState:
        DS8 4

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  199 static macRx_t  * pRxBuf;
pRxBuf:
        DS8 2
//  200 

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  201 static uint8  rxBuf[MAC_PHY_PHR_LEN + MAC_FCF_FIELD_LEN + MAC_SEQ_NUM_FIELD_LEN];
rxBuf:
        DS8 4

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  202 static uint8  rxUnreadLen;
rxUnreadLen:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  203 static uint8  rxNextLen;
rxNextLen:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  204 static uint8  rxPayloadLen;
rxPayloadLen:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  205 static uint8  rxFilter;
rxFilter:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  206 static uint8  rxPromiscuousMode;
rxPromiscuousMode:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  207 static uint8  rxIsrActiveFlag;
rxIsrActiveFlag:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  208 static uint8  rxResetFlag;
rxResetFlag:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  209 static uint8  rxFifoOverflowCount;
rxFifoOverflowCount:
        DS8 1
//  210 
//  211 #ifdef PACKET_FILTER_STATS
//  212   uint32      rxCrcFailure = 0;
//  213   uint32      rxCrcSuccess = 0;
//  214 #endif /* PACKET_FILTER_STATS */
//  215 
//  216 #ifdef CC2591_COMPRESSION_WORKAROUND
//  217   void macRxResetRssi(void);
//  218 #endif
//  219 
//  220 /**************************************************************************************************
//  221  * @fn          macRxInit
//  222  *
//  223  * @brief       Initialize receive variable states.
//  224  *
//  225  * @param       none
//  226  *
//  227  * @return      none
//  228  **************************************************************************************************
//  229  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  230 MAC_INTERNAL_API void macRxInit(void)
macRxInit:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function macRxInit
//  231 {
//  232   macRxFilter          = RX_FILTER_OFF;
        MOV.B   #0x0, &macRxFilter
//  233   rxPromiscuousMode    = PROMISCUOUS_MODE_OFF;
        MOV.B   #0x0, &rxPromiscuousMode
//  234   pRxBuf               = NULL; /* required for macRxReset() to function correctly */
        MOV.W   #0x0, &pRxBuf
//  235   macRxActive          = MAC_RX_ACTIVE_NO_ACTIVITY;
        MOV.B   #0x0, &macRxActive
//  236   pFuncRxState         = &rxStartIsr;
        CALLA   #?Subroutine8
//  237   macRxOutgoingAckFlag = 0;
??CrossCallReturnLabel_9:
        MOV.B   #0x0, &macRxOutgoingAckFlag
//  238   rxIsrActiveFlag      = 0;
        MOV.B   #0x0, &rxIsrActiveFlag
//  239   rxResetFlag          = 0;
        MOV.B   #0x0, &rxResetFlag
//  240   rxFifoOverflowCount  = 0;
        MOV.B   #0x0, &rxFifoOverflowCount
//  241 }
        RETA
          CFI EndBlock cfiBlock0

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine8:
          CFI Block cfiCond1 Using cfiCommon0
          CFI Function rxDiscardIsr
          CFI Conditional ??CrossCallReturnLabel_10, ??rxDiscardIsr_1
          CFI CFA SP+28
          CFI Block cfiCond2 Using cfiCommon0
          CFI (cfiCond2) Function rxFcsIsr
          CFI (cfiCond2) Conditional ??CrossCallReturnLabel_10, ??CrossCallReturnLabel_0
          CFI (cfiCond2) R6L Frame(CFA, -16)
          CFI (cfiCond2) R7L Frame(CFA, -14)
          CFI (cfiCond2) R8L Frame(CFA, -12)
          CFI (cfiCond2) R9L Frame(CFA, -10)
          CFI (cfiCond2) R10L Frame(CFA, -8)
          CFI (cfiCond2) R11L Frame(CFA, -6)
          CFI (cfiCond2) CFA SP+24
          CFI Block cfiCond3 Using cfiCommon0
          CFI (cfiCond3) Function rxHaltCleanupFinalStep
          CFI (cfiCond3) Conditional ??CrossCallReturnLabel_8
          CFI (cfiCond3) CFA SP+8
          CFI Block cfiCond4 Using cfiCommon0
          CFI (cfiCond4) Function macRxInit
          CFI (cfiCond4) Conditional ??CrossCallReturnLabel_9
          CFI (cfiCond4) CFA SP+8
          CFI Block cfiPicker5 Using cfiCommon1
          CFI (cfiPicker5) NoFunction
          CFI (cfiPicker5) Picker
        MOV.W   #LWRD(rxStartIsr), &pFuncRxState
        MOV.W   #HWRD(rxStartIsr), &pFuncRxState + 2
        RETA
          CFI EndBlock cfiCond1
          CFI EndBlock cfiCond2
          CFI EndBlock cfiCond3
          CFI EndBlock cfiCond4
          CFI EndBlock cfiPicker5
//  242 
//  243 
//  244 /**************************************************************************************************
//  245  * @fn          macRxRadioPowerUpInit
//  246  *
//  247  * @brief       Initialization for after radio first powers up.
//  248  *
//  249  * @param       none
//  250  *
//  251  * @return      none
//  252  **************************************************************************************************
//  253  */

        RSEG CODE:CODE:NOROOT(1)
?Subroutine2:
          CFI Block cfiCond6 Using cfiCommon0
          CFI Function rxHaltCleanupFinalStep
          CFI Conditional ??CrossCallReturnLabel_16
          CFI CFA SP+8
          CFI Block cfiCond7 Using cfiCommon0
          CFI (cfiCond7) Function macRxRadioPowerUpInit
          CFI (cfiCond7) Conditional ??CrossCallReturnLabel_15
          CFI (cfiCond7) CFA SP+8
          CFI Block cfiPicker8 Using cfiCommon1
          CFI (cfiPicker8) NoFunction
          CFI (cfiPicker8) Picker
        MOV.B   #0x5, R13
          CFI EndBlock cfiCond6
          CFI EndBlock cfiCond7
          CFI EndBlock cfiPicker8
        REQUIRE ??Subroutine2_0
        // Fall through to label ??Subroutine2_0

        RSEG CODE:CODE:REORDER:NOROOT(1)
??Subroutine2_0:
          CFI Block cfiCond9 Using cfiCommon0
          CFI Function rxDiscardIsr
          CFI Conditional ??CrossCallReturnLabel_14
          CFI CFA SP+24
          CFI Block cfiCond10 Using cfiCommon0
          CFI (cfiCond10) Function rxDiscardFrame
          CFI (cfiCond10) Conditional ??CrossCallReturnLabel_13
          CFI (cfiCond10) CFA SP+8
          CFI Block cfiCond11 Using cfiCommon0
          CFI (cfiCond11) Function rxPrepPayload
          CFI (cfiCond11) Conditional ??CrossCallReturnLabel_12
          CFI (cfiCond11) CFA SP+8
          CFI Block cfiCond12 Using cfiCommon0
          CFI (cfiCond12) Function rxStartIsr
          CFI (cfiCond12) Conditional ??CrossCallReturnLabel_11
          CFI (cfiCond12) R4L Frame(CFA, -20)
          CFI (cfiCond12) R5L Frame(CFA, -18)
          CFI (cfiCond12) R6L Frame(CFA, -16)
          CFI (cfiCond12) R7L Frame(CFA, -14)
          CFI (cfiCond12) R8L Frame(CFA, -12)
          CFI (cfiCond12) R9L Frame(CFA, -10)
          CFI (cfiCond12) R10L Frame(CFA, -8)
          CFI (cfiCond12) R11L Frame(CFA, -6)
          CFI (cfiCond12) CFA SP+26
          CFI Block cfiCond13 Using cfiCommon0
          CFI (cfiCond13) Function rxHaltCleanupFinalStep
          CFI (cfiCond13) Conditional ??CrossCallReturnLabel_16
          CFI (cfiCond13) CFA SP+8
          CFI Block cfiCond14 Using cfiCommon0
          CFI (cfiCond14) Function macRxRadioPowerUpInit
          CFI (cfiCond14) Conditional ??CrossCallReturnLabel_15
          CFI (cfiCond14) CFA SP+8
          CFI Block cfiPicker15 Using cfiCommon1
          CFI (cfiPicker15) NoFunction
          CFI (cfiPicker15) Picker
        MOV.B   #0x34, R12
        BRA     #macSpiWriteReg
          CFI EndBlock cfiCond9
          CFI EndBlock cfiCond10
          CFI EndBlock cfiCond11
          CFI EndBlock cfiCond12
          CFI EndBlock cfiCond13
          CFI EndBlock cfiCond14
          CFI EndBlock cfiPicker15

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  254 MAC_INTERNAL_API void macRxRadioPowerUpInit(void)
macRxRadioPowerUpInit:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function macRxRadioPowerUpInit
//  255 {
//  256   /* set threshold at initial value */
//  257   MAC_RADIO_SET_RX_THRESHOLD(RX_THRESHOLD_START_LEN);
        FUNCALL macRxRadioPowerUpInit, macSpiWriteReg
        LOCFRAME CSTACK, 4, STACK
        CALLA   #?Subroutine2
//  258 
//  259   /* clear any accidental threshold interrupt that happened as part of power up sequence */
//  260   MAC_RADIO_CLEAR_RX_THRESHOLD_INTERRUPT_FLAG();
??CrossCallReturnLabel_15:
        BIC.B   #0x40, &0x23
//  261 
//  262   /* enable threshold interrupts */
//  263   MAC_RADIO_ENABLE_RX_THRESHOLD_INTERRUPT();
        BIS.B   #0x40, &0x25
//  264 }
        RETA
          CFI EndBlock cfiBlock16
        REQUIRE P1IFG
        REQUIRE P1IE
//  265 
//  266 
//  267 /**************************************************************************************************
//  268  * @fn          macRxTxReset
//  269  *
//  270  * @brief       Reset the receive state.
//  271  *
//  272  * @param       none
//  273  *
//  274  * @return      none
//  275  **************************************************************************************************
//  276  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  277 MAC_INTERNAL_API void macRxTxReset(void)
macRxTxReset:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function macRxTxReset
//  278 {
//  279   /* forces receiver off, cleans up by calling macRxHaltCleanup() and macTxHaltCleanup() */
//  280   macRxHardDisable();
        FUNCALL macRxTxReset, macRxHardDisable
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macRxTxReset, macRxPromiscuousMode
        LOCFRAME CSTACK, 4, STACK
        CALLA   #macRxHardDisable
//  281 
//  282   /*
//  283    *   Note : transmit does not require any reset logic
//  284    *          beyond what macRxHardDisable() provides.
//  285    */
//  286 
//  287   /* restore deault filter mode to off */
//  288   macRxFilter = RX_FILTER_OFF;
        MOV.B   #0x0, &macRxFilter
//  289 
//  290   /* return promiscuous mode to default off state */
//  291   macRxPromiscuousMode(MAC_PROMISCUOUS_MODE_OFF);
        MOV.B   #0x0, R12
        BRA     #macRxPromiscuousMode
          CFI EndBlock cfiBlock17
//  292 }
//  293 
//  294 
//  295 /**************************************************************************************************
//  296  * @fn          macRxHaltCleanup
//  297  *
//  298  * @brief       Cleanup up the receive logic after receiver is forced off.
//  299  *
//  300  * @param       none
//  301  *
//  302  * @return      none
//  303  **************************************************************************************************
//  304  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  305 MAC_INTERNAL_API void macRxHaltCleanup(void)
macRxHaltCleanup:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function macRxHaltCleanup
//  306 {
//  307   rxResetFlag = 1;
        FUNCALL macRxHaltCleanup, rxHaltCleanupFinalStep
        LOCFRAME CSTACK, 4, STACK
        MOV.B   #0x1, &rxResetFlag
//  308   if (!rxIsrActiveFlag)
        CMP.B   #0x0, &rxIsrActiveFlag
        JNE     ??macRxHaltCleanup_0
//  309   {
//  310     rxHaltCleanupFinalStep();
        CALLA   #rxHaltCleanupFinalStep
//  311     rxResetFlag = 0;
        MOV.B   #0x0, &rxResetFlag
//  312   }
//  313 }
??macRxHaltCleanup_0:
        RETA
          CFI EndBlock cfiBlock18
//  314 
//  315 
//  316 /*=================================================================================================
//  317  * @fn          rxHaltCleanupFinalStep
//  318  *
//  319  * @brief       Required cleanup if receiver is halted in the middle of a receive.
//  320  *
//  321  * @param       none
//  322  *
//  323  * @return      none
//  324  *=================================================================================================
//  325  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine3:
          CFI Block cfiCond19 Using cfiCommon0
          CFI Function rxDone
          CFI Conditional ??rxDone_0
          CFI CFA SP+8
          CFI Block cfiCond20 Using cfiCommon0
          CFI (cfiCond20) Function rxStartIsr
          CFI (cfiCond20) Conditional ??rxStartIsr_5
          CFI (cfiCond20) R4L Frame(CFA, -20)
          CFI (cfiCond20) R5L Frame(CFA, -18)
          CFI (cfiCond20) R6L Frame(CFA, -16)
          CFI (cfiCond20) R7L Frame(CFA, -14)
          CFI (cfiCond20) R8L Frame(CFA, -12)
          CFI (cfiCond20) R9L Frame(CFA, -10)
          CFI (cfiCond20) R10L Frame(CFA, -8)
          CFI (cfiCond20) R11L Frame(CFA, -6)
          CFI (cfiCond20) CFA SP+26
          CFI Block cfiCond21 Using cfiCommon0
          CFI (cfiCond21) Function rxHaltCleanupFinalStep
          CFI (cfiCond21) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond21) CFA SP+8
          CFI Block cfiPicker22 Using cfiCommon1
          CFI (cfiPicker22) NoFunction
          CFI (cfiPicker22) Picker
        MOV.B   #0x47, R12
        CALLA   #macSpiCmdStrobe
        MOV.B   #0x47, R12
        BRA     #macSpiCmdStrobe
          CFI EndBlock cfiCond19
          CFI EndBlock cfiCond20
          CFI EndBlock cfiCond21
          CFI EndBlock cfiPicker22

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  326 static void rxHaltCleanupFinalStep(void)
rxHaltCleanupFinalStep:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function rxHaltCleanupFinalStep
//  327 {
//  328   /* cancel any upcoming ACK transmit complete callback */
//  329   MAC_RADIO_CANCEL_ACK_TX_DONE_CALLBACK();
//  330 
//  331   /* set start of frame threshold */
//  332   MAC_RADIO_SET_RX_THRESHOLD(RX_THRESHOLD_START_LEN);
        FUNCALL rxHaltCleanupFinalStep, macSpiWriteReg
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxHaltCleanupFinalStep, macSpiCmdStrobe
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxHaltCleanupFinalStep, macSpiCmdStrobe
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxHaltCleanupFinalStep, macDataRxMemFree
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxHaltCleanupFinalStep, rxPostRxUpdates
        LOCFRAME CSTACK, 4, STACK
        CALLA   #?Subroutine2
//  333 
//  334   /* flush the receive FIFO */
//  335   MAC_RADIO_FLUSH_RX_FIFO();
??CrossCallReturnLabel_16:
        CALLA   #?Subroutine3
//  336 
//  337   /* clear any receive interrupt that happened to squeak through */
//  338   MAC_RADIO_CLEAR_RX_THRESHOLD_INTERRUPT_FLAG();
??CrossCallReturnLabel_1:
        BIC.B   #0x40, &0x23
//  339 
//  340   /* if data buffer has been allocated, free it */
//  341   if (pRxBuf != NULL)
        CMP.W   #0x0, &pRxBuf
        JEQ     ??rxHaltCleanupFinalStep_0
//  342   {
//  343     MEM_FREE((uint8 **)&pRxBuf);
        MOV.W   #pRxBuf, R12
        CALLA   #macDataRxMemFree
//  344   }
//  345   /* MEM_FREE() sets parameter to NULL. */
//  346 
//  347   pFuncRxState = &rxStartIsr;
??rxHaltCleanupFinalStep_0:
        CALLA   #?Subroutine8
//  348 
//  349   /* if receive was active, perform the post receive updates */
//  350   if (macRxActive || macRxOutgoingAckFlag)
??CrossCallReturnLabel_8:
        CMP.B   #0x0, &macRxActive
        JNE     ??rxHaltCleanupFinalStep_1
        CMP.B   #0x0, &macRxOutgoingAckFlag
        JEQ     ??rxHaltCleanupFinalStep_2
//  351   {
//  352     macRxActive = MAC_RX_ACTIVE_NO_ACTIVITY;
??rxHaltCleanupFinalStep_1:
        MOV.B   #0x0, &macRxActive
//  353     macRxOutgoingAckFlag = 0;
        MOV.B   #0x0, &macRxOutgoingAckFlag
//  354 
//  355     rxPostRxUpdates();
        CALLA   #rxPostRxUpdates
//  356   }
//  357 }
??rxHaltCleanupFinalStep_2:
        RETA
          CFI EndBlock cfiBlock23
        REQUIRE P1IFG
//  358 
//  359 
//  360 /**************************************************************************************************
//  361  * @fn          macRxThresholdIsr
//  362  *
//  363  * @brief       Interrupt service routine called when bytes in FIFO reach threshold value.
//  364  *              It implements a state machine for receiving a packet.
//  365  *
//  366  * @param       none
//  367  *
//  368  * @return      none
//  369  **************************************************************************************************
//  370  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  371 MAC_INTERNAL_API void macRxThresholdIsr(void)
macRxThresholdIsr:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function macRxThresholdIsr
//  372 {
//  373   /* if currently reseting, do not execute receive ISR logic */
//  374   if (rxResetFlag)
        FUNCALL macRxThresholdIsr
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macRxThresholdIsr, rxHaltCleanupFinalStep
        LOCFRAME CSTACK, 4, STACK
        CMP.B   #0x0, &rxResetFlag
        JNE     ??macRxThresholdIsr_0
//  375   {
//  376     return;
//  377   }
//  378 
//  379   /*
//  380    *  Call the function that handles the current receive state.
//  381    *  A flag is set for the duration of the call to indicate
//  382    *  the ISR is executing.  This is necessary for the reset
//  383    *  logic so it does not perform a reset in the middle of
//  384    *  executing the ISR.
//  385    */
//  386   rxIsrActiveFlag = 1;
        MOV.B   #0x1, &rxIsrActiveFlag
//  387   (*pFuncRxState)();
        CALLA   &pFuncRxState
//  388   rxIsrActiveFlag = 0;
        MOV.B   #0x0, &rxIsrActiveFlag
//  389 
//  390   /* if a reset occurred during the ISR, peform cleanup here */
//  391   if (rxResetFlag)
        CMP.B   #0x0, &rxResetFlag
        JEQ     ??macRxThresholdIsr_0
//  392   {
//  393     rxHaltCleanupFinalStep();
        CALLA   #rxHaltCleanupFinalStep
//  394     rxResetFlag = 0;
        MOV.B   #0x0, &rxResetFlag
//  395   }
//  396 }
??macRxThresholdIsr_0:
        RETA
          CFI EndBlock cfiBlock24
//  397 
//  398 
//  399 /*=================================================================================================
//  400  * @fn          rxStartIsr
//  401  *
//  402  * @brief       First ISR state for receiving a packet - compute packet length, allocate
//  403  *              buffer, initialize buffer.  Acknowledgements are handled immediately without
//  404  *              allocating a buffer.
//  405  *
//  406  * @param       none
//  407  *
//  408  * @return      none
//  409  *=================================================================================================
//  410  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  411 static void rxStartIsr(void)
rxStartIsr:
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function rxStartIsr
//  412 {
        FUNCALL rxStartIsr, halAssertHandler
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, rxPostRxUpdates
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macSpiReadRxFifo
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, halAssertHandler
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macSpiReadRxFifo
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, halAssertHandler
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macRadioComputeLQI
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macTxAckReceivedCallback
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macTxAckNotReceivedCallback
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, rxDone
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macTxAckNotReceivedCallback
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macSpiCmdStrobe
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macSpiCmdStrobe
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, rxDone
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, rxDiscardFrame
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macDataRxMemAlloc
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macSpiCmdStrobe
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macRxCheckMACPendingCallback
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, MAC_SrcMatchCheckAllPending
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macSpiWriteReg
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, osal_memcpy
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macMcuTimerBackoffCapture
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macMcuTimerTickCapture
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, rxPrepPayload
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macRxCheckPendingCallback
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macSpiWriteReg
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macSpiWriteReg
        LOCFRAME CSTACK, 22, STACK
        FUNCALL rxStartIsr, macSpiWriteReg
        LOCFRAME CSTACK, 22, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0x2, SP
          CFI CFA SP+22
//  413   uint8  addrLen;
//  414   uint8  ackWithPending;
//  415   uint8  dstAddrMode;
//  416   uint8  srcAddrMode;
//  417   uint8  mhrLen = 0;
        MOV.B   #0x0, R7
//  418 
//  419   MAC_ASSERT(!macRxActive); /* receive on top of receive */
        CMP.B   #0x0, &macRxActive
        JEQ     ??rxStartIsr_8
        CALLA   #halAssertHandler
//  420 
//  421   /* indicate rx is active */
//  422   macRxActive = MAC_RX_ACTIVE_STARTED;
??rxStartIsr_8:
        MOV.B   #0x81, &macRxActive
//  423 
//  424   /*
//  425    *  For bullet proof functionality, need to see if the receiver was just turned off.
//  426    *  The logic to request turning off the receiver, disables interrupts and then checks
//  427    *  the value of macRxActive.  If it is TRUE, the receiver will not be turned off.
//  428    *
//  429    *  There is a small hole though.  It's possible to attempt turning off the receiver
//  430    *  in the window from when the receive interrupt fires and the point where macRxActive
//  431    *  is set to TRUE.  To plug this hole, the on/off status must be tested *after*
//  432    *  macRxActive has been set.  If the receiver is off at this point, there is nothing
//  433    *  in the RX fifo and the receive is simply aborted.
//  434    *
//  435    *  Also, there are some considerations in case a hard disable just happened.  Usually,
//  436    *  the receiver will just be off at this point after a hard disable.  The check described
//  437    *  above will account for this case too.  However, if a hard disable were immediately
//  438    *  followed by an enable, the receiver would be on.  To catch this case, the receive
//  439    *  FIFO is also tested to see if it is empty.  Recovery is identical to the other cases.
//  440    */
//  441   if (!macRxOnFlag || MAC_RADIO_RX_FIFO_IS_EMPTY())
        CMP.B   #0x0, &macRxOnFlag
        JEQ     ??rxStartIsr_9
        BIT.B   #0x20, &0x20
        JC      ??rxStartIsr_10
        BIT.B   #0x40, &0x20
        JC      ??rxStartIsr_10
//  442   {
//  443     /* reset active flag */
//  444     macRxActive = MAC_RX_ACTIVE_NO_ACTIVITY;
??rxStartIsr_9:
        MOV.B   #0x0, &macRxActive
//  445 
//  446     /*
//  447      *  To be absolutely bulletproof, must make sure no transmit queue'ed up during
//  448      *  the tiny, tiny window when macRxActive was not zero.
//  449      */
//  450     rxPostRxUpdates();
        CALLA   #rxPostRxUpdates
//  451 
//  452     /* return immediately from here */
//  453     return;
        JMP     ??rxStartIsr_3
//  454   }
//  455 
//  456   /*
//  457    *  If interrupts are held off for too long it's possible the previous "transmit done"
//  458    *  callback is pending.  If this is the case, it needs to be completed before
//  459    *  continuing with the receive logic.
//  460    */
//  461   MAC_RADIO_FORCE_TX_DONE_IF_PENDING();
//  462 
//  463   /*
//  464    *  It's possible receive logic is still waiting for confirmation of an ACK that went out
//  465    *  for the previous receive.  This is OK but the callback needs to be canceled at this point.
//  466    *  That callback execute receive cleanup logic that will run at the completion
//  467    *  of *this* receive.  Also, it is important the flag for the outgoing ACK to be cleared.
//  468    */
//  469   MAC_RADIO_CANCEL_ACK_TX_DONE_CALLBACK();
//  470   macRxOutgoingAckFlag = 0;
??rxStartIsr_10:
        MOV.B   #0x0, &macRxOutgoingAckFlag
//  471 
//  472   /*
//  473    *  Make a module-local copy of macRxFilter.  This prevents the selected
//  474    *  filter from changing in the middle of a receive.
//  475    */
//  476   rxFilter = macRxFilter;
        MOV.B   &macRxFilter, &rxFilter
//  477 
//  478   /*-------------------------------------------------------------------------------
//  479    *  Read initial frame information from FIFO.
//  480    *
//  481    *   This code is not triggered until the following are in the RX FIFO:
//  482    *     frame length          - one byte containing length of MAC frame (excludes this field)
//  483    *     frame control field   - two bytes defining frame type, addressing fields, control flags
//  484    *     sequence number       - one byte unique sequence identifier
//  485    *     additional two bytes  - these bytes are available in case the received frame is an ACK,
//  486    *                             if so, the frame can be verified and responded to immediately,
//  487    *                             if not an ACK, these bytes will be processed normally
//  488    */
//  489 
//  490   /* read frame length, frame control field, and sequence number from FIFO */
//  491   MAC_RADIO_READ_RX_FIFO(rxBuf, MAC_PHY_PHR_LEN + MAC_FCF_FIELD_LEN + MAC_SEQ_NUM_FIELD_LEN);
        MOV.B   #0x4, R13
        MOV.W   #rxBuf, R12
        CALLA   #macSpiReadRxFifo
//  492 
//  493   /* bytes to read from FIFO equals frame length minus length of MHR fields just read from FIFO */
//  494   rxUnreadLen = (rxBuf[0] & PHY_PACKET_SIZE_MASK) - MAC_FCF_FIELD_LEN - MAC_SEQ_NUM_FIELD_LEN;
        MOV.B   &rxBuf, R14
        AND.B   #0x7f, R14
        ADD.B   #0xfd, R14
        MOV.B   R14, &rxUnreadLen
//  495 
//  496   /*
//  497    *  Workaround for chip bug #1547.  The receive buffer can sometimes be corrupted by hardware.
//  498    *  This usually occurs under heavy traffic.  If a corrupted receive buffer is detected
//  499    *  the entire receive buffer is flushed.
//  500    *
//  501    *  In the case that this workaround is not needed, an assert is used to make sure the
//  502    *  receive length field is not corrupted.  This is important because a corrupted receive
//  503    *  length field is utterly fatal and, if not caught here, extremely hard to track down.
//  504    */
//  505   if (macChipVersion == REV_A)
        MOV.W   #rxBuf + 1, R11
        MOV.B   #0x7, R8
        CMP.B   #0x0, &macChipVersion
        JNE     ??rxStartIsr_11
//  506   {
//  507     if ((rxUnreadLen > (MAC_A_MAX_PHY_PACKET_SIZE - MAC_FCF_FIELD_LEN - MAC_SEQ_NUM_FIELD_LEN)) ||
//  508         (MAC_FRAME_TYPE(&rxBuf[1]) > MAC_FRAME_TYPE_MAX_VALID))
        CMP.B   #0x7d, R14
        JC      ??rxStartIsr_12
        MOV.B   R8, R14
        AND.B   @R11, R14
        CMP.B   #0x4, R14
        JNC     ??rxStartIsr_13
        JMP     ??rxStartIsr_12
//  509     {
//  510       MAC_RADIO_FLUSH_RX_FIFO();
//  511       rxDone();
//  512       return;
//  513     }
//  514   }
//  515   else
//  516   {
//  517     /* radio supplied a corrupted receive buffer length */
//  518     MAC_ASSERT(rxUnreadLen <= (MAC_A_MAX_PHY_PACKET_SIZE - MAC_FCF_FIELD_LEN - MAC_SEQ_NUM_FIELD_LEN));
??rxStartIsr_11:
        CMP.B   #0x7d, R14
        JNC     ??rxStartIsr_13
        CALLA   #halAssertHandler
//  519   }
//  520 
//  521 
//  522 
//  523   /*-------------------------------------------------------------------------------
//  524    *  Process ACKs.
//  525    *
//  526    *  If this frame is an ACK, process it immediately and exit from here.
//  527    *  If this frame is not an ACK and transmit is listening for an ACK, let
//  528    *  the transmit logic know an non-ACK was received so transmit can complete.
//  529    *
//  530    *  In promiscuous mode ACKs are treated like any other frame.
//  531    */
//  532   if ((MAC_FRAME_TYPE(&rxBuf[1]) == MAC_FRAME_TYPE_ACK) && (rxPromiscuousMode == PROMISCUOUS_MODE_OFF))
??rxStartIsr_13:
        MOV.B   R8, R14
        AND.B   @R11, R14
        CMP.B   #0x2, R14
        JNE     ??rxStartIsr_14
        CMP.B   #0x0, &rxPromiscuousMode
        JNE     ??rxStartIsr_14
//  533   {
//  534     halIntState_t  s;
//  535     uint8 fcsBuf[MAC_FCF_FIELD_LEN];
//  536     /*
//  537      *  There are guaranteed to be two unread bytes in the FIFO.  By defintion, for ACK frames
//  538      *  these two bytes will be the FCS.
//  539      */
//  540 
//  541     /* read FCS from FIFO (threshold set so bytes are guaranteed to be there) */
//  542     MAC_RADIO_READ_RX_FIFO(fcsBuf, MAC_FCS_FIELD_LEN);
        MOV.B   #0x2, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #macSpiReadRxFifo
//  543 
//  544     /*
//  545      *  This critical section ensures that the ACK timeout won't be triggered in the
//  546      *  middle of receiving the ACK frame.
//  547      */
//  548     HAL_ENTER_CRITICAL_SECTION(s);
        MOV.W   SR, R7
        dint
        nop
//  549 
//  550     /* see if transmit is listening for an ACK */
//  551     if (macTxActive == MAC_TX_ACTIVE_LISTEN_FOR_ACK)
        CMP.B   #0x86, &macTxActive
        JNE     ??rxStartIsr_15
//  552     {
//  553       MAC_ASSERT(pMacDataTx != NULL); /* transmit buffer must be present */
        CMP.W   #0x0, &pMacDataTx
        JNE     ??rxStartIsr_16
        CALLA   #halAssertHandler
//  554 
//  555       /* record link quality metrics for the receive ACK */
//  556       {
//  557         int8 rssiDbm;
//  558         uint8 corr;
//  559 
//  560         rssiDbm = PROPRIETARY_FCS_RSSI(fcsBuf) + MAC_RADIO_RSSI_OFFSET;
??rxStartIsr_16:
        MOV.B   @SP, R10
        ADD.B   #0xb4, R10
//  561         MAC_RADIO_RSSI_LNA_OFFSET(rssiDbm);
//  562         corr = PROPRIETARY_FCS_CORRELATION_VALUE(fcsBuf);
        MOV.B   0x1(SP), R8
        AND.B   #0x7f, R8
//  563 
//  564         pMacDataTx->internal.mpduLinkQuality = macRadioComputeLQI(rssiDbm, corr);
        MOV.B   R8, R13
        MOV.B   R10, R12
        CALLA   #macRadioComputeLQI
        MOV.W   &pMacDataTx, R15
        MOV.B   R12, 0x15(R15)
//  565         pMacDataTx->internal.correlation = corr;
        MOV.W   &pMacDataTx, R15
        MOV.B   R8, 0x16(R15)
//  566         pMacDataTx->internal.rssi= rssiDbm;
        MOV.W   &pMacDataTx, R15
        MOV.B   R10, 0x17(R15)
//  567       }
//  568 
//  569       /*
//  570        *  It's okay if the ACK timeout is triggered here. The callbacks for ACK received
//  571        *  or ACK not received will check "macTxActive" flag before taking any actions.
//  572        */
//  573       HAL_EXIT_CRITICAL_SECTION(s);
        MOV.W   R7, SR
//  574 
//  575       /*
//  576        *  An ACK was received so transmit logic needs to know.  If the FCS failed,
//  577        *  the transmit logic still needs to know.  In that case, treat the frame
//  578        *  as a non-ACK to complete the active transmit.
//  579        */
//  580       if (PROPRIETARY_FCS_CRC_OK(fcsBuf))
        CMP.B   #0x0, 0x1(SP)
        JGE     ??rxStartIsr_17
//  581       {
//  582         /* call transmit logic to indicate ACK was received */
//  583         macTxAckReceivedCallback(MAC_SEQ_NUMBER(&rxBuf[1]), MAC_FRAME_PENDING(&rxBuf[1]));
        MOV.B   @R11, R13
        AND.B   #0x10, R13
        MOV.B   &rxBuf + 3, R12
        CALLA   #macTxAckReceivedCallback
        JMP     ??rxStartIsr_5
//  584       }
//  585       else
//  586       {
//  587         macTxAckNotReceivedCallback();
??rxStartIsr_17:
        CALLA   #macTxAckNotReceivedCallback
        JMP     ??rxStartIsr_5
//  588       }
//  589     }
//  590     else
//  591     {
//  592       HAL_EXIT_CRITICAL_SECTION(s);
??rxStartIsr_15:
        MOV.W   R7, SR
//  593     }
//  594 
//  595     /* receive is done, exit from here */
//  596     rxDone();
        JMP     ??rxStartIsr_5
//  597     return;
//  598   }
//  599   else if (macTxActive == MAC_TX_ACTIVE_LISTEN_FOR_ACK)
??rxStartIsr_14:
        CMP.B   #0x86, &macTxActive
        JNE     ??rxStartIsr_18
//  600   {
//  601     macTxAckNotReceivedCallback();
        CALLA   #macTxAckNotReceivedCallback
//  602   }
//  603 
//  604   /*-------------------------------------------------------------------------------
//  605    *  Apply filtering.
//  606    *
//  607    *  For efficiency, see if filtering is even 'on' before processing.  Also test
//  608    *  to make sure promiscuous mode is disabled.  If promiscuous mode is enabled,
//  609    *  do not apply filtering.
//  610    */
//  611   if ((rxFilter != RX_FILTER_OFF) && !rxPromiscuousMode)
??rxStartIsr_18:
        MOV.B   &rxFilter, R14
        MOV.B   #0x3, R9
        CMP.B   #0x0, R14
        JEQ     ??rxStartIsr_19
        CMP.B   #0x0, &rxPromiscuousMode
        JNE     ??rxStartIsr_19
//  612   {
//  613     if (/* filter all frames */
//  614          (rxFilter == RX_FILTER_ALL) ||
//  615 
//  616          /* filter non-beacon frames */
//  617          ((rxFilter == RX_FILTER_NON_BEACON_FRAMES) &&
//  618           (MAC_FRAME_TYPE(&rxBuf[1]) != MAC_FRAME_TYPE_BEACON)) ||
//  619 
//  620          /* filter non-command frames */
//  621          ((rxFilter == RX_FILTER_NON_COMMAND_FRAMES) &&
//  622           ((MAC_FRAME_TYPE(&rxBuf[1]) != MAC_FRAME_TYPE_COMMAND))))
        CMP.B   #0x1, R14
        JEQ     ??rxStartIsr_0
        MOV.B   R8, R15
        AND.B   &rxBuf + 1, R15
        CMP.B   #0x2, R14
        JNE     ??rxStartIsr_20
        CMP.B   #0x0, R15
        JNE     ??rxStartIsr_0
        JMP     ??rxStartIsr_19
??rxStartIsr_20:
        CMP.B   R9, R14
        JNE     ??rxStartIsr_19
        CMP.B   R9, R15
        JNE     ??rxStartIsr_0
//  623     {
//  624       /* discard rest of frame */
//  625       rxDiscardFrame();
//  626       return;
//  627     }
//  628   }
//  629 
//  630   /*-------------------------------------------------------------------------------
//  631    *  Compute length of addressing fields.  Compute payload length.
//  632    */
//  633 
//  634   /* decode addressing modes */
//  635   dstAddrMode = MAC_DEST_ADDR_MODE(&rxBuf[1]);
??rxStartIsr_19:
        MOV.B   &rxBuf + 2, R4
        RPT     #0x2
        RRUX.B  R4
        AND.B   R9, R4
//  636   srcAddrMode = MAC_SRC_ADDR_MODE(&rxBuf[1]);
        MOV.B   &rxBuf + 2, R6
        RPT     #0x6
        RRUX.B  R6
//  637 
//  638   /*
//  639   *  Workaround for chip bug #1547.  The receive buffer can sometimes be corrupted by hardware.
//  640    *  This usually occurs under heavy traffic.  If a corrupted receive buffer is detected
//  641    *  the entire receive buffer is flushed.
//  642    */
//  643   if (macChipVersion == REV_A)
        CMP.B   #0x0, &macChipVersion
        JNE     ??rxStartIsr_21
//  644   {
//  645     if ((srcAddrMode == ADDR_MODE_RESERVERED) || (dstAddrMode == ADDR_MODE_RESERVERED))
        CMP.B   #0x1, R6
        JEQ     ??rxStartIsr_12
        CMP.B   #0x1, R4
        JNE     ??rxStartIsr_21
//  646     {
//  647       MAC_RADIO_FLUSH_RX_FIFO();
??rxStartIsr_12:
        CALLA   #?Subroutine3
//  648       rxDone();
??rxStartIsr_5:
        CALLA   #rxDone
//  649       return;
        JMP     ??rxStartIsr_3
//  650     }
//  651   }
//  652 
//  653   /*
//  654    *  Compute the addressing field length.  A lookup table based on addressing
//  655    *  mode is used for efficiency.  If the source address is present and the
//  656    *  frame is intra-PAN, the PAN Id is not repeated.  In this case, the address
//  657    *  length is adjusted to match the smaller length.
//  658    */
//  659   addrLen = macRxAddrLen[dstAddrMode] + macRxAddrLen[srcAddrMode];
??rxStartIsr_21:
        MOV.B   macRxAddrLen(R4), R10
        ADD.B   macRxAddrLen(R6), R10
        CMP.B   #0x0, R6
        JEQ     ??rxStartIsr_22
        BIT.B   #0x40, &rxBuf + 1
        JNC     ??rxStartIsr_22
//  660   if ((srcAddrMode != SADDR_MODE_NONE) && MAC_INTRA_PAN(&rxBuf[1]))
//  661   {
//  662     addrLen -= MAC_PAN_ID_FIELD_LEN;
        SUB.B   #0x2, R10
??rxStartIsr_22:
        MOV.B   &rxUnreadLen, R15
        MOV.B   R10, R14
        ADD.W   #0x2, R14
        CMP.W   R14, R15
        JGE     ??rxStartIsr_23
//  663   }
//  664 
//  665   /*
//  666    *  If there are not enough unread bytes to include the computed address
//  667    *  plus FCS field, the frame is corrupted and must be discarded.
//  668    */
//  669   if ((addrLen + MAC_FCS_FIELD_LEN) > rxUnreadLen)
//  670   {
//  671     /* discard frame and exit */
//  672     rxDiscardFrame();
??rxStartIsr_0:
        CALLA   #rxDiscardFrame
//  673     return;
        JMP     ??rxStartIsr_3
//  674   }
//  675 
//  676   /* aux security header plus payload length is equal to unread bytes minus
//  677    * address length, minus the FCS
//  678    */
//  679   rxPayloadLen = rxUnreadLen - addrLen - MAC_FCS_FIELD_LEN;
??rxStartIsr_23:
        MOV.B   R15, R14
        SUB.B   R10, R14
        SUB.B   #0x2, R14
        MOV.B   R14, &rxPayloadLen
//  680 
//  681   /*-------------------------------------------------------------------------------
//  682    *  Allocate memory for the incoming frame.
//  683    */
//  684   if (MAC_SEC_ENABLED(&rxBuf[1]))
        BIT.B   #0x8, &rxBuf + 1
        JNC     ??rxStartIsr_24
//  685   {
//  686     /* increase the allocation size of MAC header for security */
//  687     mhrLen = MAC_MHR_LEN;
        MOV.B   #0x25, R7
//  688   }
//  689 
//  690   pRxBuf = (macRx_t *) MEM_ALLOC(sizeof(macRx_t) + mhrLen + rxPayloadLen);
??rxStartIsr_24:
        MOV.B   R7, R12
        ADD.W   R14, R12
        ADD.W   #0x3a, R12
        CALLA   #macDataRxMemAlloc
        MOV.W   R12, &pRxBuf
//  691   if (pRxBuf == NULL)
        CMP.W   #0x0, R12
        JNE     ??rxStartIsr_25
//  692   {
//  693     /* Cancel the outgoing TX ACK */
//  694     MAC_RADIO_CANCEL_TX_ACK();
        MOV.B   #0x4b, R12
        CALLA   #macSpiCmdStrobe
        JMP     ??rxStartIsr_0
//  695 
//  696     /* buffer allocation failed, discard the frame and exit*/
//  697     rxDiscardFrame();
//  698     return;
//  699   }
//  700 
//  701   /*-------------------------------------------------------------------------------
//  702    *  Set up to process ACK request.  Do not ACK if in promiscuous mode.
//  703    */
//  704   ackWithPending = 0;
??rxStartIsr_25:
        MOV.B   #0x0, R5
//  705   if (!rxPromiscuousMode)
        CMP.B   #0x0, &rxPromiscuousMode
        JNE     ??rxStartIsr_26
//  706   {
//  707     macRxOutgoingAckFlag = MAC_ACK_REQUEST(&rxBuf[1]);
        MOV.B   @R11, R14
        AND.B   #0x20, R14
        MOV.B   R14, &macRxOutgoingAckFlag
//  708   }
//  709 
//  710   /*-------------------------------------------------------------------------------
//  711    *  Process any ACK request.
//  712    */
//  713   if (macRxOutgoingAckFlag)
??rxStartIsr_26:
        CMP.B   #0x0, &macRxOutgoingAckFlag
        JEQ     ??rxStartIsr_27
//  714   {
//  715     halIntState_t  s;
//  716 
//  717     /*
//  718      *  This critical section ensures that the callback ISR is initiated within time
//  719      *  to guarantee correlation with the strobe.
//  720      */
//  721     HAL_ENTER_CRITICAL_SECTION(s);
        MOV.W   SR, R7
        dint
        nop
//  722 
//  723     /* Do not ack data packet with pending more data */
//  724     if( MAC_FRAME_TYPE(&rxBuf[1]) == MAC_FRAME_TYPE_COMMAND )
        MOV.B   R8, R14
        AND.B   @R11, R14
        CMP.B   R9, R14
        JNE     ??rxStartIsr_1
//  725     {
//  726       if( macRxCheckMACPendingCallback())
        CALLA   #macRxCheckMACPendingCallback
        CMP.B   #0x0, R12
        JNE     ??rxStartIsr_28
//  727       {
//  728         /* Check is any mac data pending for end devices */
//  729         ackWithPending = MAC_RX_FLAG_ACK_PENDING;
//  730       }
//  731       else
//  732       {
//  733         if( macSrcMatchIsEnabled )
        CMP.B   #0x0, &macSrcMatchIsEnabled
        JEQ     ??rxStartIsr_29
//  734         {
//  735           /* When autopend is enabled, check if allpending is set to true */
//  736           if( MAC_SrcMatchCheckAllPending() == MAC_AUTOACK_PENDING_ALL_ON )
        CALLA   #MAC_SrcMatchCheckAllPending
        CMP.B   #0xfe, R12
        JEQ     ??rxStartIsr_28
//  737           {
//  738             ackWithPending = MAC_RX_FLAG_ACK_PENDING;
//  739           }
//  740         }
//  741         else
//  742         {
//  743           /* When autopend is disabled, check the application pending callback */
//  744           if( macRxCheckPendingCallback() )
//  745           {
//  746             ackWithPending = MAC_RX_FLAG_ACK_PENDING;
//  747           }
//  748         }
//  749       }
//  750     }
//  751 
//  752     if( ackWithPending == MAC_RX_FLAG_ACK_PENDING )
//  753     {
//  754       MAC_RADIO_TX_ACK_PEND();
//  755     }
//  756     else
//  757     {
//  758       MAC_RADIO_TX_ACK();
??rxStartIsr_1:
        MOV.B   #0x1, R13
??rxStartIsr_32:
        MOV.B   #0xd, R12
        CALLA   #macSpiWriteReg
//  759     }
//  760 
//  761 
//  762     /* request a callback to macRxAckTxDoneCallback() when the ACK transmit has finished */
//  763     MAC_RADIO_REQUEST_ACK_TX_DONE_CALLBACK();
//  764     HAL_EXIT_CRITICAL_SECTION(s);
        MOV.W   R7, SR
//  765   }
//  766 
//  767  /*-------------------------------------------------------------------------------
//  768   *  Populate the receive buffer going up to high-level.
//  769   */
//  770 
//  771   /* configure the payload buffer
//  772    * save MAC header pointer regardless of security status.
//  773    */
//  774   pRxBuf->mhr.p   = pRxBuf->msdu.p   = (uint8 *) (pRxBuf + 1);
??rxStartIsr_27:
        MOV.W   #pRxBuf, R7
        MOV.W   @R7, R15
        MOV.W   R15, R14
        ADD.W   #0x3a, R14
        MOV.W   R14, 0x2(R15)
        MOV.W   R14, 0x36(R15)
//  775   pRxBuf->mhr.len = pRxBuf->msdu.len =  rxPayloadLen;
        MOV.B   &rxPayloadLen, R14
        MOV.B   R14, 0x4(R15)
        MOV.B   R14, 0x38(R15)
//  776 
//  777   if (MAC_SEC_ENABLED(&rxBuf[1]))
        BIT.B   #0x8, &rxBuf + 1
        JNC     ??rxStartIsr_30
//  778   {
//  779     /* Copy FCF and sequence number to RX buffer */
//  780     pRxBuf->mhr.len = MAC_FCF_FIELD_LEN + MAC_SEQ_NUM_FIELD_LEN;
        MOV.B   R9, 0x38(R15)
//  781     osal_memcpy(pRxBuf->mhr.p, &rxBuf[1], pRxBuf->mhr.len);
        MOV.W   @R7, R15
        MOV.B   0x38(R15), R14
        MOV.W   R11, R13
        MOV.W   0x36(R15), R12
        CALLA   #osal_memcpy
//  782     pRxBuf->mhr.p += pRxBuf->mhr.len;
        MOV.W   @R7, R14
        MOV.B   0x38(R14), R15
        ADD.W   R15, 0x36(R14)
//  783   }
//  784 
//  785   /* set internal values */
//  786   pRxBuf->mac.srcAddr.addrMode  = srcAddrMode;
??rxStartIsr_30:
        MOV.W   @R7, R15
        MOV.B   R6, 0x1c(R15)
//  787   pRxBuf->mac.dstAddr.addrMode  = dstAddrMode;
        MOV.W   @R7, R15
        MOV.B   R4, 0x26(R15)
//  788   pRxBuf->mac.timestamp         = MAC_RADIO_BACKOFF_CAPTURE();
        CALLA   #macMcuTimerBackoffCapture
        MOV.W   @R7, R15
        MOV.W   R12, 0x28(R15)
        MOV.W   R13, 0x2a(R15)
//  789   pRxBuf->mac.timestamp2        = MAC_RADIO_TIMER_CAPTURE();
        CALLA   #macMcuTimerTickCapture
        MOV.W   @R7, R15
        MOV.W   R12, 0x2c(R15)
//  790   pRxBuf->internal.frameType    = MAC_FRAME_TYPE(&rxBuf[1]);
        AND.B   @R11, R8
        MOV.B   R8, 0x6(R15)
//  791   pRxBuf->mac.dsn               = MAC_SEQ_NUMBER(&rxBuf[1]);
        MOV.W   @R7, R15
        MOV.B   &rxBuf + 3, 0x35(R15)
//  792   pRxBuf->internal.flags        = INTERNAL_FCF_FLAGS(&rxBuf[1]) | ackWithPending;
        MOV.B   @R11, R14
        AND.B   #0x78, R14
        MOV.B   &rxBuf + 2, R15
        RPT     #0x4
        RRUX.B  R15
        AND.B   R9, R15
        BIS.B   R14, R15
        BIS.B   R5, R15
        MOV.W   @R7, R11
        MOV.B   R15, 0x7(R11)
//  793 
//  794   /*-------------------------------------------------------------------------------
//  795    *  If the processing the addressing fields does not require more bytes from
//  796    *  the FIFO go directly address processing function.  Otherwise, configure
//  797    *  interrupt to jump there once bytes are received.
//  798    */
//  799   if (addrLen == 0)
        CMP.B   #0x0, R10
        JNE     ??rxStartIsr_31
//  800   {
//  801     /* no addressing fields to read, prepare for payload interrupts */
//  802     pFuncRxState = &rxPayloadIsr;
        CALLA   #?Subroutine6
//  803     rxPrepPayload();
//  804   }
??CrossCallReturnLabel_4:
        JMP     ??rxStartIsr_3
??rxStartIsr_29:
        CALLA   #macRxCheckPendingCallback
        CMP.B   #0x0, R12
        JEQ     ??rxStartIsr_1
??rxStartIsr_28:
        MOV.B   #0x4, R5
        MOV.B   #0x5, R13
        JMP     ??rxStartIsr_32
//  805   else
//  806   {
//  807     /* need to read and process addressing fields, prepare for address interrupt */
//  808     rxNextLen = addrLen;
??rxStartIsr_31:
        MOV.B   R10, &rxNextLen
//  809     if (MAC_SEC_ENABLED(&rxBuf[1]))
        MOV.B   R10, R13
        BIT.B   #0x8, &rxBuf + 1
        JC      ??rxStartIsr_7
//  810     {
//  811       /* When security is enabled, read off security control field as well */
//  812       MAC_RADIO_SET_RX_THRESHOLD(rxNextLen + MAC_SEC_CONTROL_FIELD_LEN);
//  813     }
//  814     else
//  815     {
//  816       MAC_RADIO_SET_RX_THRESHOLD(rxNextLen);
        ADD.B   #0xff, R13
//  817     }
??rxStartIsr_7:
        CALLA   #??Subroutine2_0
//  818     pFuncRxState = &rxAddrIsr;
??CrossCallReturnLabel_11:
        MOV.W   #LWRD(rxAddrIsr), &pFuncRxState
        MOV.W   #HWRD(rxAddrIsr), &pFuncRxState + 2
//  819   }
//  820 }
??rxStartIsr_3:
        ADD.W   #0x2, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock25
        REQUIRE P1IN

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine6:
          CFI Block cfiCond26 Using cfiCommon0
          CFI Function rxAddrIsr
          CFI Conditional ??CrossCallReturnLabel_5
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+30
          CFI Block cfiCond27 Using cfiCommon0
          CFI (cfiCond27) Function rxStartIsr
          CFI (cfiCond27) Conditional ??CrossCallReturnLabel_4
          CFI (cfiCond27) R4L Frame(CFA, -20)
          CFI (cfiCond27) R5L Frame(CFA, -18)
          CFI (cfiCond27) R6L Frame(CFA, -16)
          CFI (cfiCond27) R7L Frame(CFA, -14)
          CFI (cfiCond27) R8L Frame(CFA, -12)
          CFI (cfiCond27) R9L Frame(CFA, -10)
          CFI (cfiCond27) R10L Frame(CFA, -8)
          CFI (cfiCond27) R11L Frame(CFA, -6)
          CFI (cfiCond27) CFA SP+26
          CFI Block cfiPicker28 Using cfiCommon1
          CFI (cfiPicker28) NoFunction
          CFI (cfiPicker28) Picker
        MOV.W   #LWRD(rxPayloadIsr), &pFuncRxState
        MOV.W   #HWRD(rxPayloadIsr), &pFuncRxState + 2
        BRA     #rxPrepPayload
          CFI EndBlock cfiCond26
          CFI EndBlock cfiCond27
          CFI EndBlock cfiPicker28
//  821 
//  822 
//  823 /*=================================================================================================
//  824  * @fn          rxAddrIsr
//  825  *
//  826  * @brief       Receive ISR state for decoding address.  Reads and stores the address information
//  827  *              from the incoming packet.
//  828  *
//  829  * @param       none
//  830  *
//  831  * @return      none
//  832  *=================================================================================================
//  833  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  834 static void rxAddrIsr(void)
rxAddrIsr:
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function rxAddrIsr
//  835 {
        FUNCALL rxAddrIsr, halAssertHandler
        LOCFRAME CSTACK, 26, STACK
        FUNCALL rxAddrIsr, macSpiReadRxFifo
        LOCFRAME CSTACK, 26, STACK
        FUNCALL rxAddrIsr, sAddrExtCpy
        LOCFRAME CSTACK, 26, STACK
        FUNCALL rxAddrIsr, sAddrExtCpy
        LOCFRAME CSTACK, 26, STACK
        FUNCALL rxAddrIsr, rxPrepPayload
        LOCFRAME CSTACK, 26, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        SUB.W   #0x14, SP
          CFI CFA SP+26
//  836   uint8 buf[MAX_ADDR_FIELDS_LEN];
//  837   uint8 dstAddrMode;
//  838   uint8 srcAddrMode;
//  839 #ifdef MAC_SECURITY  
//  840   uint8 securityControl;
//  841 #endif /* MAC_SECURITY */  
//  842   uint8  * p;
//  843 
//  844   MAC_ASSERT(rxNextLen != 0); /* logic assumes at least one address byte in buffer */
        CMP.B   #0x0, &rxNextLen
        JNE     ??rxAddrIsr_0
        CALLA   #halAssertHandler
//  845 
//  846   /*  read out address fields into local buffer in one shot */
//  847   MAC_RADIO_READ_RX_FIFO(buf, rxNextLen);
??rxAddrIsr_0:
        MOV.W   SP, R10
        ADD.W   #0x0, R10
        MOV.B   &rxNextLen, R13
        MOV.W   R10, R12
        CALLA   #macSpiReadRxFifo
//  848 
//  849   /* set pointer to buffer with addressing fields */
//  850   p = buf;
//  851 
//  852   /* destination address */
//  853   dstAddrMode = MAC_DEST_ADDR_MODE(&rxBuf[1]);
        MOV.B   &rxBuf + 2, R13
        RPT     #0x2
        RRUX.B  R13
        AND.B   #0x3, R13
        JEQ     ??rxAddrIsr_1
//  854   if (dstAddrMode != SADDR_MODE_NONE)
//  855   {
//  856     pRxBuf->mac.srcPanId = pRxBuf->mac.dstPanId = BUILD_UINT16(p[0], p[1]);
        MOV.W   &pRxBuf, R12
        MOV.B   @SP, R14
        MOV.B   0x1(SP), R15
        RPT     #0x8
        RLAX.W  R15
        ADD.W   R15, R14
        MOV.W   R14, 0x30(R12)
        MOV.W   R14, 0x2e(R12)
//  857     p += MAC_PAN_ID_FIELD_LEN;
//  858     if (dstAddrMode == SADDR_MODE_EXT)
        CMP.B   #0x3, R13
        JNE     ??rxAddrIsr_2
//  859     {
//  860       sAddrExtCpy(pRxBuf->mac.dstAddr.addr.extAddr, p);
        MOV.W   R10, R13
        ADD.W   #0x2, R13
        ADD.W   #0x1e, R12
        CALLA   #sAddrExtCpy
//  861       p += MAC_EXT_ADDR_FIELD_LEN;
        ADD.W   #0xa, R10
        JMP     ??rxAddrIsr_1
//  862     }
//  863     else
//  864     {
//  865       pRxBuf->mac.dstAddr.addr.shortAddr = BUILD_UINT16(p[0], p[1]);
??rxAddrIsr_2:
        MOV.B   0x2(SP), R14
        MOV.B   0x3(SP), R15
        RPT     #0x8
        RLAX.W  R15
        ADD.W   R15, R14
        MOV.W   R14, 0x1e(R12)
//  866       p += MAC_SHORT_ADDR_FIELD_LEN;
        ADD.W   #0x4, R10
//  867     }
//  868   }
//  869 
//  870   /* sources address */
//  871   srcAddrMode = MAC_SRC_ADDR_MODE(&rxBuf[1]);
??rxAddrIsr_1:
        MOV.B   &rxBuf + 2, R13
        RPT     #0x6
        RRUX.B  R13
//  872   if (srcAddrMode != SADDR_MODE_NONE)
        JEQ     ??rxAddrIsr_3
//  873   {
//  874     if (!(pRxBuf->internal.flags & MAC_RX_FLAG_INTRA_PAN))
        MOV.W   &pRxBuf, R12
        BIT.B   #0x40, 0x7(R12)
        JC      ??rxAddrIsr_4
//  875     {
//  876       pRxBuf->mac.srcPanId = BUILD_UINT16(p[0], p[1]);
        CALLA   #?Subroutine7
??CrossCallReturnLabel_6:
        MOV.W   R14, 0x2e(R12)
//  877       p += MAC_PAN_ID_FIELD_LEN;
        ADD.W   #0x2, R10
//  878     }
//  879     if (srcAddrMode == SADDR_MODE_EXT)
??rxAddrIsr_4:
        CMP.B   #0x3, R13
        JNE     ??rxAddrIsr_5
//  880     {
//  881       sAddrExtCpy(pRxBuf->mac.srcAddr.addr.extAddr, p);
        MOV.W   R10, R13
        ADD.W   #0x14, R12
        CALLA   #sAddrExtCpy
        JMP     ??rxAddrIsr_3
//  882     }
//  883     else
//  884     {
//  885       pRxBuf->mac.srcAddr.addr.shortAddr = BUILD_UINT16(p[0], p[1]);
??rxAddrIsr_5:
        CALLA   #?Subroutine7
//  886     }
//  887   }
??CrossCallReturnLabel_7:
        MOV.W   R14, 0x14(R12)
//  888 
//  889 #ifdef MAC_SECURITY
//  890   if (MAC_SEC_ENABLED(&rxBuf[1]))
//  891   {
//  892     uint8 keyIdMode;
//  893 
//  894     if (MAC_FRAME_VERSION(&rxBuf[1]) == 0)
//  895     {
//  896       /* MAC_UNSUPPORTED_LEGACY - Cancel the outgoing TX ACK.
//  897        * It may be too late but we have to try.
//  898        */
//  899       MAC_RADIO_CANCEL_TX_ACK();
//  900 
//  901       /* clean up after unsupported security legacy */
//  902       macRxHaltCleanup();
//  903       return;
//  904     }
//  905 
//  906     /* Copy addressing fields to RX buffer */
//  907     osal_memcpy(pRxBuf->mhr.p, buf, rxNextLen);
//  908     pRxBuf->mhr.p   += rxNextLen;
//  909     pRxBuf->mhr.len += rxNextLen;
//  910 
//  911     /*-------------------------------------------------------------------------------
//  912      *  Prepare for auxiliary security header interrupts.
//  913      */
//  914 
//  915     /* read out security control field from FIFO (threshold set so bytes are guaranteed to be there) */
//  916     MAC_RADIO_READ_RX_FIFO(&securityControl, MAC_SEC_CONTROL_FIELD_LEN);
//  917 
//  918     /* Copy security fields to MHR buffer */
//  919     *pRxBuf->mhr.p   = securityControl;
//  920     pRxBuf->mhr.p   += MAC_SEC_CONTROL_FIELD_LEN;
//  921     pRxBuf->mhr.len += MAC_SEC_CONTROL_FIELD_LEN;
//  922 
//  923     /* store security level and key ID mode */
//  924     pRxBuf->sec.securityLevel = SECURITY_LEVEL(securityControl);
//  925     pRxBuf->sec.keyIdMode = keyIdMode = KEY_IDENTIFIER_MODE(securityControl);
//  926 
//  927     /* Corrupted RX frame, should never occur. */
//  928     if ((keyIdMode > MAC_KEY_ID_MODE_8)
//  929     /* Get the next RX length according to AuxLen table minus security control field.
//  930      * The security control length is counted already.
//  931      */
//  932     || ((macKeySourceLen[keyIdMode] + MAC_FRAME_COUNTER_LEN) >= rxPayloadLen)
//  933     /* Security Enabled subfield is one, but the Security Level in the header is zero:
//  934      * MAC_UNSUPPORTED_SECURITY - Cancel the outgoing TX ACK.
//  935      */
//  936     || (pRxBuf->sec.securityLevel == MAC_SEC_LEVEL_NONE))
//  937     {
//  938       /* It may be too late but we have to try. */
//  939       MAC_RADIO_CANCEL_TX_ACK();
//  940 
//  941       /* clean up after unsupported security or corrupted RX frame. */
//  942       macRxHaltCleanup();
//  943       return;
//  944     }
//  945 
//  946     /* get the next RX length according to AuxLen table minus security control field.
//  947      * The sceurity control length is counted already.
//  948      */
//  949     rxNextLen = macKeySourceLen[keyIdMode] + MAC_FRAME_COUNTER_LEN;
//  950     MAC_RADIO_SET_RX_THRESHOLD(rxNextLen);
//  951     pFuncRxState = &rxSecurityHdrIsr;
//  952   }
//  953   else
//  954 #endif /* MAC_SECURITY */
//  955   {
//  956     /* clear security level */
//  957     pRxBuf->sec.securityLevel = MAC_SEC_LEVEL_NONE;
??rxAddrIsr_3:
        MOV.W   &pRxBuf, R15
        MOV.B   #0x0, 0x10(R15)
//  958 
//  959     /*-------------------------------------------------------------------------------
//  960      *  Prepare for payload interrupts.
//  961      */
//  962     pFuncRxState = &rxPayloadIsr;
        CALLA   #?Subroutine6
//  963     rxPrepPayload();
//  964   }
//  965 }
??CrossCallReturnLabel_5:
        ADD.W   #0x14, SP
          CFI CFA SP+6
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock29

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine7:
          CFI Block cfiCond30 Using cfiCommon0
          CFI Function rxAddrIsr
          CFI Conditional ??CrossCallReturnLabel_6
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+30
          CFI Block cfiCond31 Using cfiCommon0
          CFI (cfiCond31) Function rxAddrIsr
          CFI (cfiCond31) Conditional ??CrossCallReturnLabel_7
          CFI (cfiCond31) R10L Frame(CFA, -6)
          CFI (cfiCond31) CFA SP+30
          CFI Block cfiPicker32 Using cfiCommon1
          CFI (cfiPicker32) NoFunction
          CFI (cfiPicker32) Picker
        MOV.B   @R10, R14
        MOV.B   0x1(R10), R15
        RPT     #0x8
        RLAX.W  R15
        ADD.W   R15, R14
        RETA
          CFI EndBlock cfiCond30
          CFI EndBlock cfiCond31
          CFI EndBlock cfiPicker32
//  966 
//  967 
//  968 #ifdef MAC_SECURITY
//  969 /*=================================================================================================
//  970  * @fn          rxSecurityHdrIsr
//  971  *
//  972  * @brief       Receive ISR state for reading out and storing the auxiliary security header.
//  973  *
//  974  * @param       none
//  975  *
//  976  * @return      none
//  977  *=================================================================================================
//  978  */
//  979 static void rxSecurityHdrIsr(void)
//  980 {
//  981   uint8 buf[MAC_FRAME_COUNTER_LEN + MAC_KEY_ID_8_LEN];
//  982 
//  983   /* read out frame counter and key ID */
//  984   MAC_RADIO_READ_RX_FIFO(buf, rxNextLen);
//  985 
//  986   /* Incoming frame counter */
//  987   macFrameCounter = BUILD_UINT32(buf[0], buf[1], buf[2], buf[3]);
//  988   if (rxNextLen - MAC_FRAME_COUNTER_LEN > 0)
//  989   {
//  990     /* Explicit mode */
//  991     osal_memcpy(pRxBuf->sec.keySource, &buf[MAC_FRAME_COUNTER_LEN], rxNextLen - MAC_FRAME_COUNTER_LEN - 1);
//  992     pRxBuf->sec.keyIndex = buf[rxNextLen - MAC_KEY_INDEX_LEN];
//  993   }
//  994 
//  995   /* Copy security fields to RX buffer */
//  996   osal_memcpy(pRxBuf->mhr.p, buf, rxNextLen);
//  997   pRxBuf->mhr.p   += rxNextLen;
//  998   pRxBuf->mhr.len += rxNextLen;
//  999 
// 1000   /* Update payload pointer and payload length. The rxPayloadLen includes security header length
// 1001    * and SCF byte. The security header and SCF length must be deducted from the rxPayloadLen.
// 1002    */
// 1003   rxPayloadLen    -= (rxNextLen + MAC_SEC_CONTROL_FIELD_LEN);
// 1004   pRxBuf->msdu.len = rxPayloadLen;
// 1005   pRxBuf->mhr.len += rxPayloadLen;
// 1006 
// 1007   /*-------------------------------------------------------------------------------
// 1008    *  Prepare for payload interrupts.
// 1009    */
// 1010   pFuncRxState = &rxPayloadIsr;
// 1011   rxPrepPayload();
// 1012 }
// 1013 #endif /* MAC_SECURITY */
// 1014 
// 1015 
// 1016 /*=================================================================================================
// 1017  * @fn          rxPrepPayload
// 1018  *
// 1019  * @brief       Common code to prepare for the payload ISR.
// 1020  *
// 1021  * @param       none
// 1022  *
// 1023  * @return      none
// 1024  *=================================================================================================
// 1025  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1026 static void rxPrepPayload(void)
rxPrepPayload:
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function rxPrepPayload
// 1027 {
// 1028   if (rxPayloadLen == 0)
        FUNCALL rxPrepPayload, macSpiWriteReg
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxPrepPayload, macSpiWriteReg
        LOCFRAME CSTACK, 4, STACK
        MOV.B   &rxPayloadLen, R14
        CMP.B   #0x0, R14
        JNE     ??rxPrepPayload_2
// 1029   {
// 1030     MAC_RADIO_SET_RX_THRESHOLD(MAC_FCS_FIELD_LEN);
        MOV.B   #0x1, R13
        CALLA   #??Subroutine2_0
// 1031     pFuncRxState = &rxFcsIsr;
??CrossCallReturnLabel_12:
        MOV.W   #LWRD(rxFcsIsr), &pFuncRxState
        MOV.W   #HWRD(rxFcsIsr), &pFuncRxState + 2
        RETA
// 1032   }
// 1033   else
// 1034   {
// 1035     rxNextLen = MIN(rxPayloadLen, MAX_PAYLOAD_BYTES_READ_PER_INTERRUPT);
??rxPrepPayload_2:
        CALLA   #?Subroutine4
// 1036     MAC_RADIO_SET_RX_THRESHOLD(rxNextLen);
// 1037   }
??CrossCallReturnLabel_3:
        MOV.B   #0x34, R12
        BRA     #macSpiWriteReg
          CFI EndBlock cfiBlock33
// 1038 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine4:
          CFI Block cfiCond34 Using cfiCommon0
          CFI Function rxDiscardFrame
          CFI Conditional ??CrossCallReturnLabel_2
          CFI CFA SP+8
          CFI Block cfiCond35 Using cfiCommon0
          CFI (cfiCond35) Function rxPrepPayload
          CFI (cfiCond35) Conditional ??CrossCallReturnLabel_3
          CFI (cfiCond35) CFA SP+8
          CFI Block cfiPicker36 Using cfiCommon1
          CFI (cfiPicker36) NoFunction
          CFI (cfiPicker36) Picker
        CMP.B   #0x10, R14
        JNC     ??rxDiscardFrame_1
        MOV.B   #0x10, R14
??rxDiscardFrame_1:
        MOV.B   R14, &rxNextLen
        MOV.B   R14, R13
        ADD.B   #0xff, R13
        RETA
          CFI EndBlock cfiCond34
          CFI EndBlock cfiCond35
          CFI EndBlock cfiPicker36
// 1039 
// 1040 
// 1041 /*=================================================================================================
// 1042  * @fn          rxPayloadIsr
// 1043  *
// 1044  * @brief       Receive ISR state for reading out and storing the packet payload.
// 1045  *
// 1046  * @param       none
// 1047  *
// 1048  * @return      none
// 1049  *=================================================================================================
// 1050  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1051 static void rxPayloadIsr(void)
rxPayloadIsr:
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function rxPayloadIsr
// 1052 {
// 1053   MAC_RADIO_READ_RX_FIFO(pRxBuf->mhr.p, rxNextLen);
        FUNCALL rxPayloadIsr, macSpiReadRxFifo
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxPayloadIsr, rxPrepPayload
        LOCFRAME CSTACK, 4, STACK
        MOV.B   &rxNextLen, R13
        MOV.W   &pRxBuf, R15
        MOV.W   0x36(R15), R12
        CALLA   #macSpiReadRxFifo
// 1054   pRxBuf->mhr.p += rxNextLen;
        MOV.W   &pRxBuf, R14
        MOV.B   &rxNextLen, R15
        ADD.W   R15, 0x36(R14)
// 1055 
// 1056   rxPayloadLen -= rxNextLen;
        SUB.B   &rxNextLen, &rxPayloadLen
// 1057 
// 1058   rxPrepPayload();
        BRA     #rxPrepPayload
          CFI EndBlock cfiBlock37
// 1059 }
// 1060 
// 1061 
// 1062 /*=================================================================================================
// 1063  * @fn          rxFcsIsr
// 1064  *
// 1065  * @brief       Receive ISR state for handling the FCS.
// 1066  *
// 1067  * @param       none
// 1068  *
// 1069  * @return      none
// 1070  *=================================================================================================
// 1071  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1072 static void rxFcsIsr(void)
rxFcsIsr:
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function rxFcsIsr
// 1073 {
        FUNCALL rxFcsIsr, macSpiReadRxFifo
        LOCFRAME CSTACK, 16, STACK
        FUNCALL rxFcsIsr, macRxOffRequest
        LOCFRAME CSTACK, 16, STACK
        FUNCALL rxFcsIsr, MAC_SrcMatchCheckResult
        LOCFRAME CSTACK, 16, STACK
        FUNCALL rxFcsIsr, macRadioComputeLQI
        LOCFRAME CSTACK, 16, STACK
        FUNCALL rxFcsIsr, macRxCompleteCallback
        LOCFRAME CSTACK, 16, STACK
        FUNCALL rxFcsIsr, macDataRxMemFree
        LOCFRAME CSTACK, 16, STACK
        FUNCALL rxFcsIsr, macSpiWriteReg
        LOCFRAME CSTACK, 16, STACK
        FUNCALL rxFcsIsr, rxDone
        LOCFRAME CSTACK, 16, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
// 1074   uint8 crcOK;
// 1075   uint8 ackWithPending = 0;
        MOV.B   #0x0, R9
// 1076 
// 1077   /* read FCS, rxBuf is now available storage */
// 1078   MAC_RADIO_READ_RX_FIFO(rxBuf, MAC_FCS_FIELD_LEN);
        MOV.B   #0x2, R13
        MOV.W   #rxBuf, R12
        CALLA   #macSpiReadRxFifo
// 1079 
// 1080   /*
// 1081    *  The FCS has actually been replaced within the radio by a proprietary version of the FCS.
// 1082    *  This proprietary FCS is two bytes (same length as the real FCS) and contains:
// 1083    *    1) the RSSI value
// 1084    *    2) the average correlation value (used for LQI)
// 1085    *    3) a CRC passed bit
// 1086    */
// 1087 
// 1088   /* save the "CRC-is-OK" status */
// 1089   crcOK = PROPRIETARY_FCS_CRC_OK(rxBuf);
        MOV.B   &rxBuf + 1, R6
        AND.B   #0x80, R6
// 1090 
// 1091   /*
// 1092    *  See if the frame should be passed up to high-level MAC.  If the CRC is OK, the
// 1093    *  the frame is always passed up.  Frames with a bad CRC are also passed up *if*
// 1094    *  a special variant of promiscuous mode is active.
// 1095    */
// 1096   if (crcOK || (rxPromiscuousMode == MAC_PROMISCUOUS_MODE_WITH_BAD_CRC))
        MOV.W   #pRxBuf, R10
        JNE     ??rxFcsIsr_0
        CMP.B   #0x2, &rxPromiscuousMode
        JNE     ??rxFcsIsr_1
// 1097   {
// 1098     int8 rssiDbm;
// 1099     uint8 corr;
// 1100 
// 1101 #ifdef PACKET_FILTER_STATS
// 1102     rxCrcSuccess++;
// 1103 #endif /* PACKET_FILTER_STATS */
// 1104 
// 1105     /*
// 1106      *  As power saving optimization, set state variable to indicate physical receive
// 1107      *  has completed and then request turning of the receiver.  This means the receiver
// 1108      *  can be off (if other conditions permit) during execution of the callback function.
// 1109      *
// 1110      *  The receiver will be requested to turn off once again at the end of the receive
// 1111      *  logic.  There is no harm in doing this.
// 1112      */
// 1113     macRxActive = MAC_RX_ACTIVE_DONE;
??rxFcsIsr_0:
        MOV.B   #0x2, &macRxActive
// 1114     macRxOffRequest();
        CALLA   #macRxOffRequest
// 1115 
// 1116     /* decode RSSI and correlation values */
// 1117     rssiDbm = PROPRIETARY_FCS_RSSI(rxBuf) + MAC_RADIO_RSSI_OFFSET;
        MOV.B   &rxBuf, R11
        ADD.B   #0xb4, R11
// 1118     MAC_RADIO_RSSI_LNA_OFFSET(rssiDbm);
// 1119     corr = PROPRIETARY_FCS_CORRELATION_VALUE(rxBuf);
        MOV.B   &rxBuf + 1, R8
        AND.B   #0x7f, R8
// 1120 
// 1121     /* Read the source matching result back */
// 1122     if( macSrcMatchIsEnabled && MAC_RADIO_SRC_MATCH_RESULT() )
        CMP.B   #0x0, &macSrcMatchIsEnabled
        JEQ     ??rxFcsIsr_2
        CALLA   #MAC_SrcMatchCheckResult
        CMP.B   #0x0, R12
        JEQ     ??rxFcsIsr_2
// 1123     {
// 1124       /* This result will not overwrite the previously determined pRxBuf->internal.flags */
// 1125       ackWithPending = MAC_RX_FLAG_ACK_PENDING;
        MOV.B   #0x4, R9
// 1126     }
// 1127 
// 1128     /* record parameters that get passed up to high-level */
// 1129     pRxBuf->internal.flags |= ( crcOK | ackWithPending );
??rxFcsIsr_2:
        MOV.W   @R10, R15
        BIS.B   R9, R6
        BIS.B   R6, 0x7(R15)
// 1130     pRxBuf->mac.mpduLinkQuality = macRadioComputeLQI(rssiDbm, corr);
        MOV.B   R8, R13
        MOV.B   R11, R12
        CALLA   #macRadioComputeLQI
        MOV.W   @R10, R15
        MOV.B   R12, 0x32(R15)
// 1131     pRxBuf->mac.rssi = rssiDbm;
        MOV.W   @R10, R15
        MOV.B   R11, 0x34(R15)
// 1132     pRxBuf->mac.correlation = corr;
        MOV.W   @R10, R15
        MOV.B   R8, 0x33(R15)
// 1133 
// 1134     /* set the MSDU pointer to point at start of data */
// 1135     pRxBuf->mhr.p   = (uint8 *) (pRxBuf + 1);
        MOV.W   @R10, R11
        MOV.W   R11, R15
        ADD.W   #0x3a, R15
        MOV.W   R15, 0x36(R11)
// 1136     pRxBuf->msdu.p += (pRxBuf->mhr.len - pRxBuf->msdu.len);
        MOV.B   0x38(R11), R14
        MOV.B   0x4(R11), R15
        SUB.W   R15, R14
        ADD.W   R14, 0x2(R11)
// 1137 
// 1138     /* finally... execute callback function */
// 1139     macRxCompleteCallback(pRxBuf);
        MOV.W   @R10, R12
        CALLA   #macRxCompleteCallback
// 1140     pRxBuf = NULL; /* needed to indicate buffer is no longer allocated */
        JMP     ??rxFcsIsr_3
// 1141   }
// 1142   else
// 1143   {
// 1144 #ifdef PACKET_FILTER_STATS
// 1145     rxCrcFailure++;
// 1146 #endif /* PACKET_FILTER_STATS */
// 1147 
// 1148     /*
// 1149      *  The CRC is bad so no ACK was sent.  Cancel any callback and clear the flag.
// 1150      *  (It's OK to cancel the outgoing ACK even if an ACK was not requested.  It's
// 1151      *  slightly more efficient to do so.)
// 1152      */
// 1153     MAC_RADIO_CANCEL_ACK_TX_DONE_CALLBACK();
// 1154     macRxOutgoingAckFlag = 0;
??rxFcsIsr_1:
        MOV.B   #0x0, &macRxOutgoingAckFlag
// 1155 
// 1156     /* the CRC failed so the packet must be discarded */
// 1157     MEM_FREE((uint8 **)&pRxBuf);
        MOV.W   R10, R12
        CALLA   #macDataRxMemFree
// 1158     pRxBuf = NULL;  /* needed to indicate buffer is no longer allocated */
??rxFcsIsr_3:
        MOV.W   #0x0, &pRxBuf
// 1159   }
// 1160 
// 1161   /* reset threshold level, reset receive state, and complete receive logic */
// 1162   MAC_RADIO_SET_RX_THRESHOLD(RX_THRESHOLD_START_LEN);
        CALLA   #?Subroutine1
// 1163   pFuncRxState = &rxStartIsr;
// 1164   rxDone();
// 1165 }
??CrossCallReturnLabel_0:
        POPM.W  #0x6, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock38

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine1:
          CFI Block cfiCond39 Using cfiCommon0
          CFI Function rxDiscardIsr
          CFI Conditional ??rxDiscardIsr_1
          CFI CFA SP+24
          CFI Block cfiCond40 Using cfiCommon0
          CFI (cfiCond40) Function rxFcsIsr
          CFI (cfiCond40) Conditional ??CrossCallReturnLabel_0
          CFI (cfiCond40) R6L Frame(CFA, -16)
          CFI (cfiCond40) R7L Frame(CFA, -14)
          CFI (cfiCond40) R8L Frame(CFA, -12)
          CFI (cfiCond40) R9L Frame(CFA, -10)
          CFI (cfiCond40) R10L Frame(CFA, -8)
          CFI (cfiCond40) R11L Frame(CFA, -6)
          CFI (cfiCond40) CFA SP+20
          CFI Block cfiPicker41 Using cfiCommon1
          CFI (cfiPicker41) NoFunction
          CFI (cfiPicker41) Picker
        MOV.B   #0x5, R13
        MOV.B   #0x34, R12
        CALLA   #macSpiWriteReg
        CALLA   #?Subroutine8
??CrossCallReturnLabel_10:
        BRA     #rxDone
          CFI EndBlock cfiCond39
          CFI EndBlock cfiCond40
          CFI EndBlock cfiPicker41

        RSEG CODE:CODE:NOROOT(1)
macRxAckTxDoneCallback:
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function macRxAckTxDoneCallback
        FUNCALL macRxAckTxDoneCallback, rxPostRxUpdates
        LOCFRAME CSTACK, 4, STACK
        MOV.B   #0x0, &macRxOutgoingAckFlag
        CMP.B   #0x0, &macRxActive
          CFI EndBlock cfiBlock42
        REQUIRE ?Subroutine0
        // Fall through to label ?Subroutine0
// 1166 
// 1167 
// 1168 /*=================================================================================================
// 1169  * @fn          rxDone
// 1170  *
// 1171  * @brief       Common exit point for receive.
// 1172  *
// 1173  * @param       none
// 1174  *
// 1175  * @return      none
// 1176  *=================================================================================================
// 1177  */

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
          CFI Block cfiBlock43 Using cfiCommon0
          CFI NoFunction
        JNE     ??Subroutine0_0
        CALLA   #rxPostRxUpdates
??Subroutine0_0:
        RETA
          CFI EndBlock cfiBlock43

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1178 static void rxDone(void)
rxDone:
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function rxDone
// 1179 {
// 1180   /* Make sure the peak RSSI is reset */
// 1181   COMPRESSION_WORKAROUND_RESET_RSSI();
// 1182   
// 1183   /* if the receive FIFO has overflowed, flush it here */
// 1184   if (MAC_RADIO_RX_FIFO_HAS_OVERFLOWED())
        FUNCALL rxDone, macSpiCmdStrobe
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxDone, macSpiCmdStrobe
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxDone, rxPostRxUpdates
        LOCFRAME CSTACK, 4, STACK
        BIT.B   #0x40, &0x20
        JNC     ??rxDone_0
        BIT.B   #0x20, &0x20
        JC      ??rxDone_0
// 1185   {
// 1186     MAC_RADIO_FLUSH_RX_FIFO();
        CALLA   #?Subroutine3
// 1187   }
// 1188 
// 1189   /* mark receive as inactive */
// 1190   macRxActive = MAC_RX_ACTIVE_NO_ACTIVITY;
??rxDone_0:
        MOV.B   #0x0, &macRxActive
// 1191 
// 1192   /* if there is no outgoing ACK, run the post receive updates */
// 1193   if (!macRxOutgoingAckFlag)
        CMP.B   #0x0, &macRxOutgoingAckFlag
        JMP     ?Subroutine0
          CFI EndBlock cfiBlock44
        REQUIRE P1IN
// 1194   {
// 1195     rxPostRxUpdates();
// 1196   }
// 1197 }
// 1198 
// 1199 
// 1200 /**************************************************************************************************
// 1201  * @fn          macRxAckTxDoneCallback
// 1202  *
// 1203  * @brief       Function called when the outoing ACK has completed transmitting.
// 1204  *
// 1205  * @param       none
// 1206  *
// 1207  * @return      none
// 1208  **************************************************************************************************
// 1209  */
// 1210 void macRxAckTxDoneCallback(void)
// 1211 {
// 1212   macRxOutgoingAckFlag = 0;
// 1213 
// 1214   /*
// 1215    *  With certain interrupt priorities and timing conditions, it is possible this callback
// 1216    *  could be executed before the primary receive logic completes.  To prevent this, the
// 1217    *  post updates are only executed if receive logic is no longer active.  In the case the
// 1218    *  post updates are not executed here, they will execute when the main receive logic
// 1219    *  completes.
// 1220    */
// 1221   if (!macRxActive)
// 1222   {
// 1223     rxPostRxUpdates();
// 1224   }
// 1225 }
// 1226 
// 1227 
// 1228 /*=================================================================================================
// 1229  * @fn          rxPostRxUpdates
// 1230  *
// 1231  * @brief       Updates that need to be performed once receive is complete.
// 1232  *
// 1233  *              It is not fatal to execute this function if somehow receive is active.  Under
// 1234  *              certain timing/interrupt conditions a new receive may have started before this
// 1235  *              function executes.  This should happen very rarely (if it happens at all) and
// 1236  *              would cause no problems.
// 1237  *
// 1238  * @param       none
// 1239  *
// 1240  * @return      none
// 1241  *=================================================================================================
// 1242  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1243 static void rxPostRxUpdates(void)
rxPostRxUpdates:
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function rxPostRxUpdates
// 1244 {
// 1245   /* turn off receiver if permitted */
// 1246   macRxOffRequest();
        FUNCALL rxPostRxUpdates, macRxOffRequest
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxPostRxUpdates, macRadioUpdateTxPower
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxPostRxUpdates, macTxStartQueuedFrame
        LOCFRAME CSTACK, 4, STACK
        CALLA   #macRxOffRequest
// 1247 
// 1248   /* update the transmit power, update may have been blocked by transmit of outgoing ACK */
// 1249   macRadioUpdateTxPower();
        CALLA   #macRadioUpdateTxPower
// 1250 
// 1251   /* initiate and transmit that was queued during receive */
// 1252   macTxStartQueuedFrame();
        BRA     #macTxStartQueuedFrame
          CFI EndBlock cfiBlock45
// 1253 }
// 1254 
// 1255 
// 1256 /*=================================================================================================
// 1257  * @fn          rxDiscardFrame
// 1258  *
// 1259  * @brief       Initializes for discarding a packet.  Must be called before ACK is strobed.
// 1260  *
// 1261  * @param       none
// 1262  *
// 1263  * @return      none
// 1264  *=================================================================================================
// 1265  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1266 static void rxDiscardFrame(void)
rxDiscardFrame:
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function rxDiscardFrame
// 1267 {
// 1268   MAC_ASSERT(pFuncRxState == &rxStartIsr); /* illegal state for calling discard frame function */
        FUNCALL rxDiscardFrame, halAssertHandler
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxDiscardFrame, rxDone
        LOCFRAME CSTACK, 4, STACK
        FUNCALL rxDiscardFrame, macSpiWriteReg
        LOCFRAME CSTACK, 4, STACK
        CMP.W   #LWRD(rxStartIsr), &pFuncRxState
        JNE     ??rxDiscardFrame_2
        CMP.W   #HWRD(rxStartIsr), &pFuncRxState + 2
        JEQ     ??rxDiscardFrame_3
??rxDiscardFrame_2:
        CALLA   #halAssertHandler
// 1269 
// 1270   if (rxUnreadLen == 0)
??rxDiscardFrame_3:
        MOV.B   &rxUnreadLen, R14
        CMP.B   #0x0, R14
        JNE     ??rxDiscardFrame_4
// 1271   {
// 1272     rxDone();
        BRA     #rxDone
// 1273   }
// 1274   else
// 1275   {
// 1276     rxNextLen = MIN(rxUnreadLen, MAX_PAYLOAD_BYTES_READ_PER_INTERRUPT);
??rxDiscardFrame_4:
        CALLA   #?Subroutine4
// 1277     MAC_RADIO_SET_RX_THRESHOLD(rxNextLen);
??CrossCallReturnLabel_2:
        CALLA   #??Subroutine2_0
// 1278     pFuncRxState = &rxDiscardIsr;
??CrossCallReturnLabel_13:
        MOV.W   #LWRD(rxDiscardIsr), &pFuncRxState
        MOV.W   #HWRD(rxDiscardIsr), &pFuncRxState + 2
// 1279   }
// 1280 }
        RETA
          CFI EndBlock cfiBlock46
// 1281 
// 1282 
// 1283 /*=================================================================================================
// 1284  * @fn          rxDiscardIsr
// 1285  *
// 1286  * @brief       Receive ISR state for discarding a packet.
// 1287  *
// 1288  * @param       none
// 1289  *
// 1290  * @return      none
// 1291  *=================================================================================================
// 1292  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1293 static void rxDiscardIsr(void)
rxDiscardIsr:
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function rxDiscardIsr
// 1294 {
        FUNCALL rxDiscardIsr, macSpiReadRxFifo
        LOCFRAME CSTACK, 20, STACK
        FUNCALL rxDiscardIsr, macSpiWriteReg
        LOCFRAME CSTACK, 20, STACK
        FUNCALL rxDiscardIsr, macSpiWriteReg
        LOCFRAME CSTACK, 20, STACK
        FUNCALL rxDiscardIsr, rxDone
        LOCFRAME CSTACK, 20, STACK
        SUB.W   #0x10, SP
          CFI CFA SP+20
// 1295   uint8 buf[MAX_PAYLOAD_BYTES_READ_PER_INTERRUPT];
// 1296 
// 1297   MAC_RADIO_READ_RX_FIFO(buf, rxNextLen);
        MOV.B   &rxNextLen, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #macSpiReadRxFifo
// 1298   rxUnreadLen -= rxNextLen;
        SUB.B   &rxNextLen, &rxUnreadLen
// 1299 
// 1300   /* read out and discard bytes until all bytes of packet are disposed of */
// 1301   if (rxUnreadLen != 0)
        MOV.B   &rxUnreadLen, R13
        JEQ     ??rxDiscardIsr_0
// 1302   {
// 1303     if (rxUnreadLen < MAX_PAYLOAD_BYTES_READ_PER_INTERRUPT)
        CMP.B   #0x10, R13
        JC      ??rxDiscardIsr_1
// 1304     {
// 1305       rxNextLen = rxUnreadLen;
        MOV.B   R13, &rxNextLen
// 1306       MAC_RADIO_SET_RX_THRESHOLD(rxNextLen);
        ADD.B   #0xff, R13
        CALLA   #??Subroutine2_0
// 1307     }
// 1308   }
??CrossCallReturnLabel_14:
        JMP     ??rxDiscardIsr_1
// 1309   else
// 1310   {
// 1311     /* reset threshold level, reset receive state, and complete receive logic */
// 1312     MAC_RADIO_SET_RX_THRESHOLD(RX_THRESHOLD_START_LEN);
??rxDiscardIsr_0:
        CALLA   #?Subroutine1
// 1313     pFuncRxState = &rxStartIsr;
// 1314     rxDone();
// 1315   }
// 1316 }
??rxDiscardIsr_1:
        ADD.W   #0x10, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock47
// 1317 
// 1318 
// 1319 /**************************************************************************************************
// 1320  * @fn          macRxFifoOverflowIsr
// 1321  *
// 1322  * @brief       This interrupt service routine is called when RX FIFO overflow. Note that this
// 1323  *              exception does not retrieve the good frames that are trapped in the RX FIFO.
// 1324  *              It simply halts and cleanup the RX.
// 1325  *
// 1326  * @param       none
// 1327  *
// 1328  * @return      none
// 1329  **************************************************************************************************
// 1330  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1331 MAC_INTERNAL_API void macRxFifoOverflowIsr(void)
macRxFifoOverflowIsr:
          CFI Block cfiBlock48 Using cfiCommon0
          CFI Function macRxFifoOverflowIsr
// 1332 {
// 1333   rxFifoOverflowCount++; /* This flag is used for debug purpose only */
        FUNCALL macRxFifoOverflowIsr, macRxHaltCleanup
        LOCFRAME CSTACK, 4, STACK
        ADD.B   #0x1, &rxFifoOverflowCount
// 1334   macRxHaltCleanup();
        BRA     #macRxHaltCleanup
          CFI EndBlock cfiBlock48
// 1335 }
// 1336 
// 1337 
// 1338 /**************************************************************************************************
// 1339  * @fn          macRxPromiscuousMode
// 1340  *
// 1341  * @brief       Sets promiscuous mode - enabling or disabling it.
// 1342  *
// 1343  * @param       none
// 1344  *
// 1345  * @return      none
// 1346  **************************************************************************************************
// 1347  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1348 MAC_INTERNAL_API void macRxPromiscuousMode(uint8 mode)
macRxPromiscuousMode:
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function macRxPromiscuousMode
// 1349 {
// 1350   rxPromiscuousMode = mode;
        FUNCALL macRxPromiscuousMode, macDualchipOrFRMFILT0
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macRxPromiscuousMode, halAssertHandler
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macRxPromiscuousMode, macDualchipAndFRMFILT0
        LOCFRAME CSTACK, 4, STACK
        MOV.B   R12, &rxPromiscuousMode
// 1351 
// 1352   if (rxPromiscuousMode == MAC_PROMISCUOUS_MODE_OFF)
        CMP.B   #0x0, R12
        JNE     ??macRxPromiscuousMode_0
// 1353   {
// 1354     MAC_RADIO_TURN_ON_RX_FRAME_FILTERING();
        MOV.B   #0x5, R12
        BRA     #macDualchipOrFRMFILT0
// 1355   }
// 1356   else
// 1357   {
// 1358     MAC_ASSERT((mode == MAC_PROMISCUOUS_MODE_WITH_BAD_CRC)   ||
// 1359                (mode == MAC_PROMISCUOUS_MODE_COMPLIANT));  /* invalid mode */
??macRxPromiscuousMode_0:
        CMP.B   #0x2, R12
        JEQ     ??macRxPromiscuousMode_1
        CMP.B   #0x1, R12
        JEQ     ??macRxPromiscuousMode_1
        CALLA   #halAssertHandler
// 1360 
// 1361     MAC_RADIO_TURN_OFF_RX_FRAME_FILTERING();
??macRxPromiscuousMode_1:
        MOV.B   #0xfe, R12
        BRA     #macDualchipAndFRMFILT0
          CFI EndBlock cfiBlock49
// 1362   }
// 1363 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 1364 
// 1365 #ifdef CC2591_COMPRESSION_WORKAROUND
// 1366 /**************************************************************************************************
// 1367  * @fn          macRxResetRssi
// 1368  *
// 1369  * @brief       This function reset RSSI peak if the device is not actively in TX or RX.
// 1370  *
// 1371  * @param       none
// 1372  *
// 1373  * @return      none
// 1374  **************************************************************************************************
// 1375  */
// 1376 void macRxResetRssi(void)
// 1377 {
// 1378   if ( !(macRxActive || macRxOutgoingAckFlag || macTxActive) )
// 1379   {
// 1380     COMPRESSION_WORKAROUND_RESET_RSSI();
// 1381   }
// 1382 }
// 1383 #endif /* CC2591_COMPRESSION_WORKAROUND */
// 1384 
// 1385 /**************************************************************************************************
// 1386  *                                  Compile Time Integrity Checks
// 1387  **************************************************************************************************
// 1388  */
// 1389 
// 1390 /* check for changes to the spec that would affect the source code */
// 1391 #if ((MAC_A_MAX_PHY_PACKET_SIZE   !=  0x7F )   ||  \ 
// 1392      (MAC_FCF_FIELD_LEN           !=  2    )   ||  \ 
// 1393      (MAC_FCF_FRAME_TYPE_POS      !=  0    )   ||  \ 
// 1394      (MAC_FCF_FRAME_PENDING_POS   !=  4    )   ||  \ 
// 1395      (MAC_FCF_ACK_REQUEST_POS     !=  5    )   ||  \ 
// 1396      (MAC_FCF_INTRA_PAN_POS       !=  6    )   ||  \ 
// 1397      (MAC_FCF_DST_ADDR_MODE_POS   !=  10   )   ||  \ 
// 1398      (MAC_FCF_FRAME_VERSION_POS   !=  12   )   ||  \ 
// 1399      (MAC_FCF_SRC_ADDR_MODE_POS   !=  14   ))
// 1400 #error "ERROR!  Change to the spec that requires modification of source code."
// 1401 #endif
// 1402 
// 1403 /* check for changes to the internal flags format */
// 1404 #if ((MAC_RX_FLAG_VERSION      !=  0x03)  ||  \ 
// 1405      (MAC_RX_FLAG_ACK_PENDING  !=  0x04)  ||  \ 
// 1406      (MAC_RX_FLAG_SECURITY     !=  0x08)  ||  \ 
// 1407      (MAC_RX_FLAG_PENDING      !=  0x10)  ||  \ 
// 1408      (MAC_RX_FLAG_ACK_REQUEST  !=  0x20)  ||  \ 
// 1409      (MAC_RX_FLAG_INTRA_PAN    !=  0x40))
// 1410 #error "ERROR!  Change to the internal RX flags format.  Requires modification of source code."
// 1411 #endif
// 1412 
// 1413 /* validate CRC OK bit optimization */
// 1414 #if (MAC_RX_FLAG_CRC_OK != PROPRIETARY_FCS_CRC_OK_BIT)
// 1415 #error "ERROR!  Optimization relies on these bits having the same position."
// 1416 #endif
// 1417 
// 1418 #if (MAC_RX_ACTIVE_NO_ACTIVITY != 0x00)
// 1419 #error "ERROR! Zero is reserved value of macRxActive. Allows boolean operations, e.g !macRxActive."
// 1420 #endif
// 1421 
// 1422 #if (MAC_PROMISCUOUS_MODE_OFF != 0x00)
// 1423 #error "ERROR! Zero is reserved value of rxPromiscuousMode. Allows boolean operations, e.g !rxPromiscuousMode."
// 1424 #endif
// 1425 
// 1426 
// 1427 /**************************************************************************************************
// 1428 */
// 
// 1 666 bytes in segment CODE
//     3 bytes in segment DATA16_AN
//     4 bytes in segment DATA16_C
//    21 bytes in segment DATA16_Z
// 
// 1 666 bytes of CODE  memory
//     4 bytes of CONST memory
//    21 bytes of DATA  memory (+ 3 bytes shared)
//
//Errors: none
//Warnings: none

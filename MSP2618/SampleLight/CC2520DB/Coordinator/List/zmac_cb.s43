///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430      10/Jun/2013  16:24:38 /
// Copyright 1996-2013 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\z /
//                     mac\f8w\zmac_cb.c                                      /
//    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleLight\CC2520DB\..\..\..\T /
//                     ools\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0    /
//                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                      /
//                     -DDEFAULT_CHANLIST=0x00000800                          /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100     /
//                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                  /
//                     -DBEACON_REQUEST_DELAY=100                             /
//                     -DBEACON_REQ_DELAY_MASK=0x00FF                         /
//                     -DLINK_STATUS_JITTER_MASK=0x007F                       /
//                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED /
//                     =3000 -DNWK_INDIRECT_MSG_TIMEOUT=7                     /
//                     -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3        /
//                     -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2  /
//                     -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16                      /
//                     -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4       /
//                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,      /
//                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,  /
//                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                   /
//                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS= /
//                     20 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000         /
//                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100        /
//                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\ /
//                     f8wCoord.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE=T /
//                     RUE -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         /
//                     -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK) -f     /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\..\..\..\Tool /
//                     s\MSP2618\f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE          /
//                     -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF                /
//                     -DZCL_KEY_ESTABLISH -DZCL_KEY_ESTABLISHMENT_KEY_GENERA /
//                     TE_TIMEOUT=4 -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIME /
//                     OUT=10 -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=1 /
//                     0 -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING             /
//                     -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING            /
//                     -DZCL_TOU) -DZCL_DEVICE_MGMT "C:\Texas                 /
//                     Instruments\ZStack-MSP2618-2.5.1\Components\zmac\f8w\z /
//                     mac_cb.c" -D MSP430F2618 -D ZTOOL_P1 -D MT_TASK -D     /
//                     MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED -lC        /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\Coordinator\L /
//                     ist\" -lA "C:\Texas Instruments\ZStack-MSP2618-2.5.1\P /
//                     rojects\zstack\HomeAutomation\SampleLight\CC2520DB\Coo /
//                     rdinator\List\" --remarks --diag_suppress              /
//                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\Coordinator\Obj\"       /
//                     --debug -D__MSP430F2618__ -e --double=32 --clib -I     /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\" -I          /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\..\Source\"   /
//                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleLight\CC2520DB\..\..\Sour /
//                     ce\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pro /
//                     jects\zstack\HomeAutomation\SampleLight\CC2520DB\..\.. /
//                     \..\ZMain\MSP2618\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\hal\include\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\hal\target\MSP2618CC2520\" -I "C:\Texas             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\include\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\high_level\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\low_level\srf04\" -I "C:\Texas                  /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\low_level\srf04\dual_chip\" -I "C:\Texas        /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ /
//                     Projects\zstack\HomeAutomation\SampleLight\CC2520DB\.. /
//                     \..\..\..\..\Components\osal\include\" -I "C:\Texas    /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\osal\mcu\msp430\" -I "C:\Texas                      /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\services\saddr\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\services\sdata\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\af\" -I "C:\Texas                             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\nwk\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sec\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sapi\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sys\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\zcl\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\zdo\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5. /
//                     1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB\ /
//                     ..\..\..\..\..\Components\zmac\f8w\" --core=430X       /
//                     --data_model=small -Ohz --multiplier=16s               /
//                     --require_prototypes                                   /
//    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst /
//                     ack\HomeAutomation\SampleLight\CC2520DB\Coordinator\Li /
//                     st\zmac_cb.s43                                         /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME zmac_cb

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?DivMod16u
        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC MAC_CbackCheckPending
        FUNCTION MAC_CbackCheckPending,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC MAC_CbackEvent
        FUNCTION MAC_CbackEvent,0e1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 16, STACK
        FUNCTION ZMacLqiAdjust,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC ZMacLqiAdjustMode
        FUNCTION ZMacLqiAdjustMode,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC pZMac_AppCallback
        PUBLIC zmacCBSizeTable
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN nwkDB_ReturnIndirectHoldingCnt
        FUNCTION nwkDB_ReturnIndirectHoldingCnt,0202H
        EXTERN MAC_MlmeGetReq
        FUNCTION MAC_MlmeGetReq,0202H
        EXTERN osal_msg_allocate
        FUNCTION osal_msg_allocate,0202H
        EXTERN mac_msg_deallocate
        FUNCTION mac_msg_deallocate,0202H
        EXTERN osal_memcpy
        FUNCTION osal_memcpy,0202H
        EXTERN ZMac_ScanBuf
        EXTERN osal_mem_free
        FUNCTION osal_mem_free,0202H
        EXTERN _NIB
        EXTERN nwk_broadcastSend
        FUNCTION nwk_broadcastSend,0202H
        EXTERN NWK_TaskID
        EXTERN osal_msg_send
        FUNCTION osal_msg_send,0202H

// C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\zmac\f8w\zmac_cb.c
//    1 /**************************************************************************************************
//    2   Filename:       zmac_cb.c
//    3   Revised:        $Date: 2012-03-08 17:10:16 -0800 (Thu, 08 Mar 2012) $
//    4   Revision:       $Revision: 29685 $
//    5 
//    6   Description:    This file contains the NWK functions that the ZMAC calls
//    7 
//    8 
//    9   Copyright 2005-2012 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /********************************************************************************************************
//   41  *                                               INCLUDES
//   42  ********************************************************************************************************/
//   43 
//   44 #include "ZComDef.h"
//   45 #include "OSAL.h"
//   46 #include "ZMAC.h"
//   47 #include "MT_MAC.h"
//   48 #include "hal_mcu.h"
//   49 
//   50 #if !defined NONWK
//   51 #include "nwk.h"
//   52 #include "nwk_bufs.h"
//   53 #include "ZGlobals.h"
//   54 #endif
//   55 
//   56 #if defined( MACSIM )
//   57   #include "mac_sim.h"
//   58 #endif
//   59 
//   60 #include "mac_security.h"
//   61 
//   62 #include "mac_main.h"
//   63 extern void *ZMac_ScanBuf;
//   64 
//   65 /********************************************************************************************************
//   66  *                                               CONSTANTS
//   67  ********************************************************************************************************/
//   68 
//   69 #if !defined NONWK
//   70 /* Lookup table for size of structures. Must match with the order of MAC callback events */

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
//   71 const uint8 CODE zmacCBSizeTable [] = {
zmacCBSizeTable:
        DC8 0, 22, 16, 0, 0, 14, 21, 12, 2, 0, 2, 36, 16, 54, 0, 0, 6
//   72   0,
//   73   sizeof(ZMacAssociateInd_t),       // MAC_MLME_ASSOCIATE_IND      1   Associate indication
//   74   sizeof(ZMacAssociateCnf_t),       // MAC_MLME_ASSOCIATE_CNF      2   Associate confirm
//   75   0,                                // MAC_MLME_DISASSOCIATE_IND   3   Disassociate indication
//   76   0,                                // MAC_MLME_DISASSOCIATE_CNF   4   Disassociate confirm
//   77   sizeof(macMlmeBeaconNotifyInd_t), // MAC_MLME_BEACON_NOTIFY_IND  5   con notify indication
//   78   sizeof(ZMacOrphanInd_t),          // MAC_MLME_ORPHAN_IND         6   Orphan indication
//   79   sizeof(ZMacScanCnf_t),            // MAC_MLME_SCAN_CNF           7   Scan confirm
//   80   sizeof(ZMacStartCnf_t),           // MAC_MLME_START_CNF          8   Start confirm
//   81   0,                                // MAC_MLME_SYNC_LOSS_IND      9   Sync loss indication
//   82   sizeof(ZMacPollCnf_t),            // MAC_MLME_POLL_CNF           10  Poll confirm
//   83   sizeof(ZMacCommStatusInd_t),      // MAC_MLME_COMM_STATUS_IND    11  Comm status indication
//   84   sizeof(ZMacDataCnf_t),            // MAC_MCPS_DATA_CNF           12  Data confirm
//   85   sizeof(macMcpsDataInd_t),         // MAC_MCPS_DATA_IND           13  Data indication
//   86   0,                                // MAC_MCPS_PURGE_CNF          14  Purge confirm
//   87   0,                                // MAC_PWR_ON_CNF              15  Power on confirm
//   88   sizeof(ZMacPollInd_t)             // MAC_MLME_POLL_IND           16  Poll indication
//   89 };
//   90 #endif /* !defined NONWK */
//   91 
//   92 /********************************************************************************************************
//   93  *                                               LOCALS
//   94  ********************************************************************************************************/
//   95 
//   96 /* LQI Adjustment Mode */

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//   97 static ZMacLqiAdjust_t lqiAdjMode = LQI_ADJ_OFF;
lqiAdjMode:
        DS8 1
//   98 
//   99 #if !defined NONWK
//  100 /* LQI Adjustment Function */
//  101 static void ZMacLqiAdjust( uint8 corr, uint8* lqi );
//  102 #endif
//  103 
//  104 /*********************************************************************
//  105  * ZMAC Function Pointers
//  106  */
//  107 
//  108 /*
//  109  * ZMac Application callback function. This function will be called
//  110  * for every MAC message that is received over-the-air or generated
//  111  * locally by MAC for the application.
//  112  *
//  113  * The callback function should return TRUE if it has handled the
//  114  * MAC message and no further action should be taken with it. It
//  115  * should return FALSE if it has not handled the MAC message and
//  116  * normal processing should take place.
//  117  *
//  118  * NOTE: The processing in this function should be kept to the
//  119  *       minimum.
//  120  */

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  121 uint8 (*pZMac_AppCallback)( uint8 *msgPtr ) = (void*)NULL;
pZMac_AppCallback:
        DS8 4
//  122 
//  123 
//  124 /*********************************************************************
//  125  * ZMAC Functions
//  126  */
//  127 
//  128 /**************************************************************************************************
//  129  * @fn       MAC_CbackEvent()
//  130  *
//  131  * @brief    convert MAC data confirm and indication to ZMac and send to NWK
//  132  *
//  133  * @param    pData - pointer to macCbackEvent_t
//  134  *
//  135  * @return   none
//  136  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  137 void MAC_CbackEvent(macCbackEvent_t *pData)
MAC_CbackEvent:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function MAC_CbackEvent
//  138 #ifndef MT_MAC_CB_FUNC
//  139 {
        FUNCALL MAC_CbackEvent, MAC_MlmeGetReq
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, osal_msg_allocate
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, mac_msg_deallocate
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, osal_msg_allocate
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, osal_memcpy
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, osal_memcpy
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, osal_memcpy
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, osal_memcpy
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, osal_memcpy
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, osal_mem_free
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, mac_msg_deallocate
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, ZMacLqiAdjust
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, nwk_broadcastSend
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, mac_msg_deallocate
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, ZMacLqiAdjust
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, osal_msg_send
        LOCFRAME CSTACK, 16, STACK
        FUNCALL MAC_CbackEvent, mac_msg_deallocate
        LOCFRAME CSTACK, 16, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        PUSH.W  R12
          CFI CFA SP+14
        SUB.W   #0x2, SP
          CFI CFA SP+16
//  140 #if !defined NONWK
//  141   uint8 event = pData->hdr.event;
        MOV.W   0x2(SP), R15
        MOV.B   @R15, R10
//  142   uint16 tmp = zmacCBSizeTable[event];
        MOV.B   zmacCBSizeTable(R10), R11
        MOV.W   R11, 0(SP)
//  143   macCbackEvent_t *msgPtr;
//  144 
//  145   /* If the Network layer will handle a new MAC callback, a non-zero value must be entered in the
//  146    * corresponding location in the zmacCBSizeTable[] - thus the table acts as "should handle"?
//  147    */
//  148   if (tmp == 0)
        CMP.B   #0x0, R11
        JEQ     ??MAC_CbackEvent_0
//  149   {
//  150     return;
//  151   }
//  152 
//  153   // MAC_MCPS_DATA_IND is very special - it is the only event where the MAC does not free *pData.
//  154   if ( event == MAC_MCPS_DATA_IND )
        CMP.B   #0xd, R10
        JNE     ??MAC_CbackEvent_8
//  155   {
//  156     MAC_MlmeGetReq( MAC_SHORT_ADDRESS, &tmp );
        MOV.W   SP, R13
        ADD.W   #0x0, R13
        MOV.B   #0x53, R12
        CALLA   #MAC_MlmeGetReq
//  157     if ((tmp == INVALID_NODE_ADDR) || (tmp == NWK_BROADCAST_SHORTADDR_DEVALL) ||
//  158         (pData->dataInd.msdu.len == 0))
        CMP.W   #0xfffe, 0(SP)
        JEQ     ??MAC_CbackEvent_6
        CMP.W   #0xffff, 0(SP)
        JEQ     ??MAC_CbackEvent_6
        MOV.W   0x2(SP), R8
        CMP.B   #0x0, 0x4(R8)
        JEQ     ??MAC_CbackEvent_6
        JMP     ??MAC_CbackEvent_9
//  159     {
//  160       mac_msg_deallocate( (uint8 **)&pData );
//  161       return;
//  162     }
//  163     msgPtr = pData;
//  164   }
//  165   else
//  166   {
//  167     if (event == MAC_MLME_BEACON_NOTIFY_IND )
??MAC_CbackEvent_8:
        CMP.B   #0x5, R10
        JNE     ??MAC_CbackEvent_10
//  168     {
//  169       tmp += sizeof(macPanDesc_t) + pData->beaconNotifyInd.sduLength;
        MOV.W   0x2(SP), R15
        MOV.B   0xa(R15), R15
        ADD.W   #0x22, R15
        JMP     ??MAC_CbackEvent_11
//  170     }
//  171     else if (event == MAC_MLME_SCAN_CNF)
??MAC_CbackEvent_10:
        CMP.B   #0x7, R10
        JNE     ??MAC_CbackEvent_12
//  172     {
//  173       if (pData->scanCnf.scanType == ZMAC_ED_SCAN)
        MOV.W   0x2(SP), R15
        CMP.B   #0x0, 0x2(R15)
        JNE     ??MAC_CbackEvent_13
//  174       {
//  175         tmp += ZMAC_ED_SCAN_MAXCHANNELS;
        MOV.W   R11, R15
        ADD.W   #0x1b, R15
        JMP     ??MAC_CbackEvent_14
//  176       }
//  177       else
//  178       {
//  179         tmp += sizeof( ZMacPanDesc_t ) * pData->scanCnf.resultListSize;
??MAC_CbackEvent_13:
        MOV.B   0x8(R15), R15
        RLA.W   R15
        MOV.W   R15, R14
        RLAM.W  #0x4, R15
        ADD.W   R14, R15
??MAC_CbackEvent_11:
        ADD.W   R11, R15
??MAC_CbackEvent_14:
        MOV.W   R15, 0(SP)
//  180       }
//  181     }
//  182 
//  183     if ( !(msgPtr = (macCbackEvent_t *)osal_msg_allocate(tmp)) )
??MAC_CbackEvent_12:
        MOV.W   @SP, R12
        CALLA   #osal_msg_allocate
        MOV.W   R12, R8
        CMP.W   #0x0, R12
        JNE     ??MAC_CbackEvent_15
//  184     {
//  185       // Not enough memory. If data confirm - try again
//  186       if ((event == MAC_MCPS_DATA_CNF) && (pData->dataCnf.pDataReq != NULL))
        CMP.B   #0xc, R10
        JNE     ??MAC_CbackEvent_0
        MOV.W   0x2(SP), R15
        CMP.W   #0x0, 0x4(R15)
        JEQ     ??MAC_CbackEvent_0
//  187       {
//  188         halIntState_t intState;
//  189 
//  190         // This is not normally deallocated here because the pZMac_AppCallback()
//  191         // application may need it.
//  192         HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
        MOV.W   SR, R9
        dint
        nop
//  193 
//  194         mac_msg_deallocate( (uint8**)&(pData->dataCnf.pDataReq) );
        MOV.W   0x2(SP), R12
        ADD.W   #0x4, R12
        CALLA   #mac_msg_deallocate
//  195         if ( !(msgPtr = (macCbackEvent_t *)osal_msg_allocate(tmp)) )
        MOV.W   @SP, R12
        CALLA   #osal_msg_allocate
        MOV.W   R12, R8
        CMP.W   #0x0, R12
        JNE     ??MAC_CbackEvent_16
//  196         {
//  197           // Still no allocation, something is wrong
//  198           HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
        MOV.W   R9, SR
//  199           return;
        JMP     ??MAC_CbackEvent_0
//  200         }
//  201         HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
??MAC_CbackEvent_16:
        MOV.W   R9, SR
//  202       }
//  203       else
//  204       {
//  205         // This message is dropped
//  206         return;
//  207       }
//  208     }
//  209     osal_memcpy(msgPtr, pData, zmacCBSizeTable[event]);
??MAC_CbackEvent_15:
        MOV.W   R11, R14
        MOV.W   0x2(SP), R13
        MOV.W   R8, R12
        CALLA   #osal_memcpy
//  210   }
//  211 
//  212   if ( event == MAC_MLME_BEACON_NOTIFY_IND )
        MOV.W   R8, R11
        ADD.W   #0xc, R11
        CMP.B   #0x5, R10
        JNE     ??MAC_CbackEvent_17
//  213   {
//  214     macMlmeBeaconNotifyInd_t *pBeacon = (macMlmeBeaconNotifyInd_t*)msgPtr;
//  215 
//  216     osal_memcpy(pBeacon+1, pBeacon->pPanDesc, sizeof(macPanDesc_t));
        MOV.W   #0x22, R14
        MOV.W   0x4(R8), R13
        MOV.W   R8, R12
        ADD.W   #0xe, R12
        CALLA   #osal_memcpy
//  217     pBeacon->pPanDesc = (macPanDesc_t *)(pBeacon+1);
        MOV.W   R8, R12
        ADD.W   #0xe, R12
        MOV.W   R12, 0x4(R8)
//  218     osal_memcpy(pBeacon->pPanDesc+1, pBeacon->pSdu, pBeacon->sduLength);
        MOV.B   0xa(R8), R14
        MOV.W   @R11, R13
        ADD.W   #0x22, R12
        CALLA   #osal_memcpy
//  219     pBeacon->pSdu = (uint8 *)(pBeacon->pPanDesc+1);
        MOV.W   0x4(R8), R15
        ADD.W   #0x22, R15
        MOV.W   R15, 0xc(R8)
        JMP     ??MAC_CbackEvent_9
//  220   }
//  221   else if (event == MAC_MLME_SCAN_CNF)
??MAC_CbackEvent_17:
        CMP.B   #0x7, R10
        JNE     ??MAC_CbackEvent_9
//  222   {
//  223     macMlmeScanCnf_t *pScan = (macMlmeScanCnf_t*)msgPtr;
//  224 
//  225     if (ZMac_ScanBuf != NULL)
        MOV.W   &ZMac_ScanBuf, R9
        CMP.W   #0x0, R9
        JEQ     ??MAC_CbackEvent_9
//  226     {
//  227       void *pTmp = ZMac_ScanBuf;
//  228       ZMac_ScanBuf = NULL;
        MOV.W   #0x0, &ZMac_ScanBuf
//  229 
//  230       if (pScan->scanType == ZMAC_ED_SCAN)
        CMP.B   #0x0, 0x2(R8)
        MOV.W   R11, 0xa(R8)
        JNE     ??MAC_CbackEvent_18
//  231       {
//  232         pScan->result.pEnergyDetect = (uint8*) (pScan + 1);
//  233         osal_memcpy(pScan->result.pEnergyDetect, pTmp, ZMAC_ED_SCAN_MAXCHANNELS);
        MOV.W   #0x1b, R14
        JMP     ??MAC_CbackEvent_19
//  234       }
//  235       else
//  236       {
//  237         pScan->result.pPanDescriptor = (macPanDesc_t*) (pScan + 1);
//  238         osal_memcpy(pScan + 1, pTmp, sizeof( ZMacPanDesc_t ) * pScan->resultListSize);
??MAC_CbackEvent_18:
        MOV.B   0x8(R8), R14
        RLA.W   R14
        MOV.W   R14, R15
        RLAM.W  #0x4, R14
        ADD.W   R15, R14
??MAC_CbackEvent_19:
        MOV.W   R9, R13
        MOV.W   R11, R12
        CALLA   #osal_memcpy
//  239       }
//  240 
//  241       osal_mem_free(pTmp);
        MOV.W   R9, R12
        CALLA   #osal_mem_free
//  242     }
//  243   }
//  244 
//  245   if ( ( pZMac_AppCallback == NULL ) || ( pZMac_AppCallback( (uint8 *)msgPtr ) == FALSE ) )
??MAC_CbackEvent_9:
        MOV.W   &pZMac_AppCallback, R15
        BIS.W   &pZMac_AppCallback + 2, R15
        CMP.W   #0x0, R15
        JEQ     ??MAC_CbackEvent_20
        MOV.W   R8, R12
        CALLA   &pZMac_AppCallback
        CMP.B   #0x0, R12
        JNE     ??MAC_CbackEvent_21
//  246   {
//  247     // Filter out non-zigbee packets
//  248     if ( event == MAC_MCPS_DATA_IND )
??MAC_CbackEvent_20:
        CMP.B   #0xd, R10
        JNE     ??MAC_CbackEvent_22
//  249     {
//  250       uint8 fcFrameType = (pData->dataInd.msdu.p[0] & 0x03);
//  251       uint8 fcProtoVer = ((pData->dataInd.msdu.p[0] >> 2) & 0x0F);
//  252       uint8 fcReserve = (pData->dataInd.msdu.p[1] & 0xE0);
        MOV.W   0x2(SP), R15
        MOV.W   0x2(R15), R15
        MOV.B   0x1(R15), R14
        AND.B   #0xe0, R14
        MOV.B   @R15, R13
        AND.B   #0x3, R13
        CMP.B   #0x2, R13
        JC      ??MAC_CbackEvent_6
        MOV.B   @R15, R15
        RPT     #0x2
        RRUX.B  R15
        AND.B   #0xf, R15
        CMP.B   &_NIB + 18, R15
        JNE     ??MAC_CbackEvent_6
        CMP.B   #0x0, R14
        JNE     ??MAC_CbackEvent_6
        MOV.W   0x2(SP), R15
        CMP.B   #0x2, 0x1c(R15)
        JNE     ??MAC_CbackEvent_6
//  253       if ( (fcFrameType > 0x01) || (fcProtoVer != _NIB.nwkProtocolVersion) || (fcReserve != 0)
//  254           || (pData->dataInd.mac.srcAddr.addrMode != SADDR_MODE_SHORT) )
//  255       {
//  256         // Drop the message
//  257         mac_msg_deallocate( (uint8 **)&pData );
//  258         return;
//  259       }
//  260       else
//  261       {
//  262         macDataInd_t *pInd = &msgPtr->dataInd.mac;
        MOV.W   R8, R15
        ADD.W   #0x14, R15
//  263         // See if LQI needs adjustment due to frame correlation
//  264         ZMacLqiAdjust( pInd->correlation, &pInd->mpduLinkQuality );
        MOV.W   R15, R13
        ADD.W   #0x1e, R13
        MOV.B   0x1f(R15), R12
        CALLA   #ZMacLqiAdjust
//  265 
//  266         // Look for broadcast message that has a radius of greater 1
//  267         if ( (pData->dataInd.mac.dstAddr.addr.shortAddr == 0xFFFF)
//  268                && (pData->dataInd.msdu.p[6] > 1) )
        MOV.W   0x2(SP), R15
        CMP.W   #0xffff, 0x1e(R15)
        JNE     ??MAC_CbackEvent_23
        MOV.W   0x2(R15), R15
        CMP.B   #0x2, 0x6(R15)
        JNC     ??MAC_CbackEvent_23
//  269         {
//  270           // Send the messsage to a special broadcast queue
//  271           if ( nwk_broadcastSend( (uint8 *)msgPtr ) != SUCCESS )
        MOV.W   R8, R12
        CALLA   #nwk_broadcastSend
        CMP.B   #0x0, R12
        JEQ     ??MAC_CbackEvent_0
//  272           {
//  273             // Drop the message, too many broadcast messages to process
//  274             mac_msg_deallocate( (uint8 **)&pData );
??MAC_CbackEvent_6:
        MOV.W   SP, R12
        ADD.W   #0x2, R12
        JMP     ??MAC_CbackEvent_4
//  275           }
//  276           return;
//  277         }
//  278       }
//  279     }
//  280     else if ((event == MAC_MCPS_DATA_CNF) && (pData->hdr.status != MAC_NO_RESOURCES))
??MAC_CbackEvent_22:
        CMP.B   #0xc, R10
        JNE     ??MAC_CbackEvent_23
        MOV.W   0x2(SP), R15
        CMP.B   #0x1a, 0x1(R15)
        JEQ     ??MAC_CbackEvent_23
//  281     {
//  282       macMcpsDataCnf_t *pCnf = &msgPtr->dataCnf;
//  283       
//  284       if (pCnf->pDataReq->internal.txOptions & MAC_TXOPTION_ACK)
        MOV.W   0x4(R8), R15
        BIT.B   #0x1, 0xf(R15)
        JNC     ??MAC_CbackEvent_23
//  285       {
//  286         // See if LQI needs adjustment due to frame correlation
//  287         ZMacLqiAdjust( pCnf->correlation, &pCnf->mpduLinkQuality );
        MOV.W   R8, R13
        ADD.W   #0xd, R13
        MOV.B   0xe(R8), R12
        CALLA   #ZMacLqiAdjust
//  288       }
//  289     }
//  290 
//  291     // Application hasn't already processed this message. Send it to NWK task.
//  292     osal_msg_send( NWK_TaskID, (uint8 *)msgPtr );
??MAC_CbackEvent_23:
        MOV.W   R8, R13
        MOV.B   &NWK_TaskID, R12
        CALLA   #osal_msg_send
//  293   }
//  294 
//  295   if ((event == MAC_MCPS_DATA_CNF) && (pData->dataCnf.pDataReq != NULL))
??MAC_CbackEvent_21:
        CMP.B   #0xc, R10
        JNE     ??MAC_CbackEvent_0
        MOV.W   0x2(SP), R12
        CMP.W   #0x0, 0x4(R12)
        JEQ     ??MAC_CbackEvent_0
//  296   {
//  297     // If the application needs 'pDataReq' then we cannot free it here.
//  298     // The application must free it after using it. Note that 'pDataReq'
//  299     // is of macMcpsDataReq_t (and not ZMacDataReq_t) type.
//  300 
//  301     mac_msg_deallocate( (uint8**)&(pData->dataCnf.pDataReq) );
        ADD.W   #0x4, R12
??MAC_CbackEvent_4:
        CALLA   #mac_msg_deallocate
//  302   }
//  303 #endif
//  304 }
??MAC_CbackEvent_0:
        ADD.W   #0x4, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock0
//  305 #else  // ifdef MT_MAC_CB_FUNC
//  306 {
//  307   /* Check if MT has subscribed for this callback If so, pass it as an event to MonitorTest */
//  308   switch (pData->hdr.event)
//  309   {
//  310     case MAC_MLME_ASSOCIATE_IND:
//  311       if ( _macCallbackSub & CB_ID_NWK_ASSOCIATE_IND )
//  312         nwk_MTCallbackSubNwkAssociateInd ( (ZMacAssociateInd_t *)pData );
//  313       break;
//  314 
//  315     case MAC_MLME_ASSOCIATE_CNF:
//  316       if ( _macCallbackSub & CB_ID_NWK_ASSOCIATE_CNF )
//  317         nwk_MTCallbackSubNwkAssociateCnf ( (ZMacAssociateCnf_t *)pData );
//  318       break;
//  319 
//  320     case MAC_MLME_DISASSOCIATE_IND:
//  321       if ( _macCallbackSub & CB_ID_NWK_DISASSOCIATE_IND )
//  322         nwk_MTCallbackSubNwkDisassociateInd ( (ZMacDisassociateInd_t *)pData );
//  323       break;
//  324 
//  325     case MAC_MLME_DISASSOCIATE_CNF:
//  326       if ( _macCallbackSub & CB_ID_NWK_DISASSOCIATE_CNF )
//  327         nwk_MTCallbackSubNwkDisassociateCnf ( (ZMacDisassociateCnf_t *)pData );
//  328       break;
//  329 
//  330     case MAC_MLME_BEACON_NOTIFY_IND:
//  331       if ( _macCallbackSub & CB_ID_NWK_BEACON_NOTIFY_IND )
//  332         nwk_MTCallbackSubNwkBeaconNotifyInd( (ZMacBeaconNotifyInd_t *)pData );
//  333       break;
//  334 
//  335     case MAC_MLME_ORPHAN_IND:
//  336       if ( _macCallbackSub & CB_ID_NWK_ORPHAN_IND )
//  337         nwk_MTCallbackSubNwkOrphanInd( (ZMacOrphanInd_t *) pData );
//  338       break;
//  339 
//  340     case MAC_MLME_SCAN_CNF:
//  341       if ( _macCallbackSub & CB_ID_NWK_SCAN_CNF )
//  342       {
//  343         pData->scanCnf.result.pEnergyDetect = ZMac_ScanBuf;
//  344         nwk_MTCallbackSubNwkScanCnf ( (ZMacScanCnf_t *) pData );
//  345       }
//  346 
//  347       if (ZMac_ScanBuf != NULL)
//  348       {
//  349         void *pTmp = ZMac_ScanBuf;
//  350         ZMac_ScanBuf = NULL;
//  351         osal_mem_free(pTmp);
//  352       }
//  353       break;
//  354 
//  355     case MAC_MLME_START_CNF:
//  356       if ( _macCallbackSub & CB_ID_NWK_START_CNF )
//  357         nwk_MTCallbackSubNwkStartCnf ( pData->hdr.status );
//  358       break;
//  359 
//  360     case MAC_MLME_SYNC_LOSS_IND:
//  361       if ( _macCallbackSub & CB_ID_NWK_SYNC_LOSS_IND )
//  362        nwk_MTCallbackSubNwkSyncLossInd( (ZMacSyncLossInd_t *) pData );
//  363       break;
//  364 
//  365     case MAC_MLME_POLL_CNF:
//  366       if ( _macCallbackSub & CB_ID_NWK_POLL_CNF )
//  367          nwk_MTCallbackSubNwkPollCnf( pData->hdr.status );
//  368       break;
//  369 
//  370     case MAC_MLME_COMM_STATUS_IND:
//  371       if ( _macCallbackSub & CB_ID_NWK_COMM_STATUS_IND )
//  372         nwk_MTCallbackSubCommStatusInd ( (ZMacCommStatusInd_t *) pData );
//  373       break;
//  374 
//  375     case MAC_MCPS_DATA_CNF:
//  376       if (pData->dataCnf.pDataReq != NULL)
//  377         mac_msg_deallocate((uint8**)&pData->dataCnf.pDataReq);
//  378 
//  379       if ( _macCallbackSub & CB_ID_NWK_DATA_CNF )
//  380         nwk_MTCallbackSubNwkDataCnf( (ZMacDataCnf_t *) pData );
//  381       break;
//  382 
//  383     case MAC_MCPS_DATA_IND:
//  384       {
//  385         /*
//  386            Data Ind is unconventional: to save an alloc/copy, reuse the MAC
//  387            buffer and re-organize the contents into ZMAC format.
//  388         */
//  389         ZMacDataInd_t *pDataInd = (ZMacDataInd_t *) pData;
//  390         uint8 event, status, len, *msdu;
//  391 
//  392         /* Store parameters */
//  393         event = pData->hdr.event;
//  394         status = pData->hdr.status;
//  395         len = pData->dataInd.msdu.len;
//  396         msdu = pData->dataInd.msdu.p;
//  397 
//  398         /* Copy security fields */
//  399         osal_memcpy(&pDataInd->Sec, &pData->dataInd.sec, sizeof(ZMacSec_t));
//  400         
//  401         /* Copy mac fields one by one since the two buffers overlap. */
//  402         osal_memcpy(&pDataInd->SrcAddr, &pData->dataInd.mac.srcAddr, sizeof(zAddrType_t));
//  403         osal_memcpy(&pDataInd->DstAddr, &pData->dataInd.mac.dstAddr, sizeof(zAddrType_t));
//  404         pDataInd->Timestamp = pData->dataInd.mac.timestamp;
//  405         pDataInd->Timestamp2 = pData->dataInd.mac.timestamp2;
//  406         pDataInd->SrcPANId = pData->dataInd.mac.srcPanId;
//  407         pDataInd->DstPANId = pData->dataInd.mac.dstPanId;
//  408         pDataInd->mpduLinkQuality = pData->dataInd.mac.mpduLinkQuality;
//  409         pDataInd->Correlation = pData->dataInd.mac.correlation;
//  410         pDataInd->Rssi = pData->dataInd.mac.rssi;
//  411         pDataInd->Dsn = pData->dataInd.mac.dsn;
//  412 
//  413         /* Restore parameters */
//  414         pDataInd->hdr.Status = status;
//  415         pDataInd->hdr.Event = event;
//  416         pDataInd->msduLength = len;
//  417 
//  418         if (len)
//  419           pDataInd->msdu = msdu;
//  420         else
//  421           pDataInd->msdu = NULL;
//  422 
//  423         if ( _macCallbackSub & CB_ID_NWK_DATA_IND )
//  424           nwk_MTCallbackSubNwkDataInd ( pDataInd );
//  425       }
//  426 
//  427       /* free buffer */
//  428       mac_msg_deallocate( (uint8 **)&pData );
//  429       break;
//  430 
//  431     case MAC_MCPS_PURGE_CNF:
//  432       if ( _macCallbackSub & CB_ID_NWK_PURGE_CNF )
//  433         nwk_MTCallbackSubNwkPurgeCnf( (ZMacPurgeCnf_t *) pData);
//  434       break;
//  435 
//  436     default:
//  437       break;
//  438   }
//  439 }
//  440 #endif
//  441 
//  442 /********************************************************************************************************
//  443  * @fn      MAC_CbackCheckPending
//  444  *
//  445  * @brief   Return number of pending indirect msg
//  446  *
//  447  * @param   None
//  448  *
//  449  * @return  Number of indirect msg holding
//  450  ********************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  451 uint8 MAC_CbackCheckPending(void)
MAC_CbackCheckPending:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function MAC_CbackCheckPending
//  452 {
//  453 #if !defined (NONWK)
//  454   if ( ZSTACK_ROUTER_BUILD )
//  455   {
//  456     return (nwkDB_ReturnIndirectHoldingCnt());
        FUNCALL MAC_CbackCheckPending, nwkDB_ReturnIndirectHoldingCnt
        LOCFRAME CSTACK, 4, STACK
        BRA     #nwkDB_ReturnIndirectHoldingCnt
          CFI EndBlock cfiBlock1
//  457   }
//  458   else
//  459   {
//  460     return (0);
//  461   }
//  462 #else
//  463   return (0);
//  464 #endif
//  465 }
//  466 
//  467 /********************************************************************************************************
//  468  * @fn      ZMacLqiAdjustMode
//  469  *
//  470  * @brief   Sets/return LQI adjust mode
//  471  *
//  472  * @param   mode - LQI_ADJ_GET = return current mode only
//  473  *                 LQI_ADJ_OFF = disable LQI adjusts
//  474  *                 LQI_ADJ_MODEx = set to LQI adjust MODEx
//  475  *
//  476  * @return  current LQI adjust mode
//  477  ********************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  478 ZMacLqiAdjust_t ZMacLqiAdjustMode( ZMacLqiAdjust_t mode )
ZMacLqiAdjustMode:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function ZMacLqiAdjustMode
//  479 {
//  480   if ( mode != LQI_ADJ_GET )
        CMP.B   #0xff, R12
        JEQ     ??ZMacLqiAdjustMode_0
//  481   {
//  482     lqiAdjMode = mode;
        MOV.B   R12, &lqiAdjMode
//  483   }
//  484   return ( lqiAdjMode );
??ZMacLqiAdjustMode_0:
        MOV.B   &lqiAdjMode, R12
        RETA
          CFI EndBlock cfiBlock2
//  485 }
//  486 
//  487 #if !defined NONWK
//  488 /********************************************************************************************************
//  489  * @fn      ZMacLqiAdjust
//  490  *
//  491  * @brief   Adjust LQI according to correlation value
//  492  *
//  493  * @notes - the IEEE 802.15.4 specification provides some general statements on
//  494  *          the subject of LQI. Section 6.7.8: "The minimum and maximum LQI values
//  495  *          (0x00 and 0xFF) should be associated with the lowest and highest IEEE
//  496  *          802.15.4 signals detectable by the receiver, and LQ values should be
//  497  *          uniformly distributed between these two limits." Section E.2.3: "The
//  498  *          LQI (see 6.7.8) measures the received energy and/or SNR for each
//  499  *          received packet. When energy level and SNR information are combined,
//  500  *          they can indicate whether a corrupt packet resulted from low signal
//  501  *          strength or from high signal strength plus interference."
//  502  *        - LQI Adjustment Mode1 provided below is a simple algorithm to use the
//  503  *          packet correlation value (related to SNR) to scale incoming LQI value
//  504  *          (related to signal strength) to 'derate' noisy packets.
//  505  *        - LQI Adjustment Mode2 provided below is a location for a developer to
//  506  *          implement their own proprietary LQI adjustment algorithm.
//  507  *
//  508  * @param   corr - packet correlation value
//  509  * @param   lqi  - ptr to link quality (scaled rssi)
//  510  *
//  511  * @return  *lqi - adjusted link quality
//  512  ********************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  513 static void ZMacLqiAdjust( uint8 corr, uint8 *lqi )
ZMacLqiAdjust:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function ZMacLqiAdjust
//  514 {
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.W   R13, R10
//  515   if ( lqiAdjMode != LQI_ADJ_OFF )
        CMP.B   #0x0, &lqiAdjMode
        JEQ     ??ZMacLqiAdjust_1
//  516   {
//  517     uint16 adjLqi = *lqi;
        MOV.B   @R13, R15
//  518 
//  519     // Keep correlation within theoretical limits
//  520     if ( corr < LQI_CORR_MIN )
        CMP.B   #0x32, R12
        JC      ??ZMacLqiAdjust_2
//  521     {
//  522        corr = LQI_CORR_MIN;
        MOV.B   #0x32, R12
        JMP     ??ZMacLqiAdjust_3
//  523     }
//  524     else if ( corr > LQI_CORR_MAX )
??ZMacLqiAdjust_2:
        CMP.B   #0x6f, R12
        JNC     ??ZMacLqiAdjust_3
//  525     {
//  526        corr = LQI_CORR_MAX;
        MOV.B   #0x6e, R12
//  527     }
//  528 
//  529     if ( lqiAdjMode == LQI_ADJ_MODE1 )
??ZMacLqiAdjust_3:
        CMP.B   #0x1, &lqiAdjMode
        JNE     ??ZMacLqiAdjust_4
//  530     {
//  531       /* MODE1 - linear scaling of incoming LQI with a "correlation percentage"
//  532                  which is computed from the incoming correlation value between
//  533                  theorectical minimum/maximum values. This is a very simple way
//  534                  of 'derating' the incoming LQI as correlation value drops. */
//  535       adjLqi = (adjLqi * (corr - LQI_CORR_MIN)) / (LQI_CORR_MAX - LQI_CORR_MIN);
        MOV.B   R12, R12
        ADD.W   #0xffce, R12
        PUSH.W  SR
          CFI CFA SP+8
        DINT
        NOP
        MOV.W   R15, &0x130
        MOV.W   R12, &0x138
        MOV.W   &0x13a, R12
        POP.W   SR
          CFI CFA SP+6
        MOV.W   #0x3c, R14
        CALLA   #?DivMod16u
        MOV.W   R12, R15
//  536     }
//  537     else if ( lqiAdjMode == LQI_ADJ_MODE2 )
//  538     {
//  539       /* MODE2 - location for developer to implement a proprietary algorithm */
//  540     }
//  541 
//  542     // Replace incoming LQI with scaled value
//  543     *lqi = (adjLqi > 255) ? 255 : (uint8)adjLqi;
??ZMacLqiAdjust_4:
        CMP.W   #0x100, R15
        JNC     ??ZMacLqiAdjust_0
        MOV.B   #0xff, R15
??ZMacLqiAdjust_0:
        MOV.B   R15, 0(R10)
//  544   }
//  545 }
??ZMacLqiAdjust_1:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  546 #endif
// 
// 662 bytes in segment CODE
//  17 bytes in segment DATA16_C
//   5 bytes in segment DATA16_Z
// 
// 662 bytes of CODE  memory
//  17 bytes of CONST memory
//   5 bytes of DATA  memory
//
//Errors: none
//Warnings: none

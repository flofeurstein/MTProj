###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       10/Jun/2013  16:27:35 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\st #
#                     ack\zcl\zcl.c                                           #
#    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleLight\CC2520DB\..\..\..\Too #
#                     ls\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0       #
#                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                       #
#                     -DDEFAULT_CHANLIST=0x00000800                           #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100      #
#                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                   #
#                     -DBEACON_REQUEST_DELAY=100                              #
#                     -DBEACON_REQ_DELAY_MASK=0x00FF                          #
#                     -DLINK_STATUS_JITTER_MASK=0x007F                        #
#                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED= #
#                     3000 -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8  #
#                     -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2     #
#                     -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9              #
#                     -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40                #
#                     -DNWK_MAX_BINDING_ENTRIES=4                             #
#                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,       #
#                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,   #
#                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                    #
#                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=2 #
#                     0 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000           #
#                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100         #
#                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\f8 #
#                     wRouter.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                     E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8            #
#                     -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "C:\Texas              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\f8 #
#                     wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC           #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)                #
#                     -DZCL_DEVICE_MGMT "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Components\stack\zcl\z #
#                     cl.c" -D MSP430F2618 -D ZTOOL_P1 -D MT_TASK -D          #
#                     MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED -lC         #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\Router\List\"   #
#                     -lA "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects #
#                     \zstack\HomeAutomation\SampleLight\CC2520DB\Router\List #
#                     \" --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826    #
#                     -o "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleLight\CC2520DB\Router\Obj\" #
#                      --debug -D__MSP430F2618__ -e --double=32 --clib -I     #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\" -I "C:\Texas  #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\Source\" -I "C:\Texas  #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\Source\" -I         #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\..\..\..\ZMain\ #
#                     MSP2618\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1 #
#                     \Projects\zstack\HomeAutomation\SampleLight\CC2520DB\.. #
#                     \..\..\..\..\Components\hal\include\" -I "C:\Texas      #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \hal\target\MSP2618CC2520\" -I "C:\Texas                #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\include\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\high_level\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\low_level\srf04\" -I "C:\Texas                     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\low_level\srf04\dual_chip\" -I "C:\Texas           #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pro #
#                     jects\zstack\HomeAutomation\SampleLight\CC2520DB\..\..\ #
#                     ..\..\..\Components\osal\include\" -I "C:\Texas         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \osal\mcu\msp430\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \services\saddr\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \services\sdata\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\af\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5 #
#                     .1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB\ #
#                     ..\..\..\..\..\Components\stack\nwk\" -I "C:\Texas      #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\sec\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\stack\sapi\" -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\sys\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\stack\zcl\" -I "C:\Texas     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\zdo\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\zmac\" -I "C:\Texas          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \zmac\f8w\" --core=430X --data_model=small -Ohz         #
#                     --multiplier=16s --require_prototypes                   #
#    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleLight\CC2520DB\Router\List\zcl. #
#                     lst                                                     #
#    Object file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleLight\CC2520DB\Router\Obj\zcl.r #
#                     43                                                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2012-01-30 10:40:08 -0800 (Mon, 30 Jan 2012) $
      4            Revision:       $Revision: 29096 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2012 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Tasks.h"
     46          #include "AF.h"
     47          #include "ZDConfig.h"
     48          
     49          #include "zcl.h"
     50          #include "zcl_general.h"
     51          
     52          #if defined ( INTER_PAN )
     53            #include "stub_aps.h"
     54          #endif
     55          
     56          /*********************************************************************
     57           * MACROS
     58           */
     59          /*** Frame Control ***/
     60          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     61          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     62          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     63          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     64          
     65          /*** Attribute Access Control ***/
     66          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     67          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     68          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     69          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     70          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     71          
     72          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     73          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     74          
     75          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     76                                                  (zclHdr).fc.manuSpecific == 0          && \
     77                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     78          
     79          // Commands that have corresponding responses
     80          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ            || \
     81                                                  (cmd) == ZCL_CMD_WRITE           || \
     82                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED || \
     83                                                  (cmd) == ZCL_CMD_CONFIG_REPORT   || \
     84                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG || \
     85                                                  (cmd) == ZCL_CMD_DISCOVER        || \
     86                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     87          
     88          /*********************************************************************
     89           * CONSTANTS
     90           */
     91          
     92          /*********************************************************************
     93           * TYPEDEFS
     94           */
     95          typedef struct zclLibPlugin
     96          {
     97            struct zclLibPlugin *next;
     98            uint16              startClusterID;    // starting cluster ID
     99            uint16              endClusterID;      // ending cluster ID
    100            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    101          } zclLibPlugin_t;
    102          
    103          // Attribute record list item
    104          typedef struct zclAttrRecsList
    105          {
    106            struct zclAttrRecsList *next;
    107            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    108            zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
    109            zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
    110            uint8                  numAttributes; // Number of the following records
    111            CONST zclAttrRec_t     *attrs;        // attribute records
    112          } zclAttrRecsList;
    113          
    114          // Cluster option list item
    115          typedef struct zclClusterOptionList
    116          {
    117            struct zclClusterOptionList *next;
    118            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    119            uint8                       numOptions; // Number of the following records
    120            zclOptionRec_t              *options;   // option records
    121          } zclClusterOptionList;
    122          
    123          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    124          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    125          
    126          typedef struct
    127          {
    128            zclParseInProfileCmd_t   pfnParseInProfile;
    129            zclProcessInProfileCmd_t pfnProcessInProfile;
    130          } zclCmdItems_t;
    131          
    132          
    133          /*********************************************************************
    134           * GLOBAL VARIABLES
    135           */

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    136          uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS8 1
    137          
    138          // The task Id of the Application where the unprocessed Foundation
    139          // Command/Response messages will be sent to.

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    140          uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
    141          
    142          // The Application should register its attribute data validation function

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    143          zclValidateAttrData_t zcl_ValidateAttrDataCB = NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS8 4
    144          
    145          // ZCL Sequence number

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    146          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS8 1
    147          
    148          /*********************************************************************
    149           * EXTERNAL VARIABLES
    150           */
    151          
    152          /*********************************************************************
    153           * EXTERNAL FUNCTIONS
    154           */
    155          
    156          /*********************************************************************
    157           * LOCAL VARIABLES
    158           */

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    159          static zclLibPlugin_t *plugins;
   \                     plugins:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    160          static zclAttrRecsList *attrList;
   \                     attrList:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    161          static zclClusterOptionList *clusterOptionList;
   \                     clusterOptionList:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    162          static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS8 1
    163          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    164          static afIncomingMSGPacket_t *rawAFMsg = NULL;
   \                     rawAFMsg:
   \   000000                DS8 2
    165          
    166          /*********************************************************************
    167           * LOCAL FUNCTIONS
    168           */
    169          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt );  // Not static for ZNP build.
    170          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    171          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    172          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    173          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    174          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    175          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    176          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    177          
    178          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    179          
    180          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    181          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    182          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    183          #endif // ZCL_READ || ZCL_WRITE
    184          
    185          #ifdef ZCL_READ
    186          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    187          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    188                                                   uint8 *pAttrData, uint16 *pDataLen );
    189          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    190          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    191          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    192          #endif // ZCL_READ
    193          
    194          #ifdef ZCL_WRITE
    195          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
    196                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    197          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
    198                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    199          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    200          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    201          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    202          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    203          #endif // ZCL_WRITE
    204          
    205          #ifdef ZCL_REPORT
    206          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    207          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    208          #endif // ZCL_REPORT
    209          
    210          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    211          
    212          #ifdef ZCL_DISCOVER
    213          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint16 *attrId, zclAttrRec_t *pAttr );
    214          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd );
    215          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    216          #endif // ZCL_DISCOVER
    217          
    218          static uint8 zclSendMsg( zclIncoming_t *pInMsg );
    219          
    220          /*********************************************************************
    221           * Parse Profile Command Function Table
    222           */

   \                                 In  segment DATA16_C, align 2, align-sorted
    223          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ............ DC32 zclParseInReadCmd, zclProcessInReadCmd, zclParseInReadRspCmd
   \            ............
   \   00000C   ............ DC32 zclSendMsg, zclParseInWriteCmd, zclProcessInWriteCmd
   \            ............
   \   000018   ............ DC32 zclParseInWriteCmd, zclProcessInWriteUndividedCmd
   \            ....        
   \   000020   ............ DC32 zclParseInWriteRspCmd, zclSendMsg, zclParseInWriteCmd
   \            ............
   \   00002C   ........0000 DC32 zclProcessInWriteCmd, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            000000000000
   \            0000        
   \   000058   ............ DC32 zclParseInDefaultRspCmd, zclSendMsg, 0H, 0H, 0H, 0H
   \            ....00000000
   \            000000000000
   \            000000000000
    224          {
    225          #ifdef ZCL_READ
    226            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    227            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zclSendMsg                      },
    228          #else
    229            /* ZCL_CMD_READ */                { NULL,                          NULL                            },
    230            /* ZCL_CMD_READ_RSP */            { NULL,                          NULL                            },
    231          #endif // ZCL_READ
    232          
    233          #ifdef ZCL_WRITE
    234            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    235            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    236            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zclSendMsg                      },
    237            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    238          #else
    239            /* ZCL_CMD_WRITE */               { NULL,                          NULL                            },
    240            /* ZCL_CMD_WRITE_UNDIVIDED */     { NULL,                          NULL                            },
    241            /* ZCL_CMD_WRITE_RSP */           { NULL,                          NULL                            },
    242            /* ZCL_CMD_WRITE_NO_RSP */        { NULL,                          NULL                            },
    243          #endif // ZCL_WRITE
    244          
    245          #ifdef ZCL_REPORT
    246            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zclSendMsg                      },
    247            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zclSendMsg                      },
    248            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zclSendMsg                      },
    249            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zclSendMsg                      },
    250            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zclSendMsg                      },
    251          #else
    252            /* ZCL_CMD_CONFIG_REPORT */       { NULL,                          NULL                            },
    253            /* ZCL_CMD_CONFIG_REPORT_RSP */   { NULL,                          NULL                            },
    254            /* ZCL_CMD_READ_REPORT_CFG */     { NULL,                          NULL                            },
    255            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { NULL,                          NULL                            },
    256            /* ZCL_CMD_REPORT */              { NULL,                          NULL                            },
    257          #endif // ZCL_REPORT
    258          
    259            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zclSendMsg                      },
    260          
    261          #ifdef ZCL_DISCOVER
    262            /* ZCL_CMD_DISCOVER */            { zclParseInDiscCmd,             zclProcessInDiscCmd             },
    263            /* ZCL_CMD_DISCOVER_RSP */        { zclParseInDiscRspCmd,          zclSendMsg                      }
    264          #else
    265            /* ZCL_CMD_DISCOVER */            { NULL,                          NULL                            },
    266            /* ZCL_CMD_DISCOVER_RSP */        { NULL,                          NULL                            }
    267          #endif // ZCL_DISCOVER
    268          };
    269          
    270          /*********************************************************************
    271           * PUBLIC FUNCTIONS
    272           *********************************************************************/
    273          
    274          /*********************************************************************
    275           * @fn          zcl_Init
    276           *
    277           * @brief       Initialization function for the zcl layer.
    278           *
    279           * @param       task_id - ZCL task id
    280           *
    281           * @return      none
    282           */

   \                                 In  segment CODE, align 2
    283          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    284          {
    285            zcl_TaskID = task_id;
   \   000000   C24C....     MOV.B   R12, &zcl_TaskID
    286          
    287            plugins = (zclLibPlugin_t  *)NULL;
   \   000004   8243....     MOV.W   #0x0, &plugins
    288            attrList = (zclAttrRecsList *)NULL;
   \   000008   8243....     MOV.W   #0x0, &attrList
    289            clusterOptionList = (zclClusterOptionList *)NULL;
   \   00000C   8243....     MOV.W   #0x0, &clusterOptionList
    290          }
   \   000010   1001         RETA
    291          
    292          /*********************************************************************
    293           * @fn          zcl_event_loop
    294           *
    295           * @brief       Event Loop Processor for zcl.
    296           *
    297           * @param       task_id - task id
    298           * @param       events - event bitmap
    299           *
    300           * @return      unprocessed events
    301           */

   \                                 In  segment CODE, align 2
    302          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    303          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4D         MOV.W   R13, R10
    304            uint8 *msgPtr;
    305          
    306            (void)task_id;  // Intentionally unreferenced parameter
    307          
    308            if ( events & SYS_EVENT_MSG )
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   2034         JGE     ??zcl_event_loop_3
    309            {
    310              msgPtr = osal_msg_receive( zcl_TaskID );
   \   000008   0A3C         JMP     ??zcl_event_loop_2
    311              while ( msgPtr != NULL )
    312              {
    313                uint8 dealloc = TRUE;
    314          
    315                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    316                {
    317                  rawAFMsg = (afIncomingMSGPacket_t *)msgPtr;
   \                     ??zcl_event_loop_0:
   \   00000A   824B....     MOV.W   R11, &rawAFMsg
    318                  zclProcessMessageMSG( rawAFMsg );
   \   00000E   0C4B         MOV.W   R11, R12
   \   000010   ........     CALLA   #zclProcessMessageMSG
    319                  rawAFMsg = NULL;
   \   000014   8243....     MOV.W   #0x0, &rawAFMsg
    320                }
    321                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    322                {
    323                  // send it to another task to process.
    324                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
    325                  dealloc = FALSE;
    326                }
    327          
    328                // Release the memory
    329                if ( dealloc )
    330                {
    331                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_1:
   \   000018   0C4B         MOV.W   R11, R12
   \   00001A   ........     CALLA   #osal_msg_deallocate
    332                }
    333          
    334                // Next
    335                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_2:
   \   00001E   5C42....     MOV.B   &zcl_TaskID, R12
   \   000022   ........     CALLA   #osal_msg_receive
   \   000026   0B4C         MOV.W   R12, R11
   \   000028   0B93         CMP.W   #0x0, R11
   \   00002A   0A24         JEQ     ??zcl_event_loop_4
   \   00002C   FB901A000000 CMP.B   #0x1a, 0(R11)
   \   000032   EB27         JEQ     ??zcl_event_loop_0
   \   000034   F293....     CMP.B   #0xff, &zcl_RegisteredMsgTaskID
   \   000038   EF27         JEQ     ??zcl_event_loop_1
   \   00003A   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_0:
   \   00003E   EF3F         JMP     ??zcl_event_loop_2
    336              }
    337          
    338              // return unprocessed events
    339              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   000040   3AE00080     XOR.W   #0x8000, R10
   \   000044   0C4A         MOV.W   R10, R12
   \   000046   013C         JMP     ??zcl_event_loop_5
    340            }
    341          
    342            // Discard unknown events
    343            return 0;
   \                     ??zcl_event_loop_3:
   \   000048   0C43         MOV.W   #0x0, R12
   \                     ??zcl_event_loop_5:
   \   00004A   1A17         POPM.W  #0x2, R11
   \   00004C   1001         RETA
    344          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine5:
   \   000000   0D4B         MOV.W   R11, R13
   \   000002   5C42....     MOV.B   &zcl_RegisteredMsgTaskID, R12
   \   000006   ........     BRA     #osal_msg_send
    345          
    346          /*********************************************************************
    347           * @fn          zcl_getRawAFMsg
    348           *
    349           * @brief       Call to get original unprocessed AF message
    350           *              (not parsed by ZCL).
    351           *
    352           *   NOTE:  This function can only be called during a ZCL callback function
    353           *          and the calling function must NOT change any data in the message.
    354           *
    355           * @param       none
    356           *
    357           * @return      pointer to original AF message, NULL if not processing
    358           *              AF message.
    359           */

   \                                 In  segment CODE, align 2
    360          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    361          {
    362            return ( rawAFMsg );
   \   000000   1C42....     MOV.W   &rawAFMsg, R12
   \   000004   1001         RETA
    363          }
    364          
    365          /*********************************************************************
    366           * @fn          zcl_registerPlugin
    367           *
    368           * @brief       Add a Cluster Library handler
    369           *
    370           * @param       startClusterID - starting cluster ID
    371           * @param       endClusterID - ending cluster ID
    372           * @param       pfnHdlr - function pointer to incoming message handler
    373           *
    374           * @return      ZSuccess if OK
    375           */

   \                                 In  segment CODE, align 2
    376          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    377                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    378          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   084C         MOV.W   R12, R8
   \   000004   094D         MOV.W   R13, R9
   \   000006   0A4E         MOV.W   R14, R10
   \   000008   0B4F         MOV.W   R15, R11
    379            zclLibPlugin_t *pNewItem;
    380            zclLibPlugin_t *pLoop;
    381          
    382            // Fill in the new profile list
    383            pNewItem = osal_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000A   3C400A00     MOV.W   #0xa, R12
   \   00000E   ........     CALLA   #??Subroutine9_0
    384            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_40:
   \   000012   0320         JNE     ??zcl_registerPlugin_3
    385            {
    386              return (ZMemError);
   \   000014   7C401000     MOV.B   #0x10, R12
   \   000018   183C         JMP     ??zcl_registerPlugin_4
    387            }
    388          
    389            // Fill in the plugin record.
    390            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_3:
   \   00001A   8C430000     MOV.W   #0x0, 0(R12)
    391            pNewItem->startClusterID = startClusterID;
   \   00001E   8C480200     MOV.W   R8, 0x2(R12)
    392            pNewItem->endClusterID = endClusterID;
   \   000022   8C490400     MOV.W   R9, 0x4(R12)
    393            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \   000026   8C4A0600     MOV.W   R10, 0x6(R12)
   \   00002A   8C4B0800     MOV.W   R11, 0x8(R12)
    394          
    395            // Find spot in list
    396            if (  plugins == NULL )
   \   00002E   1F42....     MOV.W   &plugins, R15
   \   000032   0F93         CMP.W   #0x0, R15
   \   000034   0420         JNE     ??zcl_registerPlugin_2
    397            {
    398              plugins = pNewItem;
   \   000036   824C....     MOV.W   R12, &plugins
   \   00003A   063C         JMP     ??zcl_registerPlugin_5
    399            }
    400            else
    401            {
    402              // Look for end of list
    403              pLoop = plugins;
    404              while ( pLoop->next != NULL )
    405              {
    406                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_0:
   \   00003C   0F4B         MOV.W   R11, R15
    407              }
   \                     ??zcl_registerPlugin_2:
   \   00003E   2B4F         MOV.W   @R15, R11
   \   000040   0B93         CMP.W   #0x0, R11
   \   000042   FC23         JNE     ??zcl_registerPlugin_0
    408          
    409              // Put new item at end of list
    410              pLoop->next = pNewItem;
   \   000044   8F4C0000     MOV.W   R12, 0(R15)
    411            }
    412          
    413            return ( ZSuccess );
   \                     ??zcl_registerPlugin_5:
   \   000048   4C43         MOV.B   #0x0, R12
   \                     ??zcl_registerPlugin_4:
   \   00004A   3817         POPM.W  #0x4, R11
   \   00004C   1001         RETA
    414          }

   \                                 In  segment CODE, align 2
   \                     ??Subroutine9_0:
   \   000000   ........     CALLA   #osal_mem_alloc
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   1001         RETA
    415          
    416          /*********************************************************************
    417           * @fn          zcl_registerAttrList
    418           *
    419           * @brief       Register an Attribute List with ZCL Foundation
    420           *
    421           * @param       endpoint - endpoint the attribute list belongs to
    422           * @param       numAttr - number of attributes in list
    423           * @param       newAttrList - array of Attribute records.
    424           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    425           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    426           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    427           *
    428           * @return      ZSuccess if OK
    429           */

   \                                 In  segment CODE, align 2
    430          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    431          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
   \   000006   084E         MOV.W   R14, R8
    432            zclAttrRecsList *pNewItem;
    433            zclAttrRecsList *pLoop;
    434          
    435            // Fill in the new profile list
    436            pNewItem = osal_mem_alloc( sizeof( zclAttrRecsList ) );
   \   000008   3C401000     MOV.W   #0x10, R12
   \   00000C   ........     CALLA   #??Subroutine9_0
    437            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_39:
   \   000010   0320         JNE     ??zcl_registerAttrList_3
    438            {
    439              return (ZMemError);
   \   000012   7C401000     MOV.B   #0x10, R12
   \   000016   1A3C         JMP     ??zcl_registerAttrList_4
    440            }
    441          
    442            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_3:
   \   000018   8C430000     MOV.W   #0x0, 0(R12)
    443            pNewItem->endpoint = endpoint;
   \   00001C   CC4A0200     MOV.B   R10, 0x2(R12)
    444            pNewItem->pfnReadWriteCB = NULL;
   \   000020   8C430400     MOV.W   #0x0, 0x4(R12)
   \   000024   8C430600     MOV.W   #0x0, 0x6(R12)
    445            pNewItem->numAttributes = numAttr;
   \   000028   CC4B0C00     MOV.B   R11, 0xc(R12)
    446            pNewItem->attrs = newAttrList;
   \   00002C   8C480E00     MOV.W   R8, 0xe(R12)
    447          
    448            // Find spot in list
    449            if ( attrList == NULL )
   \   000030   1F42....     MOV.W   &attrList, R15
   \   000034   0F93         CMP.W   #0x0, R15
   \   000036   0420         JNE     ??zcl_registerAttrList_2
    450            {
    451              attrList = pNewItem;
   \   000038   824C....     MOV.W   R12, &attrList
   \   00003C   063C         JMP     ??zcl_registerAttrList_5
    452            }
    453            else
    454            {
    455              // Look for end of list
    456              pLoop = attrList;
    457              while ( pLoop->next != NULL )
    458              {
    459                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_0:
   \   00003E   0F4B         MOV.W   R11, R15
    460              }
   \                     ??zcl_registerAttrList_2:
   \   000040   2B4F         MOV.W   @R15, R11
   \   000042   0B93         CMP.W   #0x0, R11
   \   000044   FC23         JNE     ??zcl_registerAttrList_0
    461          
    462              // Put new item at end of list
    463              pLoop->next = pNewItem;
   \   000046   8F4C0000     MOV.W   R12, 0(R15)
    464            }
    465          
    466            return ( ZSuccess );
   \                     ??zcl_registerAttrList_5:
   \   00004A   4C43         MOV.B   #0x0, R12
   \                     ??zcl_registerAttrList_4:
   \   00004C   3817         POPM.W  #0x4, R11
   \   00004E   1001         RETA
    467          }
    468          
    469          /*********************************************************************
    470           * @fn          zcl_registerClusterOptionList
    471           *
    472           * @brief       Register a Cluster Option List with ZCL Foundation
    473           *
    474           * @param       endpoint - endpoint the option list belongs to
    475           * @param       numOption - number of options in list
    476           * @param       optionList - array of cluster option records.
    477           *
    478           *              NOTE: This API should be called to enable 'Application
    479           *                    Link Key' security and/or 'APS ACK' for a specific
    480           *                    Cluster. The 'Application Link Key' is discarded
    481           *                    if security isn't enabled on the device.
    482           *                    The default behavior is 'Network Key' when security
    483           *                    is enabled and no 'APS ACK' for the ZCL messages.
    484           *
    485           * @return      ZSuccess if OK
    486           */

   \                                 In  segment CODE, align 2
    487          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    488          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
   \   000006   084E         MOV.W   R14, R8
    489            zclClusterOptionList *pNewItem;
    490            zclClusterOptionList *pLoop;
    491          
    492            // Fill in the new profile list
    493            pNewItem = osal_mem_alloc( sizeof( zclClusterOptionList ) );
   \   000008   3C400600     MOV.W   #0x6, R12
   \   00000C   ........     CALLA   #??Subroutine9_0
    494            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_38:
   \   000010   0320         JNE     ??zcl_registerClusterOptionList_3
    495            {
    496              return (ZMemError);
   \   000012   7C401000     MOV.B   #0x10, R12
   \   000016   163C         JMP     ??zcl_registerClusterOptionList_4
    497            }
    498          
    499            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_3:
   \   000018   8C430000     MOV.W   #0x0, 0(R12)
    500            pNewItem->endpoint = endpoint;
   \   00001C   CC4A0200     MOV.B   R10, 0x2(R12)
    501            pNewItem->numOptions = numOption;
   \   000020   CC4B0300     MOV.B   R11, 0x3(R12)
    502            pNewItem->options = optionList;
   \   000024   8C480400     MOV.W   R8, 0x4(R12)
    503          
    504            // Find spot in list
    505            if ( clusterOptionList == NULL )
   \   000028   1F42....     MOV.W   &clusterOptionList, R15
   \   00002C   0F93         CMP.W   #0x0, R15
   \   00002E   0420         JNE     ??zcl_registerClusterOptionList_2
    506            {
    507              clusterOptionList = pNewItem;
   \   000030   824C....     MOV.W   R12, &clusterOptionList
   \   000034   063C         JMP     ??zcl_registerClusterOptionList_5
    508            }
    509            else
    510            {
    511              // Look for end of list
    512              pLoop = clusterOptionList;
    513              while ( pLoop->next != NULL )
    514              {
    515                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_0:
   \   000036   0F4B         MOV.W   R11, R15
    516              }
   \                     ??zcl_registerClusterOptionList_2:
   \   000038   2B4F         MOV.W   @R15, R11
   \   00003A   0B93         CMP.W   #0x0, R11
   \   00003C   FC23         JNE     ??zcl_registerClusterOptionList_0
    517          
    518              // Put new item at end of list
    519              pLoop->next = pNewItem;
   \   00003E   8F4C0000     MOV.W   R12, 0(R15)
    520            }
    521          
    522            return ( ZSuccess );
   \                     ??zcl_registerClusterOptionList_5:
   \   000042   4C43         MOV.B   #0x0, R12
   \                     ??zcl_registerClusterOptionList_4:
   \   000044   3817         POPM.W  #0x4, R11
   \   000046   1001         RETA
    523          }
    524          
    525          /*********************************************************************
    526           * @fn          zcl_registerValidateAttrData
    527           *
    528           * @brief       Add a validation function for attribute data
    529           *
    530           * @param       pfnValidateAttrData - function pointer to validate routine
    531           *
    532           * @return      ZSuccess if OK
    533           */

   \                                 In  segment CODE, align 2
    534          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    535          {
    536            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000000   824C....     MOV.W   R12, &zcl_ValidateAttrDataCB
   \   000004   824D....     MOV.W   R13, &zcl_ValidateAttrDataCB + 2
    537          
    538            return ( ZSuccess );
   \   000008   4C43         MOV.B   #0x0, R12
   \   00000A   1001         RETA
    539          }
    540          
    541          /*********************************************************************
    542           * @fn          zcl_registerReadWriteCB
    543           *
    544           * @brief       Register the application's callback function to read/write
    545           *              attribute data, and authorize read/write operation.
    546           *
    547           *              Note: The pfnReadWriteCB callback function is only required
    548           *                    when the attribute data format is unknown to ZCL. The
    549           *                    callback function gets called when the pointer 'dataPtr'
    550           *                    to the attribute value is NULL in the attribute database
    551           *                    registered with the ZCL.
    552           *
    553           *              Note: The pfnAuthorizeCB callback function is only required
    554           *                    when the Read/Write operation on an attribute requires
    555           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
    556           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
    557           *
    558           * @param       endpoint - application's endpoint
    559           * @param       pfnReadWriteCB - function pointer to read/write routine
    560           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
    561           *
    562           * @return      ZSuccess if successful. ZFailure, otherwise.
    563           */

   \                                 In  segment CODE, align 2
    564          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
    565                                             zclAuthorizeCB_t pfnAuthorizeCB )
    566          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0B4F         MOV.W   R15, R11
   \   000004   18410C00     MOV.W   0xc(SP), R8
   \   000008   19410E00     MOV.W   0xe(SP), R9
    567            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   00000C   ........     CALLA   #zclFindAttrRecsList
    568          
    569            if ( pRec != NULL )
   \   000010   0C93         CMP.W   #0x0, R12
   \   000012   0A24         JEQ     ??zcl_registerReadWriteCB_0
    570            {
    571              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   000014   8C4E0400     MOV.W   R14, 0x4(R12)
   \   000018   8C4B0600     MOV.W   R11, 0x6(R12)
    572              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \   00001C   8C480800     MOV.W   R8, 0x8(R12)
   \   000020   8C490A00     MOV.W   R9, 0xa(R12)
    573          
    574              return ( ZSuccess );
   \   000024   4C43         MOV.B   #0x0, R12
   \   000026   013C         JMP     ??zcl_registerReadWriteCB_1
    575            }
    576          
    577            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000028   5C43         MOV.B   #0x1, R12
   \                     ??zcl_registerReadWriteCB_1:
   \   00002A   3817         POPM.W  #0x4, R11
   \   00002C   1001         RETA
    578          }
    579          
    580          /*********************************************************************
    581           * @fn      zcl_registerForMsg
    582           *
    583           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    584           *          messages that aren't processed to one task (if a task is
    585           *          registered).
    586           *
    587           * @param   taskId - task Id of the Application where commands will be sent to
    588           *
    589           * @return  TRUE if task registeration successful, FALSE otherwise
    590           *********************************************************************/

   \                                 In  segment CODE, align 2
    591          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    592          {
    593            // Allow only the first task
    594            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000000   F293....     CMP.B   #0xff, &zcl_RegisteredMsgTaskID
   \   000004   0420         JNE     ??zcl_registerForMsg_0
    595            {
    596              zcl_RegisteredMsgTaskID = taskId;
   \   000006   C24C....     MOV.B   R12, &zcl_RegisteredMsgTaskID
    597          
    598              return ( true );
   \   00000A   5C43         MOV.B   #0x1, R12
   \   00000C   1001         RETA
    599            }
    600          
    601            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   00000E   4C43         MOV.B   #0x0, R12
   \   000010   1001         RETA
    602          }
    603          
    604          /*********************************************************************
    605           * @fn      zcl_DeviceOperational
    606           *
    607           * @brief   Used to see whether or not the device can send or respond
    608           *          to application level commands.
    609           *
    610           * @param   srcEP - source endpoint
    611           * @param   clusterID - cluster ID
    612           * @param   frameType - command type
    613           * @param   cmd - command ID
    614           *
    615           * @return  TRUE if device is operational, FALSE otherwise
    616           */

   \                                 In  segment CODE, align 2
    617          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
    618                                              uint8 frameType, uint8 cmd, uint16 profileID )
    619          {
   \   000000   31800A00     SUB.W   #0xa, SP
    620            zclAttrRec_t attrRec;
    621            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   000004   D1430000     MOV.B   #0x1, 0(SP)
    622          
    623            (void)profileID;  // Intentionally unreferenced parameter
    624          
    625            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    626            // cannot send or respond to application level commands, other than commands
    627            // to read or write attributes. Note that the Identify cluster cannot be
    628            // disabled, and remains functional regardless of this setting.
    629            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000008   4E93         CMP.B   #0x0, R14
   \   00000A   0320         JNE     ??zcl_DeviceOperational_4
   \   00000C   7F900600     CMP.B   #0x6, R15
   \   000010   1728         JNC     ??zcl_DeviceOperational_1
    630            {
    631              return ( TRUE );
    632            }
    633          
    634            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_4:
   \   000012   3D900300     CMP.W   #0x3, R13
   \   000016   1424         JEQ     ??zcl_DeviceOperational_1
    635            {
    636              return ( TRUE );
    637            }
    638          
    639            // Is device enabled?
    640            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
    641                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000018   0F41         MOV.W   SP, R15
   \   00001A   2F53         ADD.W   #0x2, R15
   \   00001C   3E401200     MOV.W   #0x12, R14
   \   000020   0D43         MOV.W   #0x0, R13
   \   000022   ........     CALLA   #??Subroutine10_0
   \                     ??CrossCallReturnLabel_34:
   \   000026   0724         JEQ     ??zcl_DeviceOperational_5
    642            {
    643              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000028   0E43         MOV.W   #0x0, R14
   \   00002A   0D41         MOV.W   SP, R13
   \   00002C   2D53         ADD.W   #0x2, R13
   \   00002E   0C41         MOV.W   SP, R12
   \   000030   0C53         ADD.W   #0x0, R12
   \   000032   ........     CALLA   #zclReadAttrData
    644            }
    645          
    646            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_5:
   \   000036   D1930000     CMP.B   #0x1, 0(SP)
   \   00003A   0224         JEQ     ??zcl_DeviceOperational_1
   \   00003C   4C43         MOV.B   #0x0, R12
   \   00003E   013C         JMP     ??zcl_DeviceOperational_0
   \                     ??zcl_DeviceOperational_1:
   \   000040   5C43         MOV.B   #0x1, R12
   \                     ??zcl_DeviceOperational_0:
   \   000042   31500A00     ADD.W   #0xa, SP
   \   000046   1001         RETA
    647          }

   \                                 In  segment CODE, align 2
   \                     ??Subroutine10_0:
   \   000000   ........     CALLA   #zclFindAttrRec
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   1001         RETA
    648          
    649          /*********************************************************************
    650           * @fn      zcl_SendCommand
    651           *
    652           * @brief   Used to send Profile and Cluster Specific Command messages.
    653           *
    654           *          NOTE: The calling application is responsible for incrementing
    655           *                the Sequence Number.
    656           *
    657           * @param   srcEp - source endpoint
    658           * @param   destAddr - destination address
    659           * @param   clusterID - cluster ID
    660           * @param   cmd - command ID
    661           * @param   specific - whether the command is Cluster Specific
    662           * @param   direction - client/server direction of the command
    663           * @param   disableDefaultRsp - disable Default Response command
    664           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    665           * @param   seqNumber - identification number for the transaction
    666           * @param   cmdFormatLen - length of the command to be sent
    667           * @param   cmdFormat - command to be sent
    668           *
    669           * @return  ZSuccess if OK
    670           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   3152         ADD.W   #0x8, SP
   \   000002   7417         POPM.W  #0x8, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine8_0:
   \   000000   ........     CALLA   #osal_mem_alloc
   \   000004   084C         MOV.W   R12, R8
   \   000006   0C93         CMP.W   #0x0, R12
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine14:
   \   000000   4A4C         MOV.B   R12, R10
   \   000002                REQUIRE ??Subroutine25_0
   \   000002                // Fall through to label ??Subroutine25_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine25_0:
   \   000000   0C48         MOV.W   R8, R12
   \   000002   ........     BRA     #osal_mem_free

   \                                 In  segment CODE, align 2
    671          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    672                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    673                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    674                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    675          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   0D12         PUSH.W  R13
   \   000004   31800600     SUB.W   #0x6, SP
   \   000008   4A4C         MOV.B   R12, R10
   \   00000A   0B4E         MOV.W   R14, R11
   \   00000C   484F         MOV.B   R15, R8
   \   00000E   57411C00     MOV.B   0x1c(SP), R7
   \   000012   55412400     MOV.B   0x24(SP), R5
   \   000016   14412800     MOV.W   0x28(SP), R4
    676            endPointDesc_t *epDesc;
    677            zclFrameHdr_t hdr;
    678            uint8 *msgBuf;
    679            uint16 msgLen;
    680            uint8 *pBuf;
    681            uint8 options;
    682            ZStatus_t status;
    683          
    684            epDesc = afFindEndPointDesc( srcEP );
   \   00001A   ........     CALLA   #afFindEndPointDesc
   \   00001E   094C         MOV.W   R12, R9
    685            if ( epDesc == NULL )
   \   000020   0C93         CMP.W   #0x0, R12
   \   000022   0220         JNE     ??zcl_SendCommand_1
    686            {
    687              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000024   6C43         MOV.B   #0x2, R12
   \   000026   713C         JMP     ??zcl_SendCommand_2
    688            }
    689          
    690          #if defined ( INTER_PAN )
    691            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
    692            {
    693              options = AF_TX_OPTIONS_NONE;
    694            }
    695            else
    696          #endif
    697            {
    698              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_1:
   \   000028   0D4B         MOV.W   R11, R13
   \   00002A   4C4A         MOV.B   R10, R12
   \   00002C   ........     CALLA   #zclGetClusterOption
   \   000030   464C         MOV.B   R12, R6
    699            }
    700          
    701            osal_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \   000032   3E400600     MOV.W   #0x6, R14
   \   000036   4D43         MOV.B   #0x0, R13
   \   000038   0C41         MOV.W   SP, R12
   \   00003A   0C53         ADD.W   #0x0, R12
   \   00003C   ........     CALLA   #osal_memset
    702          
    703            // Not Profile wide command (like READ, WRITE)
    704            if ( specific )
   \   000040   2F41         MOV.W   @SP, R15
   \   000042   3FF0FCFF     AND.W   #0xfffc, R15
   \   000046   4793         CMP.B   #0x0, R7
   \   000048   0124         JEQ     ??zcl_SendCommand_0
    705            {
    706              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   00004A   1FD3         BIS.W   #0x1, R15
    707            }
    708            else
    709            {
    710              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_0:
   \   00004C   814F0000     MOV.W   R15, 0(SP)
    711            }
    712          
    713            if ( ( epDesc->simpleDesc == NULL ) ||
    714                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type,
    715                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \   000050   1F490400     MOV.W   0x4(R9), R15
   \   000054   0F93         CMP.W   #0x0, R15
   \   000056   0E24         JEQ     ??zcl_SendCommand_3
   \   000058   1F120200     PUSH.W  0x2(R15)
   \   00005C   4F48         MOV.B   R8, R15
   \   00005E   5E410200     MOV.B   0x2(SP), R14
   \   000062   7EF00300     AND.B   #0x3, R14
   \   000066   0D4B         MOV.W   R11, R13
   \   000068   4C4A         MOV.B   R10, R12
   \   00006A   ........     CALLA   #zcl_DeviceOperational
   \   00006E   2153         ADD.W   #0x2, SP
   \   000070   4C93         CMP.B   #0x0, R12
   \   000072   0220         JNE     ??zcl_SendCommand_4
    716            {
    717              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_3:
   \   000074   5C43         MOV.B   #0x1, R12
   \   000076   493C         JMP     ??zcl_SendCommand_2
    718            }
   \                     ??zcl_SendCommand_4:
   \   000078   1F412200     MOV.W   0x22(SP), R15
    719          
    720            // Fill in the Maufacturer Code
    721            if ( manuCode != 0 )
   \   00007C   0F93         CMP.W   #0x0, R15
   \   00007E   0424         JEQ     ??zcl_SendCommand_5
    722            {
    723              hdr.fc.manuSpecific = 1;
   \   000080   A1D20000     BIS.W   #0x4, 0(SP)
    724              hdr.manuCode = manuCode;
   \   000084   814F0200     MOV.W   R15, 0x2(SP)
    725            }
    726          
    727            // Set the Command Direction
    728            if ( direction )
   \                     ??zcl_SendCommand_5:
   \   000088   C1931E00     CMP.B   #0x0, 0x1e(SP)
   \   00008C   0324         JEQ     ??zcl_SendCommand_6
    729            {
    730              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00008E   B1D20000     BIS.W   #0x8, 0(SP)
   \   000092   023C         JMP     ??zcl_SendCommand_7
    731            }
    732            else
    733            {
    734              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_6:
   \   000094   B1C20000     BIC.W   #0x8, 0(SP)
    735            }
    736          
    737            // Set the Disable Default Response field
    738            if ( disableDefaultRsp )
   \                     ??zcl_SendCommand_7:
   \   000098   C1932000     CMP.B   #0x0, 0x20(SP)
   \   00009C   0424         JEQ     ??zcl_SendCommand_8
    739            {
    740              hdr.fc.disableDefaultRsp = 1;
   \   00009E   B1D010000000 BIS.W   #0x10, 0(SP)
   \   0000A4   033C         JMP     ??zcl_SendCommand_9
    741            }
    742            else
    743            {
    744              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_8:
   \   0000A6   B1C010000000 BIC.W   #0x10, 0(SP)
    745            }
    746          
    747            // Fill in the Transaction Sequence Number
    748            hdr.transSeqNum = seqNum;
   \                     ??zcl_SendCommand_9:
   \   0000AC   C1450400     MOV.B   R5, 0x4(SP)
    749          
    750            // Fill in the command
    751            hdr.commandID = cmd;
   \   0000B0   C1480500     MOV.B   R8, 0x5(SP)
    752          
    753            // calculate the needed buffer size
    754            msgLen = zclCalcHdrSize( &hdr );
   \   0000B4   77400300     MOV.B   #0x3, R7
   \   0000B8   A1B20000     BIT.W   #0x4, 0(SP)
   \   0000BC   0228         JNC     ??zcl_SendCommand_10
   \   0000BE   77400500     MOV.B   #0x5, R7
   \                     ??zcl_SendCommand_10:
   \   0000C2   1A412600     MOV.W   0x26(SP), R10
    755            msgLen += cmdFormatLen;
   \   0000C6   075A         ADD.W   R10, R7
    756          
    757            // Allocate the buffer needed
    758            msgBuf = osal_mem_alloc( msgLen );
   \   0000C8   0C47         MOV.W   R7, R12
   \   0000CA   ........     CALLA   #??Subroutine8_0
    759            if ( msgBuf != NULL )
   \                     ??CrossCallReturnLabel_25:
   \   0000CE   1A24         JEQ     ??zcl_SendCommand_11
    760            {
    761              // Fill in the ZCL Header
    762              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   0000D0   0D4C         MOV.W   R12, R13
   \   0000D2   0C41         MOV.W   SP, R12
   \   0000D4   0C53         ADD.W   #0x0, R12
   \   0000D6   ........     CALLA   #zclBuildHdr
    763          
    764              // Fill in the command frame
    765              osal_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   0000DA   0E4A         MOV.W   R10, R14
   \   0000DC   0D44         MOV.W   R4, R13
   \   0000DE   ........     CALLA   #osal_memcpy
    766          
    767              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
    768                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   0000E2   70121E00     PUSH.B  #0x1e
   \   0000E6   4612         PUSH.B  R6
   \   0000E8   3012....     PUSH.W  #zcl_TransID
   \   0000EC   0812         PUSH.W  R8
   \   0000EE   0F47         MOV.W   R7, R15
   \   0000F0   0E4B         MOV.W   R11, R14
   \   0000F2   0D49         MOV.W   R9, R13
   \   0000F4   1C410E00     MOV.W   0xe(SP), R12
   \   0000F8   ........     CALLA   #AF_DataRequest
   \   0000FC   ........     CALLA   #?Subroutine14
    769              osal_mem_free ( msgBuf );
    770            }
   \                     ??CrossCallReturnLabel_27:
   \   000100   3152         ADD.W   #0x8, SP
   \   000102   023C         JMP     ??zcl_SendCommand_12
    771            else
    772            {
    773              status = ZMemError;
   \                     ??zcl_SendCommand_11:
   \   000104   7A401000     MOV.B   #0x10, R10
    774            }
    775          
    776            return ( status );
   \                     ??zcl_SendCommand_12:
   \   000108   4C4A         MOV.B   R10, R12
   \                     ??zcl_SendCommand_2:
   \   00010A   ........     BRA     #?Subroutine1
    777          }
    778          
    779          #ifdef ZCL_READ
    780          /*********************************************************************
    781           * @fn      zcl_SendRead
    782           *
    783           * @brief   Send a Read command
    784           *
    785           * @param   srcEP - Application's endpoint
    786           * @param   dstAddr - destination address
    787           * @param   clusterID - cluster ID
    788           * @param   readCmd - read command to be sent
    789           * @param   direction - direction of the command
    790           * @param   seqNum - transaction sequence number
    791           *
    792           * @return  ZSuccess if OK
    793           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   4C4A         MOV.B   R10, R12
   \   000002   2153         ADD.W   #0x2, SP
   \   000004   7417         POPM.W  #0x8, R11
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
    794          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    795                                  uint16 clusterID, zclReadCmd_t *readCmd,
    796                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    797          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   4C12         PUSH.B  R12
   \   000004   ........     CALLA   #?Subroutine20
    798            uint16 dataLen;
    799            uint8 *buf;
    800            uint8 *pBuf;
    801            ZStatus_t status;
    802          
    803            dataLen = readCmd->numAttr * 2; // Attribute ID
   \                     ??CrossCallReturnLabel_16:
   \   000008   654F         MOV.B   @R15, R5
   \   00000A   0555         RLA.W   R5
    804          
    805            buf = osal_mem_alloc( dataLen );
   \   00000C   0C45         MOV.W   R5, R12
   \   00000E   ........     CALLA   #osal_mem_alloc
   \   000012   0B4C         MOV.W   R12, R11
    806            if ( buf != NULL )
   \   000014   0C93         CMP.W   #0x0, R12
   \   000016   1D24         JEQ     ??zcl_SendRead_1
    807            {
    808              uint8 i;
    809          
    810              // Load the buffer - serially
    811              pBuf = buf;
   \   000018   0D4C         MOV.W   R12, R13
    812              for (i = 0; i < readCmd->numAttr; i++)
   \   00001A   4E43         MOV.B   #0x0, R14
   \   00001C   073C         JMP     ??zcl_SendRead_2
    813              {
    814                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_0:
   \   00001E   4F4E         MOV.B   R14, R15
   \   000020   0F5F         RLA.W   R15
   \   000022   0C49         MOV.W   R9, R12
   \   000024   0C5F         ADD.W   R15, R12
   \   000026   2C53         ADD.W   #0x2, R12
   \   000028   ........     CALLA   #?Subroutine22
    815                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
    816              }
   \                     ??zcl_SendRead_2:
   \   00002C   6E99         CMP.B   @R9, R14
   \   00002E   F72B         JNC     ??zcl_SendRead_0
    817          
    818              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    819                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000030   0B12         PUSH.W  R11
   \   000032   0512         PUSH.W  R5
   \   000034   4412         PUSH.B  R4
   \   000036   0312         PUSH.W  #0x0
   \   000038   4712         PUSH.B  R7
   \   00003A   4612         PUSH.B  R6
   \   00003C   4312         PUSH.B  #0x0
   \   00003E   4F43         MOV.B   #0x0, R15
   \   000040   ........     CALLA   #?Subroutine19
   \                     ??CrossCallReturnLabel_13:
   \   000044   4A4C         MOV.B   R12, R10
    820              osal_mem_free( buf );
   \   000046   0C4B         MOV.W   R11, R12
   \   000048   ........     CALLA   #osal_mem_free
   \   00004C   31500E00     ADD.W   #0xe, SP
   \   000050   023C         JMP     ??zcl_SendRead_3
    821            }
    822            else
    823            {
    824              status = ZMemError;
   \                     ??zcl_SendRead_1:
   \   000052   7A401000     MOV.B   #0x10, R10
    825            }
    826          
    827            return ( status );
   \                     ??zcl_SendRead_3:
   \   000056   ....         JMP     ?Subroutine0
    828          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine22:
   \   000000   ED4C0000     MOV.B   @R12, 0(R13)
   \   000004   1D53         ADD.W   #0x1, R13
   \   000006   DD4C01000000 MOV.B   0x1(R12), 0(R13)
   \   00000C   1D53         ADD.W   #0x1, R13
   \   00000E   5E53         ADD.B   #0x1, R14
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine20:
   \   000000   0A4D         MOV.W   R13, R10
   \   000002   084E         MOV.W   R14, R8
   \   000004   094F         MOV.W   R15, R9
   \   000006   56411A00     MOV.B   0x1a(SP), R6
   \   00000A   57411C00     MOV.B   0x1c(SP), R7
   \   00000E   54411E00     MOV.B   0x1e(SP), R4
   \   000012   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine19:
   \   000000   0E48         MOV.W   R8, R14
   \   000002   0D4A         MOV.W   R10, R13
   \   000004   5C411200     MOV.B   0x12(SP), R12
   \   000008   ........     BRA     #zcl_SendCommand
    829          
    830          /*********************************************************************
    831           * @fn      zcl_SendReadRsp
    832           *
    833           * @brief   Send a Read Response command.
    834           *
    835           * @param   srcEP - Application's endpoint
    836           * @param   dstAddr - destination address
    837           * @param   clusterID - cluster ID
    838           * @param   readRspCmd - read response command to be sent
    839           * @param   direction - direction of the command
    840           * @param   seqNum - transaction sequence number
    841           *
    842           * @return  ZSuccess if OK
    843           */

   \                                 In  segment CODE, align 2, keep-with-next
    844          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
    845                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
    846                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    847          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   0D12         PUSH.W  R13
   \   000004   2183         SUB.W   #0x2, SP
   \   000006   4A4C         MOV.B   R12, R10
   \   000008   0B4E         MOV.W   R14, R11
   \   00000A   094F         MOV.W   R15, R9
   \   00000C   55411C00     MOV.B   0x1c(SP), R5
    848            uint8 *buf;
    849            uint16 len = 0;
   \   000010   0643         MOV.W   #0x0, R6
    850            ZStatus_t status;
    851          
    852            // calculate the size of the command
    853            for ( uint8 i = 0; i < readRspCmd->numAttr; i++ )
   \   000012   4843         MOV.B   #0x0, R8
   \   000014   073C         JMP     ??zcl_SendReadRsp_4
    854            {
    855              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
    856          
    857              len += 2 + 1; // Attribute ID + Status
    858          
    859              if ( statusRec->status == ZCL_STATUS_SUCCESS )
    860              {
    861                len++; // Attribute Data Type length
    862          
    863                // Attribute Data length
    864                if ( statusRec->data != NULL )
    865                {
    866                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
    867                }
    868                else
    869                {
    870                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_1:
   \   000016   2E4F         MOV.W   @R15, R14
   \   000018   0D4B         MOV.W   R11, R13
   \   00001A   4C4A         MOV.B   R10, R12
   \   00001C   ........     CALLA   #zclGetAttrDataLengthUsingCB
   \                     ??zcl_SendReadRsp_6:
   \   000020   065C         ADD.W   R12, R6
    871                }
   \                     ??zcl_SendReadRsp_0:
   \   000022   5853         ADD.B   #0x1, R8
   \                     ??zcl_SendReadRsp_4:
   \   000024   6899         CMP.B   @R9, R8
   \   000026   152C         JC      ??zcl_SendReadRsp_5
   \   000028   0748         MOV.W   R8, R7
   \   00002A                RPT     #0x5
   \   00002A   44180758     ADDX.W  R8, R7
   \   00002E   0F49         MOV.W   R9, R15
   \   000030   0F57         ADD.W   R7, R15
   \   000032   2F53         ADD.W   #0x2, R15
   \   000034   36500300     ADD.W   #0x3, R6
   \   000038   CF930200     CMP.B   #0x0, 0x2(R15)
   \   00003C   F223         JNE     ??zcl_SendReadRsp_0
   \   00003E   1653         ADD.W   #0x1, R6
   \   000040   1D4F0400     MOV.W   0x4(R15), R13
   \   000044   0D93         CMP.W   #0x0, R13
   \   000046   E727         JEQ     ??zcl_SendReadRsp_1
   \   000048   5C4F0300     MOV.B   0x3(R15), R12
   \   00004C   ........     CALLA   #zclGetAttrDataLength
   \   000050   E73F         JMP     ??zcl_SendReadRsp_6
    872              }
    873            }
    874          
    875            buf = osal_mem_alloc( len );
   \                     ??zcl_SendReadRsp_5:
   \   000052   0C46         MOV.W   R6, R12
   \   000054   ........     CALLA   #??Subroutine8_0
    876            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_24:
   \   000058   4A24         JEQ     ??zcl_SendReadRsp_7
    877            {
    878              // Load the buffer - serially
    879              uint8 *pBuf = buf;
   \   00005A   074C         MOV.W   R12, R7
    880              for ( uint8 i = 0; i < readRspCmd->numAttr; i++ )
   \   00005C   4443         MOV.B   #0x0, R4
   \   00005E   0D3C         JMP     ??zcl_SendReadRsp_8
    881              {
    882                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
    883          
    884                *pBuf++ = LO_UINT16( statusRec->attrID );
    885                *pBuf++ = HI_UINT16( statusRec->attrID );
    886                *pBuf++ = statusRec->status;
    887          
    888                if ( statusRec->status == ZCL_STATUS_SUCCESS )
    889                {
    890                  *pBuf++ = statusRec->dataType;
    891          
    892                  if ( statusRec->data != NULL )
    893                  {
    894                    // Copy attribute data to the buffer to be sent out
    895                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
    896                  }
    897                  else
    898                  {
    899                    uint16 dataLen;
    900          
    901                    // Read attribute data directly into the buffer to be sent out
    902                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_3:
   \   000060   0F41         MOV.W   SP, R15
   \   000062   0F53         ADD.W   #0x0, R15
   \   000064   0F12         PUSH.W  R15
   \   000066   0F47         MOV.W   R7, R15
   \   000068   2E4C         MOV.W   @R12, R14
   \   00006A   0D4B         MOV.W   R11, R13
   \   00006C   4C4A         MOV.B   R10, R12
   \   00006E   ........     CALLA   #zclReadAttrDataUsingCB
    903                    pBuf += dataLen;
   \   000072   17510200     ADD.W   0x2(SP), R7
   \   000076   2153         ADD.W   #0x2, SP
    904                  }
   \                     ??zcl_SendReadRsp_2:
   \   000078   5453         ADD.B   #0x1, R4
   \                     ??zcl_SendReadRsp_8:
   \   00007A   6499         CMP.B   @R9, R4
   \   00007C   232C         JC      ??zcl_SendReadRsp_9
   \   00007E   0F44         MOV.W   R4, R15
   \   000080                RPT     #0x5
   \   000080   44180F54     ADDX.W  R4, R15
   \   000084   0C49         MOV.W   R9, R12
   \   000086   0C5F         ADD.W   R15, R12
   \   000088   2C53         ADD.W   #0x2, R12
   \   00008A   E74C0000     MOV.B   @R12, 0(R7)
   \   00008E   1753         ADD.W   #0x1, R7
   \   000090   D74C01000000 MOV.B   0x1(R12), 0(R7)
   \   000096   1753         ADD.W   #0x1, R7
   \   000098   D74C02000000 MOV.B   0x2(R12), 0(R7)
   \   00009E   1753         ADD.W   #0x1, R7
   \   0000A0   CC930200     CMP.B   #0x0, 0x2(R12)
   \   0000A4   E923         JNE     ??zcl_SendReadRsp_2
   \   0000A6   D74C03000000 MOV.B   0x3(R12), 0(R7)
   \   0000AC   1753         ADD.W   #0x1, R7
   \   0000AE   1D4C0400     MOV.W   0x4(R12), R13
   \   0000B2   0D93         CMP.W   #0x0, R13
   \   0000B4   D527         JEQ     ??zcl_SendReadRsp_3
   \   0000B6   0E47         MOV.W   R7, R14
   \   0000B8   5C4C0300     MOV.B   0x3(R12), R12
   \   0000BC   ........     CALLA   #zclSerializeData
   \   0000C0   074C         MOV.W   R12, R7
   \   0000C2   DA3F         JMP     ??zcl_SendReadRsp_2
    905                }
    906              } // for loop
    907          
    908              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
    909                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_9:
   \   0000C4   0812         PUSH.W  R8
   \   0000C6   0612         PUSH.W  R6
   \   0000C8   4512         PUSH.B  R5
   \   0000CA   0312         PUSH.W  #0x0
   \   0000CC   51122400     PUSH.B  0x24(SP)
   \   0000D0   51122400     PUSH.B  0x24(SP)
   \   0000D4   4312         PUSH.B  #0x0
   \   0000D6   5F43         MOV.B   #0x1, R15
   \   0000D8   0E4B         MOV.W   R11, R14
   \   0000DA   1D411000     MOV.W   0x10(SP), R13
   \   0000DE   4C4A         MOV.B   R10, R12
   \   0000E0   ........     CALLA   #zcl_SendCommand
   \   0000E4   ........     CALLA   #?Subroutine14
    910              osal_mem_free( buf );
    911            }
   \                     ??CrossCallReturnLabel_28:
   \   0000E8   31500E00     ADD.W   #0xe, SP
   \   0000EC   023C         JMP     ??zcl_SendReadRsp_10
    912            else
    913            {
    914              status = ZMemError;
   \                     ??zcl_SendReadRsp_7:
   \   0000EE   7A401000     MOV.B   #0x10, R10
    915            }
    916          
    917            return ( status );
   \                     ??zcl_SendReadRsp_10:
   \   0000F2   4C4A         MOV.B   R10, R12
   \   0000F4   2152         ADD.W   #0x4, SP
   \   0000F6   7417         POPM.W  #0x8, R11
   \   0000F8   1001         RETA
    918          }
    919          #endif // ZCL_READ
    920          
    921          #ifdef ZCL_WRITE
    922          /*********************************************************************
    923           * @fn      sendWriteRequest
    924           *
    925           * @brief   Send a Write command
    926           *
    927           * @param   dstAddr - destination address
    928           * @param   clusterID - cluster ID
    929           * @param   writeCmd - write command to be sent
    930           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
    931           * @param   direction - direction of the command
    932           * @param   seqNum - transaction sequence number
    933           *
    934           * @return  ZSuccess if OK
    935           */

   \                                 In  segment CODE, align 2, keep-with-next
    936          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
    937                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
    938                                          uint8 disableDefaultRsp, uint8 seqNum )
    939          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   4C12         PUSH.B  R12
   \   000004   0D12         PUSH.W  R13
   \   000006   0E12         PUSH.W  R14
   \   000008   0B4F         MOV.W   R15, R11
   \   00000A   55411A00     MOV.B   0x1a(SP), R5
   \   00000E   58411C00     MOV.B   0x1c(SP), R8
   \   000012   59411E00     MOV.B   0x1e(SP), R9
   \   000016   56412000     MOV.B   0x20(SP), R6
    940            uint8 *buf;
    941            uint16 dataLen = 0;
   \   00001A   0743         MOV.W   #0x0, R7
    942            ZStatus_t status;
    943          
    944            for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \   00001C   4A43         MOV.B   #0x0, R10
   \   00001E   103C         JMP     ??zcl_SendWriteRequest_2
    945            {
    946              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_0:
   \   000020   0E4A         MOV.W   R10, R14
   \   000022                RPT     #0x5
   \   000022   44180E5A     ADDX.W  R10, R14
   \   000026   0F4B         MOV.W   R11, R15
   \   000028   0F5E         ADD.W   R14, R15
   \   00002A   2F53         ADD.W   #0x2, R15
    947          
    948              dataLen += 2 + 1; // Attribute ID + Attribute Type
    949          
    950              // Attribute Data
    951              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
   \   00002C   1D4F0400     MOV.W   0x4(R15), R13
   \   000030   5C4F0200     MOV.B   0x2(R15), R12
   \   000034   ........     CALLA   #zclGetAttrDataLength
   \   000038   3C500300     ADD.W   #0x3, R12
   \   00003C   075C         ADD.W   R12, R7
    952            }
   \   00003E   5A53         ADD.B   #0x1, R10
   \                     ??zcl_SendWriteRequest_2:
   \   000040   6A9B         CMP.B   @R11, R10
   \   000042   EE2B         JNC     ??zcl_SendWriteRequest_0
    953          
    954            buf = osal_mem_alloc( dataLen );
   \   000044   0C47         MOV.W   R7, R12
   \   000046   ........     CALLA   #osal_mem_alloc
   \   00004A   0A4C         MOV.W   R12, R10
    955            if ( buf != NULL )
   \   00004C   0C93         CMP.W   #0x0, R12
   \   00004E   3524         JEQ     ??zcl_SendWriteRequest_3
    956            {
    957              // Load the buffer - serially
    958              uint8 *pBuf = buf;
   \   000050   0E4C         MOV.W   R12, R14
    959              for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \   000052   4443         MOV.B   #0x0, R4
   \   000054   193C         JMP     ??zcl_SendWriteRequest_4
    960              {
    961                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_1:
   \   000056   0D44         MOV.W   R4, R13
   \   000058                RPT     #0x5
   \   000058   44180D54     ADDX.W  R4, R13
   \   00005C   0F4B         MOV.W   R11, R15
   \   00005E   0F5D         ADD.W   R13, R15
   \   000060   2F53         ADD.W   #0x2, R15
    962          
    963                *pBuf++ = LO_UINT16( statusRec->attrID );
   \   000062   EE4F0000     MOV.B   @R15, 0(R14)
   \   000066   1E53         ADD.W   #0x1, R14
    964                *pBuf++ = HI_UINT16( statusRec->attrID );
   \   000068   DE4F01000000 MOV.B   0x1(R15), 0(R14)
   \   00006E   1E53         ADD.W   #0x1, R14
    965                *pBuf++ = statusRec->dataType;
   \   000070   DE4F02000000 MOV.B   0x2(R15), 0(R14)
   \   000076   1E53         ADD.W   #0x1, R14
    966          
    967                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
   \   000078   1D4F0400     MOV.W   0x4(R15), R13
   \   00007C   5C4F0200     MOV.B   0x2(R15), R12
   \   000080   ........     CALLA   #zclSerializeData
   \   000084   0E4C         MOV.W   R12, R14
    968              }
   \   000086   5453         ADD.B   #0x1, R4
   \                     ??zcl_SendWriteRequest_4:
   \   000088   649B         CMP.B   @R11, R4
   \   00008A   E52B         JNC     ??zcl_SendWriteRequest_1
    969          
    970              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
    971                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00008C   0A12         PUSH.W  R10
   \   00008E   0712         PUSH.W  R7
   \   000090   4612         PUSH.B  R6
   \   000092   0312         PUSH.W  #0x0
   \   000094   4912         PUSH.B  R9
   \   000096   4812         PUSH.B  R8
   \   000098   4312         PUSH.B  #0x0
   \   00009A   4F45         MOV.B   R5, R15
   \   00009C   1E410E00     MOV.W   0xe(SP), R14
   \   0000A0   1D411000     MOV.W   0x10(SP), R13
   \   0000A4   5C411200     MOV.B   0x12(SP), R12
   \   0000A8   ........     CALLA   #zcl_SendCommand
   \   0000AC   4B4C         MOV.B   R12, R11
    972              osal_mem_free( buf );
   \   0000AE   0C4A         MOV.W   R10, R12
   \   0000B0   ........     CALLA   #osal_mem_free
   \   0000B4   31500E00     ADD.W   #0xe, SP
   \   0000B8   023C         JMP     ??zcl_SendWriteRequest_5
    973            }
    974            else
    975            {
    976              status = ZMemError;
   \                     ??zcl_SendWriteRequest_3:
   \   0000BA   7B401000     MOV.B   #0x10, R11
    977            }
    978          
    979            return ( status);
   \                     ??zcl_SendWriteRequest_5:
   \   0000BE   4C4B         MOV.B   R11, R12
   \   0000C0   31500600     ADD.W   #0x6, SP
   \   0000C4   7417         POPM.W  #0x8, R11
   \   0000C6   1001         RETA
    980          }
    981          
    982          /*********************************************************************
    983           * @fn      zcl_SendWriteRsp
    984           *
    985           * @brief   Send a Write Response command
    986           *
    987           * @param   dstAddr - destination address
    988           * @param   clusterID - cluster ID
    989           * @param   wrtieRspCmd - write response command to be sent
    990           * @param   direction - direction of the command
    991           * @param   seqNum - transaction sequence number
    992           *
    993           * @return  ZSuccess if OK
    994           */

   \                                 In  segment CODE, align 2, keep-with-next
    995          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
    996                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
    997                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    998          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   4C12         PUSH.B  R12
   \   000004   ........     CALLA   #?Subroutine20
    999            uint16 dataLen;
   1000            uint8 *buf;
   1001            ZStatus_t status;
   1002          
   1003            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   \                     ??CrossCallReturnLabel_15:
   \   000008   6F49         MOV.B   @R9, R15
   \   00000A   054F         MOV.W   R15, R5
   \   00000C                RPT     #0x2
   \   00000C   4118055F     ADDX.W  R15, R5
   1004          
   1005            buf = osal_mem_alloc( dataLen );
   \   000010   0C45         MOV.W   R5, R12
   \   000012   ........     CALLA   #osal_mem_alloc
   \   000016   0B4C         MOV.W   R12, R11
   1006            if ( buf != NULL )
   \   000018   0C93         CMP.W   #0x0, R12
   \   00001A   2824         JEQ     ??zcl_SendWriteRsp_1
   1007            {
   1008              // Load the buffer - serially
   1009              uint8 *pBuf = buf;
   \   00001C   0D4C         MOV.W   R12, R13
   1010              for ( uint8 i = 0; i < writeRspCmd->numAttr; i++ )
   \   00001E   4E43         MOV.B   #0x0, R14
   \   000020   0B3C         JMP     ??zcl_SendWriteRsp_2
   1011              {
   1012                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_0:
   \   000022   4F4E         MOV.B   R14, R15
   \   000024   5F06         RLAM.W  #0x2, R15
   \   000026   0C49         MOV.W   R9, R12
   \   000028   0C5F         ADD.W   R15, R12
   \   00002A   DD4C02000000 MOV.B   0x2(R12), 0(R13)
   \   000030   1D53         ADD.W   #0x1, R13
   1013                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   \   000032   2C52         ADD.W   #0x4, R12
   \   000034   ........     CALLA   #?Subroutine22
   1014                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1015              }
   \                     ??zcl_SendWriteRsp_2:
   \   000038   6F49         MOV.B   @R9, R15
   \   00003A   4E9F         CMP.B   R15, R14
   \   00003C   F22B         JNC     ??zcl_SendWriteRsp_0
   1016          
   1017              // If there's only a single status record and its status field is set to
   1018              // SUCCESS then omit the attribute ID field.
   1019              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   00003E   5F93         CMP.B   #0x1, R15
   \   000040   0420         JNE     ??zcl_SendWriteRsp_3
   \   000042   C9930200     CMP.B   #0x0, 0x2(R9)
   \   000046   0120         JNE     ??zcl_SendWriteRsp_3
   1020              {
   1021                dataLen = 1;
   \   000048   1543         MOV.W   #0x1, R5
   1022              }
   1023          
   1024              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1025                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_3:
   \   00004A   0B12         PUSH.W  R11
   \   00004C   0512         PUSH.W  R5
   \   00004E   4412         PUSH.B  R4
   \   000050   0312         PUSH.W  #0x0
   \   000052   4712         PUSH.B  R7
   \   000054   4612         PUSH.B  R6
   \   000056   4312         PUSH.B  #0x0
   \   000058   6F42         MOV.B   #0x4, R15
   \   00005A   ........     CALLA   #?Subroutine19
   \                     ??CrossCallReturnLabel_14:
   \   00005E   4A4C         MOV.B   R12, R10
   1026              osal_mem_free( buf );
   \   000060   0C4B         MOV.W   R11, R12
   \   000062   ........     CALLA   #osal_mem_free
   \   000066   31500E00     ADD.W   #0xe, SP
   \   00006A   023C         JMP     ??zcl_SendWriteRsp_4
   1027            }
   1028            else
   1029            {
   1030              status = ZMemError;
   \                     ??zcl_SendWriteRsp_1:
   \   00006C   7A401000     MOV.B   #0x10, R10
   1031            }
   1032          
   1033            return ( status );
   \                     ??zcl_SendWriteRsp_4:
   \   000070                REQUIRE ?Subroutine0
   \   000070                // Fall through to label ?Subroutine0
   1034          }
   1035          #endif // ZCL_WRITE
   1036          
   1037          #ifdef ZCL_REPORT
   1038          /*********************************************************************
   1039           * @fn      zcl_SendConfigReportCmd
   1040           *
   1041           * @brief   Send a Configure Reporting command
   1042           *
   1043           * @param   dstAddr - destination address
   1044           * @param   clusterID - cluster ID
   1045           * @param   cfgReportCmd - configure reporting command to be sent
   1046           * @param   direction - direction of the command
   1047           * @param   seqNum - transaction sequence number
   1048           *
   1049           * @return  ZSuccess if OK
   1050           */
   1051          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1052                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1053                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1054          {
   1055            uint8 *buf;
   1056            uint16 dataLen = 0;
   1057            ZStatus_t status;
   1058          
   1059            // Find out the data length
   1060            for ( uint8 i = 0; i < cfgReportCmd->numAttr; i++ )
   1061            {
   1062              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1063          
   1064              dataLen += 1 + 2; // Direction + Attribute ID
   1065          
   1066              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1067              {
   1068                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1069          
   1070                // Find out the size of the Reportable Change field (for Analog data types)
   1071                if ( zclAnalogDataType( reportRec->dataType ) )
   1072                {
   1073                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1074                }
   1075              }
   1076              else
   1077              {
   1078                dataLen += 2; // Timeout Period
   1079              }
   1080            }
   1081          
   1082            buf = osal_mem_alloc( dataLen );
   1083            if ( buf != NULL )
   1084            {
   1085              // Load the buffer - serially
   1086              uint8 *pBuf = buf;
   1087              for ( uint8 i = 0; i < cfgReportCmd->numAttr; i++ )
   1088              {
   1089                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1090          
   1091                *pBuf++ = reportRec->direction;
   1092                *pBuf++ = LO_UINT16( reportRec->attrID );
   1093                *pBuf++ = HI_UINT16( reportRec->attrID );
   1094          
   1095                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1096                {
   1097                  *pBuf++ = reportRec->dataType;
   1098                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1099                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1100                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1101                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1102          
   1103                  if ( zclAnalogDataType( reportRec->dataType ) )
   1104                  {
   1105                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1106                  }
   1107                }
   1108                else
   1109                {
   1110                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   1111                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1112                }
   1113              } // for loop
   1114          
   1115              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1116                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1117              osal_mem_free( buf );
   1118            }
   1119            else
   1120            {
   1121              status = ZMemError;
   1122            }
   1123          
   1124            return ( status );
   1125          }
   1126          
   1127          /*********************************************************************
   1128           * @fn      zcl_SendConfigReportRspCmd
   1129           *
   1130           * @brief   Send a Configure Reporting Response command
   1131           *
   1132           * @param   dstAddr - destination address
   1133           * @param   clusterID - cluster ID
   1134           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1135           * @param   direction - direction of the command
   1136           * @param   seqNum - transaction sequence number
   1137           *
   1138           * @return  ZSuccess if OK
   1139           */
   1140          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1141                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1142                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1143          {
   1144            uint16 dataLen;
   1145            uint8 *buf;
   1146            ZStatus_t status;
   1147          
   1148            // Atrribute list (Status, Direction and Attribute ID)
   1149            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   1150          
   1151            buf = osal_mem_alloc( dataLen );
   1152            if ( buf != NULL )
   1153            {
   1154              // Load the buffer - serially
   1155              uint8 *pBuf = buf;
   1156              for ( uint8 i = 0; i < cfgReportRspCmd->numAttr; i++ )
   1157              {
   1158                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   1159                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   1160                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1161                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1162              }
   1163          
   1164              // If there's only a single status record and its status field is set to
   1165              // SUCCESS then omit the attribute ID field.
   1166              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   1167              {
   1168                dataLen = 1;
   1169              }
   1170          
   1171              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1172                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1173                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   1174              osal_mem_free( buf );
   1175            }
   1176            else
   1177            {
   1178              status = ZMemError;
   1179            }
   1180          
   1181            return ( status );
   1182          }
   1183          
   1184          /*********************************************************************
   1185           * @fn      zcl_SendReadReportCfgCmd
   1186           *
   1187           * @brief   Send a Read Reporting Configuration command
   1188           *
   1189           * @param   dstAddr - destination address
   1190           * @param   clusterID - cluster ID
   1191           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1192           * @param   direction - direction of the command
   1193           * @param   seqNum - transaction sequence number
   1194           *
   1195           * @return  ZSuccess if OK
   1196           */
   1197          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1198                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1199                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1200          {
   1201            uint16 dataLen;
   1202            uint8 *buf;
   1203            ZStatus_t status;
   1204          
   1205            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1206          
   1207            buf = osal_mem_alloc( dataLen );
   1208            if ( buf != NULL )
   1209            {
   1210              // Load the buffer - serially
   1211              uint8 *pBuf = buf;
   1212              for ( uint8 i = 0; i < readReportCfgCmd->numAttr; i++ )
   1213              {
   1214                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   1215                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1216                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1217              }
   1218          
   1219              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1220                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1221              osal_mem_free( buf );
   1222            }
   1223            else
   1224            {
   1225              status = ZMemError;
   1226            }
   1227          
   1228            return ( status );
   1229          }
   1230          
   1231          /*********************************************************************
   1232           * @fn      zcl_SendReadReportCfgRspCmd
   1233           *
   1234           * @brief   Send a Read Reporting Configuration Response command
   1235           *
   1236           * @param   dstAddr - destination address
   1237           * @param   clusterID - cluster ID
   1238           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1239           * @param   direction - direction of the command
   1240           * @param   seqNum - transaction sequence number
   1241           *
   1242           * @return  ZSuccess if OK
   1243           */
   1244          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1245                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1246                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1247          {
   1248            uint8 *buf;
   1249            uint16 dataLen = 0;
   1250            ZStatus_t status;
   1251          
   1252            // Find out the data length
   1253            for ( uint8 i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1254            {
   1255              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1256          
   1257              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1258          
   1259              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1260              {
   1261                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1262                {
   1263                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1264          
   1265                  // Find out the size of the Reportable Change field (for Analog data types)
   1266                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1267                  {
   1268                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1269                  }
   1270                }
   1271                else
   1272                {
   1273                  dataLen += 2; // Timeout Period
   1274                }
   1275              }
   1276            }
   1277          
   1278            buf = osal_mem_alloc( dataLen );
   1279            if ( buf != NULL )
   1280            {
   1281              // Load the buffer - serially
   1282              uint8 *pBuf = buf;
   1283              for ( uint8 i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1284              {
   1285                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1286          
   1287                *pBuf++ = reportRspRec->status;
   1288                *pBuf++ = reportRspRec->direction;
   1289                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1290                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1291          
   1292                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1293                {
   1294                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1295                  {
   1296                    *pBuf++ = reportRspRec->dataType;
   1297                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1298                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1299                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1300                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1301          
   1302                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1303                    {
   1304                      pBuf = zclSerializeData( reportRspRec->dataType,
   1305                                               reportRspRec->reportableChange, pBuf );
   1306                    }
   1307                  }
   1308                  else
   1309                  {
   1310                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   1311                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1312                  }
   1313                }
   1314              }
   1315          
   1316              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1317                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1318                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1319              osal_mem_free( buf );
   1320            }
   1321            else
   1322            {
   1323              status = ZMemError;
   1324            }
   1325          
   1326            return ( status );
   1327          }
   1328          
   1329          /*********************************************************************
   1330           * @fn      zcl_SendReportCmd
   1331           *
   1332           * @brief   Send a Report command
   1333           *
   1334           * @param   dstAddr - destination address
   1335           * @param   clusterID - cluster ID
   1336           * @param   reportCmd - report command to be sent
   1337           * @param   direction - direction of the command
   1338           * @param   seqNum - transaction sequence number
   1339           *
   1340           * @return  ZSuccess if OK
   1341           */
   1342          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1343                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1344                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1345          {
   1346            uint16 dataLen = 0;
   1347            uint8 *buf;
   1348            ZStatus_t status;
   1349          
   1350            // calculate the size of the command
   1351            for ( uint8 i = 0; i < reportCmd->numAttr; i++ )
   1352            {
   1353              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1354          
   1355              dataLen += 2 + 1; // Attribute ID + data type
   1356          
   1357              // Attribute Data
   1358              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1359            }
   1360          
   1361            buf = osal_mem_alloc( dataLen );
   1362            if ( buf != NULL )
   1363            {
   1364              // Load the buffer - serially
   1365              uint8 *pBuf = buf;
   1366              for ( uint8 i = 0; i < reportCmd->numAttr; i++ )
   1367              {
   1368                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   1369          
   1370                *pBuf++ = LO_UINT16( reportRec->attrID );
   1371                *pBuf++ = HI_UINT16( reportRec->attrID );
   1372                *pBuf++ = reportRec->dataType;
   1373          
   1374                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1375              }
   1376          
   1377              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1378                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1379              osal_mem_free( buf );
   1380            }
   1381            else
   1382            {
   1383              status = ZMemError;
   1384            }
   1385          
   1386            return ( status );
   1387          }
   1388          #endif // ZCL_REPORT
   1389          
   1390          /*********************************************************************
   1391           * @fn      zcl_SendDefaultRspCmd
   1392           *
   1393           * @brief   Send a Default Response command
   1394           *
   1395           *          Note: The manufacturer code field should be set if this
   1396           *          command is being sent in response to a manufacturer specific
   1397           *          command.
   1398           *
   1399           * @param   dstAddr - destination address
   1400           * @param   clusterID - cluster ID
   1401           * @param   defaultRspCmd - default response command to be sent
   1402           * @param   direction - direction of the command
   1403           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1404           * @param   seqNum - transaction sequence number
   1405           *
   1406           * @return  ZSuccess if OK
   1407           */

   \                                 In  segment CODE, align 2, keep-with-next
   1408          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1409                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1410                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1411          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   5A410E00     MOV.B   0xe(SP), R10
   \   000008   5B411000     MOV.B   0x10(SP), R11
   \   00000C   18411200     MOV.W   0x12(SP), R8
   \   000010   59411400     MOV.B   0x14(SP), R9
   1412            uint8 buf[2]; // Command ID and Status;
   1413          
   1414            // Load the buffer - serially
   1415            buf[0] = defaultRspCmd->commandID;
   \   000014   E14F0000     MOV.B   @R15, 0(SP)
   1416            buf[1] = defaultRspCmd->statusCode;
   \   000018   D14F01000100 MOV.B   0x1(R15), 0x1(SP)
   1417          
   1418            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1419                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   00001E   0F41         MOV.W   SP, R15
   \   000020   0F53         ADD.W   #0x0, R15
   \   000022   0F12         PUSH.W  R15
   \   000024   2312         PUSH.W  #0x2
   \   000026   4912         PUSH.B  R9
   \   000028   0812         PUSH.W  R8
   \   00002A   4B12         PUSH.B  R11
   \   00002C   4A12         PUSH.B  R10
   \   00002E   4312         PUSH.B  #0x0
   \   000030   7F400B00     MOV.B   #0xb, R15
   \   000034   ........     CALLA   #zcl_SendCommand
   \   000038   31501000     ADD.W   #0x10, SP
   \   00003C   3817         POPM.W  #0x4, R11
   \   00003E   1001         RETA
   1420          }
   1421          
   1422          #ifdef ZCL_DISCOVER
   1423          /*********************************************************************
   1424           * @fn      zcl_SendDiscoverCmd
   1425           *
   1426           * @brief   Send a Discover command
   1427           *
   1428           * @param   dstAddr - destination address
   1429           * @param   clusterID - cluster ID
   1430           * @param   discoverCmd - discover command to be sent
   1431           * @param   direction - direction of the command
   1432           * @param   seqNum - transaction sequence number
   1433           *
   1434           * @return  ZSuccess if OK
   1435           */
   1436          ZStatus_t zcl_SendDiscoverCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1437                                      uint16 clusterID, zclDiscoverCmd_t *discoverCmd,
   1438                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1439          {
   1440            uint16 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1441            uint8 *buf;
   1442            ZStatus_t status;
   1443          
   1444            buf = osal_mem_alloc( dataLen );
   1445            if ( buf != NULL )
   1446            {
   1447              // Load the buffer - serially
   1448              uint8 *pBuf = buf;
   1449              *pBuf++ = LO_UINT16(discoverCmd->startAttr);
   1450              *pBuf++ = HI_UINT16(discoverCmd->startAttr);
   1451              *pBuf++ = discoverCmd->maxAttrIDs;
   1452          
   1453              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER, FALSE,
   1454                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1455              osal_mem_free( buf );
   1456            }
   1457            else
   1458            {
   1459              status = ZMemError;
   1460            }
   1461          
   1462            return ( status );
   1463          }
   1464          
   1465          /*********************************************************************
   1466           * @fn      zcl_SendDiscoverRspCmd
   1467           *
   1468           * @brief   Send a Discover Response command
   1469           *
   1470           * @param   dstAddr - destination address
   1471           * @param   clusterID - cluster ID
   1472           * @param   reportRspCmd - report response command to be sent
   1473           * @param   direction - direction of the command
   1474           * @param   seqNum - transaction sequence number
   1475           *
   1476           * @return  ZSuccess if OK
   1477           */
   1478          ZStatus_t zcl_SendDiscoverRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1479                                uint16 clusterID, zclDiscoverRspCmd_t *discoverRspCmd,
   1480                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1481          {
   1482            uint16 dataLen = 1; // Discovery complete
   1483            uint8 *buf;
   1484            ZStatus_t status;
   1485          
   1486            // calculate the size of the command
   1487            dataLen += discoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1488          
   1489            buf = osal_mem_alloc( dataLen );
   1490            if ( buf != NULL )
   1491            {
   1492              // Load the buffer - serially
   1493              uint8 *pBuf = buf;
   1494              *pBuf++ = discoverRspCmd->discComplete;
   1495              for ( uint8 i = 0; i < discoverRspCmd->numAttr; i++ )
   1496              {
   1497                *pBuf++ = LO_UINT16(discoverRspCmd->attrList[i].attrID);
   1498                *pBuf++ = HI_UINT16(discoverRspCmd->attrList[i].attrID);
   1499                *pBuf++ = discoverRspCmd->attrList[i].dataType;
   1500              }
   1501          
   1502              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_RSP, FALSE,
   1503                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1504              osal_mem_free( buf );
   1505            }
   1506            else
   1507            {
   1508              status = ZMemError;
   1509            }
   1510          
   1511            return ( status );
   1512          }
   1513          #endif // ZCL_DISCOVER
   1514          
   1515          /*********************************************************************
   1516           * PRIVATE FUNCTIONS
   1517           *********************************************************************/
   1518          
   1519          /*********************************************************************
   1520           * @fn      zclProcessMessageMSG
   1521           *
   1522           * @brief   Data message processor callback.  This function processes
   1523           *          any incoming data - probably from other devices.  So, based
   1524           *          on cluster ID, perform the intended action.
   1525           *
   1526           * @param   pkt - incoming message
   1527           *
   1528           * @return  none
   1529           */

   \                                 In  segment CODE, align 2, keep-with-next
   1530          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zclProcessMessageMSG:
   1531          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   31801600     SUB.W   #0x16, SP
   \   000006   084C         MOV.W   R12, R8
   1532            endPointDesc_t *epDesc;
   1533            zclIncoming_t inMsg;
   1534            zclLibPlugin_t *pInPlugin;
   1535            zclDefaultRspCmd_t defautlRspCmd;
   1536            uint8 options;
   1537            uint8 securityEnable;
   1538            uint8 interPanMsg;
   1539            ZStatus_t status = ZFailure;
   1540          
   1541            if ( pkt->cmd.DataLength == 0 )
   \   000008   8C932200     CMP.W   #0x0, 0x22(R12)
   \   00000C   1E25         JEQ     ??zclProcessMessageMSG_1
   1542            {
   1543              return;   // Error, ignore the message
   1544            }
   1545          
   1546            // Initialize
   1547            inMsg.msg = pkt;
   \   00000E   814C0200     MOV.W   R12, 0x2(SP)
   1548            inMsg.attrCmd = NULL;
   \   000012   81430E00     MOV.W   #0x0, 0xe(SP)
   1549            inMsg.pData = NULL;
   \   000016   81430A00     MOV.W   #0x0, 0xa(SP)
   1550            inMsg.pDataLen = 0;
   \   00001A   81430C00     MOV.W   #0x0, 0xc(SP)
   1551          
   1552            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   00001E   0A41         MOV.W   SP, R10
   \   000020   2A53         ADD.W   #0x2, R10
   \   000022   1D4C2400     MOV.W   0x24(R12), R13
   \   000026   0C4A         MOV.W   R10, R12
   \   000028   2C53         ADD.W   #0x2, R12
   \   00002A   ........     CALLA   #zclParseHdr
   \   00002E   814C0A00     MOV.W   R12, 0xa(SP)
   1553            inMsg.pDataLen = pkt->cmd.DataLength;
   1554            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \   000032   1F482200     MOV.W   0x22(R8), R15
   \   000036   0F8C         SUB.W   R12, R15
   \   000038   1F582400     ADD.W   0x24(R8), R15
   \   00003C   814F0C00     MOV.W   R15, 0xc(SP)
   1555          
   1556            // Find the wanted endpoint
   1557            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   000040   0B48         MOV.W   R8, R11
   \   000042   3B501400     ADD.W   #0x14, R11
   \   000046   6C4B         MOV.B   @R11, R12
   \   000048   ........     CALLA   #afFindEndPointDesc
   1558            if ( epDesc == NULL )
   \   00004C   0C93         CMP.W   #0x0, R12
   \   00004E   FD24         JEQ     ??zclProcessMessageMSG_1
   1559            {
   1560              return;   // Error, ignore the message
   1561            }
   1562          
   1563            if ( ( epDesc->simpleDesc == NULL ) ||
   1564                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   1565                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \   000050   1F4C0400     MOV.W   0x4(R12), R15
   \   000054   0F93         CMP.W   #0x0, R15
   \   000056   F924         JEQ     ??zclProcessMessageMSG_1
   \   000058   0948         MOV.W   R8, R9
   \   00005A   2952         ADD.W   #0x4, R9
   \   00005C   1F120200     PUSH.W  0x2(R15)
   \   000060   5F410B00     MOV.B   0xb(SP), R15
   \   000064   5E410600     MOV.B   0x6(SP), R14
   \   000068   7EF00300     AND.B   #0x3, R14
   \   00006C   2D49         MOV.W   @R9, R13
   \   00006E   6C4B         MOV.B   @R11, R12
   \   000070   ........     CALLA   #zcl_DeviceOperational
   \   000074   2153         ADD.W   #0x2, SP
   \   000076   4C93         CMP.B   #0x0, R12
   \   000078   E824         JEQ     ??zclProcessMessageMSG_1
   1566            {
   1567              return; // Error, ignore the message
   1568            }
   1569          
   1570          #if defined ( INTER_PAN )
   1571            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   1572            {
   1573              // No foundation command is supported thru Inter-PAN communication.
   1574              // But the Smart Light cluster uses a different Frame Control format
   1575              // for it's Inter-PAN messages, where the messages could be confused
   1576              // with the foundation commands.
   1577              if ( !ZCL_CLUSTER_ID_SL( pkt->clusterId ) && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   1578              {
   1579                return;
   1580              }
   1581          
   1582              interPanMsg = TRUE;
   1583              options = AF_TX_OPTIONS_NONE;
   1584            }
   1585            else
   1586          #endif
   1587            {
   1588              interPanMsg = FALSE;
   1589              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \   00007A   2D49         MOV.W   @R9, R13
   \   00007C   6C4B         MOV.B   @R11, R12
   \   00007E   ........     CALLA   #zclGetClusterOption
   \   000082   2F49         MOV.W   @R9, R15
   \   000084   1E42....     MOV.W   &plugins, R14
   \   000088   013C         JMP     ??zclProcessMessageMSG_10
   \                     ??zclProcessMessageMSG_0:
   \   00008A   2E4E         MOV.W   @R14, R14
   \                     ??zclProcessMessageMSG_10:
   \   00008C   0E93         CMP.W   #0x0, R14
   \   00008E   4824         JEQ     ??zclProcessMessageMSG_11
   \   000090   1F9E0200     CMP.W   0x2(R14), R15
   \   000094   FA2B         JNC     ??zclProcessMessageMSG_0
   \   000096   8E9F0400     CMP.W   R15, 0x4(R14)
   \   00009A   F72B         JNC     ??zclProcessMessageMSG_0
   \   00009C   F1B007000400 BIT.B   #0x7, 0x4(SP)
   \   0000A2   0420         JNE     ??zclProcessMessageMSG_12
   \   0000A4   F1900B000900 CMP.B   #0xb, 0x9(SP)
   \   0000AA   3B24         JEQ     ??zclProcessMessageMSG_13
   1590            }
   1591          
   1592            // Find the appropriate plugin
   1593            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   1594          
   1595            // Local and remote Security options must match except for Default Response command
   1596            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   1597            {
   1598              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zclProcessMessageMSG_12:
   \   0000AC   7CB04000     BIT.B   #0x40, R12
   \   0000B0   4676         SUBC.B  R6, R6
   \   0000B2   5653         ADD.B   #0x1, R6
   1599              if ( pkt->SecurityUse != securityEnable )
   \   0000B4   C8961900     CMP.B   R6, 0x19(R8)
   \   0000B8   3424         JEQ     ??zclProcessMessageMSG_13
   1600              {
   1601                if ( UNICAST_MSG( inMsg.msg ) )
   \   0000BA   1F410200     MOV.W   0x2(SP), R15
   \   0000BE   CF931500     CMP.B   #0x0, 0x15(R15)
   \   0000C2   C320         JNE     ??zclProcessMessageMSG_1
   \   0000C4   8F930200     CMP.W   #0x0, 0x2(R15)
   \   0000C8   C020         JNE     ??zclProcessMessageMSG_1
   1602                {
   1603                  // Send a Default Response command back with no Application Link Key security
   1604                  if ( securityEnable )
   \   0000CA   56B3         BIT.B   #0x1, R6
   \   0000CC   0528         JNC     ??zclProcessMessageMSG_14
   1605                  {
   1606                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   0000CE   4E43         MOV.B   #0x0, R14
   \   0000D0   2D49         MOV.W   @R9, R13
   \   0000D2   6C4B         MOV.B   @R11, R12
   \   0000D4   ........     CALLA   #zclSetSecurityOption
   1607                  }
   1608          
   1609                  defautlRspCmd.statusCode = status;
   \                     ??zclProcessMessageMSG_14:
   \   0000D8   D1430100     MOV.B   #0x1, 0x1(SP)
   1610                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   0000DC   D14109000000 MOV.B   0x9(SP), 0(SP)
   1611                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1612                                         inMsg.msg->clusterId, &defautlRspCmd,
   1613                                         ZCL_FRAME_SERVER_CLIENT_DIR, true,
   1614                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   0000E2   51120A00     PUSH.B  0xa(SP)
   \   0000E6   11120A00     PUSH.W  0xa(SP)
   \   0000EA   5312         PUSH.B  #0x1
   \   0000EC   5312         PUSH.B  #0x1
   \   0000EE   0F41         MOV.W   SP, R15
   \   0000F0   3F52         ADD.W   #0x8, R15
   \   0000F2   1E410A00     MOV.W   0xa(SP), R14
   \   0000F6   1E4E0400     MOV.W   0x4(R14), R14
   \   0000FA   1D410A00     MOV.W   0xa(SP), R13
   \   0000FE   3D500600     ADD.W   #0x6, R13
   \   000102   1A410A00     MOV.W   0xa(SP), R10
   \   000106   5C4A1400     MOV.B   0x14(R10), R12
   \   00010A   ........     CALLA   #zcl_SendDefaultRspCmd
   1615                  if ( securityEnable )
   \   00010E   3152         ADD.W   #0x8, SP
   \   000110   56B3         BIT.B   #0x1, R6
   \   000112   9B28         JNC     ??zclProcessMessageMSG_1
   1616                  {
   1617                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   000114   5E43         MOV.B   #0x1, R14
   \   000116   2D49         MOV.W   @R9, R13
   \   000118   6C4B         MOV.B   @R11, R12
   \   00011A   ........     CALLA   #zclSetSecurityOption
   1618                  }
   1619                }
   1620          
   1621                return;   // Error, ignore the message
   \   00011E   953C         JMP     ??zclProcessMessageMSG_1
   1622              }
   1623            }
   \                     ??zclProcessMessageMSG_11:
   \   000120   0E43         MOV.W   #0x0, R14
   1624          
   1625            // Is this a foundation type message
   1626            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zclProcessMessageMSG_13:
   \   000122   F1B003000400 BIT.B   #0x3, 0x4(SP)
   \   000128   5820         JNE     ??zclProcessMessageMSG_15
   1627            {
   1628              if ( inMsg.hdr.fc.manuSpecific )
   \   00012A   A1B20400     BIT.W   #0x4, 0x4(SP)
   \   00012E   0328         JNC     ??zclProcessMessageMSG_16
   1629              {
   1630                // We don't support any manufacturer specific command
   1631                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   000130   7C408400     MOV.B   #0x84, R12
   \   000134   6A3C         JMP     ??zclProcessMessageMSG_17
   1632              }
   1633              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   1634                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zclProcessMessageMSG_16:
   \   000136   5F410900     MOV.B   0x9(SP), R15
   \   00013A   7F900E00     CMP.B   #0xe, R15
   \   00013E   4A2C         JC      ??zclProcessMessageMSG_18
   \   000140   5F0A         RLAM.W  #0x3, R15
   \   000142   1E4F....     MOV.W   zclCmdTable(R15), R14
   \   000146   1EDF....     BIS.W   zclCmdTable + 2(R15), R14
   \   00014A   0E93         CMP.W   #0x0, R14
   \   00014C   4324         JEQ     ??zclProcessMessageMSG_18
   1635              {
   1636                zclParseCmd_t parseCmd;
   1637          
   1638                parseCmd.endpoint = pkt->endPoint;
   \   00014E   E14B1000     MOV.B   @R11, 0x10(SP)
   1639                parseCmd.dataLen = inMsg.pDataLen;
   \   000152   91410C001200 MOV.W   0xc(SP), 0x12(SP)
   1640                parseCmd.pData = inMsg.pData;
   \   000158   91410A001400 MOV.W   0xa(SP), 0x14(SP)
   1641          
   1642                // Parse the command, remember that the return value is a pointer to allocated memory
   1643                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \   00015E   0C41         MOV.W   SP, R12
   \   000160   3C501000     ADD.W   #0x10, R12
   \   000164   5F410900     MOV.B   0x9(SP), R15
   \   000168   5F0A         RLAM.W  #0x3, R15
   \   00016A   1E4F....     MOV.W   zclCmdTable(R15), R14
   \   00016E   1F4F....     MOV.W   zclCmdTable + 2(R15), R15
   \   000172   ........     CALLA   #?IndCallR15
   \   000176   814C0E00     MOV.W   R12, 0xe(SP)
   1644                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \   00017A   0C93         CMP.W   #0x0, R12
   \   00017C   1524         JEQ     ??zclProcessMessageMSG_19
   \   00017E   5F410900     MOV.B   0x9(SP), R15
   \   000182   5F0A         RLAM.W  #0x3, R15
   \   000184   1E4F....     MOV.W   zclCmdTable + 4(R15), R14
   \   000188   1F4F....     MOV.W   zclCmdTable + 6(R15), R15
   \   00018C   0B4E         MOV.W   R14, R11
   \   00018E   0BDF         BIS.W   R15, R11
   \   000190   0B93         CMP.W   #0x0, R11
   \   000192   0624         JEQ     ??zclProcessMessageMSG_20
   1645                {
   1646                  // Process the command
   1647                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   000194   0C4A         MOV.W   R10, R12
   \   000196   ........     CALLA   #?IndCallR15
   1648                  {
   1649                    // Couldn't find attribute in the table.
   1650                  }
   1651                }
   1652          
   1653                // Free the buffer
   1654                if ( inMsg.attrCmd )
   \   00019A   81930E00     CMP.W   #0x0, 0xe(SP)
   \   00019E   0424         JEQ     ??zclProcessMessageMSG_19
   1655                {
   1656                  osal_mem_free( inMsg.attrCmd );
   \                     ??zclProcessMessageMSG_20:
   \   0001A0   1C410E00     MOV.W   0xe(SP), R12
   \   0001A4   ........     CALLA   #osal_mem_free
   1657                }
   1658          
   1659                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zclProcessMessageMSG_19:
   \   0001A8   5E410900     MOV.B   0x9(SP), R14
   \   0001AC   4E93         CMP.B   #0x0, R14
   \   0001AE   4D24         JEQ     ??zclProcessMessageMSG_1
   \   0001B0   6E93         CMP.B   #0x2, R14
   \   0001B2   4B24         JEQ     ??zclProcessMessageMSG_1
   \   0001B4   7E900300     CMP.B   #0x3, R14
   \   0001B8   4824         JEQ     ??zclProcessMessageMSG_1
   \   0001BA   7E900600     CMP.B   #0x6, R14
   \   0001BE   4524         JEQ     ??zclProcessMessageMSG_1
   \   0001C0   7E92         CMP.B   #0x8, R14
   \   0001C2   4324         JEQ     ??zclProcessMessageMSG_1
   \   0001C4   7E900C00     CMP.B   #0xc, R14
   \   0001C8   4024         JEQ     ??zclProcessMessageMSG_1
   \   0001CA   7E900B00     CMP.B   #0xb, R14
   \   0001CE   3D24         JEQ     ??zclProcessMessageMSG_1
   1660                {
   1661                  return; // We're done
   1662                }
   1663          
   1664                status = ZSuccess;
   \   0001D0   4C43         MOV.B   #0x0, R12
   \   0001D2   1B3C         JMP     ??zclProcessMessageMSG_17
   1665              }
   1666              else
   1667              {
   1668                // Unsupported message
   1669                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zclProcessMessageMSG_18:
   \   0001D4   7C408200     MOV.B   #0x82, R12
   \   0001D8   183C         JMP     ??zclProcessMessageMSG_17
   1670              }
   1671            }
   1672            else  // Not a foundation type message, so it must be specific to the cluster ID.
   1673            {
   1674              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zclProcessMessageMSG_15:
   \   0001DA   0E93         CMP.W   #0x0, R14
   \   0001DC   1024         JEQ     ??zclProcessMessageMSG_21
   \   0001DE   0F4E         MOV.W   R14, R15
   \   0001E0   1E4F0600     MOV.W   0x6(R15), R14
   \   0001E4   1F4F0800     MOV.W   0x8(R15), R15
   \   0001E8   0B4E         MOV.W   R14, R11
   \   0001EA   0BDF         BIS.W   R15, R11
   \   0001EC   0B93         CMP.W   #0x0, R11
   \   0001EE   0724         JEQ     ??zclProcessMessageMSG_21
   1675              {
   1676                // The return value of the plugin function will be
   1677                //  ZSuccess - Supported and need default response
   1678                //  ZFailure - Unsupported
   1679                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   1680                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   1681                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   1682                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   1683                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   0001F0   0C4A         MOV.W   R10, R12
   \   0001F2   ........     CALLA   #?IndCallR15
   1684                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   0001F6   7C93         CMP.B   #0xff, R12
   \   0001F8   2824         JEQ     ??zclProcessMessageMSG_1
   1685                {
   1686                  return; // We're done
   1687                }
   1688              }
   1689          
   1690              if ( status == ZFailure )
   \   0001FA   5C93         CMP.B   #0x1, R12
   \   0001FC   0620         JNE     ??zclProcessMessageMSG_17
   1691              {
   1692                // Unsupported message
   1693                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zclProcessMessageMSG_21:
   \   0001FE   A1B20400     BIT.W   #0x4, 0x4(SP)
   \   000202   4C7C         SUBC.B  R12, R12
   \   000204   4C5C         RLA.B   R12
   \   000206   7C508300     ADD.B   #0x83, R12
   1694                {
   1695                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   1696                }
   1697                else
   1698                {
   1699                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   1700                }
   1701              }
   1702            }
   1703          
   1704            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zclProcessMessageMSG_17:
   \   00020A   1F410200     MOV.W   0x2(SP), R15
   \   00020E   CF931500     CMP.B   #0x0, 0x15(R15)
   \   000212   1B20         JNE     ??zclProcessMessageMSG_1
   \   000214   8F930200     CMP.W   #0x0, 0x2(R15)
   \   000218   1820         JNE     ??zclProcessMessageMSG_1
   \   00021A   B1B010000400 BIT.W   #0x10, 0x4(SP)
   \   000220   142C         JC      ??zclProcessMessageMSG_1
   1705            {
   1706              // Send a Default Response command back
   1707              defautlRspCmd.statusCode = status;
   \   000222   C14C0100     MOV.B   R12, 0x1(SP)
   1708              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   000226   D14109000000 MOV.B   0x9(SP), 0(SP)
   1709              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1710                                     inMsg.msg->clusterId, &defautlRspCmd,
   1711                                     ZCL_FRAME_SERVER_CLIENT_DIR, true,
   1712                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   00022C   51120A00     PUSH.B  0xa(SP)
   \   000230   11120A00     PUSH.W  0xa(SP)
   \   000234   5312         PUSH.B  #0x1
   \   000236   5312         PUSH.B  #0x1
   \   000238   0F41         MOV.W   SP, R15
   \   00023A   3F52         ADD.W   #0x8, R15
   \   00023C   1B410A00     MOV.W   0xa(SP), R11
   \   000240   ........     CALLA   #?Subroutine17
   1713            }
   \                     ??CrossCallReturnLabel_10:
   \   000244   ........     CALLA   #zcl_SendDefaultRspCmd
   \   000248   3152         ADD.W   #0x8, SP
   1714          }
   \                     ??zclProcessMessageMSG_1:
   \   00024A   31501600     ADD.W   #0x16, SP
   \   00024E   5617         POPM.W  #0x6, R11
   \   000250   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine17:
   \   000000   1E4B0400     MOV.W   0x4(R11), R14
   \   000004   0D4B         MOV.W   R11, R13
   \   000006   3D500600     ADD.W   #0x6, R13
   \   00000A   5C4B1400     MOV.B   0x14(R11), R12
   \   00000E   1001         RETA
   1715          
   1716          /*********************************************************************
   1717           * @fn      zclParseHdr
   1718           *
   1719           * @brief   Parse header of the ZCL format
   1720           *
   1721           * @param   hdr - place to put the frame control information
   1722           * @param   pData - incoming buffer to parse
   1723           *
   1724           * @return  pointer past the header
   1725           */

   \                                 In  segment CODE, align 2, keep-with-next
   1726          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   1727          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   1728            // Clear the header
   1729            osal_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   000006   3E400600     MOV.W   #0x6, R14
   \   00000A   4D43         MOV.B   #0x0, R13
   \   00000C   ........     CALLA   #osal_memset
   1730          
   1731            // Parse the Frame Control
   1732            hdr->fc.type = zcl_FCType( *pData );
   \   000010   6F4B         MOV.B   @R11, R15
   \   000012   3FF00300     AND.W   #0x3, R15
   \   000016   2E4A         MOV.W   @R10, R14
   \   000018   3EF0FCFF     AND.W   #0xfffc, R14
   \   00001C   0EDF         BIS.W   R15, R14
   \   00001E   8A4E0000     MOV.W   R14, 0(R10)
   1733            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \   000022   EBB20000     BIT.B   #0x4, 0(R11)
   \   000026   4E7E         SUBC.B  R14, R14
   \   000028   5E53         ADD.B   #0x1, R14
   \   00002A   1EB3         BIT.W   #0x1, R14
   \   00002C   032C         JC      ??zclParseHdr_0
   \   00002E   AAC20000     BIC.W   #0x4, 0(R10)
   \   000032   023C         JMP     ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000034   AAD20000     BIS.W   #0x4, 0(R10)
   1734            if ( zcl_FCDirection( *pData ) )
   \                     ??zclParseHdr_1:
   \   000038   FBB20000     BIT.B   #0x8, 0(R11)
   \   00003C   0328         JNC     ??zclParseHdr_2
   1735            {
   1736              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00003E   BAD20000     BIS.W   #0x8, 0(R10)
   \   000042   023C         JMP     ??zclParseHdr_3
   1737            }
   1738            else
   1739            {
   1740              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000044   BAC20000     BIC.W   #0x8, 0(R10)
   1741            }
   1742          
   1743            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??zclParseHdr_3:
   \   000048   FBB010000000 BIT.B   #0x10, 0(R11)
   \   00004E   4E7E         SUBC.B  R14, R14
   \   000050   5E53         ADD.B   #0x1, R14
   \   000052   1EB3         BIT.W   #0x1, R14
   \   000054   042C         JC      ??zclParseHdr_4
   \   000056   BAC010000000 BIC.W   #0x10, 0(R10)
   \   00005C   033C         JMP     ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   00005E   BAD010000000 BIS.W   #0x10, 0(R10)
   1744            pData++;  // move past the frame control field
   \                     ??zclParseHdr_5:
   \   000064   1B53         ADD.W   #0x1, R11
   1745          
   1746            // parse the manfacturer code
   1747            if ( hdr->fc.manuSpecific )
   \   000066   AAB20000     BIT.W   #0x4, 0(R10)
   \   00006A   0928         JNC     ??zclParseHdr_6
   1748            {
   1749              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   00006C   6E4B         MOV.B   @R11, R14
   \   00006E   5F4B0100     MOV.B   0x1(R11), R15
   \   000072                RPT     #0x8
   \   000072   47180F5F     RLAX.W  R15
   \   000076   0E5F         ADD.W   R15, R14
   \   000078   8A4E0200     MOV.W   R14, 0x2(R10)
   1750              pData += 2;
   \   00007C   2B53         ADD.W   #0x2, R11
   1751            }
   1752          
   1753            // parse the Transaction Sequence Number
   1754            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   00007E   FA4B0400     MOV.B   @R11+, 0x4(R10)
   1755          
   1756            // parse the Cluster's command ID
   1757            hdr->commandID = *pData++;
   \   000082   FA4B0500     MOV.B   @R11+, 0x5(R10)
   1758          
   1759            // Should point to the frame payload
   1760            return ( pData );
   \   000086   0C4B         MOV.W   R11, R12
   \   000088   1A17         POPM.W  #0x2, R11
   \   00008A   1001         RETA
   1761          }
   1762          
   1763          /*********************************************************************
   1764           * @fn      zclBuildHdr
   1765           *
   1766           * @brief   Build header of the ZCL format
   1767           *
   1768           * @param   hdr - outgoing header information
   1769           * @param   pData - outgoing header space
   1770           *
   1771           * @return  pointer past the header
   1772           */

   \                                 In  segment CODE, align 2, keep-with-next
   1773          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   1774          {
   1775            // Build the Frame Control byte
   1776            *pData = hdr->fc.type;
   \   000000   6E4C         MOV.B   @R12, R14
   \   000002   7EF00300     AND.B   #0x3, R14
   \   000006   CD4E0000     MOV.B   R14, 0(R13)
   1777            *pData |= hdr->fc.manuSpecific << 2;
   \   00000A   6E4C         MOV.B   @R12, R14
   \   00000C   6EF2         AND.B   #0x4, R14
   \   00000E   CDDE0000     BIS.B   R14, 0(R13)
   1778            *pData |= hdr->fc.direction << 3;
   \   000012   6E4C         MOV.B   @R12, R14
   \   000014   7EF2         AND.B   #0x8, R14
   \   000016   CDDE0000     BIS.B   R14, 0(R13)
   1779            *pData |= hdr->fc.disableDefaultRsp << 4;
   \   00001A   6E4C         MOV.B   @R12, R14
   \   00001C   7EF01000     AND.B   #0x10, R14
   \   000020   CDDE0000     BIS.B   R14, 0(R13)
   1780            pData++;  // move past the frame control field
   \   000024   1D53         ADD.W   #0x1, R13
   1781          
   1782            // Add the manfacturer code
   1783            if ( hdr->fc.manuSpecific )
   \   000026   ACB20000     BIT.W   #0x4, 0(R12)
   \   00002A   0828         JNC     ??zclBuildHdr_0
   1784            {
   1785              *pData++ = LO_UINT16( hdr->manuCode );
   \   00002C   DD4C02000000 MOV.B   0x2(R12), 0(R13)
   \   000032   1D53         ADD.W   #0x1, R13
   1786              *pData++ = HI_UINT16( hdr->manuCode );
   \   000034   DD4C03000000 MOV.B   0x3(R12), 0(R13)
   \   00003A   1D53         ADD.W   #0x1, R13
   1787            }
   1788          
   1789            // Add the Transaction Sequence Number
   1790            *pData++ = hdr->transSeqNum;
   \                     ??zclBuildHdr_0:
   \   00003C   DD4C04000000 MOV.B   0x4(R12), 0(R13)
   \   000042   1D53         ADD.W   #0x1, R13
   1791          
   1792            // Add the Cluster's command ID
   1793            *pData++ = hdr->commandID;
   \   000044   DD4C05000000 MOV.B   0x5(R12), 0(R13)
   \   00004A   1D53         ADD.W   #0x1, R13
   1794          
   1795            // Should point to the frame payload
   1796            return ( pData );
   \   00004C   0C4D         MOV.W   R13, R12
   \   00004E   1001         RETA
   1797          }
   1798          
   1799          /*********************************************************************
   1800           * @fn      zclCalcHdrSize
   1801           *
   1802           * @brief   Calculate the number of bytes needed for an outgoing
   1803           *          ZCL header.
   1804           *
   1805           * @param   hdr - outgoing header information
   1806           *
   1807           * @return  returns the number of bytes needed
   1808           */
   1809          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   1810          {
   1811            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   1812          
   1813            // Add the manfacturer code
   1814            if ( hdr->fc.manuSpecific )
   1815            {
   1816              needed += 2;
   1817            }
   1818          
   1819            return ( needed );
   1820          }
   1821          
   1822          /*********************************************************************
   1823           * @fn      zclFindPlugin
   1824           *
   1825           * @brief   Find the right plugin for a cluster ID
   1826           *
   1827           * @param   clusterID - cluster ID to look for
   1828           * @param   profileID - profile ID
   1829           *
   1830           * @return  pointer to plugin, NULL if not found
   1831           */
   1832          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   1833          {
   1834            (void)profileID;  // Intentionally unreferenced parameter
   1835          
   1836            zclLibPlugin_t *pLoop = plugins;
   1837          
   1838            while ( pLoop != NULL )
   1839            {
   1840              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   1841              {
   1842                return ( pLoop );
   1843              }
   1844          
   1845              pLoop = pLoop->next;
   1846            }
   1847          
   1848            return ( (zclLibPlugin_t *)NULL );
   1849          }
   1850          
   1851          /*********************************************************************
   1852           * @fn      zclFindAttrRecsList
   1853           *
   1854           * @brief   Find the right attribute record list for an endpoint
   1855           *
   1856           * @param   clusterID - endpointto look for
   1857           *
   1858           * @return  pointer to record list, NULL if not found
   1859           */

   \                                 In  segment CODE, align 2, keep-with-next
   1860          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   1861          {
   1862            zclAttrRecsList *pLoop = attrList;
   \   000000   1F42....     MOV.W   &attrList, R15
   \   000004   013C         JMP     ??zclFindAttrRecsList_1
   1863          
   1864            while ( pLoop != NULL )
   1865            {
   1866              if ( pLoop->endpoint == endpoint )
   1867              {
   1868                return ( pLoop );
   1869              }
   1870          
   1871              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_0:
   \   000006   2F4F         MOV.W   @R15, R15
   \                     ??zclFindAttrRecsList_1:
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   0524         JEQ     ??zclFindAttrRecsList_2
   \   00000C   CF9C0200     CMP.B   R12, 0x2(R15)
   \   000010   FA23         JNE     ??zclFindAttrRecsList_0
   \   000012   0C4F         MOV.W   R15, R12
   \   000014   1001         RETA
   1872            }
   1873          
   1874            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   000016   0C43         MOV.W   #0x0, R12
   \   000018   1001         RETA
   1875          }
   1876          
   1877          /*********************************************************************
   1878           * @fn      zclFindAttrRec
   1879           *
   1880           * @brief   Find the attribute record that matchs the parameters
   1881           *
   1882           * @param   endpoint - Application's endpoint
   1883           * @param   clusterID - cluster ID
   1884           * @param   attrId - attribute looking for
   1885           * @param   pAttr - attribute record to be returned
   1886           *
   1887           * @return  TRUE if record found. FALSE, otherwise.
   1888           */

   \                                 In  segment CODE, align 2, keep-with-next
   1889          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   1890          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4D         MOV.W   R13, R10
   \   000004   0B4E         MOV.W   R14, R11
   \   000006   084F         MOV.W   R15, R8
   1891            uint8 x;
   1892            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000008   ........     CALLA   #zclFindAttrRecsList
   1893          
   1894            if ( pRec != NULL )
   \   00000C   0C93         CMP.W   #0x0, R12
   \   00000E   1B24         JEQ     ??zclFindAttrRec_1
   1895            {
   1896              for ( x = 0; x < pRec->numAttributes; x++ )
   \   000010   4E43         MOV.B   #0x0, R14
   \   000012   013C         JMP     ??zclFindAttrRec_2
   \                     ??zclFindAttrRec_0:
   \   000014   5E53         ADD.B   #0x1, R14
   \                     ??zclFindAttrRec_2:
   \   000016   5E9C0C00     CMP.B   0xc(R12), R14
   \   00001A   152C         JC      ??zclFindAttrRec_1
   1897              {
   1898                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   00001C   1F4C0E00     MOV.W   0xe(R12), R15
   \   000020   4D4E         MOV.B   R14, R13
   \   000022   5D0A         RLAM.W  #0x3, R13
   \   000024   0F5D         ADD.W   R13, R15
   \   000026   8F9A0000     CMP.W   R10, 0(R15)
   \   00002A   F423         JNE     ??zclFindAttrRec_0
   \   00002C   8F9B0200     CMP.W   R11, 0x2(R15)
   \   000030   F123         JNE     ??zclFindAttrRec_0
   1899                {
   1900                  *pAttr = pRec->attrs[x];
   \   000032   B84F0000     MOV.W   @R15+, 0(R8)
   \   000036   B84F0200     MOV.W   @R15+, 0x2(R8)
   \   00003A   B84F0400     MOV.W   @R15+, 0x4(R8)
   \   00003E   B84F0600     MOV.W   @R15+, 0x6(R8)
   1901          
   1902                  return ( TRUE ); // EMBEDDED RETURN
   \   000042   5C43         MOV.B   #0x1, R12
   \   000044   013C         JMP     ??zclFindAttrRec_3
   1903                }
   1904              }
   1905            }
   1906          
   1907            return ( FALSE );
   \                     ??zclFindAttrRec_1:
   \   000046   4C43         MOV.B   #0x0, R12
   \                     ??zclFindAttrRec_3:
   \   000048   3817         POPM.W  #0x4, R11
   \   00004A   1001         RETA
   1908          }
   1909          
   1910          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   1911          /*********************************************************************
   1912           * @fn      zclGetReadWriteCB
   1913           *
   1914           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   1915           *
   1916           * @param   endpoint - Application's endpoint
   1917           *
   1918           * @return  Read/Write CB, NULL if not found
   1919           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   0C43         MOV.W   #0x0, R12
   \   000002   0D43         MOV.W   #0x0, R13
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1920          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   1921          {
   1922            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000000   ........     CALLA   #zclFindAttrRecsList
   1923          
   1924            if ( pRec != NULL )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0624         JEQ     ??zclGetReadWriteCB_0
   1925            {
   1926              return ( pRec->pfnReadWriteCB );
   \   000008   0D4C         MOV.W   R12, R13
   \   00000A   1C4D0400     MOV.W   0x4(R13), R12
   \   00000E   1D4D0600     MOV.W   0x6(R13), R13
   \   000012   1001         RETA
   1927            }
   1928          
   1929            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000014   ....         JMP     ?Subroutine3
   1930          }
   1931          
   1932          /*********************************************************************
   1933           * @fn      zclGetAuthorizeCB
   1934           *
   1935           * @brief   Get the Read/Write Authorization callback function pointer
   1936           *          for a given endpoint.
   1937           *
   1938           * @param   endpoint - Application's endpoint
   1939           *
   1940           * @return  Authorization CB, NULL if not found
   1941           */

   \                                 In  segment CODE, align 2, keep-with-next
   1942          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   1943          {
   1944            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000000   ........     CALLA   #zclFindAttrRecsList
   1945          
   1946            if ( pRec != NULL )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0624         JEQ     ??zclGetAuthorizeCB_0
   1947            {
   1948              return ( pRec->pfnAuthorizeCB );
   \   000008   0D4C         MOV.W   R12, R13
   \   00000A   1C4D0800     MOV.W   0x8(R13), R12
   \   00000E   1D4D0A00     MOV.W   0xa(R13), R13
   \   000012   1001         RETA
   1949            }
   1950          
   1951            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000014                REQUIRE ?Subroutine3
   \   000014                // Fall through to label ?Subroutine3
   1952          }
   1953          #endif // ZCL_READ || ZCL_WRITE
   1954          
   1955          /*********************************************************************
   1956           * @fn      zclFindClusterOption
   1957           *
   1958           * @brief   Find the option record that matchs the cluster id
   1959           *
   1960           * @param   endpoint - Application's endpoint
   1961           * @param   clusterID - cluster ID looking for
   1962           *
   1963           * @return  pointer to clutser option, NULL if not found
   1964           */

   \                                 In  segment CODE, align 2, keep-with-next
   1965          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   1966          {
   \   000000   1B15         PUSHM.W #0x2, R11
   1967            zclClusterOptionList *pLoop;
   1968          
   1969            pLoop = clusterOptionList;
   \   000002   1A42....     MOV.W   &clusterOptionList, R10
   \   000006   013C         JMP     ??zclFindClusterOption_2
   1970            while ( pLoop != NULL )
   1971            {
   1972              if ( pLoop->endpoint == endpoint )
   1973              {
   1974                for ( uint8 x = 0; x < pLoop->numOptions; x++ )
   1975                {
   1976                  if ( pLoop->options[x].clusterID == clusterID )
   1977                  {
   1978                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   1979                  }
   1980                }
   1981              }
   1982          
   1983              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_0:
   \   000008   2A4A         MOV.W   @R10, R10
   \                     ??zclFindClusterOption_2:
   \   00000A   0A93         CMP.W   #0x0, R10
   \   00000C   1324         JEQ     ??zclFindClusterOption_3
   \   00000E   CA9C0200     CMP.B   R12, 0x2(R10)
   \   000012   FA23         JNE     ??zclFindClusterOption_0
   \   000014   4E43         MOV.B   #0x0, R14
   \   000016   013C         JMP     ??zclFindClusterOption_4
   \                     ??zclFindClusterOption_1:
   \   000018   5E53         ADD.B   #0x1, R14
   \                     ??zclFindClusterOption_4:
   \   00001A   5E9A0300     CMP.B   0x3(R10), R14
   \   00001E   F42F         JC      ??zclFindClusterOption_0
   \   000020   1F4A0400     MOV.W   0x4(R10), R15
   \   000024   4B4E         MOV.B   R14, R11
   \   000026   5B06         RLAM.W  #0x2, R11
   \   000028   0F5B         ADD.W   R11, R15
   \   00002A   8F9D0000     CMP.W   R13, 0(R15)
   \   00002E   F423         JNE     ??zclFindClusterOption_1
   \   000030   0C4F         MOV.W   R15, R12
   \   000032   013C         JMP     ??zclFindClusterOption_5
   1984            }
   1985          
   1986            return ( NULL );
   \                     ??zclFindClusterOption_3:
   \   000034   0C43         MOV.W   #0x0, R12
   \                     ??zclFindClusterOption_5:
   \   000036   1A17         POPM.W  #0x2, R11
   \   000038   1001         RETA
   1987          }
   1988          
   1989          /*********************************************************************
   1990           * @fn      zclGetClusterOption
   1991           *
   1992           * @brief   Get the option record that matchs the cluster id
   1993           *
   1994           * @param   endpoint - Application's endpoint
   1995           * @param   clusterID - cluster ID looking for
   1996           *
   1997           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   1998           */

   \                                 In  segment CODE, align 2, keep-with-next
   1999          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2000          {
   2001            uint8 option;
   2002            zclOptionRec_t *pOption;
   2003          
   2004            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000000   ........     CALLA   #zclFindClusterOption
   2005            if ( pOption != NULL )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0524         JEQ     ??zclGetClusterOption_0
   2006            {
   2007              option = pOption->option;
   2008              if ( !ZG_SECURE_ENABLED )
   2009              {
   2010                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2011              }
   2012          
   2013              return ( option ); // EMBEDDED RETURN
   \   000008   5C4C0200     MOV.B   0x2(R12), R12
   \   00000C   7CF0BF00     AND.B   #0xbf, R12
   \   000010   1001         RETA
   2014            }
   2015          
   2016            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   000012   4C43         MOV.B   #0x0, R12
   \   000014   1001         RETA
   2017          }
   2018          
   2019          /*********************************************************************
   2020           * @fn      zclSetSecurityOption
   2021           *
   2022           * @brief   Set the security option for the cluster id
   2023           *
   2024           * @param   endpoint - Application's endpoint
   2025           * @param   clusterID - cluster ID looking for
   2026           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2027           *
   2028           * @return  none
   2029           */

   \                                 In  segment CODE, align 2, keep-with-next
   2030          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2031          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4E         MOV.B   R14, R10
   2032            zclOptionRec_t *pOption;
   2033          
   2034            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000004   ........     CALLA   #zclFindClusterOption
   2035            if ( pOption != NULL )
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0924         JEQ     ??zclSetSecurityOption_0
   2036            {
   2037              if ( enable )
   \   00000C   4A93         CMP.B   #0x0, R10
   \   00000E   0424         JEQ     ??zclSetSecurityOption_1
   2038              {
   2039                pOption->option |= AF_EN_SECURITY;
   \   000010   FCD040000200 BIS.B   #0x40, 0x2(R12)
   \   000016   033C         JMP     ??zclSetSecurityOption_0
   2040              }
   2041              else
   2042              {
   2043                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   000018   FCC040000200 BIC.B   #0x40, 0x2(R12)
   2044              }
   2045            }
   2046          }
   \                     ??zclSetSecurityOption_0:
   \   00001E   3A41         POP.W   R10
   \   000020   1001         RETA
   2047          
   2048          #ifdef ZCL_DISCOVER
   2049          /*********************************************************************
   2050           * @fn      zclFindNextAttrRec
   2051           *
   2052           * @brief   Find the attribute (or next) record that matchs the parameters
   2053           *
   2054           * @param   endpoint - Application's endpoint
   2055           * @param   clusterID - cluster ID
   2056           * @param   attr - attribute looking for
   2057           *
   2058           * @return  pointer to attribute record, NULL if not found
   2059           */
   2060          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID,
   2061                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2062          {
   2063            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2064          
   2065            if ( pRec != NULL )
   2066            {
   2067              for ( uint16 x = 0; x < pRec->numAttributes; x++ )
   2068              {
   2069                if ( ( pRec->attrs[x].clusterID == clusterID ) &&
   2070                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2071                {
   2072                  *pAttr = pRec->attrs[x];
   2073          
   2074                  // Update attribute ID
   2075                  *attrId = pAttr->attr.attrId;
   2076          
   2077                  return ( TRUE ); // EMBEDDED RETURN
   2078                }
   2079              }
   2080            }
   2081          
   2082            return ( FALSE );
   2083          }
   2084          #endif // ZCL_DISCOVER
   2085          
   2086          /*********************************************************************
   2087           * @fn      zclSerializeData
   2088           *
   2089           * @brief   Builds a buffer from the attribute data to sent out over
   2090           *          the air.
   2091           *
   2092           * @param   dataType - data types defined in zcl.h
   2093           * @param   attrData - pointer to the attribute data
   2094           * @param   buf - where to put the serialized data
   2095           *
   2096           * @return  pointer to end of destination buffer
   2097           */

   \                                 In  segment CODE, align 2, keep-with-next
   2098          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2099          {
   \   000000   4F4C         MOV.B   R12, R15
   \   000002   0C4E         MOV.W   R14, R12
   2100            uint8 *pStr;
   2101            uint16 len;
   2102          
   2103            switch ( dataType )
   \   000004   7F82         SUB.B   #0x8, R15
   \   000006   4D24         JEQ     ??zclSerializeData_0
   \   000008   5F83         SUB.B   #0x1, R15
   \   00000A   4F24         JEQ     ??zclSerializeData_1
   \   00000C   5F83         SUB.B   #0x1, R15
   \   00000E   4F24         JEQ     ??zclSerializeData_2
   \   000010   5F83         SUB.B   #0x1, R15
   \   000012   5524         JEQ     ??zclSerializeData_3
   \   000014   7F800500     SUB.B   #0x5, R15
   \   000018   4424         JEQ     ??zclSerializeData_0
   \   00001A   7F82         SUB.B   #0x8, R15
   \   00001C   4224         JEQ     ??zclSerializeData_0
   \   00001E   5F83         SUB.B   #0x1, R15
   \   000020   4424         JEQ     ??zclSerializeData_1
   \   000022   5F83         SUB.B   #0x1, R15
   \   000024   4424         JEQ     ??zclSerializeData_2
   \   000026   5F83         SUB.B   #0x1, R15
   \   000028   4A24         JEQ     ??zclSerializeData_3
   \   00002A   7F800500     SUB.B   #0x5, R15
   \   00002E   3924         JEQ     ??zclSerializeData_0
   \   000030   5F83         SUB.B   #0x1, R15
   \   000032   3B24         JEQ     ??zclSerializeData_1
   \   000034   5F83         SUB.B   #0x1, R15
   \   000036   3B24         JEQ     ??zclSerializeData_2
   \   000038   5F83         SUB.B   #0x1, R15
   \   00003A   4124         JEQ     ??zclSerializeData_3
   \   00003C   5F83         SUB.B   #0x1, R15
   \   00003E   4324         JEQ     ??zclSerializeData_4
   \   000040   5F83         SUB.B   #0x1, R15
   \   000042   4524         JEQ     ??zclSerializeData_5
   \   000044   7F800300     SUB.B   #0x3, R15
   \   000048   2C24         JEQ     ??zclSerializeData_0
   \   00004A   5F83         SUB.B   #0x1, R15
   \   00004C   2E24         JEQ     ??zclSerializeData_1
   \   00004E   5F83         SUB.B   #0x1, R15
   \   000050   2E24         JEQ     ??zclSerializeData_2
   \   000052   5F83         SUB.B   #0x1, R15
   \   000054   3424         JEQ     ??zclSerializeData_3
   \   000056   7F800500     SUB.B   #0x5, R15
   \   00005A   2324         JEQ     ??zclSerializeData_0
   \   00005C   5F83         SUB.B   #0x1, R15
   \   00005E   2524         JEQ     ??zclSerializeData_1
   \   000060   7F800700     SUB.B   #0x7, R15
   \   000064   2224         JEQ     ??zclSerializeData_1
   \   000066   5F83         SUB.B   #0x1, R15
   \   000068   2A24         JEQ     ??zclSerializeData_3
   \   00006A   7F82         SUB.B   #0x8, R15
   \   00006C   3724         JEQ     ??zclSerializeData_6
   \   00006E   5F83         SUB.B   #0x1, R15
   \   000070   3524         JEQ     ??zclSerializeData_6
   \   000072   5F83         SUB.B   #0x1, R15
   \   000074   3724         JEQ     ??zclSerializeData_7
   \   000076   5F83         SUB.B   #0x1, R15
   \   000078   3524         JEQ     ??zclSerializeData_7
   \   00007A   7F809C00     SUB.B   #0x9c, R15
   \   00007E   1F24         JEQ     ??zclSerializeData_3
   \   000080   5F83         SUB.B   #0x1, R15
   \   000082   1D24         JEQ     ??zclSerializeData_3
   \   000084   5F83         SUB.B   #0x1, R15
   \   000086   1B24         JEQ     ??zclSerializeData_3
   \   000088   7F800600     SUB.B   #0x6, R15
   \   00008C   0E24         JEQ     ??zclSerializeData_1
   \   00008E   5F83         SUB.B   #0x1, R15
   \   000090   0C24         JEQ     ??zclSerializeData_1
   \   000092   5F83         SUB.B   #0x1, R15
   \   000094   1424         JEQ     ??zclSerializeData_3
   \   000096   7F800600     SUB.B   #0x6, R15
   \   00009A   1D24         JEQ     ??zclSerializeData_8
   \   00009C   5F83         SUB.B   #0x1, R15
   \   00009E   2B24         JEQ     ??zclSerializeData_9
   \   0000A0   1001         RETA
   2104            {
   2105              case ZCL_DATATYPE_DATA8:
   2106              case ZCL_DATATYPE_BOOLEAN:
   2107              case ZCL_DATATYPE_BITMAP8:
   2108              case ZCL_DATATYPE_INT8:
   2109              case ZCL_DATATYPE_UINT8:
   2110              case ZCL_DATATYPE_ENUM8:
   2111                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_0:
   \   0000A2   EE4D0000     MOV.B   @R13, 0(R14)
   \   0000A6   1C53         ADD.W   #0x1, R12
   2112                 break;
   \   0000A8   1001         RETA
   2113          
   2114              case ZCL_DATATYPE_DATA16:
   2115              case ZCL_DATATYPE_BITMAP16:
   2116              case ZCL_DATATYPE_UINT16:
   2117              case ZCL_DATATYPE_INT16:
   2118              case ZCL_DATATYPE_ENUM16:
   2119              case ZCL_DATATYPE_SEMI_PREC:
   2120              case ZCL_DATATYPE_CLUSTER_ID:
   2121              case ZCL_DATATYPE_ATTR_ID:
   2122                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_1:
   \   0000AA   ........     BRA     #?Subroutine21
   2123                *buf++ = HI_UINT16( *((uint16*)attrData) );
   2124                break;
   2125          
   2126              case ZCL_DATATYPE_DATA24:
   2127              case ZCL_DATATYPE_BITMAP24:
   2128              case ZCL_DATATYPE_UINT24:
   2129              case ZCL_DATATYPE_INT24:
   2130                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_2:
   \   0000AE   ........     CALLA   #?Subroutine21
   2131                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   2132                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_17:
   \   0000B2   3E4D         MOV.W   @R13+, R14
   \   0000B4   3F4D         MOV.W   @R13+, R15
   \   0000B6   CC4F0000     MOV.B   R15, 0(R12)
   \   0000BA   1C53         ADD.W   #0x1, R12
   2133                break;
   \   0000BC   1001         RETA
   2134          
   2135              case ZCL_DATATYPE_DATA32:
   2136              case ZCL_DATATYPE_BITMAP32:
   2137              case ZCL_DATATYPE_UINT32:
   2138              case ZCL_DATATYPE_INT32:
   2139              case ZCL_DATATYPE_SINGLE_PREC:
   2140              case ZCL_DATATYPE_TOD:
   2141              case ZCL_DATATYPE_DATE:
   2142              case ZCL_DATATYPE_UTC:
   2143              case ZCL_DATATYPE_BAC_OID:
   2144                buf = osal_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   0000BE   3E4D         MOV.W   @R13+, R14
   \   0000C0   3F4D         MOV.W   @R13+, R15
   \   0000C2   ........     BRA     #osal_buffer_uint32
   2145                break;
   2146          
   2147              case ZCL_DATATYPE_UINT40:
   2148                pStr = (uint8*)attrData;
   2149                buf = osal_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_4:
   \   0000C6   3E400500     MOV.W   #0x5, R14
   \   0000CA   ........     BRA     #osal_memcpy
   2150                break;
   2151          
   2152              case ZCL_DATATYPE_UINT48:
   2153                pStr = (uint8*)attrData;
   2154                buf = osal_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_5:
   \   0000CE   3E400600     MOV.W   #0x6, R14
   \   0000D2   ........     BRA     #osal_memcpy
   2155                break;
   2156          
   2157              case ZCL_DATATYPE_IEEE_ADDR:
   2158                pStr = (uint8*)attrData;
   2159                buf = osal_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_8:
   \   0000D6   3E42         MOV.W   #0x8, R14
   \   0000D8   ........     BRA     #osal_memcpy
   2160                break;
   2161          
   2162              case ZCL_DATATYPE_CHAR_STR:
   2163              case ZCL_DATATYPE_OCTET_STR:
   2164                pStr = (uint8*)attrData;
   2165                len = *pStr;
   2166                buf = osal_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_6:
   \   0000DC   6E4D         MOV.B   @R13, R14
   \   0000DE   1E53         ADD.W   #0x1, R14
   \   0000E0   ........     BRA     #osal_memcpy
   2167                break;
   2168          
   2169              case ZCL_DATATYPE_LONG_CHAR_STR:
   2170              case ZCL_DATATYPE_LONG_OCTET_STR:
   2171                pStr = (uint8*)attrData;
   2172                len = BUILD_UINT16( pStr[0], pStr[1] );
   2173                buf = osal_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_7:
   \   0000E4   6E4D         MOV.B   @R13, R14
   \   0000E6   5F4D0100     MOV.B   0x1(R13), R15
   \   0000EA                RPT     #0x8
   \   0000EA   47180F5F     RLAX.W  R15
   \   0000EE   0E5F         ADD.W   R15, R14
   \   0000F0   2E53         ADD.W   #0x2, R14
   \   0000F2   ........     BRA     #osal_memcpy
   2174                break;
   2175          
   2176              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2177                pStr = (uint8*)attrData;
   2178                buf = osal_memcpy( buf, pStr, SEC_KEY_LEN );
   \                     ??zclSerializeData_9:
   \   0000F6   3E401000     MOV.W   #0x10, R14
   \   0000FA   ........     BRA     #osal_memcpy
   2179                break;
   2180          
   2181              case ZCL_DATATYPE_NO_DATA:
   2182              case ZCL_DATATYPE_UNKNOWN:
   2183                // Fall through
   2184          
   2185              default:
   2186                break;
   2187            }
   2188          
   2189            return ( buf );
   2190          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine21:
   \   000000   EE4D0000     MOV.B   @R13, 0(R14)
   \   000004   1C53         ADD.W   #0x1, R12
   \   000006   DC4D01000000 MOV.B   0x1(R13), 0(R12)
   \   00000C   1C53         ADD.W   #0x1, R12
   \   00000E   1001         RETA
   2191          
   2192          #ifdef ZCL_REPORT
   2193          /*********************************************************************
   2194           * @fn      zclAnalogDataType
   2195           *
   2196           * @brief   Checks to see if Data Type is Analog
   2197           *
   2198           * @param   dataType - data type
   2199           *
   2200           * @return  TRUE if data type is analog
   2201           */
   2202          uint8 zclAnalogDataType( uint8 dataType )
   2203          {
   2204            uint8 analog;
   2205          
   2206            switch ( dataType )
   2207            {
   2208              case ZCL_DATATYPE_UINT8:
   2209              case ZCL_DATATYPE_UINT16:
   2210              case ZCL_DATATYPE_UINT24:
   2211              case ZCL_DATATYPE_UINT32:
   2212              case ZCL_DATATYPE_UINT40:
   2213              case ZCL_DATATYPE_UINT48:
   2214              case ZCL_DATATYPE_UINT56:
   2215              case ZCL_DATATYPE_UINT64:
   2216              case ZCL_DATATYPE_INT8:
   2217              case ZCL_DATATYPE_INT16:
   2218              case ZCL_DATATYPE_INT24:
   2219              case ZCL_DATATYPE_INT32:
   2220              case ZCL_DATATYPE_INT40:
   2221              case ZCL_DATATYPE_INT48:
   2222              case ZCL_DATATYPE_INT56:
   2223              case ZCL_DATATYPE_INT64:
   2224              case ZCL_DATATYPE_SEMI_PREC:
   2225              case ZCL_DATATYPE_SINGLE_PREC:
   2226              case ZCL_DATATYPE_DOUBLE_PREC:
   2227              case ZCL_DATATYPE_TOD:
   2228              case ZCL_DATATYPE_DATE:
   2229              case ZCL_DATATYPE_UTC:
   2230                analog = TRUE;
   2231                break;
   2232          
   2233              default:
   2234                analog = FALSE;
   2235                break;
   2236            }
   2237          
   2238            return ( analog );
   2239          }
   2240          
   2241          /*********************************************************************
   2242           * @fn      zcl_BuildAnalogData
   2243           *
   2244           * @brief   Build an analog arribute out of sequential bytes.
   2245           *
   2246           * @param   dataType - type of data
   2247           * @param   pData - pointer to data
   2248           * @param   pBuf - where to put the data
   2249           *
   2250           * @return  none
   2251           */
   2252          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf)
   2253          {
   2254            switch ( dataType )
   2255            {
   2256              case ZCL_DATATYPE_UINT8:
   2257              case ZCL_DATATYPE_INT8:
   2258                *pData = *pBuf;
   2259                break;
   2260          
   2261              case ZCL_DATATYPE_UINT16:
   2262              case ZCL_DATATYPE_INT16:
   2263              case ZCL_DATATYPE_SEMI_PREC:
   2264                *((uint16*)pData) = BUILD_UINT16( pBuf[0], pBuf[1] );
   2265                break;
   2266          
   2267              case ZCL_DATATYPE_UINT24:
   2268              case ZCL_DATATYPE_INT24:
   2269                *((uint32*)pData) = osal_build_uint32( pBuf, 3 );
   2270                break;
   2271          
   2272              case ZCL_DATATYPE_UINT32:
   2273              case ZCL_DATATYPE_INT32:
   2274              case ZCL_DATATYPE_SINGLE_PREC:
   2275              case ZCL_DATATYPE_TOD:
   2276              case ZCL_DATATYPE_DATE:
   2277              case ZCL_DATATYPE_UTC:
   2278                *((uint32*)pData) = osal_build_uint32( pBuf, 4 );
   2279                break;
   2280          
   2281              case ZCL_DATATYPE_UINT40:
   2282              case ZCL_DATATYPE_UINT48:
   2283              case ZCL_DATATYPE_UINT56:
   2284              case ZCL_DATATYPE_UINT64:
   2285              case ZCL_DATATYPE_INT40:
   2286              case ZCL_DATATYPE_INT48:
   2287              case ZCL_DATATYPE_INT56:
   2288              case ZCL_DATATYPE_INT64:
   2289              case ZCL_DATATYPE_DOUBLE_PREC:
   2290                *pData = 0;
   2291                break;
   2292          
   2293              default:
   2294                *pData = 0;
   2295                break;
   2296            }
   2297          }
   2298          #endif // ZCL_REPORT
   2299          
   2300          /*********************************************************************
   2301           * @fn      zclGetDataTypeLength
   2302           *
   2303           * @brief   Return the length of the datatype in octet.
   2304           *
   2305           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or
   2306           *                ZCL_DATATYPE_CHAR_STR data types.
   2307           *
   2308           * @param   dataType - data type
   2309           *
   2310           * @return  length of data
   2311           */

   \                                 In  segment CODE, align 2, keep-with-next
   2312          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   2313          {
   2314            uint8 len;
   2315          
   2316            switch ( dataType )
   \   000000   7C82         SUB.B   #0x8, R12
   \   000002   5124         JEQ     ??zclGetDataTypeLength_0
   \   000004   5C83         SUB.B   #0x1, R12
   \   000006   5124         JEQ     ??zclGetDataTypeLength_1
   \   000008   5C83         SUB.B   #0x1, R12
   \   00000A   5124         JEQ     ??zclGetDataTypeLength_2
   \   00000C   5C83         SUB.B   #0x1, R12
   \   00000E   5224         JEQ     ??zclGetDataTypeLength_3
   \   000010   7C800500     SUB.B   #0x5, R12
   \   000014   4824         JEQ     ??zclGetDataTypeLength_0
   \   000016   7C82         SUB.B   #0x8, R12
   \   000018   4624         JEQ     ??zclGetDataTypeLength_0
   \   00001A   5C83         SUB.B   #0x1, R12
   \   00001C   4624         JEQ     ??zclGetDataTypeLength_1
   \   00001E   5C83         SUB.B   #0x1, R12
   \   000020   4624         JEQ     ??zclGetDataTypeLength_2
   \   000022   5C83         SUB.B   #0x1, R12
   \   000024   4724         JEQ     ??zclGetDataTypeLength_3
   \   000026   7C800500     SUB.B   #0x5, R12
   \   00002A   3D24         JEQ     ??zclGetDataTypeLength_0
   \   00002C   5C83         SUB.B   #0x1, R12
   \   00002E   3D24         JEQ     ??zclGetDataTypeLength_1
   \   000030   5C83         SUB.B   #0x1, R12
   \   000032   3D24         JEQ     ??zclGetDataTypeLength_2
   \   000034   5C83         SUB.B   #0x1, R12
   \   000036   3E24         JEQ     ??zclGetDataTypeLength_3
   \   000038   5C83         SUB.B   #0x1, R12
   \   00003A   3E24         JEQ     ??zclGetDataTypeLength_4
   \   00003C   5C83         SUB.B   #0x1, R12
   \   00003E   3F24         JEQ     ??zclGetDataTypeLength_5
   \   000040   5C83         SUB.B   #0x1, R12
   \   000042   4024         JEQ     ??zclGetDataTypeLength_6
   \   000044   5C83         SUB.B   #0x1, R12
   \   000046   4124         JEQ     ??zclGetDataTypeLength_7
   \   000048   5C83         SUB.B   #0x1, R12
   \   00004A   2D24         JEQ     ??zclGetDataTypeLength_0
   \   00004C   5C83         SUB.B   #0x1, R12
   \   00004E   2D24         JEQ     ??zclGetDataTypeLength_1
   \   000050   5C83         SUB.B   #0x1, R12
   \   000052   2D24         JEQ     ??zclGetDataTypeLength_2
   \   000054   5C83         SUB.B   #0x1, R12
   \   000056   2E24         JEQ     ??zclGetDataTypeLength_3
   \   000058   5C83         SUB.B   #0x1, R12
   \   00005A   2E24         JEQ     ??zclGetDataTypeLength_4
   \   00005C   5C83         SUB.B   #0x1, R12
   \   00005E   2F24         JEQ     ??zclGetDataTypeLength_5
   \   000060   5C83         SUB.B   #0x1, R12
   \   000062   3024         JEQ     ??zclGetDataTypeLength_6
   \   000064   5C83         SUB.B   #0x1, R12
   \   000066   3124         JEQ     ??zclGetDataTypeLength_7
   \   000068   5C83         SUB.B   #0x1, R12
   \   00006A   1D24         JEQ     ??zclGetDataTypeLength_0
   \   00006C   5C83         SUB.B   #0x1, R12
   \   00006E   1D24         JEQ     ??zclGetDataTypeLength_1
   \   000070   7C800700     SUB.B   #0x7, R12
   \   000074   1A24         JEQ     ??zclGetDataTypeLength_1
   \   000076   5C83         SUB.B   #0x1, R12
   \   000078   1D24         JEQ     ??zclGetDataTypeLength_3
   \   00007A   5C83         SUB.B   #0x1, R12
   \   00007C   2624         JEQ     ??zclGetDataTypeLength_7
   \   00007E   7C80A600     SUB.B   #0xa6, R12
   \   000082   1824         JEQ     ??zclGetDataTypeLength_3
   \   000084   5C83         SUB.B   #0x1, R12
   \   000086   1624         JEQ     ??zclGetDataTypeLength_3
   \   000088   5C83         SUB.B   #0x1, R12
   \   00008A   1424         JEQ     ??zclGetDataTypeLength_3
   \   00008C   7C800600     SUB.B   #0x6, R12
   \   000090   0C24         JEQ     ??zclGetDataTypeLength_1
   \   000092   5C83         SUB.B   #0x1, R12
   \   000094   0A24         JEQ     ??zclGetDataTypeLength_1
   \   000096   5C83         SUB.B   #0x1, R12
   \   000098   0D24         JEQ     ??zclGetDataTypeLength_3
   \   00009A   7C800600     SUB.B   #0x6, R12
   \   00009E   1524         JEQ     ??zclGetDataTypeLength_7
   \   0000A0   5C83         SUB.B   #0x1, R12
   \   0000A2   1524         JEQ     ??zclGetDataTypeLength_8
   \   0000A4   173C         JMP     ??zclGetDataTypeLength_9
   2317            {
   2318              case ZCL_DATATYPE_DATA8:
   2319              case ZCL_DATATYPE_BOOLEAN:
   2320              case ZCL_DATATYPE_BITMAP8:
   2321              case ZCL_DATATYPE_INT8:
   2322              case ZCL_DATATYPE_UINT8:
   2323              case ZCL_DATATYPE_ENUM8:
   2324                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   0000A6   5C43         MOV.B   #0x1, R12
   2325                break;
   \   0000A8   1001         RETA
   2326          
   2327              case ZCL_DATATYPE_DATA16:
   2328              case ZCL_DATATYPE_BITMAP16:
   2329              case ZCL_DATATYPE_UINT16:
   2330              case ZCL_DATATYPE_INT16:
   2331              case ZCL_DATATYPE_ENUM16:
   2332              case ZCL_DATATYPE_SEMI_PREC:
   2333              case ZCL_DATATYPE_CLUSTER_ID:
   2334              case ZCL_DATATYPE_ATTR_ID:
   2335                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   0000AA   6C43         MOV.B   #0x2, R12
   2336                break;
   \   0000AC   1001         RETA
   2337          
   2338              case ZCL_DATATYPE_DATA24:
   2339              case ZCL_DATATYPE_BITMAP24:
   2340              case ZCL_DATATYPE_UINT24:
   2341              case ZCL_DATATYPE_INT24:
   2342                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   0000AE   7C400300     MOV.B   #0x3, R12
   2343                break;
   \   0000B2   1001         RETA
   2344          
   2345              case ZCL_DATATYPE_DATA32:
   2346              case ZCL_DATATYPE_BITMAP32:
   2347              case ZCL_DATATYPE_UINT32:
   2348              case ZCL_DATATYPE_INT32:
   2349              case ZCL_DATATYPE_SINGLE_PREC:
   2350              case ZCL_DATATYPE_TOD:
   2351              case ZCL_DATATYPE_DATE:
   2352              case ZCL_DATATYPE_UTC:
   2353              case ZCL_DATATYPE_BAC_OID:
   2354                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   0000B4   6C42         MOV.B   #0x4, R12
   2355                break;
   \   0000B6   1001         RETA
   2356          
   2357             case ZCL_DATATYPE_UINT40:
   2358             case ZCL_DATATYPE_INT40:
   2359                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   0000B8   7C400500     MOV.B   #0x5, R12
   2360                 break;
   \   0000BC   1001         RETA
   2361          
   2362             case ZCL_DATATYPE_UINT48:
   2363             case ZCL_DATATYPE_INT48:
   2364                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   0000BE   7C400600     MOV.B   #0x6, R12
   2365                 break;
   \   0000C2   1001         RETA
   2366          
   2367             case ZCL_DATATYPE_UINT56:
   2368             case ZCL_DATATYPE_INT56:
   2369                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   0000C4   7C400700     MOV.B   #0x7, R12
   2370                 break;
   \   0000C8   1001         RETA
   2371          
   2372             case ZCL_DATATYPE_DOUBLE_PREC:
   2373             case ZCL_DATATYPE_IEEE_ADDR:
   2374             case ZCL_DATATYPE_UINT64:
   2375             case ZCL_DATATYPE_INT64:
   2376               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   0000CA   7C42         MOV.B   #0x8, R12
   2377               break;
   \   0000CC   1001         RETA
   2378          
   2379              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2380               len = SEC_KEY_LEN;
   \                     ??zclGetDataTypeLength_8:
   \   0000CE   7C401000     MOV.B   #0x10, R12
   2381               break;
   \   0000D2   1001         RETA
   2382          
   2383              case ZCL_DATATYPE_NO_DATA:
   2384              case ZCL_DATATYPE_UNKNOWN:
   2385                // Fall through
   2386          
   2387              default:
   2388                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000D4   4C43         MOV.B   #0x0, R12
   2389                break;
   2390            }
   2391          
   2392            return ( len );
   \   0000D6   1001         RETA
   2393          }
   2394          
   2395          /*********************************************************************
   2396           * @fn      zclGetAttrDataLength
   2397           *
   2398           * @brief   Return the length of the attribute.
   2399           *
   2400           * @param   dataType - data type
   2401           * @param   pData - pointer to data
   2402           *
   2403           * @return  returns atrribute length
   2404           */

   \                                 In  segment CODE, align 2, keep-with-next
   2405          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   2406          {
   2407            uint16 dataLen = 0;
   2408          
   2409            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000000   7C904400     CMP.B   #0x44, R12
   \   000004   0324         JEQ     ??zclGetAttrDataLength_0
   \   000006   7C904300     CMP.B   #0x43, R12
   \   00000A   0820         JNE     ??zclGetAttrDataLength_1
   2410            {
   2411              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   00000C   6C4D         MOV.B   @R13, R12
   \   00000E   5F4D0100     MOV.B   0x1(R13), R15
   \   000012                RPT     #0x8
   \   000012   47180F5F     RLAX.W  R15
   \   000016   0C5F         ADD.W   R15, R12
   \   000018   2C53         ADD.W   #0x2, R12
   \   00001A   1001         RETA
   2412            }
   2413            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001C   7C904200     CMP.B   #0x42, R12
   \   000020   0324         JEQ     ??zclGetAttrDataLength_2
   \   000022   7C904100     CMP.B   #0x41, R12
   \   000026   0320         JNE     ??zclGetAttrDataLength_3
   2414            {
   2415              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_2:
   \   000028   6C4D         MOV.B   @R13, R12
   \   00002A   1C53         ADD.W   #0x1, R12
   \   00002C   1001         RETA
   2416            }
   2417            else
   2418            {
   2419              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_3:
   \   00002E   ........     CALLA   #zclGetDataTypeLength
   \   000032   4C4C         MOV.B   R12, R12
   2420            }
   2421          
   2422            return ( dataLen );
   \   000034   1001         RETA
   2423          }
   2424          
   2425          /*********************************************************************
   2426           * @fn      zclReadAttrData
   2427           *
   2428           * @brief   Read the attribute's current value into pAttrData.
   2429           *
   2430           * @param   pAttrData - where to put attribute data
   2431           * @param   pAttr - pointer to attribute
   2432           * @param   pDataLen - where to put attribute data length
   2433           *
   2434           * @return Success
   2435           */

   \                                 In  segment CODE, align 2, keep-with-next
   2436          uint8 zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   2437          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   084E         MOV.W   R14, R8
   2438            uint16 dataLen;
   2439          
   2440            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \   000008   1D4B0600     MOV.W   0x6(R11), R13
   \   00000C   5C4B0400     MOV.B   0x4(R11), R12
   \   000010   ........     CALLA   #zclGetAttrDataLength
   \   000014   094C         MOV.W   R12, R9
   2441            osal_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   000016   0E4C         MOV.W   R12, R14
   \   000018   1D4B0600     MOV.W   0x6(R11), R13
   \   00001C   0C4A         MOV.W   R10, R12
   \   00001E   ........     CALLA   #osal_memcpy
   2442          
   2443            if ( pDataLen != NULL )
   \   000022   0893         CMP.W   #0x0, R8
   \   000024   0224         JEQ     ??zclReadAttrData_0
   2444            {
   2445              *pDataLen = dataLen;
   \   000026   88490000     MOV.W   R9, 0(R8)
   2446            }
   2447          
   2448            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_0:
   \   00002A   4C43         MOV.B   #0x0, R12
   \   00002C   3817         POPM.W  #0x4, R11
   \   00002E   1001         RETA
   2449          }
   2450          
   2451          #ifdef ZCL_READ
   2452          /*********************************************************************
   2453           * @fn      zclGetAttrDataLengthUsingCB
   2454           *
   2455           * @brief   Use application's callback to get the length of the attribute's
   2456           *          current value stored in the database.
   2457           *
   2458           * @param   endpoint - application's endpoint
   2459           * @param   clusterId - cluster that attribute belongs to
   2460           * @param   attrId - attribute id
   2461           *
   2462           * @return  returns attribute length
   2463           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine4_0:
   \   000000   0A4C         MOV.W   R12, R10
   \   000002   0B4D         MOV.W   R13, R11
   \   000004   0F4C         MOV.W   R12, R15
   \   000006   0FDD         BIS.W   R13, R15
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2464          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   2465          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   084D         MOV.W   R13, R8
   \   000006   094E         MOV.W   R14, R9
   2466            uint16 dataLen = 0;
   \   000008   81430000     MOV.W   #0x0, 0(SP)
   2467            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00000C   ........     CALLA   #zclGetReadWriteCB
   \   000010   ........     CALLA   #??Subroutine4_0
   2468          
   2469            if ( pfnReadWriteCB != NULL )
   \                     ??CrossCallReturnLabel_21:
   \   000014   0A24         JEQ     ??zclGetAttrDataLengthUsingCB_0
   2470            {
   2471              // Only get the attribute length
   2472              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000016   0F41         MOV.W   SP, R15
   \   000018   0F53         ADD.W   #0x0, R15
   \   00001A   0F12         PUSH.W  R15
   \   00001C   0F43         MOV.W   #0x0, R15
   \   00001E   4E43         MOV.B   #0x0, R14
   \   000020   0D49         MOV.W   R9, R13
   \   000022   0C48         MOV.W   R8, R12
   \   000024   ........     CALLA   #?IndCallR11
   \   000028   2153         ADD.W   #0x2, SP
   2473            }
   2474          
   2475            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   00002A   2C41         MOV.W   @SP, R12
   \   00002C   2153         ADD.W   #0x2, SP
   \   00002E   3817         POPM.W  #0x4, R11
   \   000030   1001         RETA
   2476          }
   2477          
   2478          /*********************************************************************
   2479           * @fn      zclReadAttrDataUsingCB
   2480           *
   2481           * @brief   Use application's callback to read the attribute's current
   2482           *          value stored in the database.
   2483           *
   2484           * @param   endpoint - application's endpoint
   2485           * @param   clusterId - cluster that attribute belongs to
   2486           * @param   attrId - attribute id
   2487           * @param   pAttrData - where to put attribute data
   2488           * @param   pDataLen - where to put attribute data length
   2489           *
   2490           * @return  Successful if data was read
   2491           */

   \                                 In  segment CODE, align 2, keep-with-next
   2492          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   2493                                                   uint8 *pAttrData, uint16 *pDataLen )
   2494          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   084D         MOV.W   R13, R8
   \   000004   094E         MOV.W   R14, R9
   \   000006   064F         MOV.W   R15, R6
   2495            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000008   ........     CALLA   #zclGetReadWriteCB
   \   00000C   0A4C         MOV.W   R12, R10
   \   00000E   0B4D         MOV.W   R13, R11
   \   000010   1F411000     MOV.W   0x10(SP), R15
   2496          
   2497            if ( pDataLen != NULL )
   \   000014   0F93         CMP.W   #0x0, R15
   \   000016   0224         JEQ     ??zclReadAttrDataUsingCB_0
   2498            {
   2499              *pDataLen = 0; // Always initialize it to 0
   \   000018   8F430000     MOV.W   #0x0, 0(R15)
   2500            }
   2501          
   2502            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   00001C   0E4C         MOV.W   R12, R14
   \   00001E   0EDD         BIS.W   R13, R14
   \   000020   0E93         CMP.W   #0x0, R14
   \   000022   0924         JEQ     ??zclReadAttrDataUsingCB_1
   2503            {
   2504              // Read the attribute value and its length
   2505              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   000024   0F12         PUSH.W  R15
   \   000026   0F46         MOV.W   R6, R15
   \   000028   5E43         MOV.B   #0x1, R14
   \   00002A   0D49         MOV.W   R9, R13
   \   00002C   0C48         MOV.W   R8, R12
   \   00002E   ........     CALLA   #?IndCallR11
   \   000032   2153         ADD.W   #0x2, SP
   \   000034   023C         JMP     ??zclReadAttrDataUsingCB_2
   2506            }
   2507          
   2508            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   000036   7C40C100     MOV.B   #0xc1, R12
   \                     ??zclReadAttrDataUsingCB_2:
   \   00003A   5617         POPM.W  #0x6, R11
   \   00003C   1001         RETA
   2509          }
   2510          
   2511          /*********************************************************************
   2512           * @fn      zclAuthorizeRead
   2513           *
   2514           * @brief   Use application's callback to authorize a Read operation
   2515           *          on a given attribute.
   2516           *
   2517           * @param   endpoint - application's endpoint
   2518           * @param   srcAddr - source Address
   2519           * @param   pAttr - pointer to attribute
   2520           *
   2521           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   2522           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   2523           */
   2524          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   2525          {
   2526            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   2527            {
   2528              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   2529          
   2530              if ( pfnAuthorizeCB != NULL )
   2531              {
   2532                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   2533              }
   2534            }
   2535          
   2536            return ( ZCL_STATUS_SUCCESS );
   2537          }
   2538          #endif // ZCL_READ
   2539          
   2540          #ifdef ZCL_WRITE
   2541          /*********************************************************************
   2542           * @fn      zclWriteAttrData
   2543           *
   2544           * @brief   Write the received data.
   2545           *
   2546           * @param   endpoint - application's endpoint
   2547           * @param   pAttr - where to write data to
   2548           * @param   pWriteRec - data to be written
   2549           *
   2550           * @return  Successful if data was written
   2551           */

   \                                 In  segment CODE, align 2, keep-with-next
   2552          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrData:
   2553                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   2554          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4E         MOV.W   R14, R10
   \   000004   0B4F         MOV.W   R15, R11
   2555            uint8 status;
   2556          
   2557            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000006   EEB30500     BIT.B   #0x2, 0x5(R14)
   \   00000A   2228         JNC     ??zclWriteAttrData_0
   2558            {
   2559              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   00000C   ........     CALLA   #zclAuthorizeWrite
   \   000010   484C         MOV.B   R12, R8
   2560              if ( status == ZCL_STATUS_SUCCESS )
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   1F20         JNE     ??zclWriteAttrData_1
   2561              {
   2562                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   000016   1F42....     MOV.W   &zcl_ValidateAttrDataCB, R15
   \   00001A   1FD2....     BIS.W   &zcl_ValidateAttrDataCB + 2, R15
   \   00001E   0F93         CMP.W   #0x0, R15
   \   000020   0624         JEQ     ??zclWriteAttrData_2
   \   000022   0D4B         MOV.W   R11, R13
   \   000024   0C4A         MOV.W   R10, R12
   \   000026   ........     CALLA   &zcl_ValidateAttrDataCB
   \   00002A   4C93         CMP.B   #0x0, R12
   \   00002C   0E24         JEQ     ??zclWriteAttrData_3
   2563                {
   2564                  // Write the attribute value
   2565                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   00002E   1D4B0400     MOV.W   0x4(R11), R13
   \   000032   5C4A0400     MOV.B   0x4(R10), R12
   \   000036   ........     CALLA   #zclGetAttrDataLength
   \   00003A   0E4C         MOV.W   R12, R14
   2566                  osal_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   00003C   1D4B0400     MOV.W   0x4(R11), R13
   \   000040   1C4A0600     MOV.W   0x6(R10), R12
   \   000044   ........     CALLA   #osal_memcpy
   2567          
   2568                  status = ZCL_STATUS_SUCCESS;
   \   000048   053C         JMP     ??zclWriteAttrData_1
   2569                }
   2570                else
   2571                {
   2572                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   00004A   78408700     MOV.B   #0x87, R8
   \   00004E   023C         JMP     ??zclWriteAttrData_1
   2573                }
   2574              }
   2575            }
   2576            else
   2577            {
   2578              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   000050   78408800     MOV.B   #0x88, R8
   2579            }
   2580          
   2581            return ( status );
   \                     ??zclWriteAttrData_1:
   \   000054   4C48         MOV.B   R8, R12
   \   000056   3817         POPM.W  #0x4, R11
   \   000058   1001         RETA
   2582          }
   2583          
   2584          /*********************************************************************
   2585           * @fn      zclWriteAttrDataUsingCB
   2586           *
   2587           * @brief   Use application's callback to write the attribute's current
   2588           *          value stored in the database.
   2589           *
   2590           * @param   endpoint - application's endpoint
   2591           * @param   pAttr - where to write data to
   2592           * @param   pAttrData - data to be written
   2593           *
   2594           * @return  Successful if data was written
   2595           */

   \                                 In  segment CODE, align 2, keep-with-next
   2596          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr,
   \                     zclWriteAttrDataUsingCB:
   2597                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   2598          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   084E         MOV.W   R14, R8
   \   000006   094F         MOV.W   R15, R9
   2599            uint8 status;
   2600          
   2601            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000008   EEB30500     BIT.B   #0x2, 0x5(R14)
   \   00000C   1728         JNC     ??zclWriteAttrDataUsingCB_0
   2602            {
   2603              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   00000E   ........     CALLA   #zclAuthorizeWrite
   2604              if ( status == ZCL_STATUS_SUCCESS )
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   1520         JNE     ??zclWriteAttrDataUsingCB_1
   2605              {
   2606                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000016   4C4A         MOV.B   R10, R12
   \   000018   ........     CALLA   #zclGetReadWriteCB
   \   00001C   ........     CALLA   #??Subroutine4_0
   2607                if ( pfnReadWriteCB != NULL )
   \                     ??CrossCallReturnLabel_20:
   \   000020   0A24         JEQ     ??zclWriteAttrDataUsingCB_2
   2608                {
   2609                  // Write the attribute value
   2610                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId,
   2611                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   000022   0312         PUSH.W  #0x0
   \   000024   0F49         MOV.W   R9, R15
   \   000026   6E43         MOV.B   #0x2, R14
   \   000028   1D480200     MOV.W   0x2(R8), R13
   \   00002C   2C48         MOV.W   @R8, R12
   \   00002E   ........     CALLA   #?IndCallR11
   \   000032   2153         ADD.W   #0x2, SP
   \   000034   053C         JMP     ??zclWriteAttrDataUsingCB_1
   2612                }
   2613                else
   2614                {
   2615                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   000036   7C40C100     MOV.B   #0xc1, R12
   \   00003A   023C         JMP     ??zclWriteAttrDataUsingCB_1
   2616                }
   2617              }
   2618            }
   2619            else
   2620            {
   2621              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   00003C   7C408800     MOV.B   #0x88, R12
   2622            }
   2623          
   2624            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000040   3817         POPM.W  #0x4, R11
   \   000042   1001         RETA
   2625          }
   2626          
   2627          /*********************************************************************
   2628           * @fn      zclAuthorizeWrite
   2629           *
   2630           * @brief   Use application's callback to authorize a Write operation
   2631           *          on a given attribute.
   2632           *
   2633           * @param   endpoint - application's endpoint
   2634           * @param   srcAddr - source Address
   2635           * @param   pAttr - pointer to attribute
   2636           *
   2637           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   2638           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   2639           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   ........     CALLA   #zclGetAuthorizeCB
   \   000004                REQUIRE ??Subroutine4_0
   \   000004                // Fall through to label ??Subroutine4_0

   \                                 In  segment CODE, align 2, keep-with-next
   2640          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   2641          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   084D         MOV.W   R13, R8
   \   000004   094E         MOV.W   R14, R9
   2642            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   000006   FEB020000500 BIT.B   #0x20, 0x5(R14)
   \   00000C   0928         JNC     ??zclAuthorizeWrite_0
   2643            {
   2644              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00000E   ........     CALLA   #?Subroutine4
   2645          
   2646              if ( pfnAuthorizeCB != NULL )
   \                     ??CrossCallReturnLabel_19:
   \   000012   0624         JEQ     ??zclAuthorizeWrite_0
   2647              {
   2648                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000014   6E43         MOV.B   #0x2, R14
   \   000016   0D49         MOV.W   R9, R13
   \   000018   0C48         MOV.W   R8, R12
   \   00001A   ........     CALLA   #?IndCallR11
   \   00001E   013C         JMP     ??zclAuthorizeWrite_1
   2649              }
   2650            }
   2651          
   2652            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000020   4C43         MOV.B   #0x0, R12
   \                     ??zclAuthorizeWrite_1:
   \   000022   3817         POPM.W  #0x4, R11
   \   000024   1001         RETA
   2653          }
   2654          #endif // ZCL_WRITE
   2655          
   2656          #ifdef ZCL_READ
   2657          /*********************************************************************
   2658           * @fn      zclParseInReadCmd
   2659           *
   2660           * @brief   Parse the "Profile" Read Commands
   2661           *
   2662           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2663           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2664           *
   2665           * @param   pCmd - pointer to incoming data to parse
   2666           *
   2667           * @return  pointer to the parsed command structure
   2668           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   1C4B0200     MOV.W   0x2(R11), R12
   \   000004   2C53         ADD.W   #0x2, R12
   \   000006                REQUIRE ??Subroutine9_0
   \   000006                // Fall through to label ??Subroutine9_0

   \                                 In  segment CODE, align 2, keep-with-next
   2669          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   2670          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0B4C         MOV.W   R12, R11
   2671            zclReadCmd_t *readCmd;
   2672            uint8 *pBuf = pCmd->pData;
   \   000004   1A4C0400     MOV.W   0x4(R12), R10
   2673          
   2674            readCmd = (zclReadCmd_t *)osal_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   000008   ........     CALLA   #?Subroutine9
   2675            if ( readCmd != NULL )
   \                     ??CrossCallReturnLabel_36:
   \   00000C   1724         JEQ     ??zclParseInReadCmd_1
   2676            {
   2677              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   00000E   1E4B0200     MOV.W   0x2(R11), R14
   \   000012   5E03         RRUM.W  #0x1, R14
   \   000014   CC4E0000     MOV.B   R14, 0(R12)
   2678              for ( uint8 i = 0; i < readCmd->numAttr; i++ )
   \   000018   4E43         MOV.B   #0x0, R14
   \   00001A   0E3C         JMP     ??zclParseInReadCmd_2
   2679              {
   2680                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_0:
   \   00001C   6D4A         MOV.B   @R10, R13
   \   00001E   5F4A0100     MOV.B   0x1(R10), R15
   \   000022                RPT     #0x8
   \   000022   47180F5F     RLAX.W  R15
   \   000026   0D5F         ADD.W   R15, R13
   \   000028   4F4E         MOV.B   R14, R15
   \   00002A   0F5F         RLA.W   R15
   \   00002C   0B4C         MOV.W   R12, R11
   \   00002E   0B5F         ADD.W   R15, R11
   \   000030   8B4D0200     MOV.W   R13, 0x2(R11)
   2681                pBuf += 2;
   \   000034   2A53         ADD.W   #0x2, R10
   2682              }
   \   000036   5E53         ADD.B   #0x1, R14
   \                     ??zclParseInReadCmd_2:
   \   000038   6E9C         CMP.B   @R12, R14
   \   00003A   F02B         JNC     ??zclParseInReadCmd_0
   2683            }
   2684          
   2685            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_1:
   \   00003C   1A17         POPM.W  #0x2, R11
   \   00003E   1001         RETA
   2686          }
   2687          
   2688          /*********************************************************************
   2689           * @fn      zclParseInReadRspCmd
   2690           *
   2691           * @brief   Parse the "Profile" Read Response Commands
   2692           *
   2693           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2694           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2695           *
   2696           * @param   pCmd - pointer to incoming data to parse
   2697           *
   2698           * @return  pointer to the parsed command structure
   2699           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   0C48         MOV.W   R8, R12
   \   000002   7417         POPM.W  #0x8, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000   6A43         MOV.B   #0x2, R10
   \   000002                RPT     #0x6
   \   000002   45184A5B     ADDX.B  R11, R10
   \   000006   4C4A         MOV.B   R10, R12
   \   000008   0C58         ADD.W   R8, R12
   \   00000A                REQUIRE ??Subroutine8_0
   \   00000A                // Fall through to label ??Subroutine8_0

   \                                 In  segment CODE, align 2, keep-with-next
   2700          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   2701          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   074C         MOV.W   R12, R7
   2702            zclReadRspCmd_t *readRspCmd;
   2703            uint8 *pBuf = pCmd->pData;
   \   000004   194C0400     MOV.W   0x4(R12), R9
   2704            uint8 *dataPtr;
   2705            uint8 numAttr = 0;
   \   000008   4B43         MOV.B   #0x0, R11
   2706            uint8 hdrLen;
   2707            uint16 dataLen = 0;
   \   00000A   0843         MOV.W   #0x0, R8
   \   00000C   073C         JMP     ??zclParseInReadRspCmd_4
   2708            uint16 attrDataLen;
   2709          
   2710            // find out the number of attributes and the length of attribute data
   2711            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2712            {
   2713              uint8 status;
   2714          
   2715              numAttr++;
   \                     ??zclParseInReadRspCmd_0:
   \   00000E   5B53         ADD.B   #0x1, R11
   2716              pBuf += 2; // move pass attribute id
   \   000010   2953         ADD.W   #0x2, R9
   2717          
   2718              status = *pBuf++;
   \   000012   7E49         MOV.B   @R9+, R14
   2719              if ( status == ZCL_STATUS_SUCCESS )
   \   000014   4E93         CMP.B   #0x0, R14
   \   000016   0220         JNE     ??zclParseInReadRspCmd_4
   2720              {
   2721                uint8 dataType = *pBuf++;
   \   000018   ........     CALLA   #?Subroutine12
   2722          
   2723                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2724                pBuf += attrDataLen; // move pass attribute data
   2725          
   2726                // add padding if needed
   2727                if ( PADDING_NEEDED( attrDataLen ) )
   2728                {
   2729                  attrDataLen++;
   2730                }
   2731          
   2732                dataLen += attrDataLen;
   2733              }
   2734            }
   \                     ??zclParseInReadRspCmd_4:
   \   00001C   1F470400     MOV.W   0x4(R7), R15
   \   000020   1F570200     ADD.W   0x2(R7), R15
   \   000024   099F         CMP.W   R15, R9
   \   000026   F32B         JNC     ??zclParseInReadRspCmd_0
   2735          
   2736            // calculate the length of the response header
   2737            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000028   ........     CALLA   #?Subroutine8
   2738          
   2739            readRspCmd = (zclReadRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2740            if ( readRspCmd != NULL )
   \                     ??CrossCallReturnLabel_23:
   \   00002C   1224         JEQ     ??zclParseInReadRspCmd_5
   2741            {
   2742              pBuf = pCmd->pData;
   \   00002E   ........     CALLA   #?Subroutine18
   2743              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   2744          
   2745              readRspCmd->numAttr = numAttr;
   2746              for ( uint8 i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_12:
   \   000032   0D3C         JMP     ??zclParseInReadRspCmd_6
   2747              {
   2748                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_1:
   \   000034   ........     CALLA   #?Subroutine13
   2749          
   2750                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2751                pBuf += 2;
   2752          
   2753                statusRec->status = *pBuf++;
   2754                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_5:
   \   000038   C7930200     CMP.B   #0x0, 0x2(R7)
   \   00003C   0720         JNE     ??zclParseInReadRspCmd_7
   2755                {
   2756                  statusRec->dataType = *pBuf++;
   \   00003E   F7490300     MOV.B   @R9+, 0x3(R7)
   2757          
   2758                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   000042   0D49         MOV.W   R9, R13
   \   000044   5C470300     MOV.B   0x3(R7), R12
   \   000048   ........     CALLA   #?Subroutine11
   2759                  osal_memcpy( dataPtr, pBuf, attrDataLen);
   2760                  statusRec->data = dataPtr;
   2761          
   2762                  pBuf += attrDataLen; // move pass attribute data
   2763          
   2764                  // advance attribute data pointer
   2765                  if ( PADDING_NEEDED( attrDataLen ) )
   2766                  {
   2767                    attrDataLen++;
   2768                  }
   2769          
   2770                  dataPtr += attrDataLen;
   2771                }
   2772              }
   \                     ??zclParseInReadRspCmd_7:
   \   00004C   5653         ADD.B   #0x1, R6
   \                     ??zclParseInReadRspCmd_6:
   \   00004E   469B         CMP.B   R11, R6
   \   000050   F12B         JNC     ??zclParseInReadRspCmd_1
   2773            }
   2774          
   2775            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_5:
   \   000052   ....         JMP     ?Subroutine2
   2776          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine18:
   \   000000   19470400     MOV.W   0x4(R7), R9
   \   000004   4F4A         MOV.B   R10, R15
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0A5F         ADD.W   R15, R10
   \   00000A   CC4B0000     MOV.B   R11, 0(R12)
   \   00000E   4643         MOV.B   #0x0, R6
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine13:
   \   000000   0F46         MOV.W   R6, R15
   \   000002                RPT     #0x5
   \   000002   44180F56     ADDX.W  R6, R15
   \   000006   0748         MOV.W   R8, R7
   \   000008   075F         ADD.W   R15, R7
   \   00000A   2753         ADD.W   #0x2, R7
   \   00000C   6E49         MOV.B   @R9, R14
   \   00000E   5F490100     MOV.B   0x1(R9), R15
   \   000012                RPT     #0x8
   \   000012   47180F5F     RLAX.W  R15
   \   000016   0E5F         ADD.W   R15, R14
   \   000018   874E0000     MOV.W   R14, 0(R7)
   \   00001C   2953         ADD.W   #0x2, R9
   \   00001E   F7490200     MOV.B   @R9+, 0x2(R7)
   \   000022   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine12:
   \   000000   7C49         MOV.B   @R9+, R12
   \   000002   0D49         MOV.W   R9, R13
   \   000004   ........     CALLA   #zclGetAttrDataLength
   \   000008   044C         MOV.W   R12, R4
   \   00000A   095C         ADD.W   R12, R9
   \   00000C   1CB3         BIT.W   #0x1, R12
   \   00000E   0128         JNC     ??zclParseInWriteCmd_3
   \   000010   1453         ADD.W   #0x1, R4
   \                     ??zclParseInWriteCmd_3:
   \   000012   0854         ADD.W   R4, R8
   \   000014   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine11:
   \   000000   ........     CALLA   #zclGetAttrDataLength
   \   000004   044C         MOV.W   R12, R4
   \   000006   0E4C         MOV.W   R12, R14
   \   000008   0D49         MOV.W   R9, R13
   \   00000A   0C4A         MOV.W   R10, R12
   \   00000C   ........     CALLA   #osal_memcpy
   \   000010   874A0400     MOV.W   R10, 0x4(R7)
   \   000014   0954         ADD.W   R4, R9
   \   000016   14B3         BIT.W   #0x1, R4
   \   000018   0128         JNC     ??zclParseInWriteCmd_2
   \   00001A   1453         ADD.W   #0x1, R4
   \                     ??zclParseInWriteCmd_2:
   \   00001C   0A54         ADD.W   R4, R10
   \   00001E   1001         RETA
   2777          #endif // ZCL_READ
   2778          
   2779          #ifdef ZCL_WRITE
   2780          /*********************************************************************
   2781           * @fn      zclParseInWriteCmd
   2782           *
   2783           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   2784           *          Response Commands
   2785           *
   2786           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2787           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2788           *
   2789           * @param   pCmd - pointer to incoming data to parse
   2790           *
   2791           * @return  pointer to the parsed command structure
   2792           */

   \                                 In  segment CODE, align 2, keep-with-next
   2793          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   2794          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   074C         MOV.W   R12, R7
   2795            zclWriteCmd_t *writeCmd;
   2796            uint8 *pBuf = pCmd->pData;
   \   000004   194C0400     MOV.W   0x4(R12), R9
   2797            uint16 attrDataLen;
   2798            uint8 *dataPtr;
   2799            uint8 numAttr = 0;
   \   000008   4B43         MOV.B   #0x0, R11
   2800            uint8 hdrLen;
   2801            uint16 dataLen = 0;
   \   00000A   0843         MOV.W   #0x0, R8
   \   00000C   043C         JMP     ??zclParseInWriteCmd_4
   2802          
   2803            // find out the number of attributes and the length of attribute data
   2804            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2805            {
   2806              uint8 dataType;
   2807          
   2808              numAttr++;
   \                     ??zclParseInWriteCmd_0:
   \   00000E   5B53         ADD.B   #0x1, R11
   2809              pBuf += 2; // move pass attribute id
   \   000010   2953         ADD.W   #0x2, R9
   2810          
   2811              dataType = *pBuf++;
   \   000012   ........     CALLA   #?Subroutine12
   2812          
   2813              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2814              pBuf += attrDataLen; // move pass attribute data
   2815          
   2816              // add padding if needed
   2817              if ( PADDING_NEEDED( attrDataLen ) )
   2818              {
   2819                attrDataLen++;
   2820              }
   2821          
   2822              dataLen += attrDataLen;
   2823            }
   \                     ??zclParseInWriteCmd_4:
   \   000016   1F470400     MOV.W   0x4(R7), R15
   \   00001A   1F570200     ADD.W   0x2(R7), R15
   \   00001E   099F         CMP.W   R15, R9
   \   000020   F62B         JNC     ??zclParseInWriteCmd_0
   2824          
   2825            // calculate the length of the response header
   2826            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   \   000022   ........     CALLA   #?Subroutine8
   2827          
   2828            writeCmd = (zclWriteCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2829            if ( writeCmd != NULL )
   \                     ??CrossCallReturnLabel_22:
   \   000026   0D24         JEQ     ??zclParseInWriteCmd_5
   2830            {
   2831              pBuf = pCmd->pData;
   \   000028   ........     CALLA   #?Subroutine18
   2832              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   2833          
   2834              writeCmd->numAttr = numAttr;
   2835              for ( uint8 i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_11:
   \   00002C   083C         JMP     ??zclParseInWriteCmd_6
   2836              {
   2837                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zclParseInWriteCmd_1:
   \   00002E   ........     CALLA   #?Subroutine13
   2838          
   2839                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2840                pBuf += 2;
   2841                statusRec->dataType = *pBuf++;
   2842          
   2843                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \                     ??CrossCallReturnLabel_4:
   \   000032   0D49         MOV.W   R9, R13
   \   000034   5C470200     MOV.B   0x2(R7), R12
   \   000038   ........     CALLA   #?Subroutine11
   2844                osal_memcpy( dataPtr, pBuf, attrDataLen);
   2845                statusRec->attrData = dataPtr;
   2846          
   2847                pBuf += attrDataLen; // move pass attribute data
   2848          
   2849                // advance attribute data pointer
   2850                if ( PADDING_NEEDED( attrDataLen ) )
   2851                {
   2852                  attrDataLen++;
   2853                }
   2854          
   2855                dataPtr += attrDataLen;
   2856              }
   \                     ??CrossCallReturnLabel_3:
   \   00003C   5653         ADD.B   #0x1, R6
   \                     ??zclParseInWriteCmd_6:
   \   00003E   469B         CMP.B   R11, R6
   \   000040   F62B         JNC     ??zclParseInWriteCmd_1
   2857            }
   2858          
   2859            return ( (void *)writeCmd );
   \                     ??zclParseInWriteCmd_5:
   \   000042                REQUIRE ?Subroutine2
   \   000042                // Fall through to label ?Subroutine2
   2860          }
   2861          
   2862          /*********************************************************************
   2863           * @fn      zclParseInWriteRspCmd
   2864           *
   2865           * @brief   Parse the "Profile" Write Response Commands
   2866           *
   2867           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2868           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2869           *
   2870           * @param   pCmd - pointer to incoming data to parse
   2871           *
   2872           * @return  pointer to the parsed command structure
   2873           */

   \                                 In  segment CODE, align 2, keep-with-next
   2874          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   2875          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0B4C         MOV.W   R12, R11
   2876            zclWriteRspCmd_t *writeRspCmd;
   2877            uint8 *pBuf = pCmd->pData;
   \   000004   184C0400     MOV.W   0x4(R12), R8
   2878            uint8 i = 0;
   \   000008   4A43         MOV.B   #0x0, R10
   2879          
   2880            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \   00000A   ........     CALLA   #?Subroutine9
   2881            if ( writeRspCmd != NULL )
   \                     ??CrossCallReturnLabel_35:
   \   00000E   1F24         JEQ     ??zclParseInWriteRspCmd_1
   2882            {
   2883              if ( pCmd->dataLen == 1 )
   \   000010   9B930200     CMP.W   #0x1, 0x2(R11)
   \   000014   1420         JNE     ??zclParseInWriteRspCmd_2
   2884              {
   2885                // special case when all writes were successfull
   2886                writeRspCmd->attrList[i++].status = *pBuf;
   \   000016   EC480200     MOV.B   @R8, 0x2(R12)
   \   00001A   5A43         MOV.B   #0x1, R10
   \   00001C   163C         JMP     ??zclParseInWriteRspCmd_3
   2887              }
   2888              else
   2889              {
   2890                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2891                {
   2892                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_0:
   \   00001E   4F4A         MOV.B   R10, R15
   \   000020   5F06         RLAM.W  #0x2, R15
   \   000022   0D4C         MOV.W   R12, R13
   \   000024   0D5F         ADD.W   R15, R13
   \   000026   FD480200     MOV.B   @R8+, 0x2(R13)
   2893                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   00002A   6E48         MOV.B   @R8, R14
   \   00002C   5F480100     MOV.B   0x1(R8), R15
   \   000030                RPT     #0x8
   \   000030   47180F5F     RLAX.W  R15
   \   000034   0E5F         ADD.W   R15, R14
   \   000036   8D4E0400     MOV.W   R14, 0x4(R13)
   \   00003A   5A53         ADD.B   #0x1, R10
   2894                  pBuf += 2;
   \   00003C   2853         ADD.W   #0x2, R8
   2895                }
   \                     ??zclParseInWriteRspCmd_2:
   \   00003E   1F4B0400     MOV.W   0x4(R11), R15
   \   000042   1F5B0200     ADD.W   0x2(R11), R15
   \   000046   089F         CMP.W   R15, R8
   \   000048   EA2B         JNC     ??zclParseInWriteRspCmd_0
   2896              }
   2897          
   2898              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   00004A   CC4A0000     MOV.B   R10, 0(R12)
   2899            }
   2900          
   2901            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_1:
   \   00004E   3817         POPM.W  #0x4, R11
   \   000050   1001         RETA
   2902          }
   2903          #endif // ZCL_WRITE
   2904          
   2905          #ifdef ZCL_REPORT
   2906          /*********************************************************************
   2907           * @fn      zclParseInConfigReportCmd
   2908           *
   2909           * @brief   Parse the "Profile" Configure Reporting Command
   2910           *
   2911           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2912           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2913           *
   2914           * @param   pCmd - pointer to incoming data to parse
   2915           *
   2916           * @return  pointer to the parsed command structure
   2917           */
   2918          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   2919          {
   2920            zclCfgReportCmd_t *cfgReportCmd;
   2921            uint8 *pBuf = pCmd->pData;
   2922            uint8 *dataPtr;
   2923            uint8 numAttr = 0;
   2924            uint8 dataType;
   2925            uint8 hdrLen;
   2926            uint16 dataLen = 0;
   2927            uint8 reportChangeLen; // length of Reportable Change field
   2928          
   2929            // Calculate the length of the Request command
   2930            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2931            {
   2932              uint8 direction;
   2933          
   2934              numAttr++;
   2935              direction = *pBuf++;
   2936              pBuf += 2; // move pass the attribute ID
   2937          
   2938              // Is there a Reportable Change field?
   2939              if ( direction == ZCL_SEND_ATTR_REPORTS )
   2940              {
   2941                dataType = *pBuf++;
   2942                pBuf += 4; // move pass the Min and Max Reporting Intervals
   2943          
   2944                // For attributes of 'discrete' data types this field is omitted
   2945                if ( zclAnalogDataType( dataType ) )
   2946                {
   2947                  reportChangeLen = zclGetDataTypeLength( dataType );
   2948                  pBuf += reportChangeLen;
   2949          
   2950                  // add padding if needed
   2951                  if ( PADDING_NEEDED( reportChangeLen ) )
   2952                  {
   2953                    reportChangeLen++;
   2954                  }
   2955          
   2956                  dataLen += reportChangeLen;
   2957                }
   2958              }
   2959              else
   2960              {
   2961                pBuf += 2; // move pass the Timeout Period
   2962              }
   2963            } // while loop
   2964          
   2965            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   2966          
   2967            cfgReportCmd = (zclCfgReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2968            if ( cfgReportCmd != NULL )
   2969            {
   2970              pBuf = pCmd->pData;
   2971              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   2972          
   2973              cfgReportCmd->numAttr = numAttr;
   2974              for ( uint8 i = 0; i < numAttr; i++ )
   2975              {
   2976                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   2977          
   2978                osal_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   2979          
   2980                reportRec->direction = *pBuf++;
   2981                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2982                pBuf += 2;
   2983                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   2984                {
   2985                  // Attribute to be reported
   2986                  reportRec->dataType = *pBuf++;
   2987                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2988                  pBuf += 2;
   2989                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2990                  pBuf += 2;
   2991          
   2992                  // For attributes of 'discrete' data types this field is omitted
   2993                  if ( zclAnalogDataType( reportRec->dataType ) )
   2994                  {
   2995                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   2996                    reportRec->reportableChange = dataPtr;
   2997          
   2998                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   2999                    pBuf += reportChangeLen;
   3000          
   3001                    // advance attribute data pointer
   3002                    if ( PADDING_NEEDED( reportChangeLen ) )
   3003                    {
   3004                      reportChangeLen++;
   3005                    }
   3006          
   3007                    dataPtr += reportChangeLen;
   3008                  }
   3009                }
   3010                else
   3011                {
   3012                  // Attribute reports to be received
   3013                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   3014                  pBuf += 2;
   3015                }
   3016              } // while loop
   3017            }
   3018          
   3019            return ( (void *)cfgReportCmd );
   3020          }
   3021          
   3022          /*********************************************************************
   3023           * @fn      zclParseInConfigReportRspCmd
   3024           *
   3025           * @brief   Parse the "Profile" Configure Reporting Response Command
   3026           *
   3027           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3028           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3029           *
   3030           * @param   pCmd - pointer to incoming data to parse
   3031           *
   3032           * @return  pointer to the parsed command structure
   3033           */
   3034          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   3035          {
   3036            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3037            uint8 *pBuf = pCmd->pData;
   3038            uint8 numAttr;
   3039          
   3040            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   3041          
   3042            cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3043                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   3044            if ( cfgReportRspCmd != NULL )
   3045            {
   3046              cfgReportRspCmd->numAttr = numAttr;
   3047              for ( uint8 i = 0; i < cfgReportRspCmd->numAttr; i++ )
   3048              {
   3049                cfgReportRspCmd->attrList[i].status = *pBuf++;
   3050                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   3051                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3052                pBuf += 2;
   3053              }
   3054            }
   3055          
   3056            return ( (void *)cfgReportRspCmd );
   3057          }
   3058          
   3059          /*********************************************************************
   3060           * @fn      zclParseInReadReportCfgCmd
   3061           *
   3062           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3063           *
   3064           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3065           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3066           *
   3067           * @param   pCmd - pointer to incoming data to parse
   3068           *
   3069           * @return  pointer to the parsed command structure
   3070           */
   3071          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   3072          {
   3073            zclReadReportCfgCmd_t *readReportCfgCmd;
   3074            uint8 *pBuf = pCmd->pData;
   3075            uint8 numAttr;
   3076          
   3077            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   3078          
   3079            readReportCfgCmd = (zclReadReportCfgCmd_t *)osal_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3080                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   3081            if ( readReportCfgCmd != NULL )
   3082            {
   3083              readReportCfgCmd->numAttr = numAttr;
   3084              for ( uint8 i = 0; i < readReportCfgCmd->numAttr; i++)
   3085              {
   3086                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   3087                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3088                pBuf += 2;
   3089              }
   3090            }
   3091          
   3092            return ( (void *)readReportCfgCmd );
   3093          }
   3094          
   3095          /*********************************************************************
   3096           * @fn      zclParseInReadReportCfgRspCmd
   3097           *
   3098           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3099           *
   3100           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3101           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3102           *
   3103           * @param   pCmd - pointer to incoming data to parse
   3104           *
   3105           * @return  pointer to the parsed command structure
   3106           */
   3107          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   3108          {
   3109            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3110            uint8 reportChangeLen;
   3111            uint8 *pBuf = pCmd->pData;
   3112            uint8 *dataPtr;
   3113            uint8 numAttr = 0;
   3114            uint8 hdrLen;
   3115            uint16 dataLen = 0;
   3116          
   3117            // Calculate the length of the response command
   3118            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3119            {
   3120              uint8 status;
   3121              uint8 direction;
   3122          
   3123              numAttr++;
   3124              status = *pBuf++;
   3125              direction = *pBuf++;
   3126              pBuf += 2; // move pass the attribute ID
   3127          
   3128              if ( status == ZCL_STATUS_SUCCESS )
   3129              {
   3130                if ( direction == ZCL_SEND_ATTR_REPORTS )
   3131                {
   3132                  uint8 dataType = *pBuf++;
   3133                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   3134          
   3135                  // For attributes of 'discrete' data types this field is omitted
   3136                  if ( zclAnalogDataType( dataType ) )
   3137                  {
   3138                    reportChangeLen = zclGetDataTypeLength( dataType );
   3139                    pBuf += reportChangeLen;
   3140          
   3141                    // add padding if needed
   3142                    if ( PADDING_NEEDED( reportChangeLen ) )
   3143                    {
   3144                      reportChangeLen++;
   3145                    }
   3146          
   3147                    dataLen += reportChangeLen;
   3148                  }
   3149                }
   3150                else
   3151                {
   3152                  pBuf += 2; // move pass the Timeout field
   3153                }
   3154              }
   3155            } // while loop
   3156          
   3157            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   3158          
   3159            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   3160            if ( readReportCfgRspCmd != NULL )
   3161            {
   3162              pBuf = pCmd->pData;
   3163              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   3164          
   3165              readReportCfgRspCmd->numAttr = numAttr;
   3166              for ( uint8 i = 0; i < numAttr; i++ )
   3167              {
   3168                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   3169          
   3170                reportRspRec->status = *pBuf++;
   3171                reportRspRec->direction = *pBuf++;
   3172                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3173                pBuf += 2;
   3174          
   3175                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   3176                {
   3177                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   3178                  {
   3179                    reportRspRec->dataType = *pBuf++;
   3180                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3181                    pBuf += 2;
   3182                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3183                    pBuf += 2;
   3184          
   3185                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   3186                    {
   3187                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   3188                      reportRspRec->reportableChange = dataPtr;
   3189          
   3190                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   3191                      pBuf += reportChangeLen;
   3192          
   3193                      // advance attribute data pointer
   3194                      if ( PADDING_NEEDED( reportChangeLen ) )
   3195                      {
   3196                        reportChangeLen++;
   3197                      }
   3198          
   3199                      dataPtr += reportChangeLen;
   3200                    }
   3201                  }
   3202                  else
   3203                  {
   3204                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   3205                    pBuf += 2;
   3206                  }
   3207                }
   3208              }
   3209            }
   3210          
   3211            return ( (void *)readReportCfgRspCmd );
   3212          }
   3213          
   3214          /*********************************************************************
   3215           * @fn      zclParseInReportCmd
   3216           *
   3217           * @brief   Parse the "Profile" Report Command
   3218           *
   3219           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3220           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3221           *
   3222           * @param   pCmd - pointer to incoming data to parse
   3223           *
   3224           * @return  pointer to the parsed command structure
   3225           */
   3226          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   3227          {
   3228            zclReportCmd_t *reportCmd;
   3229            uint8 *pBuf = pCmd->pData;
   3230            uint16 attrDataLen;
   3231            uint8 *dataPtr;
   3232            uint8 numAttr = 0;
   3233            uint8 hdrLen;
   3234            uint16 dataLen = 0;
   3235          
   3236            // find out the number of attributes and the length of attribute data
   3237            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3238            {
   3239              uint8 dataType;
   3240          
   3241              numAttr++;
   3242              pBuf += 2; // move pass attribute id
   3243          
   3244              dataType = *pBuf++;
   3245          
   3246              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   3247              pBuf += attrDataLen; // move pass attribute data
   3248          
   3249              // add padding if needed
   3250              if ( PADDING_NEEDED( attrDataLen ) )
   3251              {
   3252                attrDataLen++;
   3253              }
   3254          
   3255              dataLen += attrDataLen;
   3256            }
   3257          
   3258            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   3259          
   3260            reportCmd = (zclReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   3261            if (reportCmd != NULL )
   3262            {
   3263              pBuf = pCmd->pData;
   3264              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   3265          
   3266              reportCmd->numAttr = numAttr;
   3267              for ( uint8 i = 0; i < numAttr; i++ )
   3268              {
   3269                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   3270          
   3271                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3272                pBuf += 2;
   3273                reportRec->dataType = *pBuf++;
   3274          
   3275                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   3276                osal_memcpy( dataPtr, pBuf, attrDataLen );
   3277                reportRec->attrData = dataPtr;
   3278          
   3279                pBuf += attrDataLen; // move pass attribute data
   3280          
   3281                // advance attribute data pointer
   3282                if ( PADDING_NEEDED( attrDataLen ) )
   3283                {
   3284                  attrDataLen++;
   3285                }
   3286          
   3287                dataPtr += attrDataLen;
   3288              }
   3289            }
   3290          
   3291            return ( (void *)reportCmd );
   3292          }
   3293          #endif // ZCL_REPORT
   3294          
   3295          /*********************************************************************
   3296           * @fn      zclParseInDefaultRspCmd
   3297           *
   3298           * @brief   Parse the "Profile" Default Response Command
   3299           *
   3300           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3301           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3302           *
   3303           * @param   pCmd - pointer to incoming data to parse
   3304           *
   3305           * @return  pointer to the parsed command structure
   3306           */

   \                                 In  segment CODE, align 2, keep-with-next
   3307          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   3308          {
   \   000000   0A12         PUSH.W  R10
   3309            zclDefaultRspCmd_t *defaultRspCmd;
   3310            uint8 *pBuf = pCmd->pData;
   \   000002   1A4C0400     MOV.W   0x4(R12), R10
   3311          
   3312            defaultRspCmd = (zclDefaultRspCmd_t *)osal_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \   000006   2C43         MOV.W   #0x2, R12
   \   000008   ........     CALLA   #??Subroutine9_0
   3313            if ( defaultRspCmd != NULL )
   \                     ??CrossCallReturnLabel_37:
   \   00000C   0424         JEQ     ??zclParseInDefaultRspCmd_0
   3314            {
   3315              defaultRspCmd->commandID = *pBuf++;
   \   00000E   FC4A0000     MOV.B   @R10+, 0(R12)
   3316              defaultRspCmd->statusCode = *pBuf;
   \   000012   EC4A0100     MOV.B   @R10, 0x1(R12)
   3317            }
   3318          
   3319            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   000016   3A41         POP.W   R10
   \   000018   1001         RETA
   3320          }
   3321          
   3322          #ifdef ZCL_DISCOVER
   3323          /*********************************************************************
   3324           * @fn      zclParseInDiscCmd
   3325           *
   3326           * @brief   Parse the "Profile" Discovery Commands
   3327           *
   3328           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3329           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3330           *
   3331           * @param   pCmd - pointer to incoming data to parse
   3332           *
   3333           * @return  pointer to the parsed command structure
   3334           */
   3335          void *zclParseInDiscCmd( zclParseCmd_t *pCmd )
   3336          {
   3337            zclDiscoverCmd_t *discoverCmd;
   3338            uint8 *pBuf = pCmd->pData;
   3339          
   3340            discoverCmd = (zclDiscoverCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverCmd_t ) );
   3341            if ( discoverCmd != NULL )
   3342            {
   3343              discoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   3344              pBuf += 2;
   3345              discoverCmd->maxAttrIDs = *pBuf;
   3346            }
   3347          
   3348            return ( (void *)discoverCmd );
   3349          }
   3350          
   3351          /*********************************************************************
   3352           * @fn      zclParseInDiscRspCmd
   3353           *
   3354           * @brief   Parse the "Profile" Discovery Response Commands
   3355           *
   3356           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3357           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3358           *
   3359           * @param   pCmd - pointer to incoming data to parse
   3360           *
   3361           * @return  pointer to the parsed command structure
   3362           */
   3363          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3364          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd )
   3365          {
   3366            zclDiscoverRspCmd_t *discoverRspCmd;
   3367            uint8 *pBuf = pCmd->pData;
   3368            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   3369          
   3370            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverRspCmd_t )
   3371                                                           + ( numAttr * sizeof(zclDiscoverInfo_t) ) );
   3372            if ( discoverRspCmd != NULL )
   3373            {
   3374              discoverRspCmd->discComplete = *pBuf++;
   3375              discoverRspCmd->numAttr = numAttr;
   3376          
   3377              for ( uint8 i = 0; i < numAttr; i++ )
   3378              {
   3379                discoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3380                pBuf += 2;
   3381                discoverRspCmd->attrList[i].dataType = *pBuf++;;
   3382              }
   3383            }
   3384          
   3385            return ( (void *)discoverRspCmd );
   3386          }
   3387          #endif // ZCL_DISCOVER
   3388          
   3389          #ifdef ZCL_READ
   3390          /*********************************************************************
   3391           * @fn      zclProcessInReadCmd
   3392           *
   3393           * @brief   Process the "Profile" Read Command
   3394           *
   3395           * @param   pInMsg - incoming message to process
   3396           *
   3397           * @return  TRUE if command processed. FALSE, otherwise.
   3398           */

   \                                 In  segment CODE, align 2, keep-with-next
   3399          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   3400          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   084C         MOV.W   R12, R8
   3401            zclReadCmd_t *readCmd;
   3402            zclReadRspCmd_t *readRspCmd;
   3403            zclAttrRec_t attrRec;
   3404            uint16 len;
   3405          
   3406            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   000006   174C0C00     MOV.W   0xc(R12), R7
   3407          
   3408            // calculate the length of the response status record
   3409            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   3410          
   3411            readRspCmd = osal_mem_alloc( len );
   \   00000A   6F47         MOV.B   @R7, R15
   \   00000C   2C43         MOV.W   #0x2, R12
   \   00000E                RPT     #0x6
   \   00000E   45180C5F     ADDX.W  R15, R12
   \   000012   ........     CALLA   #osal_mem_alloc
   \   000016   064C         MOV.W   R12, R6
   3412            if ( readRspCmd == NULL )
   \   000018   0C93         CMP.W   #0x0, R12
   \   00001A   0220         JNE     ??zclProcessInReadCmd_2
   3413            {
   3414              return FALSE; // EMBEDDED RETURN
   \   00001C   4C43         MOV.B   #0x0, R12
   \   00001E   5E3C         JMP     ??zclProcessInReadCmd_3
   3415            }
   3416          
   3417            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_2:
   \   000020   EC470000     MOV.B   @R7, 0(R12)
   3418            for ( uint8 i = 0; i < readCmd->numAttr; i++ )
   \   000024   4443         MOV.B   #0x0, R4
   \   000026   043C         JMP     ??zclProcessInReadCmd_4
   3419            {
   3420              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   3421          
   3422              statusRec->attrID = readCmd->attrID[i];
   3423          
   3424              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3425                                   readCmd->attrID[i], &attrRec ) )
   3426              {
   3427                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   3428                {
   3429                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint,
   3430                                                        &(pInMsg->msg->srcAddr), &attrRec );
   3431                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   3432                  {
   3433                    statusRec->data = attrRec.attr.dataPtr;
   3434                    statusRec->dataType = attrRec.attr.dataType;
   3435                  }
   3436                }
   3437                else
   3438                {
   3439                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   3440                }
   3441              }
   3442              else
   3443              {
   3444                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_0:
   \   000028   F94086000200 MOV.B   #0x86, 0x2(R9)
   3445              }
   \                     ??zclProcessInReadCmd_1:
   \   00002E   5453         ADD.B   #0x1, R4
   \                     ??zclProcessInReadCmd_4:
   \   000030   6497         CMP.B   @R7, R4
   \   000032   3F2C         JC      ??zclProcessInReadCmd_5
   \   000034   4F44         MOV.B   R4, R15
   \   000036   0B4F         MOV.W   R15, R11
   \   000038                RPT     #0x5
   \   000038   44180B5F     ADDX.W  R15, R11
   \   00003C   0946         MOV.W   R6, R9
   \   00003E   095B         ADD.W   R11, R9
   \   000040   2953         ADD.W   #0x2, R9
   \   000042   0F5F         RLA.W   R15
   \   000044   0B47         MOV.W   R7, R11
   \   000046   0B5F         ADD.W   R15, R11
   \   000048   2B53         ADD.W   #0x2, R11
   \   00004A   A94B0000     MOV.W   @R11, 0(R9)
   \   00004E   2A48         MOV.W   @R8, R10
   \   000050   0F41         MOV.W   SP, R15
   \   000052   0F53         ADD.W   #0x0, R15
   \   000054   2E4B         MOV.W   @R11, R14
   \   000056   1D4A0400     MOV.W   0x4(R10), R13
   \   00005A   5C4A1400     MOV.B   0x14(R10), R12
   \   00005E   ........     CALLA   #??Subroutine10_0
   \                     ??CrossCallReturnLabel_33:
   \   000062   E227         JEQ     ??zclProcessInReadCmd_0
   \   000064   D1B30500     BIT.B   #0x1, 0x5(SP)
   \   000068   2028         JNC     ??zclProcessInReadCmd_6
   \   00006A   2F48         MOV.W   @R8, R15
   \   00006C   054F         MOV.W   R15, R5
   \   00006E   35500600     ADD.W   #0x6, R5
   \   000072   F1B010000500 BIT.B   #0x10, 0x5(SP)
   \   000078   0C28         JNC     ??zclProcessInReadCmd_7
   \   00007A   5C4F1400     MOV.B   0x14(R15), R12
   \   00007E   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_18:
   \   000082   0724         JEQ     ??zclProcessInReadCmd_7
   \   000084   5E43         MOV.B   #0x1, R14
   \   000086   0D41         MOV.W   SP, R13
   \   000088   0D53         ADD.W   #0x0, R13
   \   00008A   0C45         MOV.W   R5, R12
   \   00008C   ........     CALLA   #?IndCallR11
   \   000090   013C         JMP     ??zclProcessInReadCmd_8
   \                     ??zclProcessInReadCmd_7:
   \   000092   4C43         MOV.B   #0x0, R12
   \                     ??zclProcessInReadCmd_8:
   \   000094   C94C0200     MOV.B   R12, 0x2(R9)
   \   000098   4C93         CMP.B   #0x0, R12
   \   00009A   C923         JNE     ??zclProcessInReadCmd_1
   \   00009C   994106000400 MOV.W   0x6(SP), 0x4(R9)
   \   0000A2   D94104000300 MOV.B   0x4(SP), 0x3(R9)
   \   0000A8   C23F         JMP     ??zclProcessInReadCmd_1
   \                     ??zclProcessInReadCmd_6:
   \   0000AA   F9408F000200 MOV.B   #0x8f, 0x2(R9)
   \   0000B0   BE3F         JMP     ??zclProcessInReadCmd_1
   3446            }
   3447          
   3448            // Build and send Read Response command
   3449            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   3450                             readRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3451                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_5:
   \   0000B2   2A48         MOV.W   @R8, R10
   \   0000B4   58120600     PUSH.B  0x6(R8)
   \   0000B8   5312         PUSH.B  #0x1
   \   0000BA   5312         PUSH.B  #0x1
   \   0000BC   0F46         MOV.W   R6, R15
   \   0000BE   1E4A0400     MOV.W   0x4(R10), R14
   \   0000C2   0D4A         MOV.W   R10, R13
   \   0000C4   3D500600     ADD.W   #0x6, R13
   \   0000C8   5C4A1400     MOV.B   0x14(R10), R12
   \   0000CC   ........     CALLA   #zcl_SendReadRsp
   3452            osal_mem_free( readRspCmd );
   \   0000D0   0C46         MOV.W   R6, R12
   \   0000D2   ........     CALLA   #osal_mem_free
   3453          
   3454            return TRUE;
   \   0000D6   5C43         MOV.B   #0x1, R12
   \   0000D8   31500600     ADD.W   #0x6, SP
   \                     ??zclProcessInReadCmd_3:
   \   0000DC   ....         JMP     ?Subroutine1
   3455          }
   3456          #endif // ZCL_READ
   3457          
   3458          #ifdef ZCL_WRITE
   3459          /*********************************************************************
   3460           * @fn      processInWriteCmd
   3461           *
   3462           * @brief   Process the "Profile" Write and Write No Response Commands
   3463           *
   3464           * @param   pInMsg - incoming message to process
   3465           *
   3466           * @return  TRUE if command processed. FALSE, otherwise.
   3467           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine10:
   \   000000   2E44         MOV.W   @R4, R14
   \   000002                REQUIRE ??Subroutine26_0
   \   000002                // Fall through to label ??Subroutine26_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine26_0:
   \   000000   1D4C0400     MOV.W   0x4(R12), R13
   \   000004   5C4C1400     MOV.B   0x14(R12), R12
   \   000008                REQUIRE ??Subroutine10_0
   \   000008                // Fall through to label ??Subroutine10_0

   \                                 In  segment CODE, align 2, keep-with-next
   3468          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   3469          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0B4C         MOV.W   R12, R11
   3470            zclWriteCmd_t *writeCmd;
   3471            zclWriteRspCmd_t *writeRspCmd;
   3472            uint8 sendRsp = FALSE;
   \   000006   4943         MOV.B   #0x0, R9
   3473            uint8 j = 0;
   \   000008   4A43         MOV.B   #0x0, R10
   3474          
   3475            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   00000A   154C0C00     MOV.W   0xc(R12), R5
   3476            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \   00000E   EC930700     CMP.B   #0x2, 0x7(R12)
   \   000012   0820         JNE     ??zclProcessInWriteCmd_3
   3477            {
   3478              // We need to send a response back - allocate space for it
   3479              writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t )
   3480                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   000014   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_1:
   \   000018   084C         MOV.W   R12, R8
   3481              if ( writeRspCmd == NULL )
   \   00001A   0C93         CMP.W   #0x0, R12
   \   00001C   0220         JNE     ??zclProcessInWriteCmd_4
   3482              {
   3483                return FALSE; // EMBEDDED RETURN
   \   00001E   4C43         MOV.B   #0x0, R12
   \   000020   5D3C         JMP     ??zclProcessInWriteCmd_5
   3484              }
   3485          
   3486              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_4:
   \   000022   5943         MOV.B   #0x1, R9
   3487            }
   3488          
   3489            for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_3:
   \   000024   4643         MOV.B   #0x0, R6
   \   000026   093C         JMP     ??zclProcessInWriteCmd_6
   3490            {
   3491              zclAttrRec_t attrRec;
   3492              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   3493          
   3494              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3495                                   statusRec->attrID, &attrRec ) )
   3496              {
   3497                if ( statusRec->dataType == attrRec.attr.dataType )
   3498                {
   3499                  uint8 status;
   3500          
   3501                  // Write the new attribute value
   3502                  if ( attrRec.attr.dataPtr != NULL )
   3503                  {
   3504                    status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3505                                               &attrRec, statusRec );
   3506                  }
   3507                  else // Use CB
   3508                  {
   3509                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3510                                                      &attrRec, statusRec->attrData );
   3511                  }
   3512          
   3513                  // If successful, a write attribute status record shall NOT be generated
   3514                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   3515                  {
   3516                    // Attribute is read only - move on to the next write attribute record
   3517                    writeRspCmd->attrList[j].status = status;
   3518                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3519                  }
   3520                }
   3521                else
   3522                {
   3523                  // Attribute data type is incorrect - move on to the next write attribute record
   3524                  if ( sendRsp )
   3525                  {
   3526                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   3527                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3528                  }
   3529                }
   3530              }
   3531              else
   3532              {
   3533                // Attribute is not supported - move on to the next write attribute record
   3534                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_0:
   \   000028   59B3         BIT.B   #0x1, R9
   \   00002A   0628         JNC     ??zclProcessInWriteCmd_1
   3535                {
   3536                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   00002C   F74086000200 MOV.B   #0x86, 0x2(R7)
   3537                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \                     ??zclProcessInWriteCmd_2:
   \   000032   A7440400     MOV.W   @R4, 0x4(R7)
   \   000036   5A53         ADD.B   #0x1, R10
   3538                }
   3539              }
   \                     ??zclProcessInWriteCmd_1:
   \   000038   5653         ADD.B   #0x1, R6
   \                     ??zclProcessInWriteCmd_6:
   \   00003A   6695         CMP.B   @R5, R6
   \   00003C   312C         JC      ??zclProcessInWriteCmd_7
   \   00003E   0F46         MOV.W   R6, R15
   \   000040                RPT     #0x5
   \   000040   44180F56     ADDX.W  R6, R15
   \   000044   0445         MOV.W   R5, R4
   \   000046   045F         ADD.W   R15, R4
   \   000048   2453         ADD.W   #0x2, R4
   \   00004A   4F4A         MOV.B   R10, R15
   \   00004C   5F06         RLAM.W  #0x2, R15
   \   00004E   0748         MOV.W   R8, R7
   \   000050   075F         ADD.W   R15, R7
   \   000052   2C4B         MOV.W   @R11, R12
   \   000054   0F41         MOV.W   SP, R15
   \   000056   0F53         ADD.W   #0x0, R15
   \   000058   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_30:
   \   00005C   E527         JEQ     ??zclProcessInWriteCmd_0
   \   00005E   D49104000200 CMP.B   0x4(SP), 0x2(R4)
   \   000064   1720         JNE     ??zclProcessInWriteCmd_8
   \   000066   2C4B         MOV.W   @R11, R12
   \   000068   81930600     CMP.W   #0x0, 0x6(SP)
   \   00006C   0624         JEQ     ??zclProcessInWriteCmd_9
   \   00006E   0F44         MOV.W   R4, R15
   \   000070   0E41         MOV.W   SP, R14
   \   000072   0E53         ADD.W   #0x0, R14
   \   000074   ........     CALLA   #?Subroutine15
   \                     ??CrossCallReturnLabel_6:
   \   000078   063C         JMP     ??zclProcessInWriteCmd_10
   \                     ??zclProcessInWriteCmd_9:
   \   00007A   1F440400     MOV.W   0x4(R4), R15
   \   00007E   0E41         MOV.W   SP, R14
   \   000080   0E53         ADD.W   #0x0, R14
   \   000082   ........     CALLA   #?Subroutine16
   \                     ??zclProcessInWriteCmd_10:
   \   000086   59B3         BIT.B   #0x1, R9
   \   000088   D72B         JNC     ??zclProcessInWriteCmd_1
   \   00008A   4C93         CMP.B   #0x0, R12
   \   00008C   D527         JEQ     ??zclProcessInWriteCmd_1
   \   00008E   C74C0200     MOV.B   R12, 0x2(R7)
   \   000092   CF3F         JMP     ??zclProcessInWriteCmd_2
   \                     ??zclProcessInWriteCmd_8:
   \   000094   59B3         BIT.B   #0x1, R9
   \   000096   D02B         JNC     ??zclProcessInWriteCmd_1
   \   000098   F7408D000200 MOV.B   #0x8d, 0x2(R7)
   \   00009E   C93F         JMP     ??zclProcessInWriteCmd_2
   3540            } // for loop
   3541          
   3542            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_7:
   \   0000A0   59B3         BIT.B   #0x1, R9
   \   0000A2   1B28         JNC     ??zclProcessInWriteCmd_11
   3543            {
   3544              writeRspCmd->numAttr = j;
   \   0000A4   C84A0000     MOV.B   R10, 0(R8)
   3545              if ( writeRspCmd->numAttr == 0 )
   \   0000A8   4A93         CMP.B   #0x0, R10
   \   0000AA   0420         JNE     ??zclProcessInWriteCmd_12
   3546              {
   3547                // Since all records were written successful, include a single status record
   3548                // in the resonse command with the status field set to SUCCESS and the
   3549                // attribute ID field omitted.
   3550                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0000AC   C8430200     MOV.B   #0x0, 0x2(R8)
   3551                writeRspCmd->numAttr = 1;
   \   0000B0   D8430000     MOV.B   #0x1, 0(R8)
   3552              }
   3553          
   3554              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3555                                pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3556                                true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteCmd_12:
   \   0000B4   274B         MOV.W   @R11, R7
   \   0000B6   5B120600     PUSH.B  0x6(R11)
   \   0000BA   5312         PUSH.B  #0x1
   \   0000BC   5312         PUSH.B  #0x1
   \   0000BE   0F48         MOV.W   R8, R15
   \   0000C0   1E470400     MOV.W   0x4(R7), R14
   \   0000C4   0D47         MOV.W   R7, R13
   \   0000C6   3D500600     ADD.W   #0x6, R13
   \   0000CA   5C471400     MOV.B   0x14(R7), R12
   \   0000CE   ........     CALLA   #zcl_SendWriteRsp
   3557              osal_mem_free( writeRspCmd );
   \   0000D2   ........     CALLA   #??Subroutine25_0
   3558            }
   \                     ??CrossCallReturnLabel_26:
   \   0000D6   31500600     ADD.W   #0x6, SP
   3559          
   3560            return TRUE;
   \                     ??zclProcessInWriteCmd_11:
   \   0000DA   5C43         MOV.B   #0x1, R12
   \                     ??zclProcessInWriteCmd_5:
   \   0000DC                REQUIRE ?Subroutine1
   \   0000DC                // Fall through to label ?Subroutine1
   3561          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine16:
   \   000000   0D4C         MOV.W   R12, R13
   \   000002   3D500600     ADD.W   #0x6, R13
   \   000006   5C4C1400     MOV.B   0x14(R12), R12
   \   00000A   ........     BRA     #zclWriteAttrDataUsingCB

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine15:
   \   000000   0D4C         MOV.W   R12, R13
   \   000002   3D500600     ADD.W   #0x6, R13
   \   000006   5C4C1400     MOV.B   0x14(R12), R12
   \   00000A   ........     BRA     #zclWriteAttrData

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   6C45         MOV.B   @R5, R12
   \   000002   5C06         RLAM.W  #0x2, R12
   \   000004   2C53         ADD.W   #0x2, R12
   \   000006   ........     BRA     #osal_mem_alloc
   3562          
   3563          /*********************************************************************
   3564           * @fn      zclRevertWriteUndividedCmd
   3565           *
   3566           * @brief   Revert the "Profile" Write Undevided Command
   3567           *
   3568           * @param   pInMsg - incoming message to process
   3569           * @param   curWriteRec - old data
   3570           * @param   numAttr - number of attributes to be reverted
   3571           *
   3572           * @return  none
   3573           */

   \                                 In  segment CODE, align 2
   3574          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   3575                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   3576          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0B4C         MOV.W   R12, R11
   \   000006   084D         MOV.W   R13, R8
   \   000008   094E         MOV.W   R14, R9
   3577            for ( uint8 i = 0; i < numAttr; i++ )
   \   00000A   4A43         MOV.B   #0x0, R10
   \   00000C   0C3C         JMP     ??zclRevertWriteUndividedCmd_2
   3578            {
   3579              zclAttrRec_t attrRec;
   3580              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   3581          
   3582              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3583                                    statusRec->attrID, &attrRec ) )
   3584              {
   3585                break; // should never happen
   3586              }
   3587          
   3588              if ( attrRec.attr.dataPtr != NULL )
   3589              {
   3590                // Just copy the old data back - no need to validate the data
   3591                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   3592                osal_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   3593              }
   3594              else // Use CB
   3595              {
   3596                // Write the old data back
   3597                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3598                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_0:
   \   00000E   264B         MOV.W   @R11, R6
   \   000010   0F4D         MOV.W   R13, R15
   \   000012   0E41         MOV.W   SP, R14
   \   000014   0E53         ADD.W   #0x0, R14
   \   000016   0D46         MOV.W   R6, R13
   \   000018   3D500600     ADD.W   #0x6, R13
   \   00001C   5C461400     MOV.B   0x14(R6), R12
   \   000020   ........     CALLA   #zclWriteAttrDataUsingCB
   3599              }
   \                     ??zclRevertWriteUndividedCmd_1:
   \   000024   5A53         ADD.B   #0x1, R10
   \                     ??zclRevertWriteUndividedCmd_2:
   \   000026   0A99         CMP.W   R9, R10
   \   000028   1D2C         JC      ??zclRevertWriteUndividedCmd_3
   \   00002A   0F4A         MOV.W   R10, R15
   \   00002C                RPT     #0x5
   \   00002C   44180F5A     ADDX.W  R10, R15
   \   000030   0648         MOV.W   R8, R6
   \   000032   065F         ADD.W   R15, R6
   \   000034   2C4B         MOV.W   @R11, R12
   \   000036   0F41         MOV.W   SP, R15
   \   000038   0F53         ADD.W   #0x0, R15
   \   00003A   2E46         MOV.W   @R6, R14
   \   00003C   ........     CALLA   #??Subroutine26_0
   \                     ??CrossCallReturnLabel_31:
   \   000040   1124         JEQ     ??zclRevertWriteUndividedCmd_3
   \   000042   1D460400     MOV.W   0x4(R6), R13
   \   000046   17410600     MOV.W   0x6(SP), R7
   \   00004A   0793         CMP.W   #0x0, R7
   \   00004C   E027         JEQ     ??zclRevertWriteUndividedCmd_0
   \   00004E   5C410400     MOV.B   0x4(SP), R12
   \   000052   ........     CALLA   #zclGetAttrDataLength
   \   000056   0E4C         MOV.W   R12, R14
   \   000058   1D460400     MOV.W   0x4(R6), R13
   \   00005C   0C47         MOV.W   R7, R12
   \   00005E   ........     CALLA   #osal_memcpy
   \   000062   E03F         JMP     ??zclRevertWriteUndividedCmd_1
   3600            } // for loop
   3601          }
   \                     ??zclRevertWriteUndividedCmd_3:
   \   000064   3152         ADD.W   #0x8, SP
   \   000066   5617         POPM.W  #0x6, R11
   \   000068   1001         RETA
   3602          
   3603          /*********************************************************************
   3604           * @fn      zclProcessInWriteUndividedCmd
   3605           *
   3606           * @brief   Process the "Profile" Write Undivided Command
   3607           *
   3608           * @param   pInMsg - incoming message to process
   3609           *
   3610           * @return  TRUE if command processed. FALSE, otherwise.
   3611           */

   \                                 In  segment CODE, align 2
   3612          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   3613          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   31800C00     SUB.W   #0xc, SP
   \   000006   084C         MOV.W   R12, R8
   3614            zclWriteCmd_t *writeCmd;
   3615            zclWriteRspCmd_t *writeRspCmd;
   3616            zclAttrRec_t attrRec;
   3617            uint16 dataLen;
   3618            uint16 curLen = 0;
   \   000008   0743         MOV.W   #0x0, R7
   3619            uint8 j = 0;
   \   00000A   4A43         MOV.B   #0x0, R10
   3620          
   3621            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   00000C   154C0C00     MOV.W   0xc(R12), R5
   3622          
   3623            // Allocate space for Write Response Command
   3624            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t )
   3625                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \   000010   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_2:
   \   000014   094C         MOV.W   R12, R9
   3626            if ( writeRspCmd == NULL )
   \   000016   0C93         CMP.W   #0x0, R12
   \   000018   3824         JEQ     ??zclProcessInWriteUndividedCmd_6
   3627            {
   3628              return FALSE; // EMBEDDED RETURN
   3629            }
   3630          
   3631            // If any attribute cannot be written, no attribute values are changed. Hence,
   3632            // make sure all the attributes are supported and writable
   3633            for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \   00001A   4B43         MOV.B   #0x0, R11
   \   00001C   0C3C         JMP     ??zclProcessInWriteUndividedCmd_9
   3634            {
   3635              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   3636          
   3637              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3638                                    statusRec->attrID, &attrRec ) )
   3639              {
   3640                // Attribute is not supported - stop here
   3641                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   3642                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3643                break;
   3644              }
   3645          
   3646              if ( statusRec->dataType != attrRec.attr.dataType )
   3647              {
   3648                // Attribute data type is incorrect - stope here
   3649                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   3650                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3651                break;
   3652              }
   3653          
   3654              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   3655              {
   3656                // Attribute is not writable - stop here
   3657                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   3658                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3659                break;
   3660              }
   3661          
   3662              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   3663              {
   3664                // Not authorized to write - stop here
   3665                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   3666                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3667                break;
   3668              }
   3669          
   3670              // Attribute Data length
   3671              if ( attrRec.attr.dataPtr != NULL )
   3672              {
   3673                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   3674              }
   3675              else // Use CB
   3676              {
   3677                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3678                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   00001E   2F48         MOV.W   @R8, R15
   \   000020   2E46         MOV.W   @R6, R14
   \   000022   1D4F0400     MOV.W   0x4(R15), R13
   \   000026   5C4F1400     MOV.B   0x14(R15), R12
   \   00002A   ........     CALLA   #zclGetAttrDataLengthUsingCB
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   00002E   814C0000     MOV.W   R12, 0(SP)
   3679              }
   3680          
   3681              // add padding if needed
   3682              if ( PADDING_NEEDED( dataLen ) )
   \   000032   ........     CALLA   #?Subroutine7
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   000036   6B95         CMP.B   @R5, R11
   \   000038   172C         JC      ??zclProcessInWriteUndividedCmd_0
   \   00003A   0F4B         MOV.W   R11, R15
   \   00003C                RPT     #0x5
   \   00003C   44180F5B     ADDX.W  R11, R15
   \   000040   0645         MOV.W   R5, R6
   \   000042   065F         ADD.W   R15, R6
   \   000044   2653         ADD.W   #0x2, R6
   \   000046   2448         MOV.W   @R8, R4
   \   000048   0F41         MOV.W   SP, R15
   \   00004A   2F52         ADD.W   #0x4, R15
   \   00004C   2E46         MOV.W   @R6, R14
   \   00004E   1D440400     MOV.W   0x4(R4), R13
   \   000052   5C441400     MOV.B   0x14(R4), R12
   \   000056   ........     CALLA   #??Subroutine10_0
   \                     ??CrossCallReturnLabel_32:
   \   00005A   1920         JNE     ??zclProcessInWriteUndividedCmd_10
   \   00005C   F94086000200 MOV.B   #0x86, 0x2(R9)
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   000062   A9460400     MOV.W   @R6, 0x4(R9)
   \   000066   5A43         MOV.B   #0x1, R10
   3683              {
   3684                dataLen++;
   3685              }
   3686          
   3687              curLen += dataLen;
   3688            } // for loop
   3689          
   3690            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   000068   C94A0000     MOV.B   R10, 0(R9)
   3691            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   00006C   4A93         CMP.B   #0x0, R10
   \   00006E   9020         JNE     ??zclProcessInWriteUndividedCmd_11
   3692            {
   3693              uint8 *curDataPtr;
   3694              zclWriteRec_t *curWriteRec;
   3695          
   3696              // calculate the length of the current data header
   3697              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   000070   4B4A         MOV.B   R10, R11
   \   000072                RPT     #0x5
   \   000072   44184B5A     ADDX.B  R10, R11
   3698          
   3699              // Allocate space to keep a copy of the current data
   3700              curWriteRec = (zclWriteRec_t *) osal_mem_alloc( hdrLen + curLen );
   \   000076   4C4B         MOV.B   R11, R12
   \   000078   0C57         ADD.W   R7, R12
   \   00007A   ........     CALLA   #osal_mem_alloc
   \   00007E   064C         MOV.W   R12, R6
   3701              if ( curWriteRec == NULL )
   \   000080   0C93         CMP.W   #0x0, R12
   \   000082   2420         JNE     ??zclProcessInWriteUndividedCmd_12
   3702              {
   3703                osal_mem_free(writeRspCmd );
   \   000084   0C49         MOV.W   R9, R12
   \   000086   ........     CALLA   #osal_mem_free
   3704                return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   00008A   4C43         MOV.B   #0x0, R12
   \   00008C   913C         JMP     ??zclProcessInWriteUndividedCmd_13
   3705              }
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   00008E   5C410800     MOV.B   0x8(SP), R12
   \   000092   C69C0200     CMP.B   R12, 0x2(R6)
   \   000096   0424         JEQ     ??zclProcessInWriteUndividedCmd_14
   \   000098   F9408D000200 MOV.B   #0x8d, 0x2(R9)
   \   00009E   E13F         JMP     ??zclProcessInWriteUndividedCmd_4
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   0000A0   E1B30900     BIT.B   #0x2, 0x9(SP)
   \   0000A4   042C         JC      ??zclProcessInWriteUndividedCmd_15
   \   0000A6   F94088000200 MOV.B   #0x88, 0x2(R9)
   \   0000AC   DA3F         JMP     ??zclProcessInWriteUndividedCmd_4
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0000AE   F1B020000900 BIT.B   #0x20, 0x9(SP)
   \   0000B4   0428         JNC     ??zclProcessInWriteUndividedCmd_16
   \   0000B6   F9407E000200 MOV.B   #0x7e, 0x2(R9)
   \   0000BC   D23F         JMP     ??zclProcessInWriteUndividedCmd_4
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   0000BE   1D410A00     MOV.W   0xa(SP), R13
   \   0000C2   0D93         CMP.W   #0x0, R13
   \   0000C4   AC27         JEQ     ??zclProcessInWriteUndividedCmd_1
   \   0000C6   ........     CALLA   #zclGetAttrDataLength
   \   0000CA   B13F         JMP     ??zclProcessInWriteUndividedCmd_17
   3706          
   3707              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   0000CC   4B4B         MOV.B   R11, R11
   \   0000CE   074C         MOV.W   R12, R7
   \   0000D0   075B         ADD.W   R11, R7
   3708          
   3709              // Write the new data over
   3710              for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \   0000D2   4B43         MOV.B   #0x0, R11
   \   0000D4   023C         JMP     ??zclProcessInWriteUndividedCmd_18
   3711              {
   3712                uint8 status;
   3713                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   3714                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   3715          
   3716                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3717                                      statusRec->attrID, &attrRec ) )
   3718                {
   3719                  break; // should never happen
   3720                }
   3721          
   3722                // Keep a copy of the current data before before writing the new data over
   3723                curStatusRec->attrID = statusRec->attrID;
   3724                curStatusRec->attrData = curDataPtr;
   3725          
   3726                if ( attrRec.attr.dataPtr != NULL )
   3727                {
   3728                  // Read the current value
   3729                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   3730          
   3731                  // Write the new attribute value
   3732                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3733                                             &attrRec, statusRec );
   3734                }
   3735                else // Use CBs
   3736                {
   3737                  // Read the current value
   3738                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3739                                          statusRec->attrID, curDataPtr, &dataLen );
   3740                  // Write the new attribute value
   3741                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3742                                                    &attrRec, statusRec->attrData );
   3743                }
   3744          
   3745                // If successful, a write attribute status record shall NOT be generated
   3746                if ( status != ZCL_STATUS_SUCCESS )
   3747                {
   3748                  writeRspCmd->attrList[j].status = status;
   3749                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3750          
   3751                  // Since this write failed, we need to revert all the pervious writes
   3752                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   3753                  break;
   3754                }
   3755          
   3756                // add padding if needed
   3757                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   0000D6   ........     CALLA   #?Subroutine7
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   0000DA   6B95         CMP.B   @R5, R11
   \   0000DC   4E2C         JC      ??zclProcessInWriteUndividedCmd_19
   \   0000DE   0F4B         MOV.W   R11, R15
   \   0000E0                RPT     #0x5
   \   0000E0   44180F5B     ADDX.W  R11, R15
   \   0000E4   0445         MOV.W   R5, R4
   \   0000E6   045F         ADD.W   R15, R4
   \   0000E8   2453         ADD.W   #0x2, R4
   \   0000EA   0E46         MOV.W   R6, R14
   \   0000EC   0E5F         ADD.W   R15, R14
   \   0000EE   814E0200     MOV.W   R14, 0x2(SP)
   \   0000F2   2C48         MOV.W   @R8, R12
   \   0000F4   0F41         MOV.W   SP, R15
   \   0000F6   2F52         ADD.W   #0x4, R15
   \   0000F8   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_29:
   \   0000FC   3E24         JEQ     ??zclProcessInWriteUndividedCmd_19
   \   0000FE   1F410200     MOV.W   0x2(SP), R15
   \   000102   AF440000     MOV.W   @R4, 0(R15)
   \   000106   1F410200     MOV.W   0x2(SP), R15
   \   00010A   8F470400     MOV.W   R7, 0x4(R15)
   \   00010E   81930A00     CMP.W   #0x0, 0xa(SP)
   \   000112   0E24         JEQ     ??zclProcessInWriteUndividedCmd_20
   \   000114   0E41         MOV.W   SP, R14
   \   000116   0E53         ADD.W   #0x0, R14
   \   000118   0D41         MOV.W   SP, R13
   \   00011A   2D52         ADD.W   #0x4, R13
   \   00011C   0C47         MOV.W   R7, R12
   \   00011E   ........     CALLA   #zclReadAttrData
   \   000122   2C48         MOV.W   @R8, R12
   \   000124   0F44         MOV.W   R4, R15
   \   000126   0E41         MOV.W   SP, R14
   \   000128   2E52         ADD.W   #0x4, R14
   \   00012A   ........     CALLA   #?Subroutine15
   \                     ??CrossCallReturnLabel_7:
   \   00012E   153C         JMP     ??zclProcessInWriteUndividedCmd_21
   \                     ??zclProcessInWriteUndividedCmd_20:
   \   000130   2C48         MOV.W   @R8, R12
   \   000132   0F41         MOV.W   SP, R15
   \   000134   0F53         ADD.W   #0x0, R15
   \   000136   0F12         PUSH.W  R15
   \   000138   0F47         MOV.W   R7, R15
   \   00013A   2E44         MOV.W   @R4, R14
   \   00013C   1D4C0400     MOV.W   0x4(R12), R13
   \   000140   5C4C1400     MOV.B   0x14(R12), R12
   \   000144   ........     CALLA   #zclReadAttrDataUsingCB
   \   000148   2C48         MOV.W   @R8, R12
   \   00014A   1F440400     MOV.W   0x4(R4), R15
   \   00014E   0E41         MOV.W   SP, R14
   \   000150   3E500600     ADD.W   #0x6, R14
   \   000154   ........     CALLA   #?Subroutine16
   \                     ??CrossCallReturnLabel_8:
   \   000158   2153         ADD.W   #0x2, SP
   \                     ??zclProcessInWriteUndividedCmd_21:
   \   00015A   4C93         CMP.B   #0x0, R12
   \   00015C   BC27         JEQ     ??zclProcessInWriteUndividedCmd_3
   \   00015E   474A         MOV.B   R10, R7
   \   000160   5706         RLAM.W  #0x2, R7
   \   000162   0F49         MOV.W   R9, R15
   \   000164   0F57         ADD.W   R7, R15
   \   000166   CF4C0200     MOV.B   R12, 0x2(R15)
   \   00016A   AF440400     MOV.W   @R4, 0x4(R15)
   \   00016E   5A53         ADD.B   #0x1, R10
   \   000170   4E4B         MOV.B   R11, R14
   \   000172   0D46         MOV.W   R6, R13
   \   000174   0C48         MOV.W   R8, R12
   \   000176   ........     CALLA   #zclRevertWriteUndividedCmd
   3758                {
   3759                  dataLen++;
   3760                }
   3761          
   3762                curDataPtr += dataLen;
   3763              } // for loop
   3764          
   3765              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_19:
   \   00017A   C94A0000     MOV.B   R10, 0(R9)
   3766              if ( writeRspCmd->numAttr  == 0 )
   \   00017E   4A93         CMP.B   #0x0, R10
   \   000180   0420         JNE     ??zclProcessInWriteUndividedCmd_22
   3767              {
   3768                // Since all records were written successful, include a single status record
   3769                // in the resonse command with the status field set to SUCCESS and the
   3770                // attribute ID field omitted.
   3771                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000182   C9430200     MOV.B   #0x0, 0x2(R9)
   3772                writeRspCmd->numAttr = 1;
   \   000186   D9430000     MOV.B   #0x1, 0(R9)
   3773              }
   3774          
   3775              osal_mem_free( curWriteRec );
   \                     ??zclProcessInWriteUndividedCmd_22:
   \   00018A   0C46         MOV.W   R6, R12
   \   00018C   ........     CALLA   #osal_mem_free
   3776            }
   3777          
   3778            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3779                              pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3780                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000190   2B48         MOV.W   @R8, R11
   \   000192   58120600     PUSH.B  0x6(R8)
   \   000196   5312         PUSH.B  #0x1
   \   000198   5312         PUSH.B  #0x1
   \   00019A   0F49         MOV.W   R9, R15
   \   00019C   ........     CALLA   #?Subroutine17
   \                     ??CrossCallReturnLabel_9:
   \   0001A0   ........     CALLA   #zcl_SendWriteRsp
   3781            osal_mem_free( writeRspCmd );
   \   0001A4   0C49         MOV.W   R9, R12
   \   0001A6   ........     CALLA   #osal_mem_free
   3782          
   3783            return TRUE;
   \   0001AA   5C43         MOV.B   #0x1, R12
   \   0001AC   31500600     ADD.W   #0x6, SP
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   0001B0   31500C00     ADD.W   #0xc, SP
   \   0001B4   7417         POPM.W  #0x8, R11
   \   0001B6   1001         RETA
   3784          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine7:
   \   000000   91B30400     BIT.W   #0x1, 0x4(SP)
   \   000004   0528         JNC     ??zclProcessInWriteUndividedCmd_7
   \   000006   1F410400     MOV.W   0x4(SP), R15
   \   00000A   1F53         ADD.W   #0x1, R15
   \   00000C   814F0400     MOV.W   R15, 0x4(SP)
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   000010   17510400     ADD.W   0x4(SP), R7
   \   000014   5B53         ADD.B   #0x1, R11
   \   000016   1001         RETA
   3785          #endif // ZCL_WRITE
   3786          
   3787          #ifdef ZCL_DISCOVER
   3788          /*********************************************************************
   3789           * @fn      zclProcessInDiscCmd
   3790           *
   3791           * @brief   Process the "Profile" Discover Command
   3792           *
   3793           * @param   pInMsg - incoming message to process
   3794           *
   3795           * @return  TRUE if command processed. FALSE, otherwise.
   3796           */
   3797          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   3798          {
   3799            zclDiscoverCmd_t *discoverCmd;
   3800            zclDiscoverRspCmd_t *discoverRspCmd;
   3801            uint8 discComplete = TRUE;
   3802            zclAttrRec_t attrRec;
   3803            uint16 attrID;
   3804            uint8 i;
   3805          
   3806            discoverCmd = (zclDiscoverCmd_t *)pInMsg->attrCmd;
   3807          
   3808            // Find out the number of attributes supported within the specified range
   3809            for ( i = 0, attrID = discoverCmd->startAttr; i < discoverCmd->maxAttrIDs; i++, attrID++ )
   3810            {
   3811              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3812              {
   3813                break;
   3814              }
   3815            }
   3816          
   3817            // Allocate space for the response command
   3818            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof (zclDiscoverRspCmd_t)
   3819                                                                   + sizeof ( zclDiscoverInfo_t ) * i );
   3820            if ( discoverRspCmd == NULL )
   3821            {
   3822              return FALSE; // EMEDDED RETURN
   3823            }
   3824          
   3825            discoverRspCmd->numAttr = i;
   3826            if ( discoverRspCmd->numAttr != 0 )
   3827            {
   3828              for ( i = 0, attrID = discoverCmd->startAttr; i < discoverRspCmd->numAttr; i++, attrID++ )
   3829              {
   3830                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3831                {
   3832                  break; // Attribute not supported
   3833                }
   3834          
   3835                discoverRspCmd->attrList[i].attrID = attrRec.attr.attrId;
   3836                discoverRspCmd->attrList[i].dataType = attrRec.attr.dataType;
   3837              }
   3838          
   3839              // Are there more attributes to be discovered?
   3840              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3841              {
   3842                discComplete = FALSE;
   3843              }
   3844            }
   3845          
   3846            discoverRspCmd->discComplete = discComplete;
   3847            zcl_SendDiscoverRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3848                                    pInMsg->msg->clusterId, discoverRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3849                                    true, pInMsg->hdr.transSeqNum );
   3850            osal_mem_free( discoverRspCmd );
   3851          
   3852            return TRUE;
   3853          }
   3854          #endif // ZCL_DISCOVER
   3855          
   3856          /*********************************************************************
   3857           * @fn      zclSendMsg
   3858           *
   3859           * @brief   Send an incoming message to the Application
   3860           *
   3861           * @param   pInMsg - incoming message to process
   3862           *
   3863           * @return  TRUE
   3864           */

   \                                 In  segment CODE, align 2
   3865          static uint8 zclSendMsg( zclIncoming_t *pInMsg )
   \                     zclSendMsg:
   3866          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   3867            zclIncomingMsg_t *pCmd;
   3868          
   3869            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000004   F293....     CMP.B   #0xff, &zcl_RegisteredMsgTaskID
   \   000008   2924         JEQ     ??zclSendMsg_0
   3870            {
   3871              return ( TRUE );
   3872            }
   3873          
   3874            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   00000A   3C401A00     MOV.W   #0x1a, R12
   \   00000E   ........     CALLA   #osal_msg_allocate
   \   000012   0B4C         MOV.W   R12, R11
   3875            if ( pCmd != NULL )
   \   000014   0C93         CMP.W   #0x0, R12
   \   000016   2224         JEQ     ??zclSendMsg_0
   3876            {
   3877              // fill in the message
   3878              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000018   FC4034000000 MOV.B   #0x34, 0(R12)
   3879              pCmd->zclHdr    = pInMsg->hdr;
   \   00001E   0F4A         MOV.W   R10, R15
   \   000020   2F53         ADD.W   #0x2, R15
   \   000022   BC4F0200     MOV.W   @R15+, 0x2(R12)
   \   000026   BC4F0400     MOV.W   @R15+, 0x4(R12)
   \   00002A   BC4F0600     MOV.W   @R15+, 0x6(R12)
   3880              pCmd->clusterId = pInMsg->msg->clusterId;
   \   00002E   2E4A         MOV.W   @R10, R14
   \   000030   9C4E04000800 MOV.W   0x4(R14), 0x8(R12)
   3881              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \   000036   3C500A00     ADD.W   #0xa, R12
   \   00003A   3E500600     ADD.W   #0x6, R14
   \   00003E   3D400600     MOV.W   #0x6, R13
   \   000042   ........     CALLA   #?CopyMemoryWords
   3882              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   000046   2F4A         MOV.W   @R10, R15
   \   000048   DB4F14001600 MOV.B   0x14(R15), 0x16(R11)
   3883              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00004E   9B4A0C001800 MOV.W   0xc(R10), 0x18(R11)
   3884          
   3885              // Application will free the attrCmd buffer
   3886              pInMsg->attrCmd = NULL;
   \   000054   8A430C00     MOV.W   #0x0, 0xc(R10)
   3887          
   3888              /* send message through task message */
   3889              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   000058   ........     CALLA   #?Subroutine5
   3890            }
   3891          
   3892            return ( TRUE );
   \                     ??zclSendMsg_0:
   \   00005C   5C43         MOV.B   #0x1, R12
   \   00005E   1A17         POPM.W  #0x2, R11
   \   000060   1001         RETA
   3893          }

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DC8 255
   3894          
   3895          /*********************************************************************
   3896          *********************************************************************/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     12   zclAuthorizeWrite
       12   -- Indirect call
       12   -> zclGetAuthorizeCB
      4   zclBuildHdr
     12   zclFindAttrRec
       12   -> zclFindAttrRecsList
      4   zclFindAttrRecsList
      8   zclFindClusterOption
      4   zclGetAttrDataLength
        4   -> zclGetDataTypeLength
     16   zclGetAttrDataLengthUsingCB
       16   -- Indirect call
       14   -> zclGetReadWriteCB
      4   zclGetAuthorizeCB
        4   -> zclFindAttrRecsList
      4   zclGetClusterOption
        4   -> zclFindClusterOption
      4   zclGetDataTypeLength
      4   zclGetReadWriteCB
        4   -> zclFindAttrRecsList
      8   zclParseHdr
        8   -> osal_memset
      6   zclParseInDefaultRspCmd
        6   -> osal_mem_alloc
      8   zclParseInReadCmd
        8   -> osal_mem_alloc
     20   zclParseInReadRspCmd
       20   -> osal_mem_alloc
       20   -> osal_memcpy
       20   -> zclGetAttrDataLength
     20   zclParseInWriteCmd
       20   -> osal_mem_alloc
       20   -> osal_memcpy
       20   -> zclGetAttrDataLength
     12   zclParseInWriteRspCmd
       12   -> osal_mem_alloc
     34   zclProcessInReadCmd
       28   -- Indirect call
       28   -> osal_mem_alloc
       34   -> osal_mem_free
       28   -> zclFindAttrRec
       28   -> zclGetAuthorizeCB
       34   -> zcl_SendReadRsp
     34   zclProcessInWriteCmd
       28   -> osal_mem_alloc
       34   -> osal_mem_free
       28   -> zclFindAttrRec
       28   -> zclWriteAttrData
       28   -> zclWriteAttrDataUsingCB
       34   -> zcl_SendWriteRsp
     38   zclProcessInWriteUndividedCmd
       32   -> osal_mem_alloc
       32   -> osal_mem_free
       38   -> osal_mem_free
       32   -> zclFindAttrRec
       32   -> zclGetAttrDataLength
       32   -> zclGetAttrDataLengthUsingCB
       32   -> zclReadAttrData
       34   -> zclReadAttrDataUsingCB
       32   -> zclRevertWriteUndividedCmd
       32   -> zclWriteAttrData
       34   -> zclWriteAttrDataUsingCB
       38   -> zcl_SendWriteRsp
     46   zclProcessMessageMSG
       38   -- Indirect call
       38   -> afFindEndPointDesc
       38   -> osal_mem_free
       38   -> zclGetClusterOption
       38   -> zclParseHdr
       38   -> zclSetSecurityOption
       40   -> zcl_DeviceOperational
       46   -> zcl_SendDefaultRspCmd
     12   zclReadAttrData
       12   -> osal_memcpy
       12   -> zclGetAttrDataLength
     18   zclReadAttrDataUsingCB
       18   -- Indirect call
       16   -> zclGetReadWriteCB
     24   zclRevertWriteUndividedCmd
       24   -> osal_memcpy
       24   -> zclFindAttrRec
       24   -> zclGetAttrDataLength
       24   -> zclWriteAttrDataUsingCB
      8   zclSendMsg
        8   -> osal_msg_allocate
        8   -> osal_msg_send
      4   zclSerializeData
        4   -> osal_buffer_uint32
        4   -> osal_memcpy
      6   zclSetSecurityOption
        6   -> zclFindClusterOption
     12   zclWriteAttrData
       12   -- Indirect call
       12   -> osal_memcpy
       12   -> zclAuthorizeWrite
       12   -> zclGetAttrDataLength
     14   zclWriteAttrDataUsingCB
       14   -- Indirect call
       12   -> zclAuthorizeWrite
       12   -> zclGetReadWriteCB
     14   zcl_DeviceOperational
       14   -> zclFindAttrRec
       14   -> zclReadAttrData
      4   zcl_Init
     36   zcl_SendCommand
       36   -> AF_DataRequest
       28   -> afFindEndPointDesc
       28   -> osal_mem_alloc
       36   -> osal_mem_free
       28   -> osal_memcpy
       28   -> osal_memset
       28   -> zclBuildHdr
       28   -> zclGetClusterOption
       30   -> zcl_DeviceOperational
     28   zcl_SendDefaultRspCmd
       28   -> zcl_SendCommand
     36   zcl_SendRead
       22   -> osal_mem_alloc
       36   -> osal_mem_free
       36   -> zcl_SendCommand
     38   zcl_SendReadRsp
       24   -> osal_mem_alloc
       38   -> osal_mem_free
       24   -> zclGetAttrDataLength
       24   -> zclGetAttrDataLengthUsingCB
       26   -> zclReadAttrDataUsingCB
       24   -> zclSerializeData
       38   -> zcl_SendCommand
     40   zcl_SendWriteRequest
       26   -> osal_mem_alloc
       40   -> osal_mem_free
       26   -> zclGetAttrDataLength
       26   -> zclSerializeData
       40   -> zcl_SendCommand
     36   zcl_SendWriteRsp
       22   -> osal_mem_alloc
       36   -> osal_mem_free
       36   -> zcl_SendCommand
      8   zcl_event_loop
        8   -> osal_msg_deallocate
        8   -> osal_msg_receive
        8   -> osal_msg_send
        8   -> zclProcessMessageMSG
      4   zcl_getRawAFMsg
     12   zcl_registerAttrList
       12   -> osal_mem_alloc
     12   zcl_registerClusterOptionList
       12   -> osal_mem_alloc
      4   zcl_registerForMsg
     12   zcl_registerPlugin
       12   -> osal_mem_alloc
     12   zcl_registerReadWriteCB
       12   -> zclFindAttrRecsList
      4   zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_RegisteredMsgTaskID>
       8  ??Subroutine10_0
       6  ??Subroutine25_0
       8  ??Subroutine26_0
      12  ??Subroutine4_0
      10  ??Subroutine8_0
       8  ??Subroutine9_0
       8  ?Subroutine0
       6  ?Subroutine1
       2  ?Subroutine10
      32  ?Subroutine11
      22  ?Subroutine12
      36  ?Subroutine13
       2  ?Subroutine14
      14  ?Subroutine15
      14  ?Subroutine16
      16  ?Subroutine17
      18  ?Subroutine18
      12  ?Subroutine19
       6  ?Subroutine2
      20  ?Subroutine20
      16  ?Subroutine21
      18  ?Subroutine22
       6  ?Subroutine3
       4  ?Subroutine4
      10  ?Subroutine5
      10  ?Subroutine6
      24  ?Subroutine7
      10  ?Subroutine8
       6  ?Subroutine9
       2  attrList
       2  clusterOptionList
       2  plugins
       2  rawAFMsg
      38  zclAuthorizeWrite
      80  zclBuildHdr
     112  zclCmdTable
      76  zclFindAttrRec
      26  zclFindAttrRecsList
      58  zclFindClusterOption
      54  zclGetAttrDataLength
      50  zclGetAttrDataLengthUsingCB
      20  zclGetAuthorizeCB
      22  zclGetClusterOption
     216  zclGetDataTypeLength
      22  zclGetReadWriteCB
     140  zclParseHdr
      26  zclParseInDefaultRspCmd
      64  zclParseInReadCmd
      84  zclParseInReadRspCmd
      66  zclParseInWriteCmd
      82  zclParseInWriteRspCmd
     222  zclProcessInReadCmd
     220  zclProcessInWriteCmd
     440  zclProcessInWriteUndividedCmd
     594  zclProcessMessageMSG
      48  zclReadAttrData
      62  zclReadAttrDataUsingCB
     106  zclRevertWriteUndividedCmd
      98  zclSendMsg
     254  zclSerializeData
      34  zclSetSecurityOption
      90  zclWriteAttrData
      68  zclWriteAttrDataUsingCB
      72  zcl_DeviceOperational
      18  zcl_Init
       1  zcl_RegisteredMsgTaskID
     270  zcl_SendCommand
      64  zcl_SendDefaultRspCmd
      88  zcl_SendRead
     250  zcl_SendReadRsp
     200  zcl_SendWriteRequest
     112  zcl_SendWriteRsp
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       4  zcl_ValidateAttrDataCB
      78  zcl_event_loop
       6  zcl_getRawAFMsg
      80  zcl_registerAttrList
      72  zcl_registerClusterOptionList
      18  zcl_registerForMsg
      78  zcl_registerPlugin
      46  zcl_registerReadWriteCB
      12  zcl_registerValidateAttrData

 
 5 188 bytes in segment CODE
   112 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
    15 bytes in segment DATA16_Z
 
 5 188 bytes of CODE  memory
   113 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none

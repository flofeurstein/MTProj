///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430      10/Jun/2013  16:27:33 /
// Copyright 1996-2013 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\m /
//                     ac\low_level\srf04\mac_tx.c                            /
//    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleLight\CC2520DB\..\..\..\T /
//                     ools\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0    /
//                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                      /
//                     -DDEFAULT_CHANLIST=0x00000800                          /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100     /
//                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                  /
//                     -DBEACON_REQUEST_DELAY=100                             /
//                     -DBEACON_REQ_DELAY_MASK=0x00FF                         /
//                     -DLINK_STATUS_JITTER_MASK=0x007F                       /
//                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED /
//                     =3000 -DNWK_INDIRECT_MSG_TIMEOUT=7                     /
//                     -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3        /
//                     -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2  /
//                     -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16                      /
//                     -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4       /
//                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,      /
//                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,  /
//                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                   /
//                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS= /
//                     20 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000         /
//                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100        /
//                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\ /
//                     f8wRouter.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE= /
//                     TRUE -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8        /
//                     -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "C:\Texas             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\ /
//                     f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC        /
//                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH        /
//                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4         /
//                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10        /
//                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10       /
//                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING               /
//                     -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING            /
//                     -DZCL_TOU) -DZCL_DEVICE_MGMT "C:\Texas                 /
//                     Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_le /
//                     vel\srf04\mac_tx.c" -D MSP430F2618 -D ZTOOL_P1 -D      /
//                     MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D               /
//                     LCD_SUPPORTED -lC "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\Router\List\" -lA       /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\Router\List\" /
//                      --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o  /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\Router\Obj\"  /
//                     --debug -D__MSP430F2618__ -e --double=32 --clib -I     /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\" -I          /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleLight\CC2520DB\..\Source\"   /
//                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleLight\CC2520DB\..\..\Sour /
//                     ce\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pro /
//                     jects\zstack\HomeAutomation\SampleLight\CC2520DB\..\.. /
//                     \..\ZMain\MSP2618\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\hal\include\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\hal\target\MSP2618CC2520\" -I "C:\Texas             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\include\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\high_level\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\low_level\srf04\" -I "C:\Texas                  /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mac\low_level\srf04\dual_chip\" -I "C:\Texas        /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ /
//                     Projects\zstack\HomeAutomation\SampleLight\CC2520DB\.. /
//                     \..\..\..\..\Components\osal\include\" -I "C:\Texas    /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\osal\mcu\msp430\" -I "C:\Texas                      /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\services\saddr\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\services\sdata\" -I "C:\Texas                       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\af\" -I "C:\Texas                             /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\nwk\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sec\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sapi\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\sys\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\zcl\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\stack\zdo\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleLight\CC2520DB\..\..\..\..\..\Componen /
//                     ts\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5. /
//                     1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB\ /
//                     ..\..\..\..\..\Components\zmac\f8w\" --core=430X       /
//                     --data_model=small -Ohz --multiplier=16s               /
//                     --require_prototypes                                   /
//    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst /
//                     ack\HomeAutomation\SampleLight\CC2520DB\Router\List\ma /
//                     c_tx.s43                                               /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME mac_tx

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC macTxAckNotReceivedCallback
        FUNCTION macTxAckNotReceivedCallback,0a1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC macTxAckReceivedCallback
        FUNCTION macTxAckReceivedCallback,0a1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC macTxActive
        PUBLIC macTxBe
        PUBLIC macTxChannelBusyCallback
        FUNCTION macTxChannelBusyCallback,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macTxCollisionWithRxCallback
        FUNCTION macTxCollisionWithRxCallback,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macTxCsmaBackoffDelay
        PUBLIC macTxDoneCallback
        FUNCTION macTxDoneCallback,0a1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC macTxFrame
        FUNCTION macTxFrame,0a1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC macTxFrameRetransmit
        FUNCTION macTxFrameRetransmit,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macTxHaltCleanup
        FUNCTION macTxHaltCleanup,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macTxInit
        FUNCTION macTxInit,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macTxSlottedDelay
        PUBLIC macTxStartQueuedFrame
        FUNCTION macTxStartQueuedFrame,0a1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macTxTimestampCallback
        FUNCTION macTxTimestampCallback,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macTxType
        FUNCTION txComplete,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        FUNCTION txCsmaGo,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION txCsmaPrep,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION txGo,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        EXTERN macRxHaltCleanup
        FUNCTION macRxHaltCleanup,0202H
        EXTERN pMacDataTx
        EXTERN halAssertHandler
        FUNCTION halAssertHandler,0202H
        EXTERN macBackoffTimerCapture
        FUNCTION macBackoffTimerCapture,0202H
        EXTERN macMcuTimerTickCapture
        FUNCTION macMcuTimerTickCapture,0202H
        EXTERN macRxOffRequest
        FUNCTION macRxOffRequest,0202H
        EXTERN macRadioUpdateTxPower
        FUNCTION macRadioUpdateTxPower,0202H
        EXTERN macRadioUpdateChannel
        FUNCTION macRadioUpdateChannel,0202H
        EXTERN macTxCompleteCallback
        FUNCTION macTxCompleteCallback,0202H
        EXTERN macDualchipTxCancelAckTimeoutCallback
        FUNCTION macDualchipTxCancelAckTimeoutCallback,0202H
        EXTERN macDualchipTxRequestAckTimeoutCallback
        FUNCTION macDualchipTxRequestAckTimeoutCallback,0202H
        EXTERN macPib
        EXTERN macRxActive
        EXTERN macRxOutgoingAckFlag
        EXTERN macDataTxTimeAvailable
        FUNCTION macDataTxTimeAvailable,0202H
        EXTERN macDualchipTxGoSlottedCsma
        FUNCTION macDualchipTxGoSlottedCsma,0202H
        EXTERN macDualchipTxGoCsma
        FUNCTION macDualchipTxGoCsma,0202H
        EXTERN macDualchipTxGoSlotted
        FUNCTION macDualchipTxGoSlotted,0202H
        EXTERN macRadioRandomByte
        FUNCTION macRadioRandomByte,0202H
        EXTERN macDualchipTxPrepCsmaSlotted
        FUNCTION macDualchipTxPrepCsmaSlotted,0202H
        EXTERN macSleepState
        EXTERN macDualchipTxPrepSlotted
        FUNCTION macDualchipTxPrepSlotted,0202H
        EXTERN macSpiCmdStrobe
        FUNCTION macSpiCmdStrobe,0202H
        EXTERN macSpiWriteTxFifo
        FUNCTION macSpiWriteTxFifo,0202H
        EXTERN macDualchipTxReset
        FUNCTION macDualchipTxReset,0202H

// C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_level\srf04\mac_tx.c
//    1 /**************************************************************************************************
//    2   Filename:       mac_tx.c
//    3   Revised:        $Date: 2007-10-15 14:56:36 -0700 (Mon, 15 Oct 2007) $
//    4   Revision:       $Revision: 15687 $
//    5 
//    6   Description:    Describe the purpose and contents of the file.
//    7 
//    8 
//    9   Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /* ------------------------------------------------------------------------------------------------
//   41  *                                          Includes
//   42  * ------------------------------------------------------------------------------------------------
//   43  */
//   44 
//   45 /* hal */
//   46 #include "hal_types.h"
//   47 #include "hal_defs.h"
//   48 #include "hal_mcu.h"
//   49 #include "hal_mac_cfg.h"
//   50 
//   51 /* high-level */
//   52 #include "mac_spec.h"
//   53 #include "mac_pib.h"
//   54 
//   55 /* exported low-level */
//   56 #include "mac_low_level.h"
//   57 
//   58 /* low-level specific */
//   59 #include "mac_tx.h"
//   60 #include "mac_backoff_timer.h"
//   61 #include "mac_rx.h"
//   62 #include "mac_rx_onoff.h"
//   63 #include "mac_radio.h"
//   64 #include "mac_sleep.h"
//   65 
//   66 /* target specific */
//   67 #include "mac_radio_defs.h"
//   68 
//   69 /* debug */
//   70 #include "mac_assert.h"
//   71 
//   72 
//   73 /* ------------------------------------------------------------------------------------------------
//   74  *                                            Defines
//   75  * ------------------------------------------------------------------------------------------------
//   76  */
//   77 #define MFR_LEN                   MAC_FCS_FIELD_LEN
//   78 #define PREPENDED_BYTE_LEN        1
//   79 
//   80 
//   81 /* ------------------------------------------------------------------------------------------------
//   82  *                                         Global Constants
//   83  * ------------------------------------------------------------------------------------------------
//   84  */
//   85 
//   86 /*
//   87  *  This is the time, in backoffs, required to set up a slotted transmit.
//   88  *  It is exported to high level so that code can schedule enough time
//   89  *  for slotted transmits.
//   90  *
//   91  *  A default is provided if a value is not specified.  If the default
//   92  *  is not appropriate, a #define should be added within hal_mac_cfg.h.
//   93  */
//   94 #ifndef HAL_MAC_TX_SLOTTED_DELAY
//   95 #define HAL_MAC_TX_SLOTTED_DELAY    3
//   96 #endif

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
//   97 uint8 const macTxSlottedDelay = HAL_MAC_TX_SLOTTED_DELAY;
macTxSlottedDelay:
        DC8 3
//   98 
//   99 
//  100 /* ------------------------------------------------------------------------------------------------
//  101  *                                         Global Variables
//  102  * ------------------------------------------------------------------------------------------------
//  103  */

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  104 uint8 macTxActive;
macTxActive:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  105 uint8 macTxType;
macTxType:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  106 uint8 macTxBe;
macTxBe:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  107 uint8 macTxCsmaBackoffDelay;
macTxCsmaBackoffDelay:
        DS8 1
//  108 
//  109 
//  110 /* ------------------------------------------------------------------------------------------------
//  111  *                                         Local Variables
//  112  * ------------------------------------------------------------------------------------------------
//  113  */

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  114 static uint8 nb;
nb:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  115 static uint8 txSeqn;
txSeqn:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  116 static uint8 txAckReq;
txAckReq:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  117 static uint8 txRetransmitFlag;
txRetransmitFlag:
        DS8 1
//  118 
//  119 
//  120 /* ------------------------------------------------------------------------------------------------
//  121  *                                         Local Prototypes
//  122  * ------------------------------------------------------------------------------------------------
//  123  */
//  124 static void txCsmaPrep(void);
//  125 static void txGo(void);
//  126 static void txCsmaGo(void);
//  127 static void txComplete(uint8 status);
//  128 
//  129 
//  130 /**************************************************************************************************
//  131  * @fn          macTxInit
//  132  *
//  133  * @brief       Initialize variables for tx module.
//  134  *
//  135  * @param       none
//  136  *
//  137  * @return      none
//  138  **************************************************************************************************
//  139  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  140 MAC_INTERNAL_API void macTxInit(void)
macTxInit:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function macTxInit
//  141 {
//  142   macTxActive      = MAC_TX_ACTIVE_NO_ACTIVITY;
        MOV.B   #0x0, &macTxActive
//  143   txRetransmitFlag = 0;
        MOV.B   #0x0, &txRetransmitFlag
//  144 }
        RETA
          CFI EndBlock cfiBlock0
//  145 
//  146 
//  147 /**************************************************************************************************
//  148  * @fn          macTxHaltCleanup
//  149  *
//  150  * @brief       -
//  151  *
//  152  * @param       none
//  153  *
//  154  * @return      none
//  155  **************************************************************************************************
//  156  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  157 MAC_INTERNAL_API void macTxHaltCleanup(void)
macTxHaltCleanup:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function macTxHaltCleanup
//  158 {
//  159   MAC_RADIO_TX_RESET();
        FUNCALL macTxHaltCleanup, macDualchipTxReset
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macTxHaltCleanup, macTxInit
        LOCFRAME CSTACK, 4, STACK
        CALLA   #macDualchipTxReset
//  160   macTxInit();
        BRA     #macTxInit
          CFI EndBlock cfiBlock1
//  161 }
//  162 
//  163 
//  164 /**************************************************************************************************
//  165  * @fn          macTxFrame
//  166  *
//  167  * @brief       Transmit the frame pointed to by pMacDataTx with the specified type.
//  168  *              NOTE! It is not legal to call this function from interrupt context.
//  169  *
//  170  * @param       txType - type of transmit
//  171  *
//  172  * @return      none
//  173  **************************************************************************************************
//  174  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  175 MAC_INTERNAL_API void macTxFrame(uint8 txType)
macTxFrame:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function macTxFrame
//  176 {
        FUNCALL macTxFrame, halAssertHandler
        LOCFRAME CSTACK, 8, STACK
        FUNCALL macTxFrame, txComplete
        LOCFRAME CSTACK, 8, STACK
        FUNCALL macTxFrame, macDualchipTxPrepSlotted
        LOCFRAME CSTACK, 8, STACK
        FUNCALL macTxFrame, halAssertHandler
        LOCFRAME CSTACK, 8, STACK
        FUNCALL macTxFrame, txCsmaPrep
        LOCFRAME CSTACK, 8, STACK
        FUNCALL macTxFrame, halAssertHandler
        LOCFRAME CSTACK, 8, STACK
        FUNCALL macTxFrame, macSpiCmdStrobe
        LOCFRAME CSTACK, 8, STACK
        FUNCALL macTxFrame, macSpiWriteTxFifo
        LOCFRAME CSTACK, 8, STACK
        FUNCALL macTxFrame, txGo
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.B   R12, R10
//  177   MAC_ASSERT(!macTxActive);            /* transmit on top of transmit */
        CMP.B   #0x0, &macTxActive
        JEQ     ??macTxFrame_1
        CALLA   #halAssertHandler
//  178 
//  179   /* mark transmit as active */
//  180   macTxActive = MAC_TX_ACTIVE_INITIALIZE;
??macTxFrame_1:
        MOV.B   #0x1, &macTxActive
//  181 
//  182   /*
//  183    *  The MAC will not enter sleep mode if there is an active transmit.  However, if macSleep() is
//  184    *  ever called from interrupt context, it possible to enter sleep state after a transmit is
//  185    *  intiated but before macTxActive is set.  To recover from this, the transmit must be aborted
//  186    *  and proper notificiation given to high-level.
//  187    */
//  188   if (macSleepState != MAC_SLEEP_STATE_AWAKE)
        CMP.B   #0x0, &macSleepState
        JEQ     ??macTxFrame_2
//  189   {
//  190     /* notify high-level that transmit had to be aborted */
//  191     txComplete(MAC_TX_ABORTED);
        MOV.B   #0x1d, R12
        CALLA   #txComplete
//  192 
//  193     /* exit from transmit logic */
//  194     return;
        JMP     ??macTxFrame_0
//  195   }
//  196 
//  197   /* save transmit type */
//  198   macTxType = txType;
??macTxFrame_2:
        MOV.B   R10, &macTxType
//  199 
//  200   /*-------------------------------------------------------------------------------
//  201    *  Prepare for transmit.
//  202    */
//  203   if (macTxType == MAC_TX_TYPE_SLOTTED)
        CMP.B   #0x2, R10
        JNE     ??macTxFrame_3
//  204   {
//  205     MAC_RADIO_TX_PREP_SLOTTED();
        CALLA   #macDualchipTxPrepSlotted
        JMP     ??macTxFrame_4
//  206   }
//  207   else
//  208   {
//  209     MAC_ASSERT((macTxType == MAC_TX_TYPE_SLOTTED_CSMA) || (macTxType == MAC_TX_TYPE_UNSLOTTED_CSMA));
??macTxFrame_3:
        CMP.B   #0x0, R10
        JEQ     ??macTxFrame_5
        CMP.B   #0x1, R10
        JEQ     ??macTxFrame_5
        CALLA   #halAssertHandler
//  210 
//  211     nb = 0;
??macTxFrame_5:
        MOV.B   #0x0, &nb
//  212     macTxBe = (pMacDataTx->internal.txOptions & MAC_TXOPTION_ALT_BE) ? macPib.altBe : macPib.minBe;
        MOV.W   &pMacDataTx, R15
        BIT.B   #0x40, 0xf(R15)
        JNC     ??macTxFrame_6
        MOV.B   &macPib + 64, R14
        JMP     ??macTxFrame_7
??macTxFrame_6:
        MOV.B   &macPib + 31, R14
//  213 
//  214     if ((macTxType == MAC_TX_TYPE_SLOTTED_CSMA) && (macPib.battLifeExt))
??macTxFrame_7:
        CMP.B   #0x0, &macTxType
        JNE     ??macTxFrame_8
        CMP.B   #0x0, &macPib + 3
        JEQ     ??macTxFrame_8
//  215     {
//  216       macTxBe = MIN(2, macTxBe);
        CMP.B   #0x3, R14
        JNC     ??macTxFrame_8
        MOV.B   #0x2, R14
??macTxFrame_8:
        MOV.B   R14, &macTxBe
//  217     }
//  218 
//  219     txCsmaPrep();
        CALLA   #txCsmaPrep
//  220   }
//  221 
//  222   /*-------------------------------------------------------------------------------
//  223    *  Load transmit FIFO unless this is a retransmit.  No need to write
//  224    *  the FIFO again in that case.
//  225    */
//  226   if (!txRetransmitFlag)
??macTxFrame_4:
        CMP.B   #0x0, &txRetransmitFlag
        JNE     ??macTxFrame_9
//  227   {
//  228     uint8 * p;
//  229     uint8   lenMhrMsdu;
//  230 
//  231     MAC_ASSERT(pMacDataTx != NULL); /* must have data to transmit */
        CMP.W   #0x0, &pMacDataTx
        JNE     ??macTxFrame_10
        CALLA   #halAssertHandler
//  232 
//  233     /* save needed parameters */
//  234     txAckReq = MAC_ACK_REQUEST(pMacDataTx->msdu.p);
??macTxFrame_10:
        MOV.W   &pMacDataTx, R15
        MOV.W   0x2(R15), R11
        MOV.B   @R11, R14
        AND.B   #0x20, R14
        MOV.B   R14, &txAckReq
//  235     txSeqn   = MAC_SEQ_NUMBER(pMacDataTx->msdu.p);
        MOV.W   0x2(R15), R11
        MOV.B   0x2(R11), &txSeqn
//  236 
//  237     /* set length of frame (note: use of term msdu is a misnomer, here it's actually mhr + msdu) */
//  238     lenMhrMsdu = pMacDataTx->msdu.len;
        MOV.B   0x4(R15), R10
//  239 
//  240     /* calling code guarantees an unused prepended byte  */
//  241     p = pMacDataTx->msdu.p - PREPENDED_BYTE_LEN;
        MOV.W   0x2(R15), R11
        ADD.W   #0xffff, R11
//  242 
//  243     /* first byte of buffer is length of MPDU */
//  244     *p = lenMhrMsdu + MFR_LEN;
        MOV.B   R10, R14
        ADD.B   #0x2, R14
        MOV.B   R14, 0(R11)
//  245 
//  246     /*
//  247      *  Flush the TX FIFO.  This is necessary in case the previous transmit was never
//  248      *  actually sent (e.g. CSMA failed without strobing TXON).  If bytes are written to
//  249      *  the FIFO but not transmitted, they remain in the FIFO to be transmitted whenever
//  250      *  a strobe of TXON does happen.
//  251      */
//  252     MAC_RADIO_FLUSH_TX_FIFO();
        MOV.B   #0x48, R12
        CALLA   #macSpiCmdStrobe
//  253 
//  254     /* write bytes to FIFO, prepended byte is included, MFR is not (it's generated by hardware) */
//  255     MAC_RADIO_WRITE_TX_FIFO(p, PREPENDED_BYTE_LEN + lenMhrMsdu);
        ADD.B   #0x1, R10
        MOV.B   R10, R13
        MOV.W   R11, R12
        CALLA   #macSpiWriteTxFifo
//  256   }
//  257 
//  258   /*-------------------------------------------------------------------------------
//  259    *  If not receiving, start the transmit.  If receive is active
//  260    *  queue up the transmit.
//  261    *
//  262    *  Critical sections around the state change prevents any sort of race condition
//  263    *  with  macTxStartQueuedFrame().  This guarantees function txGo() will only be
//  264    *  called once.
//  265    */
//  266   {
//  267     halIntState_t  s;
//  268 
//  269     HAL_ENTER_CRITICAL_SECTION(s);
??macTxFrame_9:
        MOV.W   SR, R15
        dint
        nop
//  270     if (!macRxActive && !macRxOutgoingAckFlag)
        CMP.B   #0x0, &macRxActive
        JNE     ??macTxFrame_11
        CMP.B   #0x0, &macRxOutgoingAckFlag
        JNE     ??macTxFrame_11
//  271     {
//  272       macTxActive = MAC_TX_ACTIVE_GO;
        MOV.B   #0x83, &macTxActive
//  273       HAL_EXIT_CRITICAL_SECTION(s);
        MOV.W   R15, SR
//  274       txGo();
        CALLA   #txGo
        JMP     ??macTxFrame_0
//  275     }
//  276     else
//  277     {
//  278       macTxActive = MAC_TX_ACTIVE_QUEUED;
??macTxFrame_11:
        MOV.B   #0x2, &macTxActive
//  279       HAL_EXIT_CRITICAL_SECTION(s);
        MOV.W   R15, SR
//  280     }
//  281   }
//  282 }
??macTxFrame_0:
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
//  283 
//  284 
//  285 /*=================================================================================================
//  286  * @fn          txCsmaPrep
//  287  *
//  288  * @brief       Prepare/initialize for a CSMA transmit.
//  289  *
//  290  * @param       none
//  291  *
//  292  * @return      none
//  293  *=================================================================================================
//  294  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  295 static void txCsmaPrep(void)
txCsmaPrep:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function txCsmaPrep
//  296 {
//  297   macTxCsmaBackoffDelay = macRadioRandomByte() & ((1 << macTxBe) - 1);
        FUNCALL txCsmaPrep, macRadioRandomByte
        LOCFRAME CSTACK, 4, STACK
        FUNCALL txCsmaPrep, macDualchipTxPrepCsmaSlotted
        LOCFRAME CSTACK, 4, STACK
        CALLA   #macRadioRandomByte
        MOV.W   #0x1, R14
        MOV.B   &macTxBe, R15
        SUB.B   #0x1, R15
        JN      ??txCsmaPrep_0
        RPT     R15
        RLAX.W  R14
??txCsmaPrep_0:
        ADD.B   #0xff, R14
        AND.B   R14, R12
        MOV.B   R12, &macTxCsmaBackoffDelay
//  298 
//  299   if (macTxType == MAC_TX_TYPE_SLOTTED_CSMA)
        CMP.B   #0x0, &macTxType
        JNE     ??txCsmaPrep_1
//  300   {
//  301     MAC_RADIO_TX_PREP_CSMA_SLOTTED();
        CALLA   #macDualchipTxPrepCsmaSlotted
//  302   }
//  303   else
//  304   {
//  305     MAC_RADIO_TX_PREP_CSMA_UNSLOTTED();
//  306   }
//  307 }
??txCsmaPrep_1:
        RETA
          CFI EndBlock cfiBlock3
//  308 
//  309 
//  310 /*=================================================================================================
//  311  * @fn          txGo
//  312  *
//  313  * @brief       Start a transmit going.
//  314  *
//  315  * @param       none
//  316  *
//  317  * @return      none
//  318  *=================================================================================================
//  319  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  320 static void txGo(void)
txGo:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function txGo
//  321 {
//  322   /*
//  323    *  If execution has reached this point, any transmitted ACK has long since completed.  It is
//  324    *  possible though that there is still a pending callback.  If so, it is irrelevant and needs to
//  325    *  be canceled at this point.
//  326    */
//  327   MAC_RADIO_CANCEL_ACK_TX_DONE_CALLBACK();
//  328   macRxOutgoingAckFlag = 0;
        FUNCALL txGo, macDualchipTxGoSlotted
        LOCFRAME CSTACK, 4, STACK
        FUNCALL txGo, txCsmaGo
        LOCFRAME CSTACK, 4, STACK
        MOV.B   #0x0, &macRxOutgoingAckFlag
//  329 
//  330   /* based on type of transmit, call the correct "go" functionality */
//  331   if (macTxType == MAC_TX_TYPE_SLOTTED)
        CMP.B   #0x2, &macTxType
        JNE     ??txGo_0
//  332   {
//  333     MAC_RADIO_TX_GO_SLOTTED();
        BRA     #macDualchipTxGoSlotted
//  334   }
//  335   else
//  336   {
//  337     txCsmaGo();
??txGo_0:
        BRA     #txCsmaGo
          CFI EndBlock cfiBlock4
//  338   }
//  339 }
//  340 
//  341 
//  342 /*=================================================================================================
//  343  * @fn          txCsmaGo
//  344  *
//  345  * @brief       Start a CSMA transmit going.
//  346  *
//  347  * @param       none
//  348  *
//  349  * @return      none
//  350  *=================================================================================================
//  351  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  352 static void txCsmaGo(void)
txCsmaGo:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function txCsmaGo
//  353 {
//  354   /* The CSMA needs to be performed at normal CCA threshold.
//  355    * Turn off the CC2591 compression workaround. 
//  356    */
//  357   COMPRESSION_WORKAROUND_OFF();
//  358 
//  359   if (macTxType == MAC_TX_TYPE_SLOTTED_CSMA)
        FUNCALL txCsmaGo, macDataTxTimeAvailable
        LOCFRAME CSTACK, 4, STACK
        FUNCALL txCsmaGo, txComplete
        LOCFRAME CSTACK, 4, STACK
        FUNCALL txCsmaGo, macDualchipTxGoSlottedCsma
        LOCFRAME CSTACK, 4, STACK
        FUNCALL txCsmaGo, macDualchipTxGoCsma
        LOCFRAME CSTACK, 4, STACK
        CMP.B   #0x0, &macTxType
        JNE     ??txCsmaGo_1
//  360   {
//  361     if (macTxCsmaBackoffDelay >= macDataTxTimeAvailable())
        CALLA   #macDataTxTimeAvailable
        CMP.B   R12, &macTxCsmaBackoffDelay
        JNC     ??txCsmaGo_2
//  362     {
//  363       txComplete(MAC_NO_TIME);
        MOV.B   #0x1c, R12
        BRA     #txComplete
//  364       return;
//  365     }
//  366     MAC_RADIO_TX_GO_SLOTTED_CSMA();
??txCsmaGo_2:
        BRA     #macDualchipTxGoSlottedCsma
//  367   }
//  368   else
//  369   {
//  370     MAC_RADIO_TX_GO_CSMA();
??txCsmaGo_1:
        BRA     #macDualchipTxGoCsma
          CFI EndBlock cfiBlock5
//  371   }
//  372 }
//  373 
//  374 
//  375 /**************************************************************************************************
//  376  * @fn          macTxFrameRetransmit
//  377  *
//  378  * @brief       Retransmit the last frame.
//  379  *
//  380  * @param       none
//  381  *
//  382  * @return      none
//  383  **************************************************************************************************
//  384  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  385 MAC_INTERNAL_API void macTxFrameRetransmit(void)
macTxFrameRetransmit:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function macTxFrameRetransmit
//  386 {
//  387   txRetransmitFlag = 1;
        FUNCALL macTxFrameRetransmit, macTxFrame
        LOCFRAME CSTACK, 4, STACK
        MOV.B   #0x1, &txRetransmitFlag
//  388   macTxFrame(macTxType);
        MOV.B   &macTxType, R12
        BRA     #macTxFrame
          CFI EndBlock cfiBlock6
//  389 }
//  390 
//  391 
//  392 /**************************************************************************************************
//  393  * @fn          macTxStartQueuedFrame
//  394  *
//  395  * @brief       See if there is a queued frame waiting to transmit.  If so, initiate
//  396  *              the transmit now.
//  397  *
//  398  * @param       none
//  399  *
//  400  * @return      none
//  401  **************************************************************************************************
//  402  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  403 MAC_INTERNAL_API void macTxStartQueuedFrame(void)
macTxStartQueuedFrame:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function macTxStartQueuedFrame
//  404 {
//  405   halIntState_t  s;
//  406 
//  407   MAC_ASSERT(!macRxActive && !macRxOutgoingAckFlag); /* queued frames should not transmit in middle of a receive */
        FUNCALL macTxStartQueuedFrame, halAssertHandler
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macTxStartQueuedFrame, txGo
        LOCFRAME CSTACK, 4, STACK
        CMP.B   #0x0, &macRxActive
        JNE     ??macTxStartQueuedFrame_0
        CMP.B   #0x0, &macRxOutgoingAckFlag
        JEQ     ??macTxStartQueuedFrame_1
??macTxStartQueuedFrame_0:
        CALLA   #halAssertHandler
//  408 
//  409   /*
//  410    *  Critical sections around the state change prevents any sort of race condition
//  411    *  with macTxFrame().  This guarantees function txGo() will only be be called once.
//  412    */
//  413   HAL_ENTER_CRITICAL_SECTION(s);
??macTxStartQueuedFrame_1:
        MOV.W   SR, R15
        dint
        nop
//  414   if (macTxActive == MAC_TX_ACTIVE_QUEUED)
        CMP.B   #0x2, &macTxActive
        JNE     ??macTxStartQueuedFrame_2
//  415   {
//  416     macTxActive = MAC_TX_ACTIVE_GO;
        MOV.B   #0x83, &macTxActive
//  417     HAL_EXIT_CRITICAL_SECTION(s);
        MOV.W   R15, SR
//  418     txGo();
        BRA     #txGo
//  419   }
//  420   else
//  421   {
//  422     HAL_EXIT_CRITICAL_SECTION(s);
??macTxStartQueuedFrame_2:
        MOV.W   R15, SR
//  423   }
//  424 }
        RETA
          CFI EndBlock cfiBlock7
//  425 
//  426 
//  427 /**************************************************************************************************
//  428  * @fn          macTxChannelBusyCallback
//  429  *
//  430  * @brief       This callback is executed if a CSMA transmit was attempted but the channel
//  431  *              was busy.
//  432  *
//  433  * @param       none
//  434  *
//  435  * @return      none
//  436  **************************************************************************************************
//  437  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  438 MAC_INTERNAL_API void macTxChannelBusyCallback(void)
macTxChannelBusyCallback:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function macTxChannelBusyCallback
//  439 {
//  440   MAC_ASSERT((macTxType == MAC_TX_TYPE_SLOTTED_CSMA) || (macTxType == MAC_TX_TYPE_UNSLOTTED_CSMA));
        FUNCALL macTxChannelBusyCallback, halAssertHandler
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macTxChannelBusyCallback, macRxOffRequest
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macTxChannelBusyCallback, txComplete
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macTxChannelBusyCallback, txCsmaPrep
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macTxChannelBusyCallback, txCsmaGo
        LOCFRAME CSTACK, 4, STACK
        CMP.B   #0x0, &macTxType
        JEQ     ??macTxChannelBusyCallback_1
        CMP.B   #0x1, &macTxType
        JEQ     ??macTxChannelBusyCallback_1
        CALLA   #halAssertHandler
//  441 
//  442   /* turn off receiver if allowed */
//  443   macTxActive = MAC_TX_ACTIVE_CHANNEL_BUSY;
??macTxChannelBusyCallback_1:
        MOV.B   #0x4, &macTxActive
//  444   macRxOffRequest();
        CALLA   #macRxOffRequest
//  445 
//  446   /*  clear channel assement failed, follow through with CSMA algorithm */
//  447   nb++;
        ADD.B   #0x1, &nb
//  448   if (nb > macPib.maxCsmaBackoffs)
        CMP.B   &nb, &macPib + 30
        JC      ??macTxChannelBusyCallback_2
//  449   {
//  450     txComplete(MAC_CHANNEL_ACCESS_FAILURE);
        MOV.B   #0xe1, R12
        BRA     #txComplete
//  451   }
//  452   else
//  453   {
//  454     macTxBe = MIN(macTxBe+1, macPib.maxBe);
??macTxChannelBusyCallback_2:
        MOV.B   &macPib + 43, R15
        MOV.B   &macTxBe, R14
        ADD.W   #0x1, R14
        CMP.W   R15, R14
        JGE     ??macTxChannelBusyCallback_0
        MOV.B   &macTxBe, R15
        ADD.B   #0x1, R15
??macTxChannelBusyCallback_0:
        MOV.B   R15, &macTxBe
//  455     txCsmaPrep();
        CALLA   #txCsmaPrep
//  456     macTxActive = MAC_TX_ACTIVE_GO;
        MOV.B   #0x83, &macTxActive
//  457     txCsmaGo();
        BRA     #txCsmaGo
          CFI EndBlock cfiBlock8
//  458   }
//  459 }
//  460 
//  461 
//  462 /**************************************************************************************************
//  463  * @fn          macTxDoneCallback
//  464  *
//  465  * @brief       This callback is executed when transmit completes.
//  466  *
//  467  * @param       none
//  468  *
//  469  * @return      none
//  470  **************************************************************************************************
//  471  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  472 MAC_INTERNAL_API void macTxDoneCallback(void)
macTxDoneCallback:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function macTxDoneCallback
//  473 {
        FUNCALL macTxDoneCallback, txComplete
        LOCFRAME CSTACK, 6, STACK
        FUNCALL macTxDoneCallback, macDualchipTxRequestAckTimeoutCallback
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
//  474   halIntState_t  s;
//  475 
//  476   /*
//  477    *  There is a small chance this function could be called twice for a single transmit.
//  478    *  To prevent logic from executing twice, the state variable macTxActive is used as
//  479    *  a gating mechanism to guarantee single time execution.
//  480    */
//  481   HAL_ENTER_CRITICAL_SECTION(s);
        MOV.W   SR, R10
        dint
        nop
//  482   if (macTxActive == MAC_TX_ACTIVE_GO)
        CMP.B   #0x83, &macTxActive
        JNE     ??macTxDoneCallback_0
//  483   {
//  484     /* see if ACK was requested */
//  485     if (!txAckReq)
        CMP.B   #0x0, &txAckReq
        JNE     ??macTxDoneCallback_1
//  486     {
//  487       macTxActive = MAC_TX_ACTIVE_DONE;
        MOV.B   #0x85, &macTxActive
//  488       HAL_EXIT_CRITICAL_SECTION(s);
        MOV.W   R10, SR
//  489 
//  490       /* ACK was not requested, transmit is complete */
//  491       txComplete(MAC_SUCCESS);
        MOV.B   #0x0, R12
        CALLA   #txComplete
        JMP     ??macTxDoneCallback_2
//  492     }
//  493     else
//  494     {
//  495       /*
//  496        *  ACK was requested - must wait to receive it.  A timer is set
//  497        *  to expire after the timeout duration for waiting for an ACK.
//  498        *  If an ACK is received, the function macTxAckReceived() is called.
//  499        *  If an ACK is not received within the timeout period,
//  500        *  the function macTxAckNotReceivedCallback() is called.
//  501        */
//  502       macTxActive = MAC_TX_ACTIVE_LISTEN_FOR_ACK;
??macTxDoneCallback_1:
        MOV.B   #0x86, &macTxActive
//  503       MAC_RADIO_TX_REQUEST_ACK_TIMEOUT_CALLBACK();
        CALLA   #macDualchipTxRequestAckTimeoutCallback
//  504       HAL_EXIT_CRITICAL_SECTION(s);
//  505     }
//  506   }
//  507   else
//  508   {
//  509     HAL_EXIT_CRITICAL_SECTION(s);
??macTxDoneCallback_0:
        MOV.W   R10, SR
//  510   }
//  511 }
??macTxDoneCallback_2:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock9
//  512 
//  513 
//  514 /**************************************************************************************************
//  515  * @fn          macTxAckReceivedCallback
//  516  *
//  517  * @brief       This function is called by the receive logic when an ACK is received and
//  518  *              transmit logic is listening for an ACK.
//  519  *
//  520  * @param       seqn        - sequence number of received ACK
//  521  * @param       pendingFlag - set if pending flag of ACK is set, cleared otherwise
//  522  *
//  523  * @return      none
//  524  **************************************************************************************************
//  525  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  526 MAC_INTERNAL_API void macTxAckReceivedCallback(uint8 seqn, uint8 pendingFlag)
macTxAckReceivedCallback:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function macTxAckReceivedCallback
//  527 {
        FUNCALL macTxAckReceivedCallback, macDualchipTxCancelAckTimeoutCallback
        LOCFRAME CSTACK, 12, STACK
        FUNCALL macTxAckReceivedCallback, txComplete
        LOCFRAME CSTACK, 12, STACK
        FUNCALL macTxAckReceivedCallback, txComplete
        LOCFRAME CSTACK, 12, STACK
        FUNCALL macTxAckReceivedCallback, txComplete
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.B   R12, R10
        MOV.B   R13, R11
//  528   halIntState_t  s;
//  529 
//  530   /* only process if listening for an ACK; critical section prevents race condition problems */
//  531   HAL_ENTER_CRITICAL_SECTION(s);
        MOV.W   SR, R8
        dint
        nop
//  532   if (macTxActive == MAC_TX_ACTIVE_LISTEN_FOR_ACK)
        CMP.B   #0x86, &macTxActive
        JNE     ??macTxAckReceivedCallback_1
//  533   {
//  534     macTxActive = MAC_TX_ACTIVE_POST_ACK;
        CALLA   #?Subroutine0
//  535     MAC_RADIO_TX_CANCEL_ACK_TIMEOUT_CALLBACK();
//  536     HAL_EXIT_CRITICAL_SECTION(s);
??CrossCallReturnLabel_0:
        MOV.W   R8, SR
//  537 
//  538     /* see if the sequence number of received ACK matches sequence number of packet just sent */
//  539     if (seqn == txSeqn)
        CMP.B   &txSeqn, R10
        JNE     ??macTxAckReceivedCallback_2
//  540     {
//  541       /*
//  542        *  Sequence numbers match so transmit is successful.  Return appropriate
//  543        *  status based on the pending flag of the received ACK.
//  544        */
//  545       if (pendingFlag)
        CMP.B   #0x0, R11
        JEQ     ??macTxAckReceivedCallback_3
//  546       {
//  547         txComplete(MAC_ACK_PENDING);
        MOV.B   #0x1b, R12
        JMP     ??macTxAckReceivedCallback_0
//  548       }
//  549       else
//  550       {
//  551         txComplete(MAC_SUCCESS);
??macTxAckReceivedCallback_3:
        MOV.B   #0x0, R12
        JMP     ??macTxAckReceivedCallback_0
//  552       }
//  553     }
//  554     else
//  555     {
//  556       /* sequence number did not match; per spec, transmit failed at this point */
//  557       txComplete(MAC_NO_ACK);
??macTxAckReceivedCallback_2:
        MOV.B   #0xe9, R12
??macTxAckReceivedCallback_0:
        CALLA   #txComplete
        JMP     ??macTxAckReceivedCallback_4
//  558     }
//  559   }
//  560   else
//  561   {
//  562     HAL_EXIT_CRITICAL_SECTION(s);
??macTxAckReceivedCallback_1:
        MOV.W   R8, SR
//  563   }
//  564 }
??macTxAckReceivedCallback_4:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock10

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine0:
          CFI Block cfiCond11 Using cfiCommon0
          CFI Function macTxAckNotReceivedCallback
          CFI Conditional ??CrossCallReturnLabel_1
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+10
          CFI Block cfiCond12 Using cfiCommon0
          CFI (cfiCond12) Function macTxAckReceivedCallback
          CFI (cfiCond12) Conditional ??CrossCallReturnLabel_0
          CFI (cfiCond12) R8L Frame(CFA, -12)
          CFI (cfiCond12) R9L Frame(CFA, -10)
          CFI (cfiCond12) R10L Frame(CFA, -8)
          CFI (cfiCond12) R11L Frame(CFA, -6)
          CFI (cfiCond12) CFA SP+16
          CFI Block cfiPicker13 Using cfiCommon1
          CFI (cfiPicker13) NoFunction
          CFI (cfiPicker13) Picker
        MOV.B   #0x87, &macTxActive
        BRA     #macDualchipTxCancelAckTimeoutCallback
          CFI EndBlock cfiCond11
          CFI EndBlock cfiCond12
          CFI EndBlock cfiPicker13
//  565 
//  566 
//  567 /**************************************************************************************************
//  568  * @fn          macTxAckNotReceivedCallback
//  569  *
//  570  * @brief       This function is called by the receive logic when transmit is listening
//  571  *              for an ACK but something else is received.  It is also called if the
//  572  *              listen-for-ACK timeout is reached.
//  573  *
//  574  * @brief
//  575  *
//  576  * @param       none
//  577  *
//  578  * @return      none
//  579  **************************************************************************************************
//  580  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  581 MAC_INTERNAL_API void macTxAckNotReceivedCallback(void)
macTxAckNotReceivedCallback:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function macTxAckNotReceivedCallback
//  582 {
        FUNCALL macTxAckNotReceivedCallback, macDualchipTxCancelAckTimeoutCallback
        LOCFRAME CSTACK, 6, STACK
        FUNCALL macTxAckNotReceivedCallback, txComplete
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
//  583   halIntState_t  s;
//  584 
//  585   /* only process if listening for an ACK; critical section prevents race condition problems */
//  586   HAL_ENTER_CRITICAL_SECTION(s);
        MOV.W   SR, R10
        dint
        nop
//  587   if (macTxActive == MAC_TX_ACTIVE_LISTEN_FOR_ACK)
        CMP.B   #0x86, &macTxActive
        JNE     ??macTxAckNotReceivedCallback_0
//  588   {
//  589     macTxActive = MAC_TX_ACTIVE_POST_ACK;
        CALLA   #?Subroutine0
//  590     MAC_RADIO_TX_CANCEL_ACK_TIMEOUT_CALLBACK();
//  591     HAL_EXIT_CRITICAL_SECTION(s);
??CrossCallReturnLabel_1:
        MOV.W   R10, SR
//  592 
//  593     /* a non-ACK was received when expecting an ACK, per spec transmit is over at this point */
//  594     txComplete(MAC_NO_ACK);
        MOV.B   #0xe9, R12
        CALLA   #txComplete
        JMP     ??macTxAckNotReceivedCallback_1
//  595   }
//  596   else
//  597   {
//  598     HAL_EXIT_CRITICAL_SECTION(s);
??macTxAckNotReceivedCallback_0:
        MOV.W   R10, SR
//  599   }
//  600 }
??macTxAckNotReceivedCallback_1:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock14
//  601 
//  602 
//  603 /*=================================================================================================
//  604  * @fn          txComplete
//  605  *
//  606  * @brief       Transmit has completed.  Perform needed maintenance and return status of
//  607  *              the transmit via callback function.
//  608  *
//  609  * @param       status - status of the transmit that just went out
//  610  *
//  611  * @return      none
//  612  *=================================================================================================
//  613  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  614 static void txComplete(uint8 status)
txComplete:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function txComplete
//  615 {
        FUNCALL txComplete, macRxOffRequest
        LOCFRAME CSTACK, 6, STACK
        FUNCALL txComplete, macRadioUpdateTxPower
        LOCFRAME CSTACK, 6, STACK
        FUNCALL txComplete, macRadioUpdateChannel
        LOCFRAME CSTACK, 6, STACK
        FUNCALL txComplete, macTxCompleteCallback
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.B   R12, R10
//  616   /* reset the retransmit flag */
//  617   txRetransmitFlag = 0;
        MOV.B   #0x0, &txRetransmitFlag
//  618 
//  619   /* update tx state; turn off receiver if nothing is keeping it on */
//  620   macTxActive = MAC_TX_ACTIVE_NO_ACTIVITY;
        MOV.B   #0x0, &macTxActive
//  621 
//  622   /* turn off receive if allowed */
//  623   macRxOffRequest();
        CALLA   #macRxOffRequest
//  624 
//  625   /* update transmit power in case there was a change */
//  626   macRadioUpdateTxPower();
        CALLA   #macRadioUpdateTxPower
//  627 
//  628   /*
//  629    *  Channel cannot change during transmit so update it here.  (Channel *can* change during
//  630    *  a receive.  The update function resets receive logic and any partially received
//  631    *  frame is purged.)
//  632    */
//  633   macRadioUpdateChannel();
        CALLA   #macRadioUpdateChannel
//  634 
//  635   /* return status of transmit via callback function */
//  636   macTxCompleteCallback(status);
        MOV.B   R10, R12
        CALLA   #macTxCompleteCallback
//  637 }
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock15
//  638 
//  639 
//  640 /**************************************************************************************************
//  641  * @fn          macTxTimestampCallback
//  642  *
//  643  * @brief       This callback function records the timestamp into the receive data structure.
//  644  *              It should be called as soon as possible after there is a valid timestamp.
//  645  *
//  646  * @param       none
//  647  *
//  648  * @return      none
//  649  **************************************************************************************************
//  650  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  651 MAC_INTERNAL_API void macTxTimestampCallback(void)
macTxTimestampCallback:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function macTxTimestampCallback
//  652 {
//  653   MAC_ASSERT(pMacDataTx != NULL); /* transmit structure must be there */
        FUNCALL macTxTimestampCallback, halAssertHandler
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macTxTimestampCallback, macBackoffTimerCapture
        LOCFRAME CSTACK, 4, STACK
        FUNCALL macTxTimestampCallback, macMcuTimerTickCapture
        LOCFRAME CSTACK, 4, STACK
        CMP.W   #0x0, &pMacDataTx
        JNE     ??macTxTimestampCallback_0
        CALLA   #halAssertHandler
//  654 
//  655   pMacDataTx->internal.timestamp  = macBackoffTimerCapture();
??macTxTimestampCallback_0:
        CALLA   #macBackoffTimerCapture
        MOV.W   &pMacDataTx, R15
        MOV.W   R12, 0x6(R15)
        MOV.W   R13, 0x8(R15)
//  656   pMacDataTx->internal.timestamp2 = MAC_RADIO_TIMER_CAPTURE();
        CALLA   #macMcuTimerTickCapture
        MOV.W   &pMacDataTx, R15
        MOV.W   R12, 0xa(R15)
//  657 }
        RETA
          CFI EndBlock cfiBlock16
//  658 
//  659 
//  660 /**************************************************************************************************
//  661  * @fn          macTxCollisionWithRxCallback
//  662  *
//  663  * @brief       Function called if transmit strobed on top of a receive.
//  664  *
//  665  * @param       none
//  666  *
//  667  * @return      none
//  668  **************************************************************************************************
//  669  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  670 MAC_INTERNAL_API void macTxCollisionWithRxCallback(void)
macTxCollisionWithRxCallback:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function macTxCollisionWithRxCallback
//  671 {
//  672   macRxHaltCleanup();
        FUNCALL macTxCollisionWithRxCallback, macRxHaltCleanup
        LOCFRAME CSTACK, 4, STACK
        BRA     #macRxHaltCleanup
          CFI EndBlock cfiBlock17
//  673 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  674 
//  675 
//  676 
//  677 /**************************************************************************************************
//  678  *                                  Compile Time Integrity Checks
//  679  **************************************************************************************************
//  680  */
//  681 #if (MAC_TX_ACTIVE_NO_ACTIVITY != 0x00)
//  682 #error "ERROR! Zero is reserved value of macTxActive. Allows boolean operations, e.g !macTxActive."
//  683 #endif
//  684 
//  685 /**************************************************************************************************
//  686 */
// 
// 722 bytes in segment CODE
//   1 byte  in segment DATA16_C
//   8 bytes in segment DATA16_Z
// 
// 722 bytes of CODE  memory
//   1 byte  of CONST memory
//   8 bytes of DATA  memory
//
//Errors: none
//Warnings: none

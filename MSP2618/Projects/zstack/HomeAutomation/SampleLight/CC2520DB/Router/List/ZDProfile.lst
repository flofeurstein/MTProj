###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       10/Jun/2013  16:27:28 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\st #
#                     ack\zdo\ZDProfile.c                                     #
#    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleLight\CC2520DB\..\..\..\Too #
#                     ls\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0       #
#                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                       #
#                     -DDEFAULT_CHANLIST=0x00000800                           #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100      #
#                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                   #
#                     -DBEACON_REQUEST_DELAY=100                              #
#                     -DBEACON_REQ_DELAY_MASK=0x00FF                          #
#                     -DLINK_STATUS_JITTER_MASK=0x007F                        #
#                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED= #
#                     3000 -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8  #
#                     -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2     #
#                     -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9              #
#                     -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40                #
#                     -DNWK_MAX_BINDING_ENTRIES=4                             #
#                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,       #
#                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,   #
#                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                    #
#                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=2 #
#                     0 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000           #
#                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100         #
#                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\f8 #
#                     wRouter.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                     E -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8            #
#                     -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "C:\Texas              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\f8 #
#                     wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC           #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)                #
#                     -DZCL_DEVICE_MGMT "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Components\stack\zdo\Z #
#                     DProfile.c" -D MSP430F2618 -D ZTOOL_P1 -D MT_TASK -D    #
#                     MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED -lC         #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\Router\List\"   #
#                     -lA "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects #
#                     \zstack\HomeAutomation\SampleLight\CC2520DB\Router\List #
#                     \" --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826    #
#                     -o "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleLight\CC2520DB\Router\Obj\" #
#                      --debug -D__MSP430F2618__ -e --double=32 --clib -I     #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\" -I "C:\Texas  #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\Source\" -I "C:\Texas  #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\Source\" -I         #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\..\..\..\ZMain\ #
#                     MSP2618\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1 #
#                     \Projects\zstack\HomeAutomation\SampleLight\CC2520DB\.. #
#                     \..\..\..\..\Components\hal\include\" -I "C:\Texas      #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \hal\target\MSP2618CC2520\" -I "C:\Texas                #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\include\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\high_level\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\low_level\srf04\" -I "C:\Texas                     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\low_level\srf04\dual_chip\" -I "C:\Texas           #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pro #
#                     jects\zstack\HomeAutomation\SampleLight\CC2520DB\..\..\ #
#                     ..\..\..\Components\osal\include\" -I "C:\Texas         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \osal\mcu\msp430\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \services\saddr\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \services\sdata\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\af\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5 #
#                     .1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB\ #
#                     ..\..\..\..\..\Components\stack\nwk\" -I "C:\Texas      #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\sec\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\stack\sapi\" -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\sys\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\stack\zcl\" -I "C:\Texas     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\zdo\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\zmac\" -I "C:\Texas          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \zmac\f8w\" --core=430X --data_model=small -Ohz         #
#                     --multiplier=16s --require_prototypes                   #
#    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleLight\CC2520DB\Router\List\ZDPr #
#                     ofile.lst                                               #
#    Object file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleLight\CC2520DB\Router\Obj\ZDPro #
#                     file.r43                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\stack\zdo\ZDProfile.c
      1          /**************************************************************************************************
      2            Filename:       ZDProfile.c
      3            Revised:        $Date: 2010-10-13 10:54:13 -0700 (Wed, 13 Oct 2010) $
      4            Revision:       $Revision: 24112 $
      5          
      6            Description:    This is the Zigbee Device Profile.
      7          
      8          
      9            Copyright 2004-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComdef.h"
     44          #include "OSAL.h"
     45          #include "AF.h"
     46          #include "NLMEDE.h"
     47          #include "nwk_util.h"
     48          #include "APS.h"
     49          
     50          #include "AddrMgr.h"
     51          #include "ZDConfig.h"
     52          #include "ZDProfile.h"
     53          #include "ZDObject.h"
     54          #include "ZDNwkMgr.h"
     55          
     56          #if defined( LCD_SUPPORTED )
     57            #include "OnBoard.h"
     58          #endif
     59          
     60          #include "nwk_util.h"
     61          
     62          #if defined( MT_ZDO_FUNC )
     63            #include "MT_ZDO.h"
     64          #endif
     65          
     66          /*********************************************************************
     67           * MACROS
     68           */
     69          
     70          #define ZADDR_TO_AFADDR( pZADDR, AFADDR ) {                            \
     71            (AFADDR).endPoint = ZDP_AF_ENDPOINT;                                 \
     72            (AFADDR).addrMode = (afAddrMode_t)(pZADDR)->addrMode;                \
     73            (AFADDR).addr.shortAddr = (pZADDR)->addr.shortAddr;                  \
     74          }
     75          
     76          #define FillAndSendBuffer( TRANSSEQ, ADDR, ID, LEN, BUF ) {     \
     77            afStatus_t stat;                                    \
     78            ZDP_TmpBuf = (BUF)+1;                               \
     79            stat = fillAndSend( (TRANSSEQ), (ADDR), (ID), (LEN) );          \
     80            osal_mem_free( (BUF) );                             \
     81            ZDP_TmpBuf = ZDP_Buf+1;                             \
     82            return stat;                                        \
     83          }
     84          
     85          #define FillAndSendTxOptions( TRANSSEQ, ADDR, ID, LEN, TxO ) {  \
     86            afStatus_t stat;                                    \
     87            ZDP_TxOptions = (TxO);                              \
     88            stat = fillAndSend( (TRANSSEQ), (ADDR), (ID), (LEN) );          \
     89            ZDP_TxOptions = AF_TX_OPTIONS_NONE;                 \
     90            return stat;                                        \
     91          }
     92          
     93          #define FillAndSendBufferTxOptions( TRANSSEQ, ADDR, ID, LEN, BUF, TxO ) { \
     94            afStatus_t stat;                                    \
     95            ZDP_TmpBuf = (BUF)+1;                               \
     96            ZDP_TxOptions = (TxO);                              \
     97            stat = fillAndSend( (TRANSSEQ), (ADDR), (ID), (LEN) );          \
     98            osal_mem_free( (BUF) );                             \
     99            ZDP_TmpBuf = ZDP_Buf+1;                             \
    100            ZDP_TxOptions = AF_TX_OPTIONS_NONE;                 \
    101            return stat;                                        \
    102          }
    103          
    104          /*********************************************************************
    105           * CONSTANTS
    106           */
    107          
    108          #define ZDP_BUF_SZ          80
    109          

   \                                 In  segment DATA16_C, align 1, align-sorted
    110          CONST byte ZDP_AF_ENDPOINT = 0;
   \                     ZDP_AF_ENDPOINT:
   \   000000   00           DC8 0
    111          
    112          /*********************************************************************
    113           * TYPEDEFS
    114           */
    115          typedef struct
    116          {
    117            void *next;
    118            uint8 taskID;
    119            uint16 clusterID;
    120          } ZDO_MsgCB_t;
    121          
    122          
    123          /*********************************************************************
    124           * GLOBAL VARIABLES
    125           */
    126          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    127          byte ZDP_TransID = 0;
   \                     ZDP_TransID:
   \   000000                DS8 1
    128          
    129          /*********************************************************************
    130           * EXTERNAL VARIABLES
    131           */
    132          
    133          extern endPointDesc_t ZDApp_epDesc;
    134          
    135          /*********************************************************************
    136           * EXTERNAL FUNCTIONS
    137           */
    138          
    139          /*********************************************************************
    140           * LOCAL FUNCTIONS
    141           */
    142          
    143          static afStatus_t fillAndSend( uint8 *transSeq, zAddrType_t *addr, cId_t clusterID, byte len );
    144          uint8 ZDO_SendMsgCBs( zdoIncomingMsg_t *inMsg );
    145          void zdpProcessAddrReq( zdoIncomingMsg_t *inMsg );
    146          
    147          /*********************************************************************
    148           * LOCAL VARIABLES
    149           */
    150          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    151          static uint8  ZDP_Buf[ ZDP_BUF_SZ ];
   \                     ZDP_Buf:
   \   000000                DS8 80

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    152          static uint8 *ZDP_TmpBuf = ZDP_Buf+1;
   \                     ZDP_TmpBuf:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for ZDP_TmpBuf>`
    153          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    154          byte ZDP_TxOptions = AF_TX_OPTIONS_NONE;
   \                     ZDP_TxOptions:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    155          ZDO_MsgCB_t *zdoMsgCBs = (ZDO_MsgCB_t *)NULL;
   \                     zdoMsgCBs:
   \   000000                DS8 2
    156          
    157          /*********************************************************************
    158           * ZDO Message Processing table
    159           */
    160          
    161          typedef void (*pfnZDPMsgProcessor)( zdoIncomingMsg_t *inMsg );
    162          
    163          typedef struct
    164          {
    165            uint16                clusterID;
    166            pfnZDPMsgProcessor    pFn;
    167          } zdpMsgProcItem_t;
    168          

   \                                 In  segment DATA16_C, align 2, align-sorted
    169          CONST zdpMsgProcItem_t zdpMsgProcs[] =
   \                     zdpMsgProcs:
   \   000000   0000         DC16 0
   \   000002   ........     DC32 zdpProcessAddrReq
   \   000006   1300         DC16 19
   \   000008   ........     DC32 ZDO_ProcessDeviceAnnce
   \   00000C   0100         DC16 1
   \   00000E   ........     DC32 zdpProcessAddrReq
   \   000012   0200         DC16 2
   \   000014   ........     DC32 ZDO_ProcessNodeDescReq
   \   000018   0300         DC16 3
   \   00001A   ........     DC32 ZDO_ProcessPowerDescReq
   \   00001E   0400         DC16 4
   \   000020   ........     DC32 ZDO_ProcessSimpleDescReq
   \   000024   0500         DC16 5
   \   000026   ........     DC32 ZDO_ProcessActiveEPReq
   \   00002A   0600         DC16 6
   \   00002C   ........     DC32 ZDO_ProcessMatchDescReq
   \   000030   1100         DC16 17
   \   000032   ........     DC32 ZDO_ProcessUserDescReq
   \   000036   1400         DC16 20
   \   000038   ........     DC32 ZDO_ProcessUserDescSet
   \   00003C   1500         DC16 21
   \   00003E   ........     DC32 ZDO_ProcessServerDiscReq
   \   000042   FFFF         DC16 65535
   \   000044   00000000     DC32 0H
    170          {
    171          #if ( RFD_RCVC_ALWAYS_ON==TRUE ) || ( ZG_BUILD_RTR_TYPE )
    172            // These aren't processed by sleeping end devices.
    173            { NWK_addr_req,           zdpProcessAddrReq },
    174            { Device_annce,           ZDO_ProcessDeviceAnnce },
    175          #endif
    176            { IEEE_addr_req,          zdpProcessAddrReq },
    177            { Node_Desc_req,          ZDO_ProcessNodeDescReq },
    178            { Power_Desc_req,         ZDO_ProcessPowerDescReq },
    179            { Simple_Desc_req,        ZDO_ProcessSimpleDescReq },
    180            { Active_EP_req,          ZDO_ProcessActiveEPReq },
    181            { Match_Desc_req,         ZDO_ProcessMatchDescReq },
    182          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
    183            { Mgmt_NWK_Disc_req,      ZDO_ProcessMgmtNwkDiscReq },
    184          #endif
    185          #if defined ( ZDO_MGMT_LQI_RESPONSE ) && ( ZG_BUILD_RTR_TYPE )
    186            { Mgmt_Lqi_req,           ZDO_ProcessMgmtLqiReq },
    187          #endif
    188          #if defined ( ZDO_MGMT_RTG_RESPONSE ) && ( ZG_BUILD_RTR_TYPE )
    189            { Mgmt_Rtg_req,           ZDO_ProcessMgmtRtgReq },
    190          #endif
    191          #if defined ( ZDO_MGMT_BIND_RESPONSE ) && defined ( REFLECTOR )
    192            { Mgmt_Bind_req,          ZDO_ProcessMgmtBindReq },
    193          #endif
    194          #if defined ( ZDO_MGMT_JOINDIRECT_RESPONSE ) && ( ZG_BUILD_RTR_TYPE )
    195            { Mgmt_Direct_Join_req,   ZDO_ProcessMgmtDirectJoinReq },
    196          #endif
    197          #if defined ( ZDO_MGMT_LEAVE_RESPONSE )
    198            { Mgmt_Leave_req,         ZDO_ProcessMgmtLeaveReq },
    199          #endif
    200          #if defined ( ZDO_MGMT_PERMIT_JOIN_RESPONSE )  && ( ZG_BUILD_RTR_TYPE )
    201            { Mgmt_Permit_Join_req,   ZDO_ProcessMgmtPermitJoinReq },
    202          #endif
    203          #if defined ( ZDO_USERDESC_RESPONSE )
    204            { User_Desc_req,          ZDO_ProcessUserDescReq },
    205          #endif
    206          #if defined ( ZDO_USERDESCSET_RESPONSE )
    207            { User_Desc_set,          ZDO_ProcessUserDescSet },
    208          #endif
    209          #if defined ( ZDO_SERVERDISC_RESPONSE )
    210            { Server_Discovery_req,   ZDO_ProcessServerDiscReq },
    211          #endif
    212            {0xFFFF, NULL} // Last
    213          };
    214          
    215          /*********************************************************************
    216           * @fn          fillAndSend
    217           *
    218           * @brief       Combined to reduce space
    219           *
    220           * @param
    221           * @param
    222           *
    223           * @return      afStatus_t
    224           */

   \                                 In  segment CODE, align 2
    225          static afStatus_t fillAndSend( uint8 *transSeq, zAddrType_t *addr, cId_t clusterID, byte len )
   \                     fillAndSend:
    226          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31800C00     SUB.W   #0xc, SP
   \   000006   0B4C         MOV.W   R12, R11
   \   000008   084D         MOV.W   R13, R8
   \   00000A   094E         MOV.W   R14, R9
   \   00000C   4A4F         MOV.B   R15, R10
    227            afAddrType_t afAddr;
    228          
    229            osal_memset( &afAddr, 0, sizeof(afAddrType_t) );
   \   00000E   3E400C00     MOV.W   #0xc, R14
   \   000012   4D43         MOV.B   #0x0, R13
   \   000014   0C41         MOV.W   SP, R12
   \   000016   0C53         ADD.W   #0x0, R12
   \   000018   ........     CALLA   #osal_memset
    230            ZADDR_TO_AFADDR( addr, afAddr );
   \   00001C   C1430900     MOV.B   #0x0, 0x9(SP)
   \   000020   D14808000800 MOV.B   0x8(R8), 0x8(SP)
   \   000026   A1480000     MOV.W   @R8, 0(SP)
    231          
    232            *(ZDP_TmpBuf-1) = *transSeq;
   \   00002A   1F42....     MOV.W   &ZDP_TmpBuf, R15
   \   00002E   EF4BFFFF     MOV.B   @R11, 0xffff(R15)
    233          
    234            return AF_DataRequest( &afAddr, &ZDApp_epDesc, clusterID,
    235                                     (uint16)(len+1), (uint8*)(ZDP_TmpBuf-1),
    236                                     transSeq, ZDP_TxOptions,  AF_DEFAULT_RADIUS );
   \   000032   70121E00     PUSH.B  #0x1e
   \   000036   5212....     PUSH.B  &ZDP_TxOptions
   \   00003A   0B12         PUSH.W  R11
   \   00003C   3F53         ADD.W   #0xffff, R15
   \   00003E   0F12         PUSH.W  R15
   \   000040   4F4A         MOV.B   R10, R15
   \   000042   1F53         ADD.W   #0x1, R15
   \   000044   0E49         MOV.W   R9, R14
   \   000046   3D40....     MOV.W   #ZDApp_epDesc, R13
   \   00004A   0C41         MOV.W   SP, R12
   \   00004C   3C52         ADD.W   #0x8, R12
   \   00004E   ........     CALLA   #AF_DataRequest
   \   000052   31501400     ADD.W   #0x14, SP
   \   000056   3817         POPM.W  #0x4, R11
   \   000058   1001         RETA
    237          
    238          }
    239          
    240          /*********************************************************************
    241           * @fn          ZDP_SendData
    242           *
    243           * @brief       This builds and send a request message that has
    244           *              NWKAddrOfInterest as its only parameter.
    245           *
    246           * @param       dstAddr - destination address
    247           * @param       cmd - clusterID
    248           * @param       dataLen - number of bytes of data
    249           * @param       data - pointer to the data
    250           * @param       SecurityEnable - Security Options
    251           *
    252           * @return      afStatus_t
    253           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   ........     CALLA   #??Subroutine10_0
   \                     ??CrossCallReturnLabel_33:
   \   000004   5617         POPM.W  #0x6, R11
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine10_0:
   \   000000   ........     CALLA   #fillAndSend
   \   000004   C243....     MOV.B   #0x0, &ZDP_TxOptions
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
    254          afStatus_t ZDP_SendData( uint8 *TransSeq, zAddrType_t *dstAddr, uint16 cmd,
   \                     ZDP_SendData:
    255                                  byte len, uint8 *buf, byte SecurityEnable )
    256          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   58411200     MOV.B   0x12(SP), R8
    257            uint8 *pBuf = ZDP_TmpBuf;
   \   000006   1942....     MOV.W   &ZDP_TmpBuf, R9
    258            byte cnt = len;
   \   00000A   464F         MOV.B   R15, R6
   \   00000C   1B411000     MOV.W   0x10(SP), R11
   \   000010   033C         JMP     ??ZDP_SendData_1
    259          
    260            while ( cnt-- )
    261            {
    262              *pBuf++ = *buf++;
   \                     ??ZDP_SendData_0:
   \   000012   F94B0000     MOV.B   @R11+, 0(R9)
   \   000016   1953         ADD.W   #0x1, R9
    263            }
   \                     ??ZDP_SendData_1:
   \   000018   4A46         MOV.B   R6, R10
   \   00001A   7653         ADD.B   #0xff, R6
   \   00001C   4A93         CMP.B   #0x0, R10
   \   00001E   F923         JNE     ??ZDP_SendData_0
    264          
    265            FillAndSendTxOptions( TransSeq, dstAddr, cmd, len, ((SecurityEnable) ? AF_EN_SECURITY : 0) );
   \   000020   4893         CMP.B   #0x0, R8
   \   000022   0220         JNE     ??ZDP_SendData_2
   \   000024   4A43         MOV.B   #0x0, R10
   \   000026   023C         JMP     ??ZDP_SendData_3
   \                     ??ZDP_SendData_2:
   \   000028   7A404000     MOV.B   #0x40, R10
   \                     ??ZDP_SendData_3:
   \   00002C   C24A....     MOV.B   R10, &ZDP_TxOptions
   \   000030   ........     BRA     #?Subroutine2
    266          }
    267          
    268          /*********************************************************************
    269           * @fn          ZDP_NWKAddrOfInterestReq
    270           *
    271           * @brief       This builds and send a request message that has
    272           *              NWKAddrOfInterest as its only parameter.
    273           *
    274           * @param       dstAddr - destination address
    275           * @param       nwkAddr - 16 bit address
    276           * @param       SecurityEnable - Security Options
    277           *
    278           * @return      afStatus_t
    279           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   0D4C         MOV.W   R12, R13
   \   000002   3C40....     MOV.W   #ZDP_TransID, R12
   \   000006   ........     BRA     #fillAndSend

   \                                 In  segment CODE, align 2, keep-with-next
    280          afStatus_t ZDP_NWKAddrOfInterestReq( zAddrType_t *dstAddr, uint16 nwkAddr,
   \                     ZDP_NWKAddrOfInterestReq:
    281                                               byte cmd, byte SecurityEnable )
    282          {
    283            (void)SecurityEnable;  // Intentionally unreferenced parameter
    284          
    285            ZDP_TmpBuf[0] = LO_UINT16( nwkAddr );
   \   000000   ........     CALLA   #?Subroutine15
    286            ZDP_TmpBuf[1] = HI_UINT16( nwkAddr );
    287          
    288            return fillAndSend( &ZDP_TransID, dstAddr, cmd, 2 );
   \                     ??CrossCallReturnLabel_10:
   \   000004   6F43         MOV.B   #0x2, R15
   \   000006   4E4E         MOV.B   R14, R14
   \   000008   ........     BRA     #?Subroutine5
    289          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine15:
   \   000000   1F42....     MOV.W   &ZDP_TmpBuf, R15
   \   000004   CF4D0000     MOV.B   R13, 0(R15)
   \   000008                RPT     #0x8
   \   000008   47190D10     RRUX.W  R13
   \   00000C   CF4D0100     MOV.B   R13, 0x1(R15)
   \   000010   1001         RETA
    290          
    291          /*********************************************************************
    292           * Address Requests
    293           */
    294          
    295          /*********************************************************************
    296           * @fn          ZDP_NwkAddrReq
    297           *
    298           * @brief       This builds and send a NWK_addr_req message.  This
    299           *              function sends a broadcast message looking for a 16
    300           *              bit address with a 64 bit address as bait.
    301           *
    302           * @param       IEEEAddress - looking for this device
    303           * @param       SecurityEnable - Security Options
    304           *
    305           * @return      afStatus_t
    306           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine17:
   \   000000   F1400F000C00 MOV.B   #0xf, 0xc(SP)
   \   000006   B140FDFF0400 MOV.W   #0xfffd, 0x4(SP)
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine12:
   \   000000   0D41         MOV.W   SP, R13
   \   000002   2D52         ADD.W   #0x4, R13
   \   000004                REQUIRE ??Subroutine12_0
   \   000004                // Fall through to label ??Subroutine12_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine12_0:
   \   000000   3C40....     MOV.W   #ZDP_TransID, R12
   \   000004   ........     BRA     #fillAndSend

   \                                 In  segment CODE, align 2, keep-with-next
    307          afStatus_t ZDP_NwkAddrReq( uint8 *IEEEAddress, byte ReqType,
   \                     ZDP_NwkAddrReq:
    308                                     byte StartIndex, byte SecurityEnable )
    309          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31800A00     SUB.W   #0xa, SP
   \   000006   084C         MOV.W   R12, R8
   \   000008   4A4D         MOV.B   R13, R10
   \   00000A   4B4E         MOV.B   R14, R11
    310            uint8 *pBuf = ZDP_TmpBuf;
   \   00000C   1942....     MOV.W   &ZDP_TmpBuf, R9
    311            byte len = Z_EXTADDR_LEN + 1 + 1;  // IEEEAddress + ReqType + StartIndex.
    312            zAddrType_t dstAddr;
    313          
    314            (void)SecurityEnable;  // Intentionally unreferenced parameter
    315          
    316            if ( osal_ExtAddrEqual( saveExtAddr, IEEEAddress ) == FALSE )
   \   000010   0D4C         MOV.W   R12, R13
   \   000012   3C40....     MOV.W   #saveExtAddr, R12
   \   000016   ........     CALLA   #sAddrExtCmp
   \   00001A   4C93         CMP.B   #0x0, R12
   \   00001C   0320         JNE     ??ZDP_NwkAddrReq_0
    317            {
    318              dstAddr.addrMode = AddrBroadcast;
   \   00001E   ........     CALLA   #?Subroutine17
    319              dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
    320            }
   \                     ??CrossCallReturnLabel_13:
   \   000022   053C         JMP     ??ZDP_NwkAddrReq_1
    321            else
    322            {
    323              dstAddr.addrMode = Addr16Bit;
   \                     ??ZDP_NwkAddrReq_0:
   \   000024   E1430800     MOV.B   #0x2, 0x8(SP)
    324              dstAddr.addr.shortAddr = ZDAppNwkAddr.addr.shortAddr;
   \   000028   9142....0000 MOV.W   &ZDAppNwkAddr, 0(SP)
    325            }
    326          
    327            pBuf = osal_cpyExtAddr( pBuf, IEEEAddress );
   \                     ??ZDP_NwkAddrReq_1:
   \   00002E   0D48         MOV.W   R8, R13
   \   000030   0C49         MOV.W   R9, R12
   \   000032   ........     CALLA   #sAddrExtCpy
   \   000036   094C         MOV.W   R12, R9
    328          
    329            *pBuf++ = ReqType;
   \   000038   CC4A0000     MOV.B   R10, 0(R12)
   \   00003C   1953         ADD.W   #0x1, R9
    330            *pBuf++ = StartIndex;
   \   00003E   C94B0000     MOV.B   R11, 0(R9)
    331          
    332            return fillAndSend( &ZDP_TransID, &dstAddr, NWK_addr_req, len );
   \   000042   7F400A00     MOV.B   #0xa, R15
   \   000046   0E43         MOV.W   #0x0, R14
   \   000048   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_38:
   \   00004C   31500A00     ADD.W   #0xa, SP
   \   000050   3817         POPM.W  #0x4, R11
   \   000052   1001         RETA
    333          }
    334          
    335          /*********************************************************************
    336           * @fn          ZDP_IEEEAddrReq
    337           *
    338           * @brief       This builds and send a IEEE_addr_req message.  This
    339           *              function sends a unicast message looking for a 64
    340           *              bit IEEE address with a 16 bit address as bait.
    341           *
    342           * @param       ReqType - ZDP_IEEEADDR_REQTYPE_SINGLE or
    343           *                        ZDP_IEEEADDR_REQTYPE_EXTENDED
    344           * @param       SecurityEnable - Security Options
    345           *
    346           * @return      afStatus_t
    347           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   31500A00     ADD.W   #0xa, SP
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
    348          afStatus_t ZDP_IEEEAddrReq( uint16 shortAddr, byte ReqType,
   \                     ZDP_IEEEAddrReq:
    349                                      byte StartIndex, byte SecurityEnable )
    350          {
   \   000000   31800A00     SUB.W   #0xa, SP
    351            uint8 *pBuf = ZDP_TmpBuf;
   \   000004   1F42....     MOV.W   &ZDP_TmpBuf, R15
    352            byte len = 2 + 1 + 1;  // shortAddr + ReqType + StartIndex.
    353            zAddrType_t dstAddr;
    354          
    355            (void)SecurityEnable;  // Intentionally unreferenced parameter
    356          
    357            dstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   000008   E1430800     MOV.B   #0x2, 0x8(SP)
    358            dstAddr.addr.shortAddr = shortAddr;
   \   00000C   814C0000     MOV.W   R12, 0(SP)
    359          
    360            *pBuf++ = LO_UINT16( shortAddr );
   \   000010   ........     CALLA   #?Subroutine18
    361            *pBuf++ = HI_UINT16( shortAddr );
   \                     ??CrossCallReturnLabel_15:
   \   000014   1F53         ADD.W   #0x1, R15
    362          
    363            *pBuf++ = ReqType;
   \   000016   CF4D0000     MOV.B   R13, 0(R15)
   \   00001A   1F53         ADD.W   #0x1, R15
    364            *pBuf++ = StartIndex;
   \   00001C   CF4E0000     MOV.B   R14, 0(R15)
    365          
    366            return fillAndSend( &ZDP_TransID, &dstAddr, IEEE_addr_req, len );
   \   000020   6F42         MOV.B   #0x4, R15
   \   000022   1E43         MOV.W   #0x1, R14
   \   000024   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_39:
   \   000028   ....         JMP     ?Subroutine4
    367          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine18:
   \   000000   CF4C0000     MOV.B   R12, 0(R15)
   \   000004   1F53         ADD.W   #0x1, R15
   \   000006                RPT     #0x8
   \   000006   47190C10     RRUX.W  R12
   \   00000A   CF4C0000     MOV.B   R12, 0(R15)
   \   00000E   1001         RETA
    368          
    369          /*********************************************************************
    370           * @fn          ZDP_MatchDescReq
    371           *
    372           * @brief       This builds and send a Match_Desc_req message.  This
    373           *              function sends a broadcast or unicast message
    374           *              requesting the list of endpoint/interfaces that
    375           *              match profile ID and cluster IDs.
    376           *
    377           * @param       dstAddr - destination address
    378           * @param       nwkAddr - network address of interest
    379           * @param       ProfileID - Profile ID
    380           * @param       NumInClusters - number of input clusters
    381           * @param       InClusterList - input cluster ID list
    382           * @param       NumOutClusters - number of output clusters
    383           * @param       OutClusterList - output cluster ID list
    384           * @param       SecurityEnable - Security Options
    385           *
    386           * @return      afStatus_t
    387           */

   \                                 In  segment CODE, align 2, keep-with-next
    388          afStatus_t ZDP_MatchDescReq( zAddrType_t *dstAddr, uint16 nwkAddr,
   \                     ZDP_MatchDescReq:
    389                                          uint16 ProfileID,
    390                                          byte NumInClusters, cId_t *InClusterList,
    391                                          byte NumOutClusters, cId_t *OutClusterList,
    392                                          byte SecurityEnable )
    393          {
   \   000000   5B15         PUSHM.W #0x6, R11
    394            uint8 *pBuf = ZDP_TmpBuf;
   \   000002   1842....     MOV.W   &ZDP_TmpBuf, R8
   \   000006   5B411200     MOV.B   0x12(SP), R11
    395            // nwkAddr+ProfileID+NumInClusters+NumOutClusters.
    396            byte i, len = 2 + 2 + 1 + 1;  // nwkAddr+ProfileID+NumInClusters+NumOutClusters.
    397          
    398            (void)SecurityEnable;  // Intentionally unreferenced parameter
    399          
    400            len += (NumInClusters + NumOutClusters) * sizeof(uint16);
   \   00000A   4A4F         MOV.B   R15, R10
   \   00000C   4A5B         ADD.B   R11, R10
   \   00000E   4A5A         RLA.B   R10
   \   000010   7A500600     ADD.B   #0x6, R10
    401          
    402            if ( len >= ZDP_BUF_SZ-1 )
   \   000014   7A904F00     CMP.B   #0x4f, R10
   \   000018   0328         JNC     ??ZDP_MatchDescReq_2
    403            {
    404              return afStatus_MEM_FAIL;
   \   00001A   7C401000     MOV.B   #0x10, R12
   \   00001E   533C         JMP     ??ZDP_MatchDescReq_3
    405            }
    406          
    407            // The spec changed in Zigbee 2007 (2.4.3.1.7.1) to not allow sending
    408            // this command to 0xFFFF.  So, here we will filter this and replace 
    409            // with 0xFFFD to only send to devices with RX ON.  This includes the 
    410            // network address of interest.
    411            if ( ((dstAddr->addrMode == AddrBroadcast) || (dstAddr->addrMode == Addr16Bit))
    412                && (dstAddr->addr.shortAddr == NWK_BROADCAST_SHORTADDR_DEVALL) )
   \                     ??ZDP_MatchDescReq_2:
   \   000020   594C0800     MOV.B   0x8(R12), R9
   \   000024   79900F00     CMP.B   #0xf, R9
   \   000028   0224         JEQ     ??ZDP_MatchDescReq_4
   \   00002A   6993         CMP.B   #0x2, R9
   \   00002C   0620         JNE     ??ZDP_MatchDescReq_5
   \                     ??ZDP_MatchDescReq_4:
   \   00002E   BC930000     CMP.W   #0xffff, 0(R12)
   \   000032   0320         JNE     ??ZDP_MatchDescReq_5
    413            {
    414              dstAddr->addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
   \   000034   BC40FDFF0000 MOV.W   #0xfffd, 0(R12)
    415            }
    416            if ( nwkAddr == NWK_BROADCAST_SHORTADDR_DEVALL )
   \                     ??ZDP_MatchDescReq_5:
   \   00003A   3D93         CMP.W   #0xffff, R13
   \   00003C   0220         JNE     ??ZDP_MatchDescReq_6
    417            {
    418              nwkAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
   \   00003E   3D40FDFF     MOV.W   #0xfffd, R13
    419            }
    420            
    421            *pBuf++ = LO_UINT16( nwkAddr );   // NWKAddrOfInterest
   \                     ??ZDP_MatchDescReq_6:
   \   000042   C84D0000     MOV.B   R13, 0(R8)
   \   000046   1853         ADD.W   #0x1, R8
    422            *pBuf++ = HI_UINT16( nwkAddr );
   \   000048                RPT     #0x8
   \   000048   47190D10     RRUX.W  R13
   \   00004C   C84D0000     MOV.B   R13, 0(R8)
   \   000050   1853         ADD.W   #0x1, R8
    423          
    424            *pBuf++ = LO_UINT16( ProfileID );   // Profile ID
   \   000052   C84E0000     MOV.B   R14, 0(R8)
   \   000056   1853         ADD.W   #0x1, R8
    425            *pBuf++ = HI_UINT16( ProfileID );
   \   000058                RPT     #0x8
   \   000058   47190E10     RRUX.W  R14
   \   00005C   C84E0000     MOV.B   R14, 0(R8)
   \   000060   1853         ADD.W   #0x1, R8
    426          
    427            *pBuf++ = NumInClusters; // Input cluster list
   \   000062   C84F0000     MOV.B   R15, 0(R8)
   \   000066   1853         ADD.W   #0x1, R8
    428            if ( NumInClusters )
   \   000068   4F93         CMP.B   #0x0, R15
   \   00006A   1124         JEQ     ??ZDP_MatchDescReq_7
    429            {
    430              for (i=0; i<NumInClusters; ++i)  {
   \   00006C   4E43         MOV.B   #0x0, R14
   \   00006E   1D411000     MOV.W   0x10(SP), R13
    431                *pBuf++ = LO_UINT16( InClusterList[i] );
   \                     ??ZDP_MatchDescReq_0:
   \   000072   464E         MOV.B   R14, R6
   \   000074   0656         RLA.W   R6
   \   000076   094D         MOV.W   R13, R9
   \   000078   0956         ADD.W   R6, R9
   \   00007A   E8490000     MOV.B   @R9, 0(R8)
   \   00007E   1853         ADD.W   #0x1, R8
    432                *pBuf++ = HI_UINT16( InClusterList[i] );
   \   000080   D84901000000 MOV.B   0x1(R9), 0(R8)
   \   000086   1853         ADD.W   #0x1, R8
    433              }
   \   000088   5E53         ADD.B   #0x1, R14
   \   00008A   4E9F         CMP.B   R15, R14
   \   00008C   F22B         JNC     ??ZDP_MatchDescReq_0
    434            }
    435          
    436            *pBuf++ = NumOutClusters; // Output cluster list
   \                     ??ZDP_MatchDescReq_7:
   \   00008E   C84B0000     MOV.B   R11, 0(R8)
   \   000092   1853         ADD.W   #0x1, R8
    437            if ( NumOutClusters )
   \   000094   4B93         CMP.B   #0x0, R11
   \   000096   1124         JEQ     ??ZDP_MatchDescReq_8
    438            {
    439              for (i=0; i<NumOutClusters; ++i)  {
   \   000098   4E43         MOV.B   #0x0, R14
   \   00009A   1F411400     MOV.W   0x14(SP), R15
    440                *pBuf++ = LO_UINT16( OutClusterList[i] );
   \                     ??ZDP_MatchDescReq_1:
   \   00009E   494E         MOV.B   R14, R9
   \   0000A0   0959         RLA.W   R9
   \   0000A2   0D4F         MOV.W   R15, R13
   \   0000A4   0D59         ADD.W   R9, R13
   \   0000A6   E84D0000     MOV.B   @R13, 0(R8)
   \   0000AA   1853         ADD.W   #0x1, R8
    441                *pBuf++ = HI_UINT16( OutClusterList[i] );
   \   0000AC   D84D01000000 MOV.B   0x1(R13), 0(R8)
   \   0000B2   1853         ADD.W   #0x1, R8
    442              }
   \   0000B4   5E53         ADD.B   #0x1, R14
   \   0000B6   4E9B         CMP.B   R11, R14
   \   0000B8   F22B         JNC     ??ZDP_MatchDescReq_1
    443            }
    444          
    445            return fillAndSend( &ZDP_TransID, dstAddr, Match_Desc_req, len );
   \                     ??ZDP_MatchDescReq_8:
   \   0000BA   4F4A         MOV.B   R10, R15
   \   0000BC   3E400600     MOV.W   #0x6, R14
   \   0000C0   0D4C         MOV.W   R12, R13
   \   0000C2   ........     CALLA   #??Subroutine12_0
   \                     ??ZDP_MatchDescReq_3:
   \   0000C6   5617         POPM.W  #0x6, R11
   \   0000C8   1001         RETA
    446          }
    447          
    448          /*********************************************************************
    449           * @fn          ZDP_SimpleDescReq
    450           *
    451           * @brief       This builds and send a NWK_Simple_Desc_req
    452           *              message.  This function sends unicast message to the
    453           *              destination device.
    454           *
    455           * @param       dstAddr - destination address
    456           * @param       nwkAddr - 16 bit address
    457           * @param       epIntf - endpoint/interface
    458           * @param       SecurityEnable - Security Options
    459           *
    460           * @return      afStatus_t
    461           */

   \                                 In  segment CODE, align 2, keep-with-next
    462          afStatus_t ZDP_SimpleDescReq( zAddrType_t *dstAddr, uint16 nwkAddr,
   \                     ZDP_SimpleDescReq:
    463                                              byte endPoint, byte SecurityEnable )
    464          
    465          {
    466            (void)SecurityEnable;  // Intentionally unreferenced parameter
    467          
    468            ZDP_TmpBuf[0] = LO_UINT16( nwkAddr );
   \   000000   ........     CALLA   #?Subroutine15
    469            ZDP_TmpBuf[1] = HI_UINT16( nwkAddr );
    470            ZDP_TmpBuf[2] = endPoint;
   \                     ??CrossCallReturnLabel_9:
   \   000004   CF4E0200     MOV.B   R14, 0x2(R15)
    471          
    472            return fillAndSend( &ZDP_TransID, dstAddr, Simple_Desc_req, 3 );
   \   000008   7F400300     MOV.B   #0x3, R15
   \   00000C   2E42         MOV.W   #0x4, R14
   \   00000E   ........     BRA     #?Subroutine5
    473          }
    474          
    475          /*********************************************************************
    476           * @fn          ZDP_UserDescSet
    477           *
    478           * @brief       This builds and send a User_Desc_set message to set
    479           *              the user descriptor.  This function sends unicast
    480           *              message to the destination device.
    481           *
    482           * @param       dstAddr - destination address
    483           * @param       nwkAddr - 16 bit address
    484           * @param       UserDescriptor - user descriptor
    485           * @param       SecurityEnable - Security Options
    486           *
    487           * @return      afStatus_t
    488           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   0D4B         MOV.W   R11, R13
   \   000002   ........     CALLA   #??Subroutine12_0
   \                     ??CrossCallReturnLabel_35:
   \   000006   1A17         POPM.W  #0x2, R11
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
    489          afStatus_t ZDP_UserDescSet( zAddrType_t *dstAddr, uint16 nwkAddr,
   \                     ZDP_UserDescSet:
    490                                    UserDescriptorFormat_t *UserDescriptor,
    491                                    byte SecurityEnable )
    492          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0B4C         MOV.W   R12, R11
   \   000004   0F4E         MOV.W   R14, R15
    493            uint8 *pBuf = ZDP_TmpBuf;
   \   000006   1C42....     MOV.W   &ZDP_TmpBuf, R12
    494            byte len = (UserDescriptor->len < AF_MAX_USER_DESCRIPTOR_LEN) ?
    495                        UserDescriptor->len : AF_MAX_USER_DESCRIPTOR_LEN;
   \   00000A   6A4E         MOV.B   @R14, R10
   \   00000C   7A901000     CMP.B   #0x10, R10
   \   000010   0228         JNC     ??ZDP_UserDescSet_1
   \   000012   7A401000     MOV.B   #0x10, R10
    496            byte addrLen = 2;
    497          
    498            (void)SecurityEnable;  // Intentionally unreferenced parameter
    499          
    500            *pBuf++ = LO_UINT16( nwkAddr );
   \                     ??ZDP_UserDescSet_1:
   \   000016   CC4D0000     MOV.B   R13, 0(R12)
   \   00001A   1C53         ADD.W   #0x1, R12
    501            *pBuf++ = HI_UINT16( nwkAddr );
   \   00001C                RPT     #0x8
   \   00001C   47190D10     RRUX.W  R13
   \   000020   CC4D0000     MOV.B   R13, 0(R12)
   \   000024   1C53         ADD.W   #0x1, R12
    502          
    503            *pBuf++ = len;
   \   000026   CC4A0000     MOV.B   R10, 0(R12)
   \   00002A   1C53         ADD.W   #0x1, R12
    504            addrLen = 3;
    505          
    506            pBuf = osal_memcpy( pBuf, UserDescriptor->desc, len );
   \   00002C   4E4A         MOV.B   R10, R14
   \   00002E   1F53         ADD.W   #0x1, R15
   \   000030   0D4F         MOV.W   R15, R13
   \   000032   ........     CALLA   #osal_memcpy
    507            osal_memset( pBuf, AF_USER_DESCRIPTOR_FILL, AF_MAX_USER_DESCRIPTOR_LEN-len );
   \   000036   3E401000     MOV.W   #0x10, R14
   \   00003A   0E8A         SUB.W   R10, R14
   \   00003C   7D402000     MOV.B   #0x20, R13
   \   000040   ........     CALLA   #osal_memset
    508          
    509            return fillAndSend( &ZDP_TransID, dstAddr, User_Desc_set, (AF_MAX_USER_DESCRIPTOR_LEN + addrLen) );
   \   000044   7F401300     MOV.B   #0x13, R15
   \   000048   3E401400     MOV.W   #0x14, R14
   \   00004C   ........     BRA     #?Subroutine0
    510          }
    511          
    512          /*********************************************************************
    513           * @fn          ZDP_ServerDiscReq
    514           *
    515           * @brief       Build and send a Server_Discovery_req request message.
    516           *
    517           * @param       serverMask - 16-bit bit-mask of server services being sought.
    518           * @param       SecurityEnable - Security Options
    519           *
    520           * @return      afStatus_t
    521           */

   \                                 In  segment CODE, align 2, keep-with-next
    522          afStatus_t ZDP_ServerDiscReq( uint16 serverMask, byte SecurityEnable )
   \                     ZDP_ServerDiscReq:
    523          {
   \   000000   31800A00     SUB.W   #0xa, SP
    524            uint8 *pBuf = ZDP_TmpBuf;
   \   000004   1F42....     MOV.W   &ZDP_TmpBuf, R15
    525            zAddrType_t dstAddr;
    526          
    527            dstAddr.addrMode = AddrBroadcast;
   \   000008   ........     CALLA   #?Subroutine17
    528            dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
    529          
    530            *pBuf++ = LO_UINT16( serverMask );
   \                     ??CrossCallReturnLabel_12:
   \   00000C   ........     CALLA   #?Subroutine18
    531            *pBuf = HI_UINT16( serverMask );
    532          
    533            FillAndSendTxOptions( &ZDP_TransID, &dstAddr, Server_Discovery_req, 2,
    534                       ((SecurityEnable) ? AF_EN_SECURITY : AF_TX_OPTIONS_NONE) );
   \                     ??CrossCallReturnLabel_14:
   \   000010   4D93         CMP.B   #0x0, R13
   \   000012   0220         JNE     ??ZDP_ServerDiscReq_0
   \   000014   4E43         MOV.B   #0x0, R14
   \   000016   023C         JMP     ??ZDP_ServerDiscReq_1
   \                     ??ZDP_ServerDiscReq_0:
   \   000018   7E404000     MOV.B   #0x40, R14
   \                     ??ZDP_ServerDiscReq_1:
   \   00001C   C24E....     MOV.B   R14, &ZDP_TxOptions
   \   000020   6F43         MOV.B   #0x2, R15
   \   000022   3E401500     MOV.W   #0x15, R14
   \   000026   0D41         MOV.W   SP, R13
   \   000028   0D53         ADD.W   #0x0, R13
   \   00002A   3C40....     MOV.W   #ZDP_TransID, R12
   \   00002E   ........     CALLA   #??Subroutine10_0
   \                     ??CrossCallReturnLabel_34:
   \   000032                REQUIRE ?Subroutine4
   \   000032                // Fall through to label ?Subroutine4
    535          }
    536          
    537          /*********************************************************************
    538           * @fn          ZDP_DeviceAnnce
    539           *
    540           * @brief       This builds and send a Device_Annce message.  This
    541           *              function sends a broadcast message.
    542           *
    543           * @param       nwkAddr - 16 bit address of the device
    544           * @param       IEEEAddr - 64 bit address of the device
    545           * @param       capabilities - device capabilities.  This field is only
    546           *                 sent for v1.1 networks.
    547           * @param       SecurityEnable - Security Options
    548           *
    549           * @return      afStatus_t
    550           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine25_0:
   \   000000   ........     CALLA   #sAddrExtCpy
   \   000004   1F42....     MOV.W   &ZDP_TmpBuf, R15
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
    551          afStatus_t ZDP_DeviceAnnce( uint16 nwkAddr, uint8 *IEEEAddr,
   \                     ZDP_DeviceAnnce:
    552                                        byte capabilities, byte SecurityEnable )
    553          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31800A00     SUB.W   #0xa, SP
   \   000006   4A4E         MOV.B   R14, R10
    554            zAddrType_t dstAddr;
    555            uint8 len;
    556          
    557            (void)SecurityEnable;  // Intentionally unreferenced parameter
    558          
    559            dstAddr.addrMode = (afAddrMode_t)AddrBroadcast;
   \   000008   ........     CALLA   #?Subroutine17
    560            dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
   \                     ??CrossCallReturnLabel_11:
   \   00000C   1F42....     MOV.W   &ZDP_TmpBuf, R15
   \   000010   CF4C0000     MOV.B   R12, 0(R15)
    561          
    562            ZDP_TmpBuf[0] = LO_UINT16( nwkAddr );
    563            ZDP_TmpBuf[1] = HI_UINT16( nwkAddr );
   \   000014                RPT     #0x8
   \   000014   47190C10     RRUX.W  R12
   \   000018   CF4C0100     MOV.B   R12, 0x1(R15)
    564            osal_cpyExtAddr( &ZDP_TmpBuf[2], IEEEAddr );
   \   00001C   2F53         ADD.W   #0x2, R15
   \   00001E   0C4F         MOV.W   R15, R12
   \   000020   ........     CALLA   #??Subroutine25_0
    565            len = 2 + Z_EXTADDR_LEN;
    566          
    567            ZDP_TmpBuf[10] = capabilities;
   \                     ??CrossCallReturnLabel_30:
   \   000024   CF4A0A00     MOV.B   R10, 0xa(R15)
    568            len++;
    569          
    570            return fillAndSend( &ZDP_TransID, &dstAddr, Device_annce, len );
   \   000028   7F400B00     MOV.B   #0xb, R15
   \   00002C   3E401300     MOV.W   #0x13, R14
   \   000030   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_40:
   \   000034   31500A00     ADD.W   #0xa, SP
   \   000038   3A41         POP.W   R10
   \   00003A   1001         RETA
    571          }
    572          
    573          /*********************************************************************
    574           * Address Responses
    575           */
    576          
    577          /*********************************************************************
    578           * @fn      zdpProcessAddrReq
    579           *
    580           * @brief   Process an incoming NWK_addr_req or IEEE_addr_req message and then
    581           *          build and send a corresponding NWK_addr_rsp or IEEE_addr_rsp msg.
    582           *
    583           * @param   inMsg - incoming message
    584           *
    585           * @return  none
    586           */

   \                                 In  segment CODE, align 2, keep-with-next
    587          void zdpProcessAddrReq( zdoIncomingMsg_t *inMsg )
   \                     zdpProcessAddrReq:
    588          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   31801000     SUB.W   #0x10, SP
   \   000006   0B4C         MOV.W   R12, R11
    589            associated_devices_t *pAssoc;
    590            uint8 reqType;
    591            uint16 aoi = INVALID_NODE_ADDR;
   \   000008   3940FEFF     MOV.W   #0xfffe, R9
    592            uint8 *ieee = NULL;
   \   00000C   0643         MOV.W   #0x0, R6
    593          
    594            reqType = inMsg->asdu[(inMsg->clusterID == NWK_addr_req) ? Z_EXTADDR_LEN : sizeof( uint16 ) ];
   \   00000E   1F4C0E00     MOV.W   0xe(R12), R15
   \   000012   0F93         CMP.W   #0x0, R15
   \   000014   0224         JEQ     ??zdpProcessAddrReq_5
   \   000016   2743         MOV.W   #0x2, R7
   \   000018   013C         JMP     ??zdpProcessAddrReq_6
   \                     ??zdpProcessAddrReq_5:
   \   00001A   3742         MOV.W   #0x8, R7
   \                     ??zdpProcessAddrReq_6:
   \   00001C   1E4C1600     MOV.W   0x16(R12), R14
   \   000020   0D4E         MOV.W   R14, R13
   \   000022   0D57         ADD.W   R7, R13
   \   000024   674D         MOV.B   @R13, R7
    595          
    596            if ( inMsg->clusterID == NWK_addr_req )
   \   000026   3840....     MOV.W   #ZDAppNwkAddr, R8
   \   00002A   0F93         CMP.W   #0x0, R15
   \   00002C   1620         JNE     ??zdpProcessAddrReq_7
    597          
    598            {
    599              ieee = inMsg->asdu;
   \   00002E   064E         MOV.W   R14, R6
    600          
    601              if ( osal_ExtAddrEqual( saveExtAddr, ieee ) )
   \   000030   0D4E         MOV.W   R14, R13
   \   000032   3C40....     MOV.W   #saveExtAddr, R12
   \   000036   ........     CALLA   #sAddrExtCmp
   \   00003A   4C93         CMP.B   #0x0, R12
   \   00003C   0224         JEQ     ??zdpProcessAddrReq_8
    602              {
    603                aoi = ZDAppNwkAddr.addr.shortAddr;
   \   00003E   2948         MOV.W   @R8, R9
   \   000040   303C         JMP     ??zdpProcessAddrReq_9
    604              }
    605              // Handle response for sleeping end devices
    606              else if ( (ZSTACK_ROUTER_BUILD)
    607                && (((pAssoc = AssocGetWithExt( ieee )) != NULL)
    608                       && (pAssoc->nodeRelation == CHILD_RFD)) )
   \                     ??zdpProcessAddrReq_8:
   \   000042   0C46         MOV.W   R6, R12
   \   000044   ........     CALLA   #AssocGetWithExt
   \   000048   0C93         CMP.W   #0x0, R12
   \   00004A   3024         JEQ     ??zdpProcessAddrReq_10
   \   00004C   DC930400     CMP.B   #0x1, 0x4(R12)
   \   000050   2D20         JNE     ??zdpProcessAddrReq_10
    609              {
    610                aoi = pAssoc->shortAddr;
   \   000052   294C         MOV.W   @R12, R9
    611                if ( reqType != ZDP_ADDR_REQTYPE_SINGLE )
   \   000054   4793         CMP.B   #0x0, R7
   \   000056   2420         JNE     ??zdpProcessAddrReq_11
   \   000058   243C         JMP     ??zdpProcessAddrReq_9
    612                  reqType = 0xFF; // Force Invalid
    613              }
    614            }
    615            else  // if ( inMsg->clusterID == IEEE_addr_req )
    616            {
    617              aoi = BUILD_UINT16( inMsg->asdu[0], inMsg->asdu[1] );
   \                     ??zdpProcessAddrReq_7:
   \   00005A   694E         MOV.B   @R14, R9
   \   00005C   5F4E0100     MOV.B   0x1(R14), R15
   \   000060                RPT     #0x8
   \   000060   47180F5F     RLAX.W  R15
   \   000064   095F         ADD.W   R15, R9
    618          
    619              if ( aoi == ZDAppNwkAddr.addr.shortAddr )
   \   000066   2998         CMP.W   @R8, R9
   \   000068   0320         JNE     ??zdpProcessAddrReq_12
    620              {
    621                ieee = saveExtAddr;
   \   00006A   3640....     MOV.W   #saveExtAddr, R6
   \   00006E   193C         JMP     ??zdpProcessAddrReq_9
    622              }
    623              else if ( (ZSTACK_ROUTER_BUILD)
    624                && (((pAssoc = AssocGetWithShort( aoi )) != NULL)
    625                       && (pAssoc->nodeRelation == CHILD_RFD)) )
   \                     ??zdpProcessAddrReq_12:
   \   000070   0C49         MOV.W   R9, R12
   \   000072   ........     CALLA   #AssocGetWithShort
   \   000076   0C93         CMP.W   #0x0, R12
   \   000078   1924         JEQ     ??zdpProcessAddrReq_10
   \   00007A   DC930400     CMP.B   #0x1, 0x4(R12)
   \   00007E   1620         JNE     ??zdpProcessAddrReq_10
    626              {
    627                AddrMgrEntry_t addrEntry;
    628                addrEntry.user = ADDRMGR_USER_DEFAULT;
   \   000080   C1430200     MOV.B   #0x0, 0x2(SP)
    629                addrEntry.index = pAssoc->addrIdx;
   \   000084   914C02000E00 MOV.W   0x2(R12), 0xe(SP)
    630                if ( AddrMgrEntryGet( &addrEntry ) )
   \   00008A   0C41         MOV.W   SP, R12
   \   00008C   2C53         ADD.W   #0x2, R12
   \   00008E   ........     CALLA   #AddrMgrEntryGet
   \   000092   4C93         CMP.B   #0x0, R12
   \   000094   0324         JEQ     ??zdpProcessAddrReq_13
    631                {
    632                  ieee = addrEntry.extAddr;
   \   000096   0641         MOV.W   SP, R6
   \   000098   36500600     ADD.W   #0x6, R6
    633                }
    634          
    635                if ( reqType != ZDP_ADDR_REQTYPE_SINGLE )
   \                     ??zdpProcessAddrReq_13:
   \   00009C   4793         CMP.B   #0x0, R7
   \   00009E   0124         JEQ     ??zdpProcessAddrReq_9
    636                  reqType = 0xFF; // Force Invalid
   \                     ??zdpProcessAddrReq_11:
   \   0000A0   7743         MOV.B   #0xff, R7
    637              }
    638            }
    639          
    640            if ( ((aoi != INVALID_NODE_ADDR) && (ieee != NULL)) || (inMsg->wasBroadcast == FALSE) )
   \                     ??zdpProcessAddrReq_9:
   \   0000A2   3990FEFF     CMP.W   #0xfffe, R9
   \   0000A6   0224         JEQ     ??zdpProcessAddrReq_10
   \   0000A8   0693         CMP.W   #0x0, R6
   \   0000AA   0320         JNE     ??zdpProcessAddrReq_14
   \                     ??zdpProcessAddrReq_10:
   \   0000AC   CB930C00     CMP.B   #0x0, 0xc(R11)
   \   0000B0   8220         JNE     ??zdpProcessAddrReq_15
    641            {
    642              uint8 stat;
    643              uint8 *pBuf = ZDP_TmpBuf;
   \                     ??zdpProcessAddrReq_14:
   \   0000B2   1C42....     MOV.W   &ZDP_TmpBuf, R12
    644              // Status + IEEE-Addr + Nwk-Addr.
    645              uint8 len = 1 + Z_EXTADDR_LEN + 2;
   \   0000B6   7A400B00     MOV.B   #0xb, R10
    646              
    647              // If aoi and iee are both setup, we found results
    648              if ( (aoi != INVALID_NODE_ADDR) && (ieee != NULL) )
   \   0000BA   3990FEFF     CMP.W   #0xfffe, R9
   \   0000BE   0B24         JEQ     ??zdpProcessAddrReq_16
   \   0000C0   0693         CMP.W   #0x0, R6
   \   0000C2   0924         JEQ     ??zdpProcessAddrReq_16
    649              {
    650                stat = ((reqType == ZDP_ADDR_REQTYPE_SINGLE) || (reqType == ZDP_ADDR_REQTYPE_EXTENDED)) 
    651                              ? ZDP_SUCCESS : ZDP_INVALID_REQTYPE;
   \   0000C4   4793         CMP.B   #0x0, R7
   \   0000C6   0524         JEQ     ??zdpProcessAddrReq_4
   \   0000C8   5793         CMP.B   #0x1, R7
   \   0000CA   0324         JEQ     ??zdpProcessAddrReq_4
   \   0000CC   75408000     MOV.B   #0x80, R5
   \   0000D0   0B3C         JMP     ??zdpProcessAddrReq_2
   \                     ??zdpProcessAddrReq_4:
   \   0000D2   4543         MOV.B   #0x0, R5
   \   0000D4   093C         JMP     ??zdpProcessAddrReq_2
    652              }
    653              else 
    654              {
    655                // not found and the req was unicast to this device
    656                stat = ZDP_DEVICE_NOT_FOUND;
   \                     ??zdpProcessAddrReq_16:
   \   0000D6   75408100     MOV.B   #0x81, R5
    657                
    658                // Fill in the missing field with this device's address
    659                if ( inMsg->clusterID == NWK_addr_req )
   \   0000DA   8B930E00     CMP.W   #0x0, 0xe(R11)
   \   0000DE   0220         JNE     ??zdpProcessAddrReq_17
    660                {
    661                  aoi = ZDAppNwkAddr.addr.shortAddr;
   \   0000E0   2948         MOV.W   @R8, R9
   \   0000E2   023C         JMP     ??zdpProcessAddrReq_2
    662                }
    663                else
    664                {
    665                  ieee = saveExtAddr;
   \                     ??zdpProcessAddrReq_17:
   \   0000E4   3640....     MOV.W   #saveExtAddr, R6
    666                }
    667              }
    668          
    669              *pBuf++ = stat;
   \                     ??zdpProcessAddrReq_2:
   \   0000E8   CC450000     MOV.B   R5, 0(R12)
   \   0000EC   1C53         ADD.W   #0x1, R12
    670          
    671              pBuf = osal_cpyExtAddr( pBuf, ieee );
   \   0000EE   0D46         MOV.W   R6, R13
   \   0000F0   ........     CALLA   #sAddrExtCpy
   \   0000F4   044C         MOV.W   R12, R4
    672          
    673              *pBuf++ = LO_UINT16( aoi );
   \   0000F6   CC490000     MOV.B   R9, 0(R12)
   \   0000FA   1453         ADD.W   #0x1, R4
    674              *pBuf++ = HI_UINT16( aoi );
   \   0000FC   0F49         MOV.W   R9, R15
   \   0000FE                RPT     #0x8
   \   0000FE   47190F10     RRUX.W  R15
   \   000102   C44F0000     MOV.B   R15, 0(R4)
   \   000106   1453         ADD.W   #0x1, R4
    675          
    676              if ( ZSTACK_ROUTER_BUILD )
    677              {
    678                if ( (reqType == ZDP_ADDR_REQTYPE_EXTENDED) && (aoi == ZDAppNwkAddr.addr.shortAddr)
    679                     && (stat == ZDP_SUCCESS) )
   \   000108   5793         CMP.B   #0x1, R7
   \   00010A   4620         JNE     ??zdpProcessAddrReq_18
   \   00010C   2998         CMP.W   @R8, R9
   \   00010E   4420         JNE     ??zdpProcessAddrReq_18
   \   000110   4593         CMP.B   #0x0, R5
   \   000112   4220         JNE     ??zdpProcessAddrReq_18
    680                {
    681                  uint8  cnt = 0;
   \   000114   C1430000     MOV.B   #0x0, 0(SP)
    682                  uint16 *list = AssocMakeList( &cnt );
   \   000118   0C41         MOV.W   SP, R12
   \   00011A   0C53         ADD.W   #0x0, R12
   \   00011C   ........     CALLA   #AssocMakeList
    683          
    684                  if ( list != NULL )
   \   000120   0C93         CMP.W   #0x0, R12
   \   000122   3624         JEQ     ??zdpProcessAddrReq_19
    685                  {
    686                    byte idx = inMsg->asdu[(((inMsg->clusterID == NWK_addr_req) ? Z_EXTADDR_LEN : sizeof( uint16 )) + 1)];
   \   000124   8B930E00     CMP.W   #0x0, 0xe(R11)
   \   000128   0224         JEQ     ??zdpProcessAddrReq_20
   \   00012A   2F43         MOV.W   #0x2, R15
   \   00012C   013C         JMP     ??zdpProcessAddrReq_21
   \                     ??zdpProcessAddrReq_20:
   \   00012E   3F42         MOV.W   #0x8, R15
   \                     ??zdpProcessAddrReq_21:
   \   000130   174B1600     MOV.W   0x16(R11), R7
   \   000134   075F         ADD.W   R15, R7
   \   000136   5E470100     MOV.B   0x1(R7), R14
    687                    uint16 *pList = list + idx;
   \   00013A   474E         MOV.B   R14, R7
   \   00013C   0757         RLA.W   R7
   \   00013E   0F4C         MOV.W   R12, R15
   \   000140   0F57         ADD.W   R7, R15
    688          
    689                    // NumAssocDev field is only present on success.
    690                    if ( cnt > idx )
   \   000142   6E91         CMP.B   @SP, R14
   \   000144   082C         JC      ??zdpProcessAddrReq_22
    691                    {
    692                      cnt -= idx;
   \   000146   6A41         MOV.B   @SP, R10
   \   000148   4A8E         SUB.B   R14, R10
   \   00014A   C14A0000     MOV.B   R10, 0(SP)
    693                      len += (cnt * sizeof( uint16 ));
   \   00014E   4A5A         RLA.B   R10
   \   000150   7A500B00     ADD.B   #0xb, R10
   \   000154   023C         JMP     ??zdpProcessAddrReq_23
    694                    }
    695                    else
    696                    {
    697                      cnt = 0;
   \                     ??zdpProcessAddrReq_22:
   \   000156   C1430000     MOV.B   #0x0, 0(SP)
    698                    }
    699                    *pBuf++ = cnt;
   \                     ??zdpProcessAddrReq_23:
   \   00015A   E4410000     MOV.B   @SP, 0(R4)
   \   00015E   1453         ADD.W   #0x1, R4
    700                    len++;
    701          
    702                    // StartIndex field is only present if NumAssocDev field is non-zero.
    703                    *pBuf++ = idx;
   \   000160   C44E0000     MOV.B   R14, 0(R4)
   \   000164   1453         ADD.W   #0x1, R4
    704                    len++;
   \   000166   6A53         ADD.B   #0x2, R10
   \   000168   0D3C         JMP     ??zdpProcessAddrReq_24
    705          
    706                    while ( cnt != 0 )
    707                    {
    708                      *pBuf++ = LO_UINT16( *pList );
   \                     ??zdpProcessAddrReq_0:
   \   00016A   E44F0000     MOV.B   @R15, 0(R4)
   \   00016E   1453         ADD.W   #0x1, R4
    709                      *pBuf++ = HI_UINT16( *pList );
   \   000170   3E4F         MOV.W   @R15+, R14
   \   000172                RPT     #0x8
   \   000172   47190E10     RRUX.W  R14
   \   000176   C44E0000     MOV.B   R14, 0(R4)
   \   00017A   1453         ADD.W   #0x1, R4
    710                      pList++;
    711                      cnt--;
   \   00017C   6E41         MOV.B   @SP, R14
   \   00017E   7E53         ADD.B   #0xff, R14
   \   000180   C14E0000     MOV.B   R14, 0(SP)
    712                    }
   \                     ??zdpProcessAddrReq_24:
   \   000184   C1930000     CMP.B   #0x0, 0(SP)
   \   000188   F023         JNE     ??zdpProcessAddrReq_0
    713          
    714                    osal_mem_free( (uint8 *)list );
   \   00018A   ........     CALLA   #osal_mem_free
   \   00018E   043C         JMP     ??zdpProcessAddrReq_18
    715                  }
    716                  else
    717                  {
    718                    // NumAssocDev field is only present on success.
    719                    *pBuf++ = 0;
   \                     ??zdpProcessAddrReq_19:
   \   000190   C4430000     MOV.B   #0x0, 0(R4)
    720                    len++;
   \   000194   7A400C00     MOV.B   #0xc, R10
    721                  }
    722                }
    723              }
    724          
    725              ZDP_TxOptions = AF_MSG_ACK_REQUEST;
   \                     ??zdpProcessAddrReq_18:
   \   000198   F2401000.... MOV.B   #0x10, &ZDP_TxOptions
    726              fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), (cId_t)(inMsg->clusterID | ZDO_RESPONSE_BIT), len );
   \   00019E   4F4A         MOV.B   R10, R15
   \   0001A0   1E4B0E00     MOV.W   0xe(R11), R14
   \   0001A4   3ED00080     BIS.W   #0x8000, R14
   \   0001A8   0D4B         MOV.W   R11, R13
   \   0001AA   2D53         ADD.W   #0x2, R13
   \   0001AC   3B501100     ADD.W   #0x11, R11
   \   0001B0   0C4B         MOV.W   R11, R12
   \   0001B2   ........     CALLA   #??Subroutine10_0
    727              ZDP_TxOptions = AF_TX_OPTIONS_NONE;
    728            }
    729          }
   \                     ??zdpProcessAddrReq_15:
   \   0001B6   31501000     ADD.W   #0x10, SP
   \   0001BA   7417         POPM.W  #0x8, R11
   \   0001BC   1001         RETA
    730          
    731          /*********************************************************************
    732           * @fn          ZDP_NodeDescMsg
    733           *
    734           * @brief       Builds and sends a Node Descriptor message, unicast to the
    735           *              specified device.
    736           *
    737           * @param       inMsg - incoming message
    738           * @param       nwkAddr - 16 bit network address for device
    739           * @param       pNodeDesc - pointer to the node descriptor
    740           *
    741           * @return      afStatus_t
    742           */

   \                                 In  segment CODE, align 2, keep-with-next
    743          afStatus_t ZDP_NodeDescMsg( zdoIncomingMsg_t *inMsg,
   \                     ZDP_NodeDescMsg:
    744                                     uint16 nwkAddr, NodeDescriptorFormat_t *pNodeDesc )
    745          {
    746            uint8 *pBuf = ZDP_TmpBuf;
   \   000000   1F42....     MOV.W   &ZDP_TmpBuf, R15
    747            byte len;
    748          
    749            len = 1 + 2 + 13;  // Status + nwkAddr + Node descriptor
    750          
    751            *pBuf++ = ZDP_SUCCESS;
   \   000004   CF430000     MOV.B   #0x0, 0(R15)
   \   000008   1F53         ADD.W   #0x1, R15
    752          
    753            *pBuf++ = LO_UINT16( nwkAddr );
   \   00000A   CF4D0000     MOV.B   R13, 0(R15)
   \   00000E   1F53         ADD.W   #0x1, R15
    754            *pBuf++ = HI_UINT16( nwkAddr );
   \   000010                RPT     #0x8
   \   000010   47190D10     RRUX.W  R13
   \   000014   CF4D0000     MOV.B   R13, 0(R15)
   \   000018   1F53         ADD.W   #0x1, R15
    755          
    756            *pBuf++ = (byte)((pNodeDesc->ComplexDescAvail << 3) |
    757                               (pNodeDesc->UserDescAvail << 4) |
    758                               (pNodeDesc->LogicalType & 0x07));
   \   00001A   6D4E         MOV.B   @R14, R13
   \   00001C   7DF01F00     AND.B   #0x1f, R13
   \   000020   CF4D0000     MOV.B   R13, 0(R15)
   \   000024   1F53         ADD.W   #0x1, R15
    759          
    760            *pBuf++ = (byte)((pNodeDesc->FrequencyBand << 3) | (pNodeDesc->APSFlags & 0x07));
   \   000026   DF4E01000000 MOV.B   0x1(R14), 0(R15)
   \   00002C   1F53         ADD.W   #0x1, R15
    761            *pBuf++ = pNodeDesc->CapabilityFlags;
   \   00002E   DF4E02000000 MOV.B   0x2(R14), 0(R15)
   \   000034   1F53         ADD.W   #0x1, R15
    762            *pBuf++ = pNodeDesc->ManufacturerCode[0];
   \   000036   DF4E03000000 MOV.B   0x3(R14), 0(R15)
   \   00003C   1F53         ADD.W   #0x1, R15
    763            *pBuf++ = pNodeDesc->ManufacturerCode[1];
   \   00003E   DF4E04000000 MOV.B   0x4(R14), 0(R15)
   \   000044   1F53         ADD.W   #0x1, R15
    764            *pBuf++ = pNodeDesc->MaxBufferSize;
   \   000046   DF4E05000000 MOV.B   0x5(R14), 0(R15)
   \   00004C   1F53         ADD.W   #0x1, R15
    765            *pBuf++ = pNodeDesc->MaxInTransferSize[0];
   \   00004E   DF4E06000000 MOV.B   0x6(R14), 0(R15)
   \   000054   1F53         ADD.W   #0x1, R15
    766            *pBuf++ = pNodeDesc->MaxInTransferSize[1];
   \   000056   DF4E07000000 MOV.B   0x7(R14), 0(R15)
   \   00005C   1F53         ADD.W   #0x1, R15
    767          
    768            *pBuf++ = LO_UINT16( pNodeDesc->ServerMask );
   \   00005E   DF4E08000000 MOV.B   0x8(R14), 0(R15)
   \   000064   1F53         ADD.W   #0x1, R15
    769            *pBuf++ = HI_UINT16( pNodeDesc->ServerMask );
   \   000066   DF4E09000000 MOV.B   0x9(R14), 0(R15)
   \   00006C   1F53         ADD.W   #0x1, R15
    770            *pBuf++ = pNodeDesc->MaxOutTransferSize[0];
   \   00006E   DF4E0A000000 MOV.B   0xa(R14), 0(R15)
   \   000074   1F53         ADD.W   #0x1, R15
    771            *pBuf++ = pNodeDesc->MaxOutTransferSize[1];
   \   000076   DF4E0B000000 MOV.B   0xb(R14), 0(R15)
   \   00007C   1F53         ADD.W   #0x1, R15
    772            *pBuf = pNodeDesc->DescriptorCapability;
   \   00007E   DF4E0C000000 MOV.B   0xc(R14), 0(R15)
    773          
    774            return fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), Node_Desc_rsp, len );
   \   000084   7F401000     MOV.B   #0x10, R15
   \   000088   3E400280     MOV.W   #0x8002, R14
   \   00008C   0D4C         MOV.W   R12, R13
   \   00008E   2D53         ADD.W   #0x2, R13
   \   000090   3C501100     ADD.W   #0x11, R12
   \   000094   ........     BRA     #fillAndSend
    775          }
    776          
    777          /*********************************************************************
    778           * @fn          ZDP_PowerDescMsg
    779           *
    780           * @brief       Builds and sends a Power Descriptor message, unicast to the
    781           *              specified device.
    782           *
    783           * @param       inMsg - incoming message (request)
    784           * @param       nwkAddr - 16 bit network address for device
    785           * @param       pPowerDesc - pointer to the node descriptor
    786           *
    787           * @return      afStatus_t
    788           */

   \                                 In  segment CODE, align 2, keep-with-next
    789          afStatus_t ZDP_PowerDescMsg( zdoIncomingMsg_t *inMsg,
   \                     ZDP_PowerDescMsg:
    790                               uint16 nwkAddr, NodePowerDescriptorFormat_t *pPowerDesc )
    791          {
   \   000000   0A12         PUSH.W  R10
    792            uint8 *pBuf = ZDP_TmpBuf;
   \   000002   1A42....     MOV.W   &ZDP_TmpBuf, R10
    793            byte len = 1 + 2 + 2;  // Status + nwkAddr + Node Power descriptor.
    794          
    795            *pBuf++ = ZDP_SUCCESS;
   \   000006   CA430000     MOV.B   #0x0, 0(R10)
   \   00000A   1A53         ADD.W   #0x1, R10
    796          
    797            *pBuf++ = LO_UINT16( nwkAddr );
   \   00000C   CA4D0000     MOV.B   R13, 0(R10)
   \   000010   1A53         ADD.W   #0x1, R10
    798            *pBuf++ = HI_UINT16( nwkAddr );
   \   000012                RPT     #0x8
   \   000012   47190D10     RRUX.W  R13
   \   000016   CA4D0000     MOV.B   R13, 0(R10)
   \   00001A   1A53         ADD.W   #0x1, R10
    799          
    800            *pBuf++ = (byte)((pPowerDesc->AvailablePowerSources << 4)
    801                              | (pPowerDesc->PowerMode & 0x0F));
   \   00001C   EA4E0000     MOV.B   @R14, 0(R10)
   \   000020   1A53         ADD.W   #0x1, R10
    802            *pBuf++ = (byte)((pPowerDesc->CurrentPowerSourceLevel << 4)
    803                              | (pPowerDesc->CurrentPowerSource & 0x0F));
   \   000022   2E4E         MOV.W   @R14, R14
   \   000024   0F4E         MOV.W   R14, R15
   \   000026                RPT     #0x8
   \   000026   47190F10     RRUX.W  R15
   \   00002A   7FF00F00     AND.B   #0xf, R15
   \   00002E                RPT     #0xc
   \   00002E   4B190E10     RRUX.W  R14
   \   000032                RPT     #0x4
   \   000032   43184E5E     RLAX.B  R14
   \   000036   4EDF         BIS.B   R15, R14
   \   000038   CA4E0000     MOV.B   R14, 0(R10)
    804          
    805            return fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), Power_Desc_rsp, len );
   \   00003C   7F400500     MOV.B   #0x5, R15
   \   000040   3E400380     MOV.W   #0x8003, R14
   \   000044   ........     CALLA   #?Subroutine14
   \                     ??CrossCallReturnLabel_8:
   \   000048   3A41         POP.W   R10
   \   00004A   1001         RETA
    806          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine14:
   \   000000   0D4C         MOV.W   R12, R13
   \   000002   2D53         ADD.W   #0x2, R13
   \   000004   3C501100     ADD.W   #0x11, R12
   \   000008   ........     BRA     #fillAndSend
    807          
    808          /*********************************************************************
    809           * @fn          ZDP_SimpleDescMsg
    810           *
    811           * @brief       Builds and sends a Simple Descriptor message, unicast to the
    812           *              specified device.
    813           *
    814           * @param       inMsg - incoming message (request)
    815           * @param       Status - message status (ZDP_SUCCESS or other)
    816           * @param       pSimpleDesc - pointer to the node descriptor
    817           *
    818           * @return      afStatus_t
    819           */

   \                                 In  segment CODE, align 2, keep-with-next
    820          afStatus_t ZDP_SimpleDescMsg( zdoIncomingMsg_t *inMsg, byte Status,
   \                     ZDP_SimpleDescMsg:
    821                                        SimpleDescriptionFormat_t *pSimpleDesc )
    822          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4D         MOV.B   R13, R10
   \   000004   0F4E         MOV.W   R14, R15
    823            uint8 *pBuf = ZDP_TmpBuf;
   \   000006   1B42....     MOV.W   &ZDP_TmpBuf, R11
    824            uint8 i, len;
    825          
    826            if ( Status == ZDP_SUCCESS && pSimpleDesc )
   \   00000A   4D93         CMP.B   #0x0, R13
   \   00000C   0F20         JNE     ??ZDP_SimpleDescMsg_2
   \   00000E   0E93         CMP.W   #0x0, R14
   \   000010   0D24         JEQ     ??ZDP_SimpleDescMsg_2
    827            {
    828              // Status + NWKAddrOfInterest + desc length + empty simple descriptor.
    829              len = 1 + 2 + 1 + 8;
    830              len += (pSimpleDesc->AppNumInClusters + pSimpleDesc->AppNumOutClusters) * sizeof ( uint16 );
   \   000012   5D4E0700     MOV.B   0x7(R14), R13
   \   000016   5D5E0A00     ADD.B   0xa(R14), R13
   \   00001A   4D5D         RLA.B   R13
   \   00001C   7D500C00     ADD.B   #0xc, R13
    831            }
    832            else
    833            {
    834              len = 1 + 2 + 1; // Status + desc length
    835            }
    836            if ( len >= ZDP_BUF_SZ-1 )
   \   000020   7D904F00     CMP.B   #0x4f, R13
   \   000024   0428         JNC     ??ZDP_SimpleDescMsg_3
    837            {
    838              return afStatus_MEM_FAIL;
   \   000026   7C401000     MOV.B   #0x10, R12
   \   00002A   653C         JMP     ??ZDP_SimpleDescMsg_4
    839            }
   \                     ??ZDP_SimpleDescMsg_2:
   \   00002C   6D42         MOV.B   #0x4, R13
    840          
    841            *pBuf++ = Status;
   \                     ??ZDP_SimpleDescMsg_3:
   \   00002E   CB4A0000     MOV.B   R10, 0(R11)
   \   000032   1B53         ADD.W   #0x1, R11
    842          
    843            *pBuf++ = LO_UINT16( ZDAppNwkAddr.addr.shortAddr );
   \   000034   DB42....0000 MOV.B   &ZDAppNwkAddr, 0(R11)
   \   00003A   1B53         ADD.W   #0x1, R11
    844            *pBuf++ = HI_UINT16( ZDAppNwkAddr.addr.shortAddr );
   \   00003C   DB42....0000 MOV.B   &ZDAppNwkAddr + 1, 0(R11)
   \   000042   1B53         ADD.W   #0x1, R11
    845          
    846            if ( len > 4 )
   \   000044   7D900500     CMP.B   #0x5, R13
   \   000048   4F28         JNC     ??ZDP_SimpleDescMsg_5
    847            {
    848              *pBuf++ = len - 4;   // Simple descriptor length
   \   00004A   4E4D         MOV.B   R13, R14
   \   00004C   6E82         SUB.B   #0x4, R14
   \   00004E   CB4E0000     MOV.B   R14, 0(R11)
   \   000052   1B53         ADD.W   #0x1, R11
    849          
    850              *pBuf++ = pSimpleDesc->EndPoint;
   \   000054   EB4F0000     MOV.B   @R15, 0(R11)
   \   000058   1B53         ADD.W   #0x1, R11
    851              *pBuf++ = LO_UINT16( pSimpleDesc->AppProfId );
   \   00005A   DB4F02000000 MOV.B   0x2(R15), 0(R11)
   \   000060   1B53         ADD.W   #0x1, R11
    852              *pBuf++ = HI_UINT16( pSimpleDesc->AppProfId );
   \   000062   DB4F03000000 MOV.B   0x3(R15), 0(R11)
   \   000068   1B53         ADD.W   #0x1, R11
    853              *pBuf++ = LO_UINT16( pSimpleDesc->AppDeviceId );
   \   00006A   DB4F04000000 MOV.B   0x4(R15), 0(R11)
   \   000070   1B53         ADD.W   #0x1, R11
    854              *pBuf++ = HI_UINT16( pSimpleDesc->AppDeviceId );
   \   000072   DB4F05000000 MOV.B   0x5(R15), 0(R11)
   \   000078   1B53         ADD.W   #0x1, R11
    855          
    856              *pBuf++ = (byte)(pSimpleDesc->AppDevVer << 4);
   \   00007A   5E4F0600     MOV.B   0x6(R15), R14
   \   00007E                RPT     #0x4
   \   00007E   43184E5E     RLAX.B  R14
   \   000082   CB4E0000     MOV.B   R14, 0(R11)
   \   000086   1B53         ADD.W   #0x1, R11
    857          
    858              *pBuf++ = pSimpleDesc->AppNumInClusters;
   \   000088   DB4F07000000 MOV.B   0x7(R15), 0(R11)
   \   00008E   1B53         ADD.W   #0x1, R11
    859              if ( pSimpleDesc->AppNumInClusters )
   \   000090   CF930700     CMP.B   #0x0, 0x7(R15)
   \   000094   1124         JEQ     ??ZDP_SimpleDescMsg_6
    860              {
    861                for (i=0; i<pSimpleDesc->AppNumInClusters; ++i)
   \   000096   4E43         MOV.B   #0x0, R14
   \   000098   0C3C         JMP     ??ZDP_SimpleDescMsg_7
    862                {
    863                  *pBuf++ = LO_UINT16( pSimpleDesc->pAppInClusterList[i] );
   \                     ??ZDP_SimpleDescMsg_0:
   \   00009A   4A4E         MOV.B   R14, R10
   \   00009C   0A5A         RLA.W   R10
   \   00009E   184F0800     MOV.W   0x8(R15), R8
   \   0000A2   085A         ADD.W   R10, R8
   \   0000A4   EB480000     MOV.B   @R8, 0(R11)
   \   0000A8   1B53         ADD.W   #0x1, R11
    864                  *pBuf++ = HI_UINT16( pSimpleDesc->pAppInClusterList[i] );
   \   0000AA   184F0800     MOV.W   0x8(R15), R8
   \   0000AE   ........     CALLA   #?Subroutine19
    865                }
   \                     ??ZDP_SimpleDescMsg_7:
   \   0000B2   5E9F0700     CMP.B   0x7(R15), R14
   \   0000B6   F12B         JNC     ??ZDP_SimpleDescMsg_0
    866              }
    867          
    868              *pBuf++ = pSimpleDesc->AppNumOutClusters;
   \                     ??ZDP_SimpleDescMsg_6:
   \   0000B8   DB4F0A000000 MOV.B   0xa(R15), 0(R11)
   \   0000BE   1B53         ADD.W   #0x1, R11
    869              if ( pSimpleDesc->AppNumOutClusters )
   \   0000C0   CF930A00     CMP.B   #0x0, 0xa(R15)
   \   0000C4   1324         JEQ     ??ZDP_SimpleDescMsg_8
    870              {
    871                for (i=0; i<pSimpleDesc->AppNumOutClusters; ++i)
   \   0000C6   4E43         MOV.B   #0x0, R14
   \                     ??ZDP_SimpleDescMsg_1:
   \   0000C8   5E9F0A00     CMP.B   0xa(R15), R14
   \   0000CC   0F2C         JC      ??ZDP_SimpleDescMsg_8
    872                {
    873                  *pBuf++ = LO_UINT16( pSimpleDesc->pAppOutClusterList[i] );
   \   0000CE   4A4E         MOV.B   R14, R10
   \   0000D0   0A5A         RLA.W   R10
   \   0000D2   184F0C00     MOV.W   0xc(R15), R8
   \   0000D6   085A         ADD.W   R10, R8
   \   0000D8   EB480000     MOV.B   @R8, 0(R11)
   \   0000DC   1B53         ADD.W   #0x1, R11
    874                  *pBuf++ = HI_UINT16( pSimpleDesc->pAppOutClusterList[i] );
   \   0000DE   184F0C00     MOV.W   0xc(R15), R8
   \   0000E2   ........     CALLA   #?Subroutine19
    875                }
    876              }
    877            }
   \                     ??CrossCallReturnLabel_16:
   \   0000E6   F03F         JMP     ??ZDP_SimpleDescMsg_1
    878          
    879            else
    880            {
    881              *pBuf = 0; // Description Length = 0;
   \                     ??ZDP_SimpleDescMsg_5:
   \   0000E8   CB430000     MOV.B   #0x0, 0(R11)
    882            }
    883          
    884            return fillAndSend( &(inMsg->TransSeq), &(inMsg->srcAddr), Simple_Desc_rsp, len );
   \                     ??ZDP_SimpleDescMsg_8:
   \   0000EC   4F4D         MOV.B   R13, R15
   \   0000EE   3E400480     MOV.W   #0x8004, R14
   \   0000F2   ........     CALLA   #?Subroutine14
   \                     ??ZDP_SimpleDescMsg_4:
   \   0000F6   3817         POPM.W  #0x4, R11
   \   0000F8   1001         RETA
    885          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine19:
   \   000000   085A         ADD.W   R10, R8
   \   000002   DB4801000000 MOV.B   0x1(R8), 0(R11)
   \   000008   1B53         ADD.W   #0x1, R11
   \   00000A   5E53         ADD.B   #0x1, R14
   \   00000C   1001         RETA
    886          
    887          /*********************************************************************
    888           * @fn          ZDP_EPRsp
    889           *
    890           * @brief       This builds and send an endpoint list. Used in
    891           *              Active_EP_rsp and Match_Desc_Rsp
    892           *              message.  This function sends unicast message to the
    893           *              requesting device.
    894           *
    895           * @param       MsgType - either Active_EP_rsp or Match_Desc_Rsp
    896           * @param       dstAddr - destination address
    897           * @param       Status - message status (ZDP_SUCCESS or other)
    898           * @param       nwkAddr - Device's short address that this response describes
    899           * @param       Count - number of endpoint/interfaces in list
    900           * @param       pEPIntfList - Array of Endpoint/Interfaces
    901           * @param       SecurityEnable - Security Options
    902           *
    903           * @return      afStatus_t
    904           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   ........     CALLA   #?Subroutine21
   \                     ??CrossCallReturnLabel_17:
   \   000004   1C53         ADD.W   #0x1, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine21:
   \   000000   CC4E0000     MOV.B   R14, 0(R12)
   \   000004   1C53         ADD.W   #0x1, R12
   \   000006                RPT     #0x8
   \   000006   47190E10     RRUX.W  R14
   \   00000A   CC4E0000     MOV.B   R14, 0(R12)
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
    905          afStatus_t ZDP_EPRsp( uint16 MsgType, byte TransSeq, zAddrType_t *dstAddr,
   \                     ZDP_EPRsp:
    906                                  byte Status, uint16 nwkAddr, byte Count,
    907                                  uint8 *pEPList,
    908                                  byte SecurityEnable )
    909          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4D12         PUSH.B  R13
   \   000004   0B4C         MOV.W   R12, R11
   \   000006   084E         MOV.W   R14, R8
   \   000008   1D411200     MOV.W   0x12(SP), R13
    910            uint8 *pBuf = ZDP_TmpBuf;
   \   00000C   1C42....     MOV.W   &ZDP_TmpBuf, R12
    911            byte len = 1 + 2 + 1;  // Status + nwkAddr + endpoint/interface count.
   \   000010   6A42         MOV.B   #0x4, R10
    912            byte txOptions;
    913          
    914            (void)SecurityEnable;  // Intentionally unreferenced parameter
    915          
    916            if ( MsgType == Match_Desc_rsp )
   \   000012   3B900680     CMP.W   #0x8006, R11
   \   000016   0224         JEQ     ??ZDP_EPRsp_0
   \   000018   4943         MOV.B   #0x0, R9
   \   00001A   023C         JMP     ??ZDP_EPRsp_1
   \                     ??ZDP_EPRsp_0:
   \   00001C   79401000     MOV.B   #0x10, R9
    917              txOptions = AF_MSG_ACK_REQUEST;
    918            else
    919              txOptions = 0;
    920          
    921              *pBuf++ = Status;
   \                     ??ZDP_EPRsp_1:
   \   000020   CC4F0000     MOV.B   R15, 0(R12)
   \   000024   1C53         ADD.W   #0x1, R12
   \   000026   1E410E00     MOV.W   0xe(SP), R14
    922            *pBuf++ = LO_UINT16( nwkAddr );
   \   00002A   ........     CALLA   #?Subroutine9
    923            *pBuf++ = HI_UINT16( nwkAddr );
   \                     ??CrossCallReturnLabel_3:
   \   00002E   5E411000     MOV.B   0x10(SP), R14
    924          
    925            *pBuf++ = Count;   // Endpoint/Interface count
   \   000032   CC4E0000     MOV.B   R14, 0(R12)
   \   000036   1C53         ADD.W   #0x1, R12
    926          
    927            if ( Count )
   \   000038   4E93         CMP.B   #0x0, R14
   \   00003A   0424         JEQ     ??ZDP_EPRsp_2
    928            {
    929              len += Count;
   \   00003C   4A4E         MOV.B   R14, R10
   \   00003E   6A52         ADD.B   #0x4, R10
    930              osal_memcpy( pBuf, pEPList, Count );
   \   000040   ........     CALLA   #osal_memcpy
    931            }
    932          
    933            FillAndSendTxOptions( &TransSeq, dstAddr, MsgType, len, txOptions );
   \                     ??ZDP_EPRsp_2:
   \   000044   C249....     MOV.B   R9, &ZDP_TxOptions
   \   000048   4F4A         MOV.B   R10, R15
   \   00004A   0E4B         MOV.W   R11, R14
   \   00004C   0D48         MOV.W   R8, R13
   \   00004E   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_32:
   \   000052   2153         ADD.W   #0x2, SP
   \   000054   3817         POPM.W  #0x4, R11
   \   000056   1001         RETA
    934          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine10:
   \   000000   0C41         MOV.W   SP, R12
   \   000002   2C52         ADD.W   #0x4, R12
   \   000004                REQUIRE ??Subroutine10_0
   \   000004                // Fall through to label ??Subroutine10_0
    935          
    936          /*********************************************************************
    937           * @fn          ZDP_UserDescRsp
    938           *
    939           * @brief       Build and send the User Decriptor Response.
    940           *
    941           *
    942           * @param       dstAddr - destination address
    943           * @param       nwkAddrOfInterest -
    944           * @param       userDesc -
    945           * @param       SecurityEnable - Security Options
    946           *
    947           * @return      ZStatus_t
    948           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine13:
   \   000000   0C41         MOV.W   SP, R12
   \   000002   2C52         ADD.W   #0x4, R12
   \   000004   ........     BRA     #fillAndSend

   \                                 In  segment CODE, align 2, keep-with-next
    949          ZStatus_t ZDP_UserDescRsp( byte TransSeq, zAddrType_t *dstAddr,
   \                     ZDP_UserDescRsp:
    950                          uint16 nwkAddrOfInterest, UserDescriptorFormat_t *userDesc,
    951                          byte SecurityEnable )
    952          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   4C12         PUSH.B  R12
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   0D4F         MOV.W   R15, R13
    953            uint8 *pBuf = ZDP_TmpBuf;
   \   000008   1C42....     MOV.W   &ZDP_TmpBuf, R12
    954            byte len = 1 + 2 + 1;  // Status + nwkAddr + descriptor length.
    955          
    956            (void)SecurityEnable;  // Intentionally unreferenced parameter
    957          
    958            len += userDesc->len;
   \   00000C   6A4F         MOV.B   @R15, R10
   \   00000E   6A52         ADD.B   #0x4, R10
    959          
    960            *pBuf++ = ZSUCCESS;
   \   000010   CC430000     MOV.B   #0x0, 0(R12)
   \   000014   1C53         ADD.W   #0x1, R12
    961          
    962            *pBuf++ = LO_UINT16( nwkAddrOfInterest );
   \   000016   ........     CALLA   #?Subroutine9
    963            *pBuf++ = HI_UINT16( nwkAddrOfInterest );
    964          
    965            *pBuf++ = userDesc->len;
   \                     ??CrossCallReturnLabel_2:
   \   00001A   EC4F0000     MOV.B   @R15, 0(R12)
   \   00001E   1C53         ADD.W   #0x1, R12
    966            osal_memcpy( pBuf, userDesc->desc, userDesc->len );
   \   000020   6E4F         MOV.B   @R15, R14
   \   000022   1D53         ADD.W   #0x1, R13
   \   000024   ........     CALLA   #osal_memcpy
    967          
    968            return (ZStatus_t)fillAndSend( &TransSeq, dstAddr, User_Desc_rsp, len );
   \   000028   4F4A         MOV.B   R10, R15
   \   00002A   3E401180     MOV.W   #0x8011, R14
   \   00002E   0D4B         MOV.W   R11, R13
   \   000030   ........     CALLA   #?Subroutine13
   \                     ??CrossCallReturnLabel_4:
   \   000034   2153         ADD.W   #0x2, SP
   \   000036   1A17         POPM.W  #0x2, R11
   \   000038   1001         RETA
    969          }
    970          
    971          /*********************************************************************
    972           * @fn          ZDP_ServerDiscRsp
    973           *
    974           * @brief       Build and send the Server_Discovery_rsp response.
    975           *
    976           * @param       transID - Transaction sequence number of request.
    977           * @param       dstAddr - Network Destination Address.
    978           * @param       status - Status of response to request.
    979           * @param       aoi - Network Address of Interest of request.
    980           * @param       serverMask - Bit map of service(s) being sought.
    981           * @param       SecurityEnable - Security Options
    982           *
    983           * @return      ZStatus_t
    984           */

   \                                 In  segment CODE, align 2, keep-with-next
    985          ZStatus_t ZDP_ServerDiscRsp( byte transID, zAddrType_t *dstAddr, byte status,
   \                     ZDP_ServerDiscRsp:
    986                                     uint16 aoi, uint16 serverMask, byte SecurityEnable )
    987          {
   \   000000   4C12         PUSH.B  R12
    988            const byte len = 1  + 2;  // status + aoi + mask.
    989            uint8 *pBuf = ZDP_TmpBuf;
   \   000002   1F42....     MOV.W   &ZDP_TmpBuf, R15
    990            ZStatus_t stat;
    991          
    992            // Intentionally unreferenced parameters
    993            (void)aoi;
    994            (void)SecurityEnable;
    995          
    996            *pBuf++ = status;
   \   000006   CF4E0000     MOV.B   R14, 0(R15)
   \   00000A   1F53         ADD.W   #0x1, R15
   \   00000C   1E410600     MOV.W   0x6(SP), R14
    997          
    998            *pBuf++ = LO_UINT16( serverMask );
   \   000010   CF4E0000     MOV.B   R14, 0(R15)
   \   000014   1F53         ADD.W   #0x1, R15
    999            *pBuf++ = HI_UINT16( serverMask );
   \   000016                RPT     #0x8
   \   000016   47190E10     RRUX.W  R14
   \   00001A   CF4E0000     MOV.B   R14, 0(R15)
   1000          
   1001            ZDP_TxOptions = AF_MSG_ACK_REQUEST;
   \   00001E   F2401000.... MOV.B   #0x10, &ZDP_TxOptions
   1002            stat = fillAndSend( &transID, dstAddr, Server_Discovery_rsp, len );
   \   000024   7F400300     MOV.B   #0x3, R15
   \   000028   3E401580     MOV.W   #0x8015, R14
   \   00002C   ........     CALLA   #?Subroutine10
   1003            ZDP_TxOptions = AF_TX_OPTIONS_NONE;
   1004          
   1005            return ( stat );
   \                     ??CrossCallReturnLabel_31:
   \   000030   2153         ADD.W   #0x2, SP
   \   000032   1001         RETA
   1006          }
   1007          
   1008          /*********************************************************************
   1009           * @fn          ZDP_GenericRsp
   1010           *
   1011           * @brief       Sends a response message with only the parameter status
   1012           *              byte and the addr of interest for data.
   1013           *              This function sends unicast message to the
   1014           *              requesting device.
   1015           *
   1016           * @param       dstAddr - destination address
   1017           * @param       status  - generic status for response
   1018           * @param       aoi     - address of interest
   1019           * @param       dstAddr - destination address
   1020           * @param       rspId   - response cluster ID
   1021           * @param       SecurityEnable - Security Options
   1022           *
   1023           * @return      afStatus_t
   1024           */

   \                                 In  segment CODE, align 2, keep-with-next
   1025          afStatus_t ZDP_GenericRsp( byte TransSeq, zAddrType_t *dstAddr,
   \                     ZDP_GenericRsp:
   1026                               byte status, uint16 aoi, uint16 rspID, byte SecurityEnable )
   1027          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4C12         PUSH.B  R12
   \   000004   1C410800     MOV.W   0x8(SP), R12
   1028            uint8 len;
   1029          
   1030            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1031          
   1032            ZDP_TmpBuf[0] = status;
   \   000008   1A42....     MOV.W   &ZDP_TmpBuf, R10
   \   00000C   CA4E0000     MOV.B   R14, 0(R10)
   1033            ZDP_TmpBuf[1] = LO_UINT16( aoi );
   \   000010   CA4F0100     MOV.B   R15, 0x1(R10)
   1034            ZDP_TmpBuf[2] = HI_UINT16( aoi );
   \   000014                RPT     #0x8
   \   000014   47190F10     RRUX.W  R15
   \   000018   CA4F0200     MOV.B   R15, 0x2(R10)
   1035          
   1036            // Length byte
   1037            ZDP_TmpBuf[3] = 0;
   \   00001C   CA430300     MOV.B   #0x0, 0x3(R10)
   1038            len = 4;
   1039          
   1040            return fillAndSend( &TransSeq, dstAddr, rspID, len );
   \   000020   6F42         MOV.B   #0x4, R15
   \   000022   0E4C         MOV.W   R12, R14
   \   000024   ........     CALLA   #?Subroutine13
   \                     ??CrossCallReturnLabel_5:
   \   000028   2153         ADD.W   #0x2, SP
   \   00002A   3A41         POP.W   R10
   \   00002C   1001         RETA
   1041          }
   1042          
   1043          /*********************************************************************
   1044           * Binding
   1045           */
   1046          /*********************************************************************
   1047           * @fn          ZDP_EndDeviceBindReq
   1048           *
   1049           * @brief       This builds and sends a End_Device_Bind_req message.
   1050           *              This function sends a unicast message.
   1051           *
   1052           * @param       dstAddr - destination address
   1053           * @param       LocalCoordinator - short address of local coordinator
   1054           * @param       epIntf - Endpoint/Interface of Simple Desc
   1055           * @param       ProfileID - Profile ID
   1056           *
   1057           *   The Input cluster list is the opposite of what you would think.
   1058           *   This is the output cluster list of this device
   1059           * @param       NumInClusters - number of input clusters
   1060           * @param       InClusterList - input cluster ID list
   1061           *
   1062           *   The Output cluster list is the opposite of what you would think.
   1063           *   This is the input cluster list of this device
   1064           * @param       NumOutClusters - number of output clusters
   1065           * @param       OutClusterList - output cluster ID list
   1066           *
   1067           * @param       SecurityEnable - Security Options
   1068           *
   1069           * @return      afStatus_t
   1070           */

   \                                 In  segment CODE, align 2, keep-with-next
   1071          afStatus_t ZDP_EndDeviceBindReq( zAddrType_t *dstAddr,
   \                     ZDP_EndDeviceBindReq:
   1072                                           uint16 LocalCoordinator,
   1073                                           byte endPoint,
   1074                                           uint16 ProfileID,
   1075                                           byte NumInClusters, cId_t *InClusterList,
   1076                                           byte NumOutClusters, cId_t *OutClusterList,
   1077                                           byte SecurityEnable )
   1078          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   084C         MOV.W   R12, R8
   \   000004   094D         MOV.W   R13, R9
   \   000006   4B4E         MOV.B   R14, R11
   \   000008   054F         MOV.W   R15, R5
   1079            uint8 *pBuf = ZDP_TmpBuf;
   \   00000A   1642....     MOV.W   &ZDP_TmpBuf, R6
   \   00000E   57411400     MOV.B   0x14(SP), R7
   \   000012   54411800     MOV.B   0x18(SP), R4
   1080            uint8 i, len;
   1081            uint8 *ieeeAddr;
   1082          
   1083            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1084          
   1085            // LocalCoordinator + SrcExtAddr + ep + ProfileID +  NumInClusters + NumOutClusters.
   1086            len = 2 + Z_EXTADDR_LEN + 1 + 2 + 1 + 1;
   1087            len += (NumInClusters + NumOutClusters) * sizeof ( uint16 );
   \   000016   4A47         MOV.B   R7, R10
   \   000018   4A54         ADD.B   R4, R10
   \   00001A   4A5A         RLA.B   R10
   \   00001C   7A500F00     ADD.B   #0xf, R10
   1088          
   1089            if ( len >= ZDP_BUF_SZ-1 )
   \   000020   7A904F00     CMP.B   #0x4f, R10
   \   000024   0328         JNC     ??ZDP_EndDeviceBindReq_2
   1090            {
   1091              return afStatus_MEM_FAIL;
   \   000026   7C401000     MOV.B   #0x10, R12
   \   00002A   443C         JMP     ??ZDP_EndDeviceBindReq_3
   1092            }
   1093          
   1094            if ( LocalCoordinator != NLME_GetShortAddr() )
   \                     ??ZDP_EndDeviceBindReq_2:
   \   00002C   ........     CALLA   #NLME_GetShortAddr
   \   000030   099C         CMP.W   R12, R9
   \   000032   0224         JEQ     ??ZDP_EndDeviceBindReq_4
   1095            {
   1096              return afStatus_INVALID_PARAMETER;
   \   000034   6C43         MOV.B   #0x2, R12
   \   000036   3E3C         JMP     ??ZDP_EndDeviceBindReq_3
   1097            }
   1098          
   1099            *pBuf++ = LO_UINT16( LocalCoordinator );
   \                     ??ZDP_EndDeviceBindReq_4:
   \   000038   C6490000     MOV.B   R9, 0(R6)
   \   00003C   1653         ADD.W   #0x1, R6
   1100            *pBuf++ = HI_UINT16( LocalCoordinator );
   \   00003E                RPT     #0x8
   \   00003E   47190910     RRUX.W  R9
   \   000042   C6490000     MOV.B   R9, 0(R6)
   \   000046   1653         ADD.W   #0x1, R6
   1101          
   1102            ieeeAddr = NLME_GetExtAddr();
   \   000048   ........     CALLA   #NLME_GetExtAddr
   1103            pBuf = osal_cpyExtAddr( pBuf, ieeeAddr );
   \   00004C   0D4C         MOV.W   R12, R13
   \   00004E   0C46         MOV.W   R6, R12
   \   000050   ........     CALLA   #sAddrExtCpy
   \   000054   064C         MOV.W   R12, R6
   1104          
   1105            *pBuf++ = endPoint;
   \   000056   CC4B0000     MOV.B   R11, 0(R12)
   \   00005A   1653         ADD.W   #0x1, R6
   1106          
   1107            *pBuf++ = LO_UINT16( ProfileID );   // Profile ID
   \   00005C   C6450000     MOV.B   R5, 0(R6)
   \   000060   1653         ADD.W   #0x1, R6
   1108            *pBuf++ = HI_UINT16( ProfileID );
   \   000062                RPT     #0x8
   \   000062   47190510     RRUX.W  R5
   \   000066   C6450000     MOV.B   R5, 0(R6)
   \   00006A   1653         ADD.W   #0x1, R6
   1109          
   1110            *pBuf++ = NumInClusters; // Input cluster list
   \   00006C   C6470000     MOV.B   R7, 0(R6)
   \   000070   1653         ADD.W   #0x1, R6
   1111            for ( i = 0; i < NumInClusters; ++i )
   \   000072   4E43         MOV.B   #0x0, R14
   \   000074   1F411600     MOV.W   0x16(SP), R15
   \   000078   063C         JMP     ??ZDP_EndDeviceBindReq_5
   1112            {
   1113              *pBuf++ = LO_UINT16(InClusterList[i]);
   \                     ??ZDP_EndDeviceBindReq_0:
   \   00007A   4D4E         MOV.B   R14, R13
   \   00007C   0D5D         RLA.W   R13
   \   00007E   0B4F         MOV.W   R15, R11
   \   000080   0B5D         ADD.W   R13, R11
   \   000082   ........     CALLA   #?Subroutine16
   1114              *pBuf++ = HI_UINT16(InClusterList[i]);
   1115            }
   \                     ??ZDP_EndDeviceBindReq_5:
   \   000086   4E97         CMP.B   R7, R14
   \   000088   F82B         JNC     ??ZDP_EndDeviceBindReq_0
   1116          
   1117            *pBuf++ = NumOutClusters; // Output cluster list
   \   00008A   C6440000     MOV.B   R4, 0(R6)
   \   00008E   1653         ADD.W   #0x1, R6
   1118            for ( i = 0; i < NumOutClusters; ++i )
   \   000090   4E43         MOV.B   #0x0, R14
   \   000092   1F411A00     MOV.W   0x1a(SP), R15
   \   000096   063C         JMP     ??ZDP_EndDeviceBindReq_6
   1119            {
   1120              *pBuf++ = LO_UINT16(OutClusterList[i]);
   \                     ??ZDP_EndDeviceBindReq_1:
   \   000098   474E         MOV.B   R14, R7
   \   00009A   0757         RLA.W   R7
   \   00009C   0B4F         MOV.W   R15, R11
   \   00009E   0B57         ADD.W   R7, R11
   \   0000A0   ........     CALLA   #?Subroutine16
   1121              *pBuf++ = HI_UINT16(OutClusterList[i]);
   1122            }
   \                     ??ZDP_EndDeviceBindReq_6:
   \   0000A4   4E94         CMP.B   R4, R14
   \   0000A6   F82B         JNC     ??ZDP_EndDeviceBindReq_1
   1123          
   1124            return fillAndSend( &ZDP_TransID, dstAddr, End_Device_Bind_req, len );
   \   0000A8   4F4A         MOV.B   R10, R15
   \   0000AA   3E402000     MOV.W   #0x20, R14
   \   0000AE   0D48         MOV.W   R8, R13
   \   0000B0   ........     CALLA   #??Subroutine12_0
   \                     ??ZDP_EndDeviceBindReq_3:
   \   0000B4   7417         POPM.W  #0x8, R11
   \   0000B6   1001         RETA
   1125          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine16:
   \   000000   E64B0000     MOV.B   @R11, 0(R6)
   \   000004   1653         ADD.W   #0x1, R6
   \   000006   D64B01000000 MOV.B   0x1(R11), 0(R6)
   \   00000C   1653         ADD.W   #0x1, R6
   \   00000E   5E53         ADD.B   #0x1, R14
   \   000010   1001         RETA
   1126          
   1127          /*********************************************************************
   1128           * @fn          ZDP_BindUnbindReq
   1129           *
   1130           * @brief       This builds and send a Bind_req or Unbind_req message
   1131           *              Depending on the ClusterID. This function
   1132           *              sends a unicast message to the local coordinator.
   1133           *
   1134           * @param       BindOrUnbind - either Bind_req or Unbind_req
   1135           * @param       dstAddr - destination address of the message
   1136           * @param       SourceAddr - source 64 bit address of the binding
   1137           * @param       SrcEPIntf - Source endpoint/interface
   1138           * @param       ClusterID - Binding cluster ID
   1139           * @param       DestinationAddr - destination 64 bit addr of binding
   1140           * @param       DstEPIntf - destination endpoint/interface
   1141           * @param       SecurityEnable - Security Options
   1142           *
   1143           * @return      afStatus_t
   1144           */

   \                                 In  segment CODE, align 2, keep-with-next
   1145          afStatus_t ZDP_BindUnbindReq( uint16 BindOrUnbind, zAddrType_t *dstAddr,
   \                     ZDP_BindUnbindReq:
   1146                                        uint8 *SourceAddr, byte SrcEndPoint,
   1147                                        cId_t ClusterID,
   1148                                        zAddrType_t *destinationAddr, byte DstEndPoint,
   1149                                        byte SecurityEnable )
   1150          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   084C         MOV.W   R12, R8
   \   000004   094D         MOV.W   R13, R9
   \   000006   0D4E         MOV.W   R14, R13
   \   000008   4B4F         MOV.B   R15, R11
   \   00000A   56411400     MOV.B   0x14(SP), R6
   1151            uint8 *pBuf = ZDP_TmpBuf;
   \   00000E   1C42....     MOV.W   &ZDP_TmpBuf, R12
   1152            byte len;
   1153          
   1154            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1155          
   1156            // SourceAddr + SrcEPIntf + ClusterID +  addrMode.
   1157            len = Z_EXTADDR_LEN + 1 + sizeof( cId_t ) + sizeof( uint8 );
   \   000012   7A400C00     MOV.B   #0xc, R10
   \   000016   17411200     MOV.W   0x12(SP), R7
   1158            if ( destinationAddr->addrMode == Addr64Bit )
   \   00001A   5E470800     MOV.B   0x8(R7), R14
   \   00001E   7E900300     CMP.B   #0x3, R14
   \   000022   0320         JNE     ??ZDP_BindUnbindReq_0
   1159              len += Z_EXTADDR_LEN + 1;     // +1 for DstEPIntf
   \   000024   7A401500     MOV.B   #0x15, R10
   \   000028   043C         JMP     ??ZDP_BindUnbindReq_1
   1160            else if ( destinationAddr->addrMode == AddrGroup )
   \                     ??ZDP_BindUnbindReq_0:
   \   00002A   5E93         CMP.B   #0x1, R14
   \   00002C   0220         JNE     ??ZDP_BindUnbindReq_1
   1161              len += sizeof ( uint16 );
   \   00002E   7A400E00     MOV.B   #0xe, R10
   1162          
   1163            pBuf = osal_cpyExtAddr( pBuf, SourceAddr );
   \                     ??ZDP_BindUnbindReq_1:
   \   000032   ........     CALLA   #sAddrExtCpy
   1164            *pBuf++ = SrcEndPoint;
   \   000036   CC4B0000     MOV.B   R11, 0(R12)
   \   00003A   1C53         ADD.W   #0x1, R12
   \   00003C   1E411000     MOV.W   0x10(SP), R14
   1165          
   1166            *pBuf++ = LO_UINT16( ClusterID );
   \   000040   ........     CALLA   #?Subroutine9
   1167          
   1168            *pBuf++ = HI_UINT16( ClusterID );
   1169            *pBuf++ = destinationAddr->addrMode;
   \                     ??CrossCallReturnLabel_1:
   \   000044   DC4708000000 MOV.B   0x8(R7), 0(R12)
   \   00004A   1C53         ADD.W   #0x1, R12
   1170            if ( destinationAddr->addrMode == Addr64Bit )
   \   00004C   5E470800     MOV.B   0x8(R7), R14
   \   000050   7E900300     CMP.B   #0x3, R14
   \   000054   0620         JNE     ??ZDP_BindUnbindReq_2
   1171            {
   1172              pBuf = osal_cpyExtAddr( pBuf, destinationAddr->addr.extAddr );
   1173              *pBuf = DstEndPoint;
   \   000056   0D47         MOV.W   R7, R13
   \   000058   ........     CALLA   #sAddrExtCpy
   \   00005C   CC460000     MOV.B   R6, 0(R12)
   \   000060   083C         JMP     ??ZDP_BindUnbindReq_3
   1174            }
   1175            else if ( destinationAddr->addrMode == AddrGroup )
   \                     ??ZDP_BindUnbindReq_2:
   \   000062   5E93         CMP.B   #0x1, R14
   \   000064   0620         JNE     ??ZDP_BindUnbindReq_3
   1176            {
   1177              *pBuf++ = LO_UINT16( destinationAddr->addr.shortAddr );
   \   000066   EC470000     MOV.B   @R7, 0(R12)
   \   00006A   1C53         ADD.W   #0x1, R12
   1178              *pBuf++ = HI_UINT16( destinationAddr->addr.shortAddr );
   \   00006C   DC4701000000 MOV.B   0x1(R7), 0(R12)
   1179            }
   1180          
   1181            FillAndSendTxOptions( &ZDP_TransID, dstAddr, BindOrUnbind, len, AF_MSG_ACK_REQUEST );
   \                     ??ZDP_BindUnbindReq_3:
   \   000072   F2401000.... MOV.B   #0x10, &ZDP_TxOptions
   \   000078   4F4A         MOV.B   R10, R15
   \   00007A   0E48         MOV.W   R8, R14
   \   00007C   0D49         MOV.W   R9, R13
   \   00007E   3C40....     MOV.W   #ZDP_TransID, R12
   \   000082                REQUIRE ?Subroutine2
   \   000082                // Fall through to label ?Subroutine2
   1182          }
   1183          
   1184          /*********************************************************************
   1185           * Network Management
   1186           */
   1187          
   1188          /*********************************************************************
   1189           * @fn          ZDP_MgmtNwkDiscReq
   1190           *
   1191           * @brief       This builds and send a Mgmt_NWK_Disc_req message. This
   1192           *              function sends a unicast message.
   1193           *
   1194           * @param       dstAddr - destination address of the message
   1195           * @param       ScanChannels - 32 bit address bit map
   1196           * @param       StartIndex - Starting index within the reporting network
   1197           *                           list
   1198           * @param       SecurityEnable - Security Options
   1199           *
   1200           * @return      afStatus_t
   1201           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   ........     CALLA   #??Subroutine12_0
   \                     ??CrossCallReturnLabel_36:
   \   000004   3817         POPM.W  #0x4, R11
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1202          afStatus_t ZDP_MgmtNwkDiscReq( zAddrType_t *dstAddr,
   \                     ZDP_MgmtNwkDiscReq:
   1203                                         uint32 ScanChannels,
   1204                                         byte ScanDuration,
   1205                                         byte StartIndex,
   1206                                         byte SecurityEnable )
   1207          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0B4C         MOV.W   R12, R11
   \   000004   4A4D         MOV.B   R13, R10
   \   000006   58410C00     MOV.B   0xc(SP), R8
   1208            uint8 *pBuf = ZDP_TmpBuf;
   1209            byte len = sizeof( uint32 )+1+1;  // ScanChannels + ScanDuration + StartIndex.
   1210          
   1211            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1212          
   1213            pBuf = osal_buffer_uint32( pBuf, ScanChannels );
   \   00000A   1C42....     MOV.W   &ZDP_TmpBuf, R12
   \   00000E   ........     CALLA   #osal_buffer_uint32
   1214          
   1215            *pBuf++ = ScanDuration;
   \   000012   CC4A0000     MOV.B   R10, 0(R12)
   \   000016   1C53         ADD.W   #0x1, R12
   1216            *pBuf = StartIndex;
   \   000018   CC480000     MOV.B   R8, 0(R12)
   1217          
   1218            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_NWK_Disc_req, len );
   \   00001C   7F400600     MOV.B   #0x6, R15
   \   000020   3E403000     MOV.W   #0x30, R14
   \   000024   0D4B         MOV.W   R11, R13
   \   000026   ....         JMP     ?Subroutine1
   1219          }
   1220          
   1221          /*********************************************************************
   1222           * @fn          ZDP_MgmtDirectJoinReq
   1223           *
   1224           * @brief       This builds and send a Mgmt_Direct_Join_req message. This
   1225           *              function sends a unicast message.
   1226           *
   1227           * @param       dstAddr - destination address of the message
   1228           * @param       deviceAddr - 64 bit IEEE Address
   1229           * @param       SecurityEnable - Security Options
   1230           *
   1231           * @return      afStatus_t
   1232           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine11:
   \   000000   1C42....     MOV.W   &ZDP_TmpBuf, R12
   \   000004                REQUIRE ??Subroutine25_0
   \   000004                // Fall through to label ??Subroutine25_0

   \                                 In  segment CODE, align 2, keep-with-next
   1233          afStatus_t ZDP_MgmtDirectJoinReq( zAddrType_t *dstAddr,
   \                     ZDP_MgmtDirectJoinReq:
   1234                                         uint8 *deviceAddr,
   1235                                         byte capInfo,
   1236                                         byte SecurityEnable )
   1237          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0B4C         MOV.W   R12, R11
   \   000004   4A4E         MOV.B   R14, R10
   1238            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1239          
   1240            osal_cpyExtAddr( ZDP_TmpBuf, deviceAddr );
   \   000006   ........     CALLA   #?Subroutine11
   1241            ZDP_TmpBuf[Z_EXTADDR_LEN] = capInfo;
   \                     ??CrossCallReturnLabel_29:
   \   00000A   CF4A0800     MOV.B   R10, 0x8(R15)
   1242          
   1243            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_Direct_Join_req, (Z_EXTADDR_LEN + 1) );
   \   00000E   7F400900     MOV.B   #0x9, R15
   \   000012   3E403500     MOV.W   #0x35, R14
   \   000016                REQUIRE ?Subroutine0
   \   000016                // Fall through to label ?Subroutine0
   1244          }
   1245          
   1246          /*********************************************************************
   1247           * @fn          ZDP_MgmtPermitJoinReq
   1248           *
   1249           * @brief       This builds and send a Mgmt_Permit_Join_req message.
   1250           *
   1251           * @param       dstAddr - destination address of the message
   1252           * @param       duration - Permit duration
   1253           * @param       TcSignificance - Trust Center Significance
   1254           *
   1255           * @return      afStatus_t
   1256           */

   \                                 In  segment CODE, align 2, keep-with-next
   1257          afStatus_t ZDP_MgmtPermitJoinReq( zAddrType_t *dstAddr, byte duration,
   \                     ZDP_MgmtPermitJoinReq:
   1258                                            byte TcSignificance, byte SecurityEnable )
   1259          {
   1260            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1261          
   1262            // Build buffer
   1263            ZDP_TmpBuf[ZDP_MGMT_PERMIT_JOIN_REQ_DURATION] = duration;
   \   000000   1F42....     MOV.W   &ZDP_TmpBuf, R15
   \   000004   CF4D0000     MOV.B   R13, 0(R15)
   1264            ZDP_TmpBuf[ZDP_MGMT_PERMIT_JOIN_REQ_TC_SIG]   = TcSignificance;
   \   000008   CF4E0100     MOV.B   R14, 0x1(R15)
   1265          
   1266            // Send the message
   1267            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_Permit_Join_req,
   1268                                ZDP_MGMT_PERMIT_JOIN_REQ_SIZE );
   \   00000C   6F43         MOV.B   #0x2, R15
   \   00000E   3E403600     MOV.W   #0x36, R14
   \   000012                REQUIRE ?Subroutine5
   \   000012                // Fall through to label ?Subroutine5
   1269          }
   1270          
   1271          /*********************************************************************
   1272           * @fn          ZDP_MgmtLeaveReq
   1273           *
   1274           * @brief       This builds and send a Mgmt_Leave_req message.
   1275           *
   1276           * @param       dstAddr - destination address of the message
   1277           *              IEEEAddr - IEEE adddress of device that is removed
   1278           *              RemoveChildren - set to 1 to remove the children of the
   1279           *                                device as well. 0 otherwise.
   1280           *              Rejoin - set to 1 if the removed device should rejoin
   1281                                   afterwards. 0 otherwise.
   1282           *
   1283           * @return      afStatus_t
   1284           */

   \                                 In  segment CODE, align 2, keep-with-next
   1285          afStatus_t ZDP_MgmtLeaveReq( zAddrType_t *dstAddr, uint8 *IEEEAddr, uint8 RemoveChildren,
   \                     ZDP_MgmtLeaveReq:
   1286                           uint8 Rejoin, uint8 SecurityEnable )
   1287          
   1288          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   084C         MOV.W   R12, R8
   \   000004   4A4E         MOV.B   R14, R10
   \   000006   4B4F         MOV.B   R15, R11
   \   000008   ........     CALLA   #?Subroutine11
   1289            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1290          
   1291            osal_cpyExtAddr( ZDP_TmpBuf, IEEEAddr );
   1292            ZDP_TmpBuf[Z_EXTADDR_LEN] = 0;
   \                     ??CrossCallReturnLabel_28:
   \   00000C   CF430800     MOV.B   #0x0, 0x8(R15)
   1293          
   1294            if ( RemoveChildren == TRUE )
   \   000010   5A93         CMP.B   #0x1, R10
   \   000012   0320         JNE     ??ZDP_MgmtLeaveReq_0
   1295            {
   1296              ZDP_TmpBuf[Z_EXTADDR_LEN] |= ZDP_MGMT_LEAVE_REQ_RC;
   \   000014   FF4040000800 MOV.B   #0x40, 0x8(R15)
   1297            }
   1298            if ( Rejoin == TRUE )
   \                     ??ZDP_MgmtLeaveReq_0:
   \   00001A   5B93         CMP.B   #0x1, R11
   \   00001C   0320         JNE     ??ZDP_MgmtLeaveReq_1
   1299            {
   1300              ZDP_TmpBuf[Z_EXTADDR_LEN] |= ZDP_MGMT_LEAVE_REQ_REJOIN;
   \   00001E   FFD080000800 BIS.B   #0x80, 0x8(R15)
   1301            }
   1302          
   1303            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_Leave_req, (Z_EXTADDR_LEN + 1) );
   \                     ??ZDP_MgmtLeaveReq_1:
   \   000024   7F400900     MOV.B   #0x9, R15
   \   000028   3E403400     MOV.W   #0x34, R14
   \   00002C   0D48         MOV.W   R8, R13
   \   00002E                REQUIRE ?Subroutine1
   \   00002E                // Fall through to label ?Subroutine1
   1304          }
   1305          
   1306          /*********************************************************************
   1307           * @fn          ZDP_MgmtNwkUpdateReq
   1308           *
   1309           * @brief       This builds and send a Mgmt_NWK_Update_req message. This
   1310           *              function sends a unicast or broadcast message.
   1311           *
   1312           * @param       dstAddr - destination address of the message
   1313           * @param       ChannelMask - 32 bit address bit map
   1314           * @param       ScanDuration - length of time to spend scanning each channel
   1315           * @param       ScanCount - number of energy scans to be conducted
   1316           * @param       NwkUpdateId - NWk Update Id value
   1317           * @param       NwkManagerAddr - NWK address for device with Network Manager
   1318           *                               bit set in its Node Descriptor
   1319           *
   1320           * @return      afStatus_t
   1321           */

   \                                 In  segment CODE, align 2
   1322          afStatus_t ZDP_MgmtNwkUpdateReq( zAddrType_t *dstAddr,
   \                     ZDP_MgmtNwkUpdateReq:
   1323                                           uint32 ChannelMask,
   1324                                           uint8 ScanDuration,
   1325                                           uint8 ScanCount,
   1326                                           uint8 NwkUpdateId,
   1327                                           uint16 NwkManagerAddr )
   1328          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   084C         MOV.W   R12, R8
   \   000004   4B4D         MOV.B   R13, R11
   \   000006   59411000     MOV.B   0x10(SP), R9
   \   00000A   56411200     MOV.B   0x12(SP), R6
   1329            uint8 *pBuf = ZDP_TmpBuf;
   1330            byte len = sizeof( uint32 ) + 1;  // ChannelMask + ScanDuration
   \   00000E   7A400500     MOV.B   #0x5, R10
   1331          
   1332            pBuf = osal_buffer_uint32( pBuf, ChannelMask );
   \   000012   1C42....     MOV.W   &ZDP_TmpBuf, R12
   \   000016   ........     CALLA   #osal_buffer_uint32
   1333          
   1334            *pBuf++ = ScanDuration;
   \   00001A   CC4B0000     MOV.B   R11, 0(R12)
   \   00001E   1C53         ADD.W   #0x1, R12
   1335          
   1336            if ( ScanDuration <= 0x05 )
   \   000020   7B900600     CMP.B   #0x6, R11
   \   000024   052C         JC      ??ZDP_MgmtNwkUpdateReq_0
   1337            {
   1338              // Request is to scan over channelMask
   1339              len += sizeof( uint8 );
   \   000026   7A400600     MOV.B   #0x6, R10
   1340          
   1341              *pBuf++ = ScanCount;
   \   00002A   CC490000     MOV.B   R9, 0(R12)
   \   00002E   113C         JMP     ??ZDP_MgmtNwkUpdateReq_1
   1342            }
   1343            else if ( ( ScanDuration == 0xFE ) || ( ScanDuration == 0xFF ) )
   \                     ??ZDP_MgmtNwkUpdateReq_0:
   \   000030   7B90FE00     CMP.B   #0xfe, R11
   \   000034   0224         JEQ     ??ZDP_MgmtNwkUpdateReq_2
   \   000036   7B93         CMP.B   #0xff, R11
   \   000038   0C20         JNE     ??ZDP_MgmtNwkUpdateReq_1
   1344            {
   1345              // Request is to change Channel (0xFE) or apsChannelMask and NwkManagerAddr (0xFF)
   1346              len += sizeof( uint8 );
   \                     ??ZDP_MgmtNwkUpdateReq_2:
   \   00003A   7A400600     MOV.B   #0x6, R10
   1347          
   1348              *pBuf++ = NwkUpdateId;
   \   00003E   CC460000     MOV.B   R6, 0(R12)
   \   000042   1C53         ADD.W   #0x1, R12
   1349          
   1350              if ( ScanDuration == 0xFF )
   \   000044   7B93         CMP.B   #0xff, R11
   \   000046   0520         JNE     ??ZDP_MgmtNwkUpdateReq_1
   1351              {
   1352                len += sizeof( uint16 );
   \   000048   7A42         MOV.B   #0x8, R10
   \   00004A   1E411400     MOV.W   0x14(SP), R14
   1353          
   1354                *pBuf++  = LO_UINT16( NwkManagerAddr );
   \   00004E   ........     CALLA   #?Subroutine21
   1355                *pBuf++  = HI_UINT16( NwkManagerAddr );
   1356              }
   1357            }
   1358          
   1359            return fillAndSend( &ZDP_TransID, dstAddr, Mgmt_NWK_Update_req, len );
   \                     ??ZDP_MgmtNwkUpdateReq_1:
   \   000052   4F4A         MOV.B   R10, R15
   \   000054   3E403800     MOV.W   #0x38, R14
   \   000058   0D48         MOV.W   R8, R13
   \   00005A   ........     CALLA   #??Subroutine12_0
   \                     ??CrossCallReturnLabel_37:
   \   00005E   5617         POPM.W  #0x6, R11
   \   000060   1001         RETA
   1360          }
   1361          
   1362          
   1363          /*********************************************************************
   1364           * Network Management Responses
   1365           */
   1366          
   1367          /*********************************************************************
   1368           * @fn          ZDP_MgmtNwkDiscRsp
   1369           *
   1370           * @brief       This builds and send a Mgmt_NWK_Disc_rsp message. This
   1371           *              function sends a unicast message.
   1372           *
   1373           * @param       dstAddr - destination address of the message
   1374           * @param       Status - message status (ZDP_SUCCESS or other)
   1375           * @param       NetworkCount - Total number of networks found
   1376           * @param       StartIndex - Starting index within the reporting network
   1377           *                           list
   1378           * @param       NetworkListCount - number of network lists included
   1379           *                                 in this message
   1380           * @param       NetworkList - List of network descriptors
   1381           * @param       SecurityEnable - Security Options
   1382           *
   1383           * @return      afStatus_t
   1384           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   0F49         MOV.W   R9, R15
   \   000002                REQUIRE ??Subroutine6_0
   \   000002                // Fall through to label ??Subroutine6_0

   \                                 In  segment CODE, align 2
   \                     ??Subroutine6_0:
   \   000000   1F53         ADD.W   #0x1, R15
   \   000002   824F....     MOV.W   R15, &ZDP_TmpBuf
   \   000006   4F4A         MOV.B   R10, R15
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   2153         ADD.W   #0x2, SP
   \   000002   7417         POPM.W  #0x8, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000   4C4A         MOV.B   R10, R12
   \   000002                REQUIRE ??Subroutine8_0
   \   000002                // Fall through to label ??Subroutine8_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine8_0:
   \   000000   1C53         ADD.W   #0x1, R12
   \   000002   ........     CALLA   #osal_mem_alloc
   \   000006   094C         MOV.W   R12, R9
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   0D46         MOV.W   R6, R13
   \   000002                REQUIRE ??Subroutine24_0
   \   000002                // Fall through to label ??Subroutine24_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine24_0:
   \   000000   0C41         MOV.W   SP, R12
   \   000002   2C52         ADD.W   #0x4, R12
   \   000004   ........     CALLA   #?Subroutine20
   \                     ??CrossCallReturnLabel_27:
   \   000008   4C4A         MOV.B   R10, R12
   \   00000A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine20:
   \   000000   ........     CALLA   #fillAndSend
   \   000004   4A4C         MOV.B   R12, R10
   \   000006   0C49         MOV.W   R9, R12
   \   000008   ........     CALLA   #osal_mem_free
   \   00000C   B240........ MOV.W   #ZDP_Buf + 1, &ZDP_TmpBuf
   \   000012   1001         RETA

   \                                 In  segment CODE, align 2
   1385          afStatus_t ZDP_MgmtNwkDiscRsp( byte TransSeq, zAddrType_t *dstAddr,
   \                     ZDP_MgmtNwkDiscRsp:
   1386                                      byte Status,
   1387                                      byte NetworkCount,
   1388                                      byte StartIndex,
   1389                                      byte NetworkListCount,
   1390                                      networkDesc_t *NetworkList,
   1391                                      byte SecurityEnable )
   1392          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   4C12         PUSH.B  R12
   \   000004   064D         MOV.W   R13, R6
   \   000006   4B4E         MOV.B   R14, R11
   \   000008   484F         MOV.B   R15, R8
   \   00000A   55411600     MOV.B   0x16(SP), R5
   \   00000E   57411800     MOV.B   0x18(SP), R7
   1393            uint8 *buf;
   1394            uint8 *pBuf;
   1395            byte len = 1+1+1+1;  // Status + NetworkCount + StartIndex + NetworkCountList.
   1396            byte idx;
   1397          
   1398            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1399          
   1400            len += (NetworkListCount * ( ZDP_NETWORK_EXTENDED_DISCRIPTOR_SIZE - 2 ));
   \   000012   6A42         MOV.B   #0x4, R10
   \   000014                RPT     #0xc
   \   000014   4B184A57     ADDX.B  R7, R10
   1401          
   1402            buf = osal_mem_alloc( len+1 );
   \   000018   ........     CALLA   #?Subroutine8
   1403            if ( buf == NULL )
   \                     ??CrossCallReturnLabel_23:
   \   00001C   0320         JNE     ??ZDP_MgmtNwkDiscRsp_2
   1404            {
   1405              return afStatus_MEM_FAIL;
   \   00001E   7C401000     MOV.B   #0x10, R12
   \   000022   453C         JMP     ??ZDP_MgmtNwkDiscRsp_3
   1406            }
   1407          
   1408            pBuf = buf+1;
   \                     ??ZDP_MgmtNwkDiscRsp_2:
   \   000024   044C         MOV.W   R12, R4
   \   000026   1453         ADD.W   #0x1, R4
   1409          
   1410            *pBuf++ = Status;
   \   000028   C44B0000     MOV.B   R11, 0(R4)
   \   00002C   1453         ADD.W   #0x1, R4
   1411            *pBuf++ = NetworkCount;
   \   00002E   C4480000     MOV.B   R8, 0(R4)
   \   000032   1453         ADD.W   #0x1, R4
   1412            *pBuf++ = StartIndex;
   \   000034   C4450000     MOV.B   R5, 0(R4)
   \   000038   1453         ADD.W   #0x1, R4
   1413            *pBuf++ = NetworkListCount;
   \   00003A   C4470000     MOV.B   R7, 0(R4)
   \   00003E   1453         ADD.W   #0x1, R4
   1414          
   1415            for ( idx = 0; idx < NetworkListCount; idx++ )
   \   000040   4843         MOV.B   #0x0, R8
   \   000042   1B411A00     MOV.W   0x1a(SP), R11
   \   000046   063C         JMP     ??ZDP_MgmtNwkDiscRsp_4
   1416            {
   1417              osal_cpyExtAddr( pBuf, NetworkList->extendedPANID);
   1418              pBuf += Z_EXTADDR_LEN;
   1419          
   1420              *pBuf++  = NetworkList->logicalChannel;                // LogicalChannel
   1421              *pBuf    = NetworkList->stackProfile;                  // Stack profile
   1422              *pBuf++ |= (byte)(NetworkList->version << 4);          // ZigBee Version
   1423              *pBuf    = BEACON_ORDER_NO_BEACONS;                    // Beacon Order
   1424              *pBuf++ |= (uint8)(BEACON_ORDER_NO_BEACONS << 4);      // Superframe Order
   1425          
   1426              if ( NetworkList->chosenRouter != INVALID_NODE_ADDR )
   1427              {
   1428                *pBuf++ = TRUE;                         // Permit Joining
   1429              }
   1430              else
   1431              {
   1432                *pBuf++ = FALSE;
   \                     ??ZDP_MgmtNwkDiscRsp_0:
   \   000048   C4430000     MOV.B   #0x0, 0(R4)
   \                     ??ZDP_MgmtNwkDiscRsp_6:
   \   00004C   1453         ADD.W   #0x1, R4
   1433              }
   1434          
   1435              NetworkList = NetworkList->nextDesc;    // Move to next list entry
   \   00004E   1B4B1600     MOV.W   0x16(R11), R11
   \   000052   5853         ADD.B   #0x1, R8
   \                     ??ZDP_MgmtNwkDiscRsp_4:
   \   000054   4897         CMP.B   R7, R8
   \   000056   252C         JC      ??ZDP_MgmtNwkDiscRsp_5
   \   000058   0D4B         MOV.W   R11, R13
   \   00005A   3D500C00     ADD.W   #0xc, R13
   \   00005E   0C44         MOV.W   R4, R12
   \   000060   ........     CALLA   #sAddrExtCpy
   \   000064   3452         ADD.W   #0x8, R4
   \   000066   D44B02000000 MOV.B   0x2(R11), 0(R4)
   \   00006C   1453         ADD.W   #0x1, R4
   \   00006E   D44B06000000 MOV.B   0x6(R11), 0(R4)
   \   000074   0F44         MOV.W   R4, R15
   \   000076   1453         ADD.W   #0x1, R4
   \   000078   5E4B0500     MOV.B   0x5(R11), R14
   \   00007C                RPT     #0x4
   \   00007C   43184E5E     RLAX.B  R14
   \   000080   CFDE0000     BIS.B   R14, 0(R15)
   \   000084   F4400F000000 MOV.B   #0xf, 0(R4)
   \   00008A   0F44         MOV.W   R4, R15
   \   00008C   1453         ADD.W   #0x1, R4
   \   00008E   FFD0F0000000 BIS.B   #0xf0, 0(R15)
   \   000094   BB90FEFF0800 CMP.W   #0xfffe, 0x8(R11)
   \   00009A   D627         JEQ     ??ZDP_MgmtNwkDiscRsp_0
   \   00009C   D4430000     MOV.B   #0x1, 0(R4)
   \   0000A0   D53F         JMP     ??ZDP_MgmtNwkDiscRsp_6
   1436            }
   1437          
   1438            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_NWK_Disc_rsp, len, buf );
   \                     ??ZDP_MgmtNwkDiscRsp_5:
   \   0000A2   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_19:
   \   0000A6   3E403080     MOV.W   #0x8030, R14
   \   0000AA   ........     CALLA   #?Subroutine7
   \                     ??ZDP_MgmtNwkDiscRsp_3:
   \   0000AE   ....         JMP     ?Subroutine3
   1439          }
   1440          
   1441          /*********************************************************************
   1442           * @fn          ZDP_MgmtLqiRsp
   1443           *
   1444           * @brief       This builds and send a Mgmt_Lqi_rsp message. This
   1445           *              function sends a unicast message.
   1446           *
   1447           * @param       dstAddr - destination address of the message
   1448           * @param       Status - message status (ZDP_SUCCESS or other)
   1449           * @param       NeighborLqiEntries - Total number of entries found
   1450           * @param       StartIndex - Starting index within the reporting list
   1451           * @param       NeighborLqiCount - number of lists included
   1452           *                                 in this message
   1453           * @param       NeighborLqiList - List of NeighborLqiItems.  This list
   1454           *                is the list to be sent, not the entire list
   1455           * @param       SecurityEnable - true if secure
   1456           *
   1457           * @return      ZStatus_t
   1458           */

   \                                 In  segment CODE, align 2, keep-with-next
   1459          ZStatus_t ZDP_MgmtLqiRsp( byte TransSeq, zAddrType_t *dstAddr,
   \                     ZDP_MgmtLqiRsp:
   1460                                    byte Status,
   1461                                    byte NeighborLqiEntries,
   1462                                    byte StartIndex,
   1463                                    byte NeighborLqiCount,
   1464                                    ZDP_MgmtLqiItem_t* NeighborList,
   1465                                    byte SecurityEnable )
   1466          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   4C12         PUSH.B  R12
   \   000004   094D         MOV.W   R13, R9
   \   000006   4B4F         MOV.B   R15, R11
   \   000008   57411600     MOV.B   0x16(SP), R7
   \   00000C   18411A00     MOV.W   0x1a(SP), R8
   1467            ZDP_MgmtLqiItem_t* list = NeighborList;
   1468            uint8 *buf, *pBuf;
   1469            byte len, x;
   1470          
   1471            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1472          
   1473            if ( ZSuccess != Status )
   \   000010   4E93         CMP.B   #0x0, R14
   \   000012   0A24         JEQ     ??ZDP_MgmtLqiRsp_1
   1474            {
   1475              ZDP_TmpBuf[0] = Status;
   \   000014   1F42....     MOV.W   &ZDP_TmpBuf, R15
   \   000018   CF4E0000     MOV.B   R14, 0(R15)
   1476              return fillAndSend( &TransSeq, dstAddr, Mgmt_Lqi_rsp, 1 );
   \   00001C   5F43         MOV.B   #0x1, R15
   \   00001E   3E403180     MOV.W   #0x8031, R14
   \   000022   ........     CALLA   #?Subroutine13
   1477            }
   \                     ??CrossCallReturnLabel_7:
   \   000026   6C3C         JMP     ??ZDP_MgmtLqiRsp_2
   \                     ??ZDP_MgmtLqiRsp_1:
   \   000028   54411800     MOV.B   0x18(SP), R4
   1478          
   1479            // (Status + NeighborLqiEntries + StartIndex + NeighborLqiCount) +
   1480            //  neighbor LQI data.
   1481            len = (1 + 1 + 1 + 1) + (NeighborLqiCount * ZDP_MGMTLQI_EXTENDED_SIZE);
   \   00002C   4A44         MOV.B   R4, R10
   \   00002E   4A5A         RLA.B   R10
   \   000030   4E4A         MOV.B   R10, R14
   \   000032   4A5A         RLA.B   R10
   \   000034   4E5A         ADD.B   R10, R14
   \   000036                RPT     #0x2
   \   000036   41184A5A     RLAX.B  R10
   \   00003A   4A5E         ADD.B   R14, R10
   \   00003C   6A52         ADD.B   #0x4, R10
   1482          
   1483            buf = osal_mem_alloc( len+1 );
   \   00003E   4C4A         MOV.B   R10, R12
   \   000040   1C53         ADD.W   #0x1, R12
   \   000042   ........     CALLA   #osal_mem_alloc
   \   000046   064C         MOV.W   R12, R6
   1484            if ( buf == NULL )
   \   000048   0C93         CMP.W   #0x0, R12
   \   00004A   0320         JNE     ??ZDP_MgmtLqiRsp_3
   1485            {
   1486              return afStatus_MEM_FAIL;
   \   00004C   7C401000     MOV.B   #0x10, R12
   \   000050   573C         JMP     ??ZDP_MgmtLqiRsp_2
   1487            }
   1488          
   1489            pBuf = buf+1;
   \                     ??ZDP_MgmtLqiRsp_3:
   \   000052   054C         MOV.W   R12, R5
   \   000054   1553         ADD.W   #0x1, R5
   1490          
   1491            *pBuf++ = Status;
   \   000056   C5430000     MOV.B   #0x0, 0(R5)
   \   00005A   1553         ADD.W   #0x1, R5
   1492            *pBuf++ = NeighborLqiEntries;
   \   00005C   C54B0000     MOV.B   R11, 0(R5)
   \   000060   1553         ADD.W   #0x1, R5
   1493            *pBuf++ = StartIndex;
   \   000062   C5470000     MOV.B   R7, 0(R5)
   \   000066   1553         ADD.W   #0x1, R5
   1494            *pBuf++ = NeighborLqiCount;
   \   000068   C5440000     MOV.B   R4, 0(R5)
   \   00006C   1553         ADD.W   #0x1, R5
   1495          
   1496            for ( x = 0; x < NeighborLqiCount; x++ )
   \   00006E   4B43         MOV.B   #0x0, R11
   \   000070   353C         JMP     ??ZDP_MgmtLqiRsp_4
   1497            {
   1498              osal_cpyExtAddr( pBuf, list->extPanID);         // Extended PanID
   \                     ??ZDP_MgmtLqiRsp_0:
   \   000072   0D48         MOV.W   R8, R13
   \   000074   2D53         ADD.W   #0x2, R13
   \   000076   0C45         MOV.W   R5, R12
   \   000078   ........     CALLA   #sAddrExtCpy
   1499              pBuf += Z_EXTADDR_LEN;
   1500          
   1501              // EXTADDR
   1502              pBuf = osal_cpyExtAddr( pBuf, list->extAddr );
   \   00007C   0D48         MOV.W   R8, R13
   \   00007E   3D500A00     ADD.W   #0xa, R13
   \   000082   3552         ADD.W   #0x8, R5
   \   000084   0C45         MOV.W   R5, R12
   \   000086   ........     CALLA   #sAddrExtCpy
   \   00008A   054C         MOV.W   R12, R5
   1503          
   1504              // NWKADDR
   1505              *pBuf++ = LO_UINT16( list->nwkAddr );
   \   00008C   DC4812000000 MOV.B   0x12(R8), 0(R12)
   \   000092   1553         ADD.W   #0x1, R5
   1506              *pBuf++ = HI_UINT16( list->nwkAddr );
   \   000094   D54813000000 MOV.B   0x13(R8), 0(R5)
   \   00009A   1553         ADD.W   #0x1, R5
   1507          
   1508              // DEVICETYPE
   1509              *pBuf = list->devType;
   \   00009C   D54814000000 MOV.B   0x14(R8), 0(R5)
   1510          
   1511              // RXONIDLE
   1512              *pBuf |= (uint8)(list->rxOnIdle << 2);
   \   0000A2   5E481500     MOV.B   0x15(R8), R14
   \   0000A6                RPT     #0x2
   \   0000A6   41184E5E     RLAX.B  R14
   \   0000AA   C5DE0000     BIS.B   R14, 0(R5)
   1513          
   1514              // RELATIONSHIP
   1515              *pBuf++ |= (uint8)(list->relation << 4);
   \   0000AE   0F45         MOV.W   R5, R15
   \   0000B0   1553         ADD.W   #0x1, R5
   \   0000B2   5E481600     MOV.B   0x16(R8), R14
   \   0000B6                RPT     #0x4
   \   0000B6   43184E5E     RLAX.B  R14
   \   0000BA   CFDE0000     BIS.B   R14, 0(R15)
   1516          
   1517              // PERMITJOINING
   1518              *pBuf++ = (uint8)(list->permit);
   \   0000BE   D54817000000 MOV.B   0x17(R8), 0(R5)
   \   0000C4   1553         ADD.W   #0x1, R5
   1519          
   1520              // DEPTH
   1521              *pBuf++ = list->depth;
   \   0000C6   D54818000000 MOV.B   0x18(R8), 0(R5)
   \   0000CC   1553         ADD.W   #0x1, R5
   1522          
   1523              // LQI
   1524              *pBuf++ = list->lqi;
   \   0000CE   D54819000000 MOV.B   0x19(R8), 0(R5)
   \   0000D4   1553         ADD.W   #0x1, R5
   1525          
   1526              list++; // next list entry
   \   0000D6   38501A00     ADD.W   #0x1a, R8
   1527            }
   \   0000DA   5B53         ADD.B   #0x1, R11
   \                     ??ZDP_MgmtLqiRsp_4:
   \   0000DC   4B94         CMP.B   R4, R11
   \   0000DE   C92B         JNC     ??ZDP_MgmtLqiRsp_0
   1528          
   1529            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_Lqi_rsp, len, buf );
   \   0000E0   0F46         MOV.W   R6, R15
   \   0000E2   ........     CALLA   #??Subroutine6_0
   \                     ??CrossCallReturnLabel_21:
   \   0000E6   3E403180     MOV.W   #0x8031, R14
   \   0000EA   0D49         MOV.W   R9, R13
   \   0000EC   ........     CALLA   #?Subroutine13
   \                     ??CrossCallReturnLabel_6:
   \   0000F0   4A4C         MOV.B   R12, R10
   \   0000F2   0C46         MOV.W   R6, R12
   \   0000F4   ........     CALLA   #osal_mem_free
   \   0000F8   B240........ MOV.W   #ZDP_Buf + 1, &ZDP_TmpBuf
   \   0000FE   4C4A         MOV.B   R10, R12
   \                     ??ZDP_MgmtLqiRsp_2:
   \   000100   ....         JMP     ?Subroutine3
   1530          }
   1531          
   1532          /*********************************************************************
   1533           * @fn          ZDP_MgmtRtgRsp
   1534           *
   1535           * @brief       This builds and send a Mgmt_Rtg_rsp message. This
   1536           *              function sends a unicast message.
   1537           *
   1538           * @param       dstAddr - destination address of the message
   1539           * @param       Status - message status (ZDP_SUCCESS or other)
   1540           * @param       RoutingTableEntries - Total number of entries
   1541           * @param       StartIndex - Starting index within the reporting list
   1542           * @param       RoutingTableListCount - number of entries included
   1543           *                                      in this message
   1544           * @param       RoutingTableList - List of Routing Table entries
   1545           * @param       SecurityEnable - true to enable security for this message
   1546           *
   1547           * @return      ZStatus_t
   1548           */

   \                                 In  segment CODE, align 2, keep-with-next
   1549          ZStatus_t ZDP_MgmtRtgRsp( byte TransSeq, zAddrType_t *dstAddr,
   \                     ZDP_MgmtRtgRsp:
   1550                                      byte Status,
   1551                                      byte RoutingTableEntries,
   1552                                      byte StartIndex,
   1553                                      byte RoutingListCount,
   1554                                      rtgItem_t *RoutingTableList,
   1555                                      byte SecurityEnable )
   1556          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   4C12         PUSH.B  R12
   \   000004   064D         MOV.W   R13, R6
   \   000006   4B4E         MOV.B   R14, R11
   \   000008   484F         MOV.B   R15, R8
   \   00000A   54411600     MOV.B   0x16(SP), R4
   \   00000E   57411800     MOV.B   0x18(SP), R7
   1557            uint8 *buf;
   1558            uint8 *pBuf;
   1559            // Status + RoutingTableEntries + StartIndex + RoutingListCount.
   1560            byte len = 1 + 1 + 1 + 1;
   1561            byte x;
   1562          
   1563            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1564          
   1565            // Add an array for Routing List data
   1566            len += (RoutingListCount * ZDP_ROUTINGENTRY_SIZE);
   \   000012   6A42         MOV.B   #0x4, R10
   \   000014                RPT     #0x5
   \   000014   44184A57     ADDX.B  R7, R10
   1567          
   1568            buf = osal_mem_alloc( (short)(len+1) );
   \   000018   ........     CALLA   #?Subroutine8
   1569            if ( buf == NULL )
   \                     ??CrossCallReturnLabel_22:
   \   00001C   0320         JNE     ??ZDP_MgmtRtgRsp_1
   1570            {
   1571              return afStatus_MEM_FAIL;
   \   00001E   7C401000     MOV.B   #0x10, R12
   \   000022   303C         JMP     ??ZDP_MgmtRtgRsp_2
   1572            }
   1573          
   1574            pBuf = buf+1;
   \                     ??ZDP_MgmtRtgRsp_1:
   \   000024   0E4C         MOV.W   R12, R14
   \   000026   1E53         ADD.W   #0x1, R14
   1575          
   1576            *pBuf++ = Status;
   \   000028   CE4B0000     MOV.B   R11, 0(R14)
   \   00002C   1E53         ADD.W   #0x1, R14
   1577            *pBuf++ = RoutingTableEntries;
   \   00002E   CE480000     MOV.B   R8, 0(R14)
   \   000032   1E53         ADD.W   #0x1, R14
   1578            *pBuf++ = StartIndex;
   \   000034   CE440000     MOV.B   R4, 0(R14)
   \   000038   1E53         ADD.W   #0x1, R14
   1579            *pBuf++ = RoutingListCount;
   \   00003A   CE470000     MOV.B   R7, 0(R14)
   \   00003E   1E53         ADD.W   #0x1, R14
   1580          
   1581            for ( x = 0; x < RoutingListCount; x++ )
   \   000040   4D43         MOV.B   #0x0, R13
   \   000042   1F411A00     MOV.W   0x1a(SP), R15
   \   000046   153C         JMP     ??ZDP_MgmtRtgRsp_3
   1582            {
   1583              *pBuf++ = LO_UINT16( RoutingTableList->dstAddress );  // Destination Address
   \                     ??ZDP_MgmtRtgRsp_0:
   \   000048   EE4F0000     MOV.B   @R15, 0(R14)
   \   00004C   1E53         ADD.W   #0x1, R14
   1584              *pBuf++ = HI_UINT16( RoutingTableList->dstAddress );
   \   00004E   DE4F01000000 MOV.B   0x1(R15), 0(R14)
   \   000054   1E53         ADD.W   #0x1, R14
   1585              *pBuf++ = RoutingTableList->status;
   \   000056   DE4F05000000 MOV.B   0x5(R15), 0(R14)
   \   00005C   1E53         ADD.W   #0x1, R14
   1586              *pBuf++ = LO_UINT16( RoutingTableList->nextHopAddress );  // Next hop
   \   00005E   DE4F02000000 MOV.B   0x2(R15), 0(R14)
   \   000064   1E53         ADD.W   #0x1, R14
   1587              *pBuf++ = HI_UINT16( RoutingTableList->nextHopAddress );
   \   000066   DE4F03000000 MOV.B   0x3(R15), 0(R14)
   \   00006C   1E53         ADD.W   #0x1, R14
   1588              RoutingTableList++;    // Move to next list entry
   \   00006E   3F52         ADD.W   #0x8, R15
   1589            }
   \   000070   5D53         ADD.B   #0x1, R13
   \                     ??ZDP_MgmtRtgRsp_3:
   \   000072   4D97         CMP.B   R7, R13
   \   000074   E92B         JNC     ??ZDP_MgmtRtgRsp_0
   1590          
   1591            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_Rtg_rsp, len, buf );
   \   000076   0F4C         MOV.W   R12, R15
   \   000078   ........     CALLA   #??Subroutine6_0
   \                     ??CrossCallReturnLabel_20:
   \   00007C   3E403280     MOV.W   #0x8032, R14
   \   000080   ........     CALLA   #?Subroutine7
   \                     ??ZDP_MgmtRtgRsp_2:
   \   000084                REQUIRE ?Subroutine3
   \   000084                // Fall through to label ?Subroutine3
   1592          }
   1593          
   1594          /*********************************************************************
   1595           * @fn          ZDP_MgmtBindRsp
   1596           *
   1597           * @brief       This builds and send a Mgmt_Bind_rsp message. This
   1598           *              function sends a unicast message.
   1599           *
   1600           * @param       dstAddr - destination address of the message
   1601           * @param       Status - message status (ZDP_SUCCESS or other)
   1602           * @param       BindingTableEntries - Total number of entries
   1603           * @param       StartIndex - Starting index within the reporting list
   1604           * @param       BindingTableListCount - number of entries included
   1605           *                                 in this message
   1606           * @param       BindingTableList - List of Binding Table entries
   1607           * @param       SecurityEnable - Security Options
   1608           *
   1609           * @return      ZStatus_t
   1610           */

   \                                 In  segment CODE, align 2
   1611          ZStatus_t ZDP_MgmtBindRsp( byte TransSeq, zAddrType_t *dstAddr,
   \                     ZDP_MgmtBindRsp:
   1612                                      byte Status,
   1613                                      byte BindingTableEntries,
   1614                                      byte StartIndex,
   1615                                      byte BindingTableListCount,
   1616                                      apsBindingItem_t *BindingTableList,
   1617                                      byte SecurityEnable )
   1618          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   4C12         PUSH.B  R12
   \   000004   084D         MOV.W   R13, R8
   \   000006   4A4E         MOV.B   R14, R10
   \   000008   4B4F         MOV.B   R15, R11
   \   00000A   57411200     MOV.B   0x12(SP), R7
   \   00000E   56411400     MOV.B   0x14(SP), R6
   1619            uint8 *buf;
   1620            uint8 *pBuf;
   1621            uint8 maxLen; // maxLen is the maximum packet length to allocate enough memory space
   1622            uint8 len;    // Actual length varies due to different addrMode
   1623            uint8 x;
   1624            byte extZdpBindEntrySize = ZDP_BINDINGENTRY_SIZE + 1 + 1; // One more byte for cluserID and DstAddrMode
   1625            byte shortZdpBindEntrySize = ZDP_BINDINGENTRY_SIZE + 1 + 1 + 2 - 8 - 1; // clusterID + DstAddrMode + shortAddr - ExtAddr - DstEndpoint
   1626          
   1627            (void)SecurityEnable;  // Intentionally unreferenced parameter
   1628          
   1629            // Status + BindingTableEntries + StartIndex + BindingTableListCount.
   1630            maxLen = 1 + 1 + 1 + 1;
   1631            maxLen += (BindingTableListCount * extZdpBindEntrySize );  //max length
   1632            buf = osal_mem_alloc( maxLen + 1 );  // +1 for transaction ID
   \   000012   4C46         MOV.B   R6, R12
   \   000014   4E46         MOV.B   R6, R14
   \   000016                RPT     #0x2
   \   000016   41184C5C     RLAX.B  R12
   \   00001A   4E5C         ADD.B   R12, R14
   \   00001C                RPT     #0x2
   \   00001C   41184C5C     RLAX.B  R12
   \   000020   4C5E         ADD.B   R14, R12
   \   000022   6C52         ADD.B   #0x4, R12
   \   000024   ........     CALLA   #??Subroutine8_0
   1633          
   1634            if ( buf == NULL )
   \                     ??CrossCallReturnLabel_25:
   \   000028   0320         JNE     ??ZDP_MgmtBindRsp_2
   1635            {
   1636              return afStatus_MEM_FAIL;
   \   00002A   7C401000     MOV.B   #0x10, R12
   \   00002E   4A3C         JMP     ??ZDP_MgmtBindRsp_3
   1637            }
   1638          
   1639            pBuf = buf+1;
   \                     ??ZDP_MgmtBindRsp_2:
   \   000030   1C53         ADD.W   #0x1, R12
   1640          
   1641            *pBuf++ = Status;
   \   000032   CC4A0000     MOV.B   R10, 0(R12)
   \   000036   1C53         ADD.W   #0x1, R12
   1642            *pBuf++ = BindingTableEntries;
   \   000038   CC4B0000     MOV.B   R11, 0(R12)
   \   00003C   1C53         ADD.W   #0x1, R12
   1643            *pBuf++ = StartIndex;
   \   00003E   CC470000     MOV.B   R7, 0(R12)
   \   000042   1C53         ADD.W   #0x1, R12
   1644            *pBuf++ = BindingTableListCount;
   \   000044   CC460000     MOV.B   R6, 0(R12)
   \   000048   1C53         ADD.W   #0x1, R12
   1645          
   1646            // Initial length = Status + BindingTableEntries + StartIndex + BindingTableListCount.
   1647            // length += ZDP_BINDINGENTRY_SIZE   -- Version 1.0
   1648            //           extZdpBindEntrySize     -- Version 1.1 extended address mode
   1649            //           shortZdpBindEntrySize   -- Version 1.1 group address mode
   1650          
   1651            len = 1 + 1 + 1 + 1;
   \   00004A   6A42         MOV.B   #0x4, R10
   1652            for ( x = 0; x < BindingTableListCount; x++ )
   \   00004C   4743         MOV.B   #0x0, R7
   \   00004E   1B411600     MOV.W   0x16(SP), R11
   \   000052   0D3C         JMP     ??ZDP_MgmtBindRsp_4
   1653            {
   1654              pBuf = osal_cpyExtAddr( pBuf, BindingTableList->srcAddr );
   1655              *pBuf++ = BindingTableList->srcEP;
   1656          
   1657              // Cluster ID
   1658              *pBuf++ = LO_UINT16( BindingTableList->clusterID );
   1659              *pBuf++ = HI_UINT16( BindingTableList->clusterID );
   1660          
   1661              *pBuf++ = BindingTableList->dstAddr.addrMode;
   1662              if ( BindingTableList->dstAddr.addrMode == Addr64Bit )
   1663              {
   1664                len += extZdpBindEntrySize;
   1665                pBuf = osal_cpyExtAddr( pBuf, BindingTableList->dstAddr.addr.extAddr );
   1666                *pBuf++ = BindingTableList->dstEP;
   1667              }
   1668              else
   1669              {
   1670                len += shortZdpBindEntrySize;
   \                     ??ZDP_MgmtBindRsp_0:
   \   000054   7A500E00     ADD.B   #0xe, R10
   1671                *pBuf++ = LO_UINT16( BindingTableList->dstAddr.addr.shortAddr );
   \   000058   DC4B0C000000 MOV.B   0xc(R11), 0(R12)
   \   00005E   1C53         ADD.W   #0x1, R12
   1672                *pBuf++ = HI_UINT16( BindingTableList->dstAddr.addr.shortAddr );
   \   000060   DC4B0D000000 MOV.B   0xd(R11), 0(R12)
   \                     ??ZDP_MgmtBindRsp_6:
   \   000066   1C53         ADD.W   #0x1, R12
   1673              }
   1674              BindingTableList++;    // Move to next list entry
   \   000068   3B501800     ADD.W   #0x18, R11
   \   00006C   5753         ADD.B   #0x1, R7
   \                     ??ZDP_MgmtBindRsp_4:
   \   00006E   4796         CMP.B   R6, R7
   \   000070   222C         JC      ??ZDP_MgmtBindRsp_5
   \   000072   0D4B         MOV.W   R11, R13
   \   000074   ........     CALLA   #sAddrExtCpy
   \   000078   DC4B08000000 MOV.B   0x8(R11), 0(R12)
   \   00007E   1C53         ADD.W   #0x1, R12
   \   000080   DC4B0A000000 MOV.B   0xa(R11), 0(R12)
   \   000086   1C53         ADD.W   #0x1, R12
   \   000088   DC4B0B000000 MOV.B   0xb(R11), 0(R12)
   \   00008E   1C53         ADD.W   #0x1, R12
   \   000090   DC4B14000000 MOV.B   0x14(R11), 0(R12)
   \   000096   1C53         ADD.W   #0x1, R12
   \   000098   FB9003001400 CMP.B   #0x3, 0x14(R11)
   \   00009E   DA23         JNE     ??ZDP_MgmtBindRsp_0
   \   0000A0   7A501500     ADD.B   #0x15, R10
   \   0000A4   0D4B         MOV.W   R11, R13
   \   0000A6   3D500C00     ADD.W   #0xc, R13
   \   0000AA   ........     CALLA   #sAddrExtCpy
   \   0000AE   DC4B16000000 MOV.B   0x16(R11), 0(R12)
   \   0000B4   D83F         JMP     ??ZDP_MgmtBindRsp_6
   1675            }
   1676          
   1677            FillAndSendBuffer( &TransSeq, dstAddr, Mgmt_Bind_rsp, len, buf );
   \                     ??ZDP_MgmtBindRsp_5:
   \   0000B6   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_18:
   \   0000BA   3E403380     MOV.W   #0x8033, R14
   \   0000BE   0D48         MOV.W   R8, R13
   \   0000C0   ........     CALLA   #??Subroutine24_0
   \                     ??ZDP_MgmtBindRsp_3:
   \   0000C4   2153         ADD.W   #0x2, SP
   \   0000C6   5617         POPM.W  #0x6, R11
   \   0000C8   1001         RETA
   1678          }
   1679          
   1680          /*********************************************************************
   1681           * @fn          ZDP_MgmtNwkUpdateNotify
   1682           *
   1683           * @brief       This builds and send a Mgmt_NWK_Update_notify message. This
   1684           *              function sends a unicast message.
   1685           *
   1686           * @param       dstAddr - destination address of the message
   1687           * @param       status - message status (ZDP_SUCCESS or other)
   1688           * @param       scannedChannels - List of channels scanned by the request
   1689           * @param       totalTransmissions - Total transmissions
   1690           * @param       transmissionFailures - Sum of transmission failures
   1691           * @param       listCount - Number of records contained in the energyValues list
   1692           * @param       energyValues - List of descriptors, one for each of ListCount,
   1693           *                             of the enegry detect descriptors
   1694           * @param       txOptions - Transmit options
   1695           * @param       securityEnable - Security options
   1696           *
   1697           * @return      afStatus_t
   1698           */

   \                                 In  segment CODE, align 2
   1699          afStatus_t ZDP_MgmtNwkUpdateNotify( uint8 TransSeq, zAddrType_t *dstAddr,
   \                     ZDP_MgmtNwkUpdateNotify:
   1700                                              uint8 status, uint32 scannedChannels,
   1701                                              uint16 totalTransmissions, uint16 transmissionFailures,
   1702                                              uint8 listCount, uint8 *energyValues, uint8 txOptions,
   1703                                              uint8 securityEnable )
   1704          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   4C12         PUSH.B  R12
   \   000004   0D12         PUSH.W  R13
   \   000006   444E         MOV.B   R14, R4
   \   000008   074F         MOV.W   R15, R7
   \   00000A   1A411800     MOV.W   0x18(SP), R10
   \   00000E   1B411A00     MOV.W   0x1a(SP), R11
   \   000012   55412200     MOV.B   0x22(SP), R5
   \   000016   56411E00     MOV.B   0x1e(SP), R6
   1705            uint8 *buf;
   1706            uint8 *pBuf;
   1707            uint8 len;
   1708          
   1709            (void)securityEnable;  // Intentionally unreferenced parameter
   1710          
   1711            // Status + ScannedChannels + totalTransmissions + transmissionFailures + ListCount + energyValues
   1712            len = 1 + 4 + 2 + 2 + 1 + listCount;
   \   00001A   4846         MOV.B   R6, R8
   \   00001C   78500A00     ADD.B   #0xa, R8
   1713          
   1714            buf = osal_mem_alloc( len+1 ); // +1 for transaction ID
   \   000020   4C48         MOV.B   R8, R12
   \   000022   ........     CALLA   #??Subroutine8_0
   1715            if ( buf == NULL )
   \                     ??CrossCallReturnLabel_24:
   \   000026   0320         JNE     ??ZDP_MgmtNwkUpdateNotify_0
   1716            {
   1717              return afStatus_MEM_FAIL;
   \   000028   7C401000     MOV.B   #0x10, R12
   \   00002C   2F3C         JMP     ??ZDP_MgmtNwkUpdateNotify_1
   1718            }
   1719          
   1720            pBuf = buf+1;
   \                     ??ZDP_MgmtNwkUpdateNotify_0:
   \   00002E   1C53         ADD.W   #0x1, R12
   1721          
   1722            *pBuf++ = status;
   \   000030   CC440000     MOV.B   R4, 0(R12)
   \   000034   1C53         ADD.W   #0x1, R12
   1723          
   1724            pBuf = osal_buffer_uint32( pBuf, scannedChannels );
   \   000036   0E4A         MOV.W   R10, R14
   \   000038   0F4B         MOV.W   R11, R15
   \   00003A   ........     CALLA   #osal_buffer_uint32
   1725          
   1726            *pBuf++ = LO_UINT16( totalTransmissions );
   \   00003E   CC470000     MOV.B   R7, 0(R12)
   \   000042   1C53         ADD.W   #0x1, R12
   1727            *pBuf++ = HI_UINT16( totalTransmissions );
   \   000044                RPT     #0x8
   \   000044   47190710     RRUX.W  R7
   \   000048   CC470000     MOV.B   R7, 0(R12)
   \   00004C   1C53         ADD.W   #0x1, R12
   \   00004E   1E411C00     MOV.W   0x1c(SP), R14
   1728          
   1729            *pBuf++ = LO_UINT16( transmissionFailures );
   \   000052   ........     CALLA   #?Subroutine9
   1730            *pBuf++ = HI_UINT16( transmissionFailures );
   1731          
   1732            *pBuf++ = listCount;
   \                     ??CrossCallReturnLabel_0:
   \   000056   CC460000     MOV.B   R6, 0(R12)
   \   00005A   1C53         ADD.W   #0x1, R12
   1733          
   1734            if ( listCount > 0 )
   \   00005C   4693         CMP.B   #0x0, R6
   \   00005E   0524         JEQ     ??ZDP_MgmtNwkUpdateNotify_2
   1735              osal_memcpy( pBuf, energyValues, listCount );
   \   000060   4E46         MOV.B   R6, R14
   \   000062   1D412000     MOV.W   0x20(SP), R13
   \   000066   ........     CALLA   #osal_memcpy
   1736          
   1737            FillAndSendBufferTxOptions( &TransSeq, dstAddr, Mgmt_NWK_Update_notify, len, buf, txOptions );
   \                     ??ZDP_MgmtNwkUpdateNotify_2:
   \   00006A   0F49         MOV.W   R9, R15
   \   00006C   1F53         ADD.W   #0x1, R15
   \   00006E   824F....     MOV.W   R15, &ZDP_TmpBuf
   \   000072   C245....     MOV.B   R5, &ZDP_TxOptions
   \   000076   4F48         MOV.B   R8, R15
   \   000078   3E403880     MOV.W   #0x8038, R14
   \   00007C   2D41         MOV.W   @SP, R13
   \   00007E   0C41         MOV.W   SP, R12
   \   000080   2C53         ADD.W   #0x2, R12
   \   000082   ........     CALLA   #?Subroutine20
   \                     ??CrossCallReturnLabel_26:
   \   000086   C243....     MOV.B   #0x0, &ZDP_TxOptions
   \   00008A   4C4A         MOV.B   R10, R12
   \                     ??ZDP_MgmtNwkUpdateNotify_1:
   \   00008C   2152         ADD.W   #0x4, SP
   \   00008E   7417         POPM.W  #0x8, R11
   \   000090   1001         RETA
   1738          }
   1739          
   1740          /*********************************************************************
   1741           * Functions to register for ZDO Over-the-air messages
   1742           */
   1743          
   1744          /*********************************************************************
   1745           * @fn          ZDO_RegisterForZDOMsg
   1746           *
   1747           * @brief       Call this function to register of an incoming over
   1748           *              the air ZDO message - probably a response message
   1749           *              but requests can also be received.
   1750           *              Messages are delivered to the task with ZDO_CB_MSG
   1751           *              as the message ID.
   1752           *
   1753           * @param       taskID - Where you would like the message delivered
   1754           * @param       clusterID - What message?
   1755           *
   1756           * @return      ZSuccess - successful, ZMemError if not
   1757           */

   \                                 In  segment CODE, align 2
   1758          ZStatus_t ZDO_RegisterForZDOMsg( uint8 taskID, uint16 clusterID )
   \                     ZDO_RegisterForZDOMsg:
   1759          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   1760            ZDO_MsgCB_t *pList;
   1761            ZDO_MsgCB_t *pLast;
   1762            ZDO_MsgCB_t *pNew;
   1763          
   1764            // Look for duplicate
   1765            pList = pLast = zdoMsgCBs;
   \   000006   1842....     MOV.W   &zdoMsgCBs, R8
   \   00000A   0F48         MOV.W   R8, R15
   \   00000C   083C         JMP     ??ZDO_RegisterForZDOMsg_1
   1766            while ( pList )
   1767            {
   1768              if ( pList->taskID == taskID && pList->clusterID == clusterID )
   \                     ??ZDO_RegisterForZDOMsg_0:
   \   00000E   CF9C0200     CMP.B   R12, 0x2(R15)
   \   000012   0320         JNE     ??ZDO_RegisterForZDOMsg_2
   \   000014   8F9D0400     CMP.W   R13, 0x4(R15)
   \   000018   1824         JEQ     ??ZDO_RegisterForZDOMsg_3
   1769                return ( ZSuccess );
   1770              pLast = pList;
   \                     ??ZDO_RegisterForZDOMsg_2:
   \   00001A   084F         MOV.W   R15, R8
   1771              pList = (ZDO_MsgCB_t *)pList->next;
   \   00001C   2F4F         MOV.W   @R15, R15
   1772            }
   \                     ??ZDO_RegisterForZDOMsg_1:
   \   00001E   0F93         CMP.W   #0x0, R15
   \   000020   F623         JNE     ??ZDO_RegisterForZDOMsg_0
   1773          
   1774            // Add to the list
   1775            pNew = (ZDO_MsgCB_t *)osal_mem_alloc( sizeof ( ZDO_MsgCB_t ) );
   \   000022   3C400600     MOV.W   #0x6, R12
   \   000026   ........     CALLA   #osal_mem_alloc
   1776            if ( pNew )
   \   00002A   0C93         CMP.W   #0x0, R12
   \   00002C   1024         JEQ     ??ZDO_RegisterForZDOMsg_4
   1777            {
   1778              pNew->taskID = taskID;
   \   00002E   CC4A0200     MOV.B   R10, 0x2(R12)
   1779              pNew->clusterID = clusterID;
   \   000032   8C4B0400     MOV.W   R11, 0x4(R12)
   1780              pNew->next = NULL;
   \   000036   8C430000     MOV.W   #0x0, 0(R12)
   1781              if ( zdoMsgCBs )
   \   00003A   8293....     CMP.W   #0x0, &zdoMsgCBs
   \   00003E   0324         JEQ     ??ZDO_RegisterForZDOMsg_5
   1782              {
   1783                pLast->next = pNew;
   \   000040   884C0000     MOV.W   R12, 0(R8)
   \   000044   023C         JMP     ??ZDO_RegisterForZDOMsg_3
   1784              }
   1785              else
   1786                zdoMsgCBs = pNew;
   \                     ??ZDO_RegisterForZDOMsg_5:
   \   000046   824C....     MOV.W   R12, &zdoMsgCBs
   1787              return ( ZSuccess );
   \                     ??ZDO_RegisterForZDOMsg_3:
   \   00004A   4C43         MOV.B   #0x0, R12
   \   00004C   023C         JMP     ??ZDO_RegisterForZDOMsg_6
   1788            }
   1789            else
   1790              return ( ZMemError );
   \                     ??ZDO_RegisterForZDOMsg_4:
   \   00004E   7C401000     MOV.B   #0x10, R12
   \                     ??ZDO_RegisterForZDOMsg_6:
   \   000052   3817         POPM.W  #0x4, R11
   \   000054   1001         RETA
   1791          }
   1792          
   1793          /*********************************************************************
   1794           * @fn          ZDO_RemoveRegisteredCB
   1795           *
   1796           * @brief       Call this function if you don't want to receive the
   1797           *              incoming message.
   1798           *
   1799           * @param       taskID - Where the messages are being delivered.
   1800           * @param       clusterID - What message?
   1801           *
   1802           * @return      ZSuccess - successful, ZFailure if not found
   1803           */

   \                                 In  segment CODE, align 2
   1804          ZStatus_t ZDO_RemoveRegisteredCB( uint8 taskID, uint16 clusterID )
   \                     ZDO_RemoveRegisteredCB:
   1805          {
   1806            ZDO_MsgCB_t *pList;
   1807            ZDO_MsgCB_t *pLast = NULL;
   \   000000   0E43         MOV.W   #0x0, R14
   1808          
   1809            pList = zdoMsgCBs;
   \   000002   1F42....     MOV.W   &zdoMsgCBs, R15
   \   000006   023C         JMP     ??ZDO_RemoveRegisteredCB_1
   1810            while ( pList )
   1811            {
   1812              if ( pList->taskID == taskID && pList->clusterID == clusterID )
   1813              {
   1814                if ( pLast )
   1815                {
   1816                  // remove this one from the linked list
   1817                  pLast->next = pList->next;
   1818                }
   1819                else if ( pList->next )
   1820                {
   1821                  // remove the first one from the linked list
   1822                  zdoMsgCBs = pList->next;
   1823                }
   1824                else
   1825                {
   1826                  // remove the only item from the list
   1827                  zdoMsgCBs = (ZDO_MsgCB_t *)NULL;
   1828                }
   1829                osal_mem_free( pList );
   1830                return ( ZSuccess );
   1831              }
   1832              pLast = pList;
   \                     ??ZDO_RemoveRegisteredCB_0:
   \   000008   0E4F         MOV.W   R15, R14
   1833              pList = pList->next;
   \   00000A   2F4F         MOV.W   @R15, R15
   \                     ??ZDO_RemoveRegisteredCB_1:
   \   00000C   0F93         CMP.W   #0x0, R15
   \   00000E   1824         JEQ     ??ZDO_RemoveRegisteredCB_2
   \   000010   CF9C0200     CMP.B   R12, 0x2(R15)
   \   000014   F923         JNE     ??ZDO_RemoveRegisteredCB_0
   \   000016   8F9D0400     CMP.W   R13, 0x4(R15)
   \   00001A   F623         JNE     ??ZDO_RemoveRegisteredCB_0
   \   00001C   2D4F         MOV.W   @R15, R13
   \   00001E   0E93         CMP.W   #0x0, R14
   \   000020   0324         JEQ     ??ZDO_RemoveRegisteredCB_3
   \   000022   8E4D0000     MOV.W   R13, 0(R14)
   \   000026   073C         JMP     ??ZDO_RemoveRegisteredCB_4
   \                     ??ZDO_RemoveRegisteredCB_3:
   \   000028   0D93         CMP.W   #0x0, R13
   \   00002A   0324         JEQ     ??ZDO_RemoveRegisteredCB_5
   \   00002C   824D....     MOV.W   R13, &zdoMsgCBs
   \   000030   023C         JMP     ??ZDO_RemoveRegisteredCB_4
   \                     ??ZDO_RemoveRegisteredCB_5:
   \   000032   8243....     MOV.W   #0x0, &zdoMsgCBs
   \                     ??ZDO_RemoveRegisteredCB_4:
   \   000036   0C4F         MOV.W   R15, R12
   \   000038   ........     CALLA   #osal_mem_free
   \   00003C   4C43         MOV.B   #0x0, R12
   \   00003E   1001         RETA
   1834            }
   1835          
   1836            return ( ZFailure );
   \                     ??ZDO_RemoveRegisteredCB_2:
   \   000040   5C43         MOV.B   #0x1, R12
   \   000042   1001         RETA
   1837          }
   1838          
   1839          /*********************************************************************
   1840           * @fn          ZDO_SendMsgCBs
   1841           *
   1842           * @brief       This function sends messages to registered tasks.
   1843           *              Local to ZDO and shouldn't be called outside of ZDO.
   1844           *
   1845           * @param       inMsg - incoming message
   1846           *
   1847           * @return      TRUE if sent to at least 1 task, FALSE if not
   1848           */

   \                                 In  segment CODE, align 2
   1849          uint8 ZDO_SendMsgCBs( zdoIncomingMsg_t *inMsg )
   \                     ZDO_SendMsgCBs:
   1850          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0B4C         MOV.W   R12, R11
   1851            uint8 ret = FALSE;
   \   000004   4A43         MOV.B   #0x0, R10
   1852            ZDO_MsgCB_t *pList = zdoMsgCBs;
   \   000006   1842....     MOV.W   &zdoMsgCBs, R8
   \   00000A   2A3C         JMP     ??ZDO_SendMsgCBs_1
   1853            while ( pList )
   1854            {
   1855              if ( pList->clusterID == inMsg->clusterID )
   \                     ??ZDO_SendMsgCBs_0:
   \   00000C   989B0E000400 CMP.W   0xe(R11), 0x4(R8)
   \   000012   2520         JNE     ??ZDO_SendMsgCBs_2
   1856              {
   1857                zdoIncomingMsg_t *msgPtr;
   1858          
   1859                // Send the address to the task
   1860                msgPtr = (zdoIncomingMsg_t *)osal_msg_allocate( sizeof( zdoIncomingMsg_t ) + inMsg->asduLen );
   \   000014   5C4B1200     MOV.B   0x12(R11), R12
   \   000018   3C501800     ADD.W   #0x18, R12
   \   00001C   ........     CALLA   #osal_msg_allocate
   \   000020   094C         MOV.W   R12, R9
   1861                if ( msgPtr )
   \   000022   0C93         CMP.W   #0x0, R12
   \   000024   1C24         JEQ     ??ZDO_SendMsgCBs_2
   1862                {
   1863                  // copy struct
   1864                  osal_memcpy( msgPtr, inMsg, sizeof( zdoIncomingMsg_t ));
   \   000026   3E401800     MOV.W   #0x18, R14
   \   00002A   0D4B         MOV.W   R11, R13
   \   00002C   ........     CALLA   #osal_memcpy
   1865          
   1866                  if ( inMsg->asduLen )
   \   000030   CB931200     CMP.B   #0x0, 0x12(R11)
   \   000034   0B24         JEQ     ??ZDO_SendMsgCBs_3
   1867                  {
   1868                    msgPtr->asdu = (byte*)(((byte*)msgPtr) + sizeof( zdoIncomingMsg_t ));
   \   000036   0C49         MOV.W   R9, R12
   \   000038   3C501800     ADD.W   #0x18, R12
   \   00003C   894C1600     MOV.W   R12, 0x16(R9)
   1869                    osal_memcpy( msgPtr->asdu, inMsg->asdu, inMsg->asduLen );
   \   000040   5E4B1200     MOV.B   0x12(R11), R14
   \   000044   1D4B1600     MOV.W   0x16(R11), R13
   \   000048   ........     CALLA   #osal_memcpy
   1870                  }
   1871          
   1872                  msgPtr->hdr.event = ZDO_CB_MSG;
   \                     ??ZDO_SendMsgCBs_3:
   \   00004C   F940D3000000 MOV.B   #0xd3, 0(R9)
   1873                  osal_msg_send( pList->taskID, (uint8 *)msgPtr );
   \   000052   0D49         MOV.W   R9, R13
   \   000054   5C480200     MOV.B   0x2(R8), R12
   \   000058   ........     CALLA   #osal_msg_send
   1874                  ret = TRUE;
   \   00005C   5A43         MOV.B   #0x1, R10
   1875                }
   1876              }
   1877              pList = (ZDO_MsgCB_t *)pList->next;
   \                     ??ZDO_SendMsgCBs_2:
   \   00005E   2848         MOV.W   @R8, R8
   1878            }
   \                     ??ZDO_SendMsgCBs_1:
   \   000060   0893         CMP.W   #0x0, R8
   \   000062   D423         JNE     ??ZDO_SendMsgCBs_0
   1879            return ( ret );
   \   000064   4C4A         MOV.B   R10, R12
   \   000066   3817         POPM.W  #0x4, R11
   \   000068   1001         RETA
   1880          }
   1881          
   1882          /*********************************************************************
   1883           * Incoming message processor
   1884           */
   1885          
   1886          /*********************************************************************
   1887           * @fn          ZDP_IncomingData
   1888           *
   1889           * @brief       This function indicates the transfer of a data PDU (ASDU)
   1890           *              from the APS sub-layer to the ZDO.
   1891           *
   1892           * @param       pData - Incoming Message
   1893           *
   1894           * @return      none
   1895           */

   \                                 In  segment CODE, align 2
   1896          void ZDP_IncomingData( afIncomingMSGPacket_t *pData )
   \                     ZDP_IncomingData:
   1897          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31801800     SUB.W   #0x18, SP
   1898            uint8 x = 0;
   \   000006   4A43         MOV.B   #0x0, R10
   1899            uint8 handled;
   1900            zdoIncomingMsg_t inMsg;
   1901          
   1902            inMsg.srcAddr.addrMode = Addr16Bit;
   \   000008   E1430A00     MOV.B   #0x2, 0xa(SP)
   1903            inMsg.srcAddr.addr.shortAddr = pData->srcAddr.addr.shortAddr;
   \   00000C   914C06000200 MOV.W   0x6(R12), 0x2(SP)
   1904            inMsg.wasBroadcast = pData->wasBroadcast;
   \   000012   D14C15000C00 MOV.B   0x15(R12), 0xc(SP)
   1905            inMsg.clusterID = pData->clusterId;
   \   000018   914C04000E00 MOV.W   0x4(R12), 0xe(SP)
   1906            inMsg.SecurityUse = pData->SecurityUse;
   \   00001E   D14C19001000 MOV.B   0x19(R12), 0x10(SP)
   1907          
   1908            inMsg.asduLen = pData->cmd.DataLength-1;
   \   000024   5E4C2200     MOV.B   0x22(R12), R14
   \   000028   7E53         ADD.B   #0xff, R14
   \   00002A   C14E1200     MOV.B   R14, 0x12(SP)
   1909            inMsg.asdu = pData->cmd.Data+1;
   \   00002E   1F4C2400     MOV.W   0x24(R12), R15
   \   000032   1F53         ADD.W   #0x1, R15
   \   000034   814F1600     MOV.W   R15, 0x16(SP)
   1910            inMsg.TransSeq = pData->cmd.Data[0];
   \   000038   1F4C2400     MOV.W   0x24(R12), R15
   \   00003C   E14F1100     MOV.B   @R15, 0x11(SP)
   1911            inMsg.macDestAddr = pData->macDestAddr;
   \   000040   914C12001400 MOV.W   0x12(R12), 0x14(SP)
   1912          
   1913            handled = ZDO_SendMsgCBs( &inMsg );
   \   000046   0B41         MOV.W   SP, R11
   \   000048   0B53         ADD.W   #0x0, R11
   \   00004A   0C4B         MOV.W   R11, R12
   \   00004C   ........     CALLA   #ZDO_SendMsgCBs
   \   000050   013C         JMP     ??ZDP_IncomingData_2
   1914          
   1915          #if (defined MT_ZDO_CB_FUNC)
   1916          #if !defined MT_TASK
   1917            if (zgZdoDirectCB)
   1918          #endif
   1919            {
   1920              MT_ZdoDirectCB( pData, &inMsg );
   1921            }
   1922          #endif
   1923          
   1924            while ( zdpMsgProcs[x].clusterID != 0xFFFF )
   1925            {
   1926              if ( zdpMsgProcs[x].clusterID == inMsg.clusterID )
   1927              {
   1928                zdpMsgProcs[x].pFn( &inMsg );
   1929                return;
   1930              }
   1931              x++;
   \                     ??ZDP_IncomingData_0:
   \   000052   5A53         ADD.B   #0x1, R10
   \                     ??ZDP_IncomingData_2:
   \   000054   0F4A         MOV.W   R10, R15
   \   000056                RPT     #0x5
   \   000056   44180F5A     ADDX.W  R10, R15
   \   00005A   1E4F....     MOV.W   zdpMsgProcs(R15), R14
   \   00005E   3E93         CMP.W   #0xffff, R14
   \   000060   0B24         JEQ     ??ZDP_IncomingData_3
   \   000062   1E910E00     CMP.W   0xe(SP), R14
   \   000066   F523         JNE     ??ZDP_IncomingData_0
   \   000068   0C4B         MOV.W   R11, R12
   \   00006A   1E4F....     MOV.W   zdpMsgProcs + 2(R15), R14
   \   00006E   1F4F....     MOV.W   zdpMsgProcs + 4(R15), R15
   \   000072   ........     CALLA   #?IndCallR15
   \   000076   053C         JMP     ??ZDP_IncomingData_1
   1932            }
   1933          
   1934            // Handle unhandled messages
   1935            if ( !handled )
   \                     ??ZDP_IncomingData_3:
   \   000078   4C93         CMP.B   #0x0, R12
   \   00007A   0320         JNE     ??ZDP_IncomingData_1
   1936              ZDApp_InMsgCB( &inMsg );
   \   00007C   0C4B         MOV.W   R11, R12
   \   00007E   ........     CALLA   #ZDApp_InMsgCB
   1937          }
   \                     ??ZDP_IncomingData_1:
   \   000082   31501800     ADD.W   #0x18, SP
   \   000086   1A17         POPM.W  #0x2, R11
   \   000088   1001         RETA

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for ZDP_TmpBuf>`:
   \   000000   ....         DC16 ZDP_Buf + 1H
   1938          
   1939          /*********************************************************************
   1940          *********************************************************************/
   1941          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     12   ZDO_RegisterForZDOMsg
       12   -> osal_mem_alloc
      4   ZDO_RemoveRegisteredCB
        4   -> osal_mem_free
     12   ZDO_SendMsgCBs
       12   -> osal_memcpy
       12   -> osal_msg_allocate
       12   -> osal_msg_send
     16   ZDP_BindUnbindReq
       16   -> fillAndSend
       16   -> sAddrExtCpy
     16   ZDP_DeviceAnnce
       16   -> fillAndSend
       16   -> sAddrExtCpy
     14   ZDP_EPRsp
       14   -> fillAndSend
       14   -> osal_memcpy
     20   ZDP_EndDeviceBindReq
       20   -> NLME_GetExtAddr
       20   -> NLME_GetShortAddr
       20   -> fillAndSend
       20   -> sAddrExtCpy
      8   ZDP_GenericRsp
        8   -> fillAndSend
     14   ZDP_IEEEAddrReq
       14   -> fillAndSend
     32   ZDP_IncomingData
       32   -- Indirect call
       32   -> ZDApp_InMsgCB
       32   -> ZDO_SendMsgCBs
     16   ZDP_MatchDescReq
       16   -> fillAndSend
     18   ZDP_MgmtBindRsp
       18   -> fillAndSend
       18   -> osal_mem_alloc
       18   -> osal_mem_free
       18   -> sAddrExtCpy
      8   ZDP_MgmtDirectJoinReq
        8   -> fillAndSend
        8   -> sAddrExtCpy
     12   ZDP_MgmtLeaveReq
       12   -> fillAndSend
       12   -> sAddrExtCpy
     22   ZDP_MgmtLqiRsp
       22   -> fillAndSend
       22   -> osal_mem_alloc
       22   -> osal_mem_free
       22   -> sAddrExtCpy
     12   ZDP_MgmtNwkDiscReq
       12   -> fillAndSend
       12   -> osal_buffer_uint32
     22   ZDP_MgmtNwkDiscRsp
       22   -> fillAndSend
       22   -> osal_mem_alloc
       22   -> osal_mem_free
       22   -> sAddrExtCpy
     24   ZDP_MgmtNwkUpdateNotify
       24   -> fillAndSend
       24   -> osal_buffer_uint32
       24   -> osal_mem_alloc
       24   -> osal_mem_free
       24   -> osal_memcpy
     16   ZDP_MgmtNwkUpdateReq
       16   -> fillAndSend
       16   -> osal_buffer_uint32
      4   ZDP_MgmtPermitJoinReq
        4   -> fillAndSend
     22   ZDP_MgmtRtgRsp
       22   -> fillAndSend
       22   -> osal_mem_alloc
       22   -> osal_mem_free
      4   ZDP_NWKAddrOfInterestReq
        4   -> fillAndSend
      4   ZDP_NodeDescMsg
        4   -> fillAndSend
     22   ZDP_NwkAddrReq
       22   -> fillAndSend
       22   -> sAddrExtCmp
       22   -> sAddrExtCpy
      6   ZDP_PowerDescMsg
        6   -> fillAndSend
     16   ZDP_SendData
       16   -> fillAndSend
     14   ZDP_ServerDiscReq
       14   -> fillAndSend
      6   ZDP_ServerDiscRsp
        6   -> fillAndSend
     12   ZDP_SimpleDescMsg
       12   -> fillAndSend
      4   ZDP_SimpleDescReq
        4   -> fillAndSend
     10   ZDP_UserDescRsp
       10   -> fillAndSend
       10   -> osal_memcpy
      8   ZDP_UserDescSet
        8   -> fillAndSend
        8   -> osal_memcpy
        8   -> osal_memset
     32   fillAndSend
       32   -> AF_DataRequest
       24   -> osal_memset
     36   zdpProcessAddrReq
       36   -> AddrMgrEntryGet
       36   -> AssocGetWithExt
       36   -> AssocGetWithShort
       36   -> AssocMakeList
       36   -> fillAndSend
       36   -> osal_mem_free
       36   -> sAddrExtCmp
       36   -> sAddrExtCpy


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for ZDP_TmpBuf>
      10  ??Subroutine10_0
       8  ??Subroutine12_0
      12  ??Subroutine24_0
      10  ??Subroutine25_0
      10  ??Subroutine6_0
      12  ??Subroutine8_0
      10  ?Subroutine0
       8  ?Subroutine1
       4  ?Subroutine10
       4  ?Subroutine11
       4  ?Subroutine12
       8  ?Subroutine13
      12  ?Subroutine14
      18  ?Subroutine15
      18  ?Subroutine16
      14  ?Subroutine17
      16  ?Subroutine18
      14  ?Subroutine19
       8  ?Subroutine2
      20  ?Subroutine20
      16  ?Subroutine21
       6  ?Subroutine3
       6  ?Subroutine4
      10  ?Subroutine5
       2  ?Subroutine6
       2  ?Subroutine7
       2  ?Subroutine8
       8  ?Subroutine9
      86  ZDO_RegisterForZDOMsg
      68  ZDO_RemoveRegisteredCB
     106  ZDO_SendMsgCBs
       1  ZDP_AF_ENDPOINT
     130  ZDP_BindUnbindReq
      80  ZDP_Buf
      60  ZDP_DeviceAnnce
      88  ZDP_EPRsp
     184  ZDP_EndDeviceBindReq
      46  ZDP_GenericRsp
      42  ZDP_IEEEAddrReq
     138  ZDP_IncomingData
     202  ZDP_MatchDescReq
     202  ZDP_MgmtBindRsp
      22  ZDP_MgmtDirectJoinReq
      46  ZDP_MgmtLeaveReq
     258  ZDP_MgmtLqiRsp
      40  ZDP_MgmtNwkDiscReq
     176  ZDP_MgmtNwkDiscRsp
     146  ZDP_MgmtNwkUpdateNotify
      98  ZDP_MgmtNwkUpdateReq
      18  ZDP_MgmtPermitJoinReq
     132  ZDP_MgmtRtgRsp
      12  ZDP_NWKAddrOfInterestReq
     152  ZDP_NodeDescMsg
      84  ZDP_NwkAddrReq
      76  ZDP_PowerDescMsg
      52  ZDP_SendData
      50  ZDP_ServerDiscReq
      52  ZDP_ServerDiscRsp
     250  ZDP_SimpleDescMsg
      18  ZDP_SimpleDescReq
       2  ZDP_TmpBuf
       1  ZDP_TransID
       1  ZDP_TxOptions
      58  ZDP_UserDescRsp
      80  ZDP_UserDescSet
      90  fillAndSend
       2  zdoMsgCBs
      72  zdpMsgProcs
     446  zdpProcessAddrReq

 
 3 980 bytes in segment CODE
    73 bytes in segment DATA16_C
     2 bytes in segment DATA16_I
     2 bytes in segment DATA16_ID
    84 bytes in segment DATA16_Z
 
 3 980 bytes of CODE  memory
    75 bytes of CONST memory
    86 bytes of DATA  memory

Errors: none
Warnings: none

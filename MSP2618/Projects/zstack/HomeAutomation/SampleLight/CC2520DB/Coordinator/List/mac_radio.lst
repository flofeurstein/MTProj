###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       10/Jun/2013  16:24:35 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\ma #
#                     c\low_level\srf04\mac_radio.c                           #
#    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleLight\CC2520DB\..\..\..\Too #
#                     ls\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0       #
#                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                       #
#                     -DDEFAULT_CHANLIST=0x00000800                           #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100      #
#                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                   #
#                     -DBEACON_REQUEST_DELAY=100                              #
#                     -DBEACON_REQ_DELAY_MASK=0x00FF                          #
#                     -DLINK_STATUS_JITTER_MASK=0x007F                        #
#                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED= #
#                     3000 -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8  #
#                     -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2     #
#                     -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9              #
#                     -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40                #
#                     -DNWK_MAX_BINDING_ENTRIES=4                             #
#                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,       #
#                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,   #
#                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                    #
#                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=2 #
#                     0 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000           #
#                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100         #
#                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\Tools\MSP2618\f8 #
#                     wCoord.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE=TRUE #
#                      -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8             #
#                     -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK) -f      #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\..\..\..\Tools\ #
#                     MSP2618\f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE             #
#                     -DZCL_BASIC -DZCL_IDENTIFY -DZCL_ON_OFF                 #
#                     -DZCL_KEY_ESTABLISH -DZCL_KEY_ESTABLISHMENT_KEY_GENERAT #
#                     E_TIMEOUT=4 -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOU #
#                     T=10 -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10   #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)                #
#                     -DZCL_DEVICE_MGMT "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_lev #
#                     el\srf04\mac_radio.c" -D MSP430F2618 -D ZTOOL_P1 -D     #
#                     MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED  #
#                     -lC "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects #
#                     \zstack\HomeAutomation\SampleLight\CC2520DB\Coordinator #
#                     \List\" -lA "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ #
#                     Projects\zstack\HomeAutomation\SampleLight\CC2520DB\Coo #
#                     rdinator\List\" --remarks --diag_suppress               #
#                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\Coordinator\Obj\"         #
#                     --debug -D__MSP430F2618__ -e --double=32 --clib -I      #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\" -I "C:\Texas  #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\Source\" -I "C:\Texas  #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\Source\" -I         #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleLight\CC2520DB\..\..\..\ZMain\ #
#                     MSP2618\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1 #
#                     \Projects\zstack\HomeAutomation\SampleLight\CC2520DB\.. #
#                     \..\..\..\..\Components\hal\include\" -I "C:\Texas      #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \hal\target\MSP2618CC2520\" -I "C:\Texas                #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\include\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\high_level\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\low_level\srf04\" -I "C:\Texas                     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mac\low_level\srf04\dual_chip\" -I "C:\Texas           #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pro #
#                     jects\zstack\HomeAutomation\SampleLight\CC2520DB\..\..\ #
#                     ..\..\..\Components\osal\include\" -I "C:\Texas         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \osal\mcu\msp430\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \services\saddr\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \services\sdata\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\af\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5 #
#                     .1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB\ #
#                     ..\..\..\..\..\Components\stack\nwk\" -I "C:\Texas      #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\sec\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\stack\sapi\" -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\sys\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\stack\zcl\" -I "C:\Texas     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \stack\zdo\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleLight\CC2520DB #
#                     \..\..\..\..\..\Components\zmac\" -I "C:\Texas          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleLight\CC2520DB\..\..\..\..\..\Components #
#                     \zmac\f8w\" --core=430X --data_model=small -Ohz         #
#                     --multiplier=16s --require_prototypes                   #
#    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleLight\CC2520DB\Coordinator\List #
#                     \mac_radio.lst                                          #
#    Object file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleLight\CC2520DB\Coordinator\Obj\ #
#                     mac_radio.r43                                           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_level\srf04\mac_radio.c
      1          /**************************************************************************************************
      2            Filename:       mac_radio.c
      3            Revised:        $Date: 2007-09-11 10:58:41 -0700 (Tue, 11 Sep 2007) $
      4            Revision:       $Revision: 15371 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2012 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_types.h"
     47          
     48          /* high-level */
     49          #include "mac_pib.h"
     50          
     51          /* exported low-level */
     52          #include "mac_low_level.h"
     53          
     54          /* low-level specific */
     55          #include "mac_radio.h"
     56          #include "mac_tx.h"
     57          #include "mac_rx.h"
     58          #include "mac_rx_onoff.h"
     59          #include "mac_sleep.h"
     60          #include "mac_backoff_timer.h"
     61          
     62          /* target specific */
     63          #include "mac_radio_defs.h"
     64          
     65          /* debug */
     66          #include "mac_assert.h"
     67          
     68          
     69          /* ------------------------------------------------------------------------------------------------
     70           *                                          Includes
     71           * ------------------------------------------------------------------------------------------------
     72           */
     73          #define ED_RF_POWER_MIN_DBM   (MAC_RADIO_RECEIVER_SENSITIVITY_DBM + MAC_SPEC_ED_MIN_DBM_ABOVE_RECEIVER_SENSITIVITY)
     74          #define ED_RF_POWER_MAX_DBM   MAC_RADIO_RECEIVER_SATURATION_DBM
     75          
     76          
     77          /* ------------------------------------------------------------------------------------------------
     78           *                                        Global Variables
     79           * ------------------------------------------------------------------------------------------------
     80           */

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     81          uint8 macPhyTxPower;
   \                     macPhyTxPower:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     82          uint8 macPhyChannel;
   \                     macPhyChannel:
   \   000000                DS8 1
     83          
     84          
     85          /* ------------------------------------------------------------------------------------------------
     86           *                                        Local Variables
     87           * ------------------------------------------------------------------------------------------------
     88           */

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     89          static uint8 reqChannel;
   \                     reqChannel:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     90          static uint8 reqTxPower;
   \                     reqTxPower:
   \   000000                DS8 1
     91          
     92          
     93          /* ------------------------------------------------------------------------------------------------
     94           *                                        Local Functions
     95           * ------------------------------------------------------------------------------------------------
     96           */
     97          static uint8 radioComputeED(int8 rssiDbm);
     98          
     99          
    100          /**************************************************************************************************
    101           * @fn          macRadioInit
    102           *
    103           * @brief       Initialize radio software.
    104           *
    105           * @param       none
    106           *
    107           * @return      none
    108           **************************************************************************************************
    109           */

   \                                 In  segment CODE, align 2
    110          MAC_INTERNAL_API void macRadioInit(void)
   \                     macRadioInit:
    111          {
    112            /* variable initialization for this module */
    113            reqChannel    = MAC_RADIO_CHANNEL_DEFAULT;
   \   000000   F2400B00.... MOV.B   #0xb, &reqChannel
    114            macPhyChannel = MAC_RADIO_CHANNEL_INVALID;
   \   000006   F243....     MOV.B   #0xff, &macPhyChannel
    115            reqTxPower    = MAC_RADIO_TX_POWER_INVALID;
   \   00000A   F243....     MOV.B   #0xff, &reqTxPower
    116            macPhyTxPower = MAC_RADIO_TX_POWER_INVALID;
   \   00000E   F243....     MOV.B   #0xff, &macPhyTxPower
    117          }
   \   000012   1001         RETA
    118          
    119          
    120          /**************************************************************************************************
    121           * @fn          macRadioReset
    122           *
    123           * @brief       Resets the radio module.
    124           *
    125           * @param       none
    126           *
    127           * @return      none
    128           **************************************************************************************************
    129           */

   \                                 In  segment CODE, align 2
    130          MAC_INTERNAL_API void macRadioReset(void)
   \                     macRadioReset:
    131          {
    132            macRadioStopScan();
   \   000000   ........     CALLA   #macRadioStopScan
    133            macRadioEnergyDetectStop();
   \   000004   ........     BRA     #macRadioEnergyDetectStop
    134          }
    135          
    136          
    137          /**************************************************************************************************
    138           * @fn          macRadioRandomByte
    139           *
    140           * @brief       Return a random byte derived from previously set random seed.
    141           *
    142           * @param       none
    143           *
    144           * @return      a random byte
    145           **************************************************************************************************
    146           */

   \                                 In  segment CODE, align 2
    147          MAC_INTERNAL_API uint8 macRadioRandomByte(void)
   \                     macRadioRandomByte:
    148          {
    149            return(MAC_RADIO_RANDOM_BYTE());
   \   000000   ........     BRA     #macDualchipRandomByte
    150          }
    151          
    152          
    153          /**************************************************************************************************
    154           * @fn          macRadioSetPanCoordinator
    155           *
    156           * @brief       Configure the pan coordinator status of the radio
    157           *
    158           * @param       panCoordFlag - non-zero to configure radio to be pan coordinator
    159           *                             zero to configure radio as NON pan coordinator
    160           *
    161           * @return      none
    162           **************************************************************************************************
    163           */

   \                                 In  segment CODE, align 2
    164          MAC_INTERNAL_API void macRadioSetPanCoordinator(uint8 panCoordFlag)
   \                     macRadioSetPanCoordinator:
    165          {
    166            /* abstracted radio configuration */
    167            MAC_RADIO_SET_PAN_COORDINATOR(panCoordFlag);
   \   000000   4C93         CMP.B   #0x0, R12
   \   000002   0324         JEQ     ??macRadioSetPanCoordinator_0
   \   000004   6C43         MOV.B   #0x2, R12
   \   000006   ........     BRA     #macDualchipOrFRMFILT0
   \                     ??macRadioSetPanCoordinator_0:
   \   00000A   7C40FD00     MOV.B   #0xfd, R12
   \   00000E   ........     BRA     #macDualchipAndFRMFILT0
    168          }
    169          
    170          
    171          /**************************************************************************************************
    172           * @fn          macRadioSetPanID
    173           *
    174           * @brief       Set the pan ID on the radio.
    175           *
    176           * @param       panID - 16 bit PAN identifier
    177           *
    178           * @return      none
    179           **************************************************************************************************
    180           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   3C40F203     MOV.W   #0x3f2, R12
   \   000004   ........     BRA     #macSpiWriteRamUint16

   \                                 In  segment CODE, align 2
    181          void macRadioSetPanID(uint16 panID)
   \                     macRadioSetPanID:
    182          {
    183            /* abstracted radio configuration */
    184            MAC_RADIO_SET_PAN_ID(panID);
   \   000000   0D4C         MOV.W   R12, R13
   \   000002   ....         JMP     ?Subroutine0
    185          }
    186          
    187          
    188          /**************************************************************************************************
    189           * @fn          macRadioSetShortAddr
    190           *
    191           * @brief       Set the short addrss on the radio.
    192           *
    193           * @param       shortAddr - 16 bit short address
    194           *
    195           * @return      none
    196           **************************************************************************************************
    197           */

   \                                 In  segment CODE, align 2, keep-with-next
    198          MAC_INTERNAL_API void macRadioSetShortAddr(uint16 shortAddr)
   \                     macRadioSetShortAddr:
    199          {
    200            /* abstracted radio configuration */
    201            MAC_RADIO_SET_SHORT_ADDR(shortAddr);
   \   000000   0D4C         MOV.W   R12, R13
   \   000002   3C40F403     MOV.W   #0x3f4, R12
   \   000006   ........     BRA     #macSpiWriteRamUint16
    202          }
    203          
    204          
    205          /**************************************************************************************************
    206           * @fn          macRadioSetIEEEAddr
    207           *
    208           * @brief       Set the IEEE address on the radio.
    209           *
    210           * @param       pIEEEAddr - pointer to array holding 64 bit IEEE address; array must be little
    211           *                          endian format (starts with lowest signficant byte)
    212           *
    213           * @return      none
    214           **************************************************************************************************
    215           */

   \                                 In  segment CODE, align 2, keep-with-next
    216          MAC_INTERNAL_API void macRadioSetIEEEAddr(uint8 * pIEEEAddr)
   \                     macRadioSetIEEEAddr:
    217          {
    218            /* abstracted radio configuration */
    219            MAC_RADIO_SET_IEEE_ADDR(pIEEEAddr);
   \   000000   7E42         MOV.B   #0x8, R14
   \   000002   0D4C         MOV.W   R12, R13
   \   000004   3C40EA03     MOV.W   #0x3ea, R12
   \   000008   ........     BRA     #macSpiWriteRam
    220          }
    221          
    222          
    223          /**************************************************************************************************
    224           * @fn          macRadioSetTxPower
    225           *
    226           * @brief       Set transmitter power of the radio.
    227           *
    228           * @param       txPower - the minus dBm for power but as a postive integer (or if configured
    229           *                        for it, txPower is the raw register value). If PA/LNA is installed
    230           *                        then txPower becomes positive dBm.
    231           *
    232           * @return      The minus dBm for power actually set according to what is possible according to
    233                          the build and run-time configuration set.
    234           **************************************************************************************************
    235           */
    236          #ifndef HAL_MAC_USE_REGISTER_POWER_VALUES
    237          /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    238          

   \                                 In  segment CODE, align 2, keep-with-next
    239          MAC_INTERNAL_API uint8 macRadioSetTxPower(uint8 txPower)
   \                     macRadioSetTxPower:
    240          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
    241            halIntState_t  s;
    242          #if defined MAC_RUNTIME_CC2591 || defined MAC_RUNTIME_CC2590
    243            const uint8 CODE *pTable = macRadioDefsTxPwrTables[macRadioDefsRefTableId >> 4];
    244          #elif defined HAL_PA_LNA || defined HAL_PA_LNA_CC2590
    245            const uint8 CODE *pTable = macRadioDefsTxPwrTables[0];
    246          #else
    247            const uint8 CODE *pTable = macRadioDefsTxPwrBare;
    248          #endif
    249          
    250            /* if the selected dBm is out of range, use the closest available */
    251            if ((int8)txPower > (int8)pTable[MAC_RADIO_DEFS_TBL_TXPWR_FIRST_ENTRY])
   \   000004   5F42....     MOV.B   &macRadioDefsTxPwrBare, R15
   \   000008   4F9C         CMP.B   R12, R15
   \   00000A   0234         JGE     ??macRadioSetTxPower_0
    252            {
    253              /* greater than base value -- out of table range */
    254              txPower = pTable[MAC_RADIO_DEFS_TBL_TXPWR_FIRST_ENTRY];
   \   00000C   4A4F         MOV.B   R15, R10
   \   00000E   053C         JMP     ??macRadioSetTxPower_1
    255            }
    256            else if ((int8)txPower < (int8)pTable[MAC_RADIO_DEFS_TBL_TXPWR_LAST_ENTRY])
   \                     ??macRadioSetTxPower_0:
   \   000010   5E42....     MOV.B   &macRadioDefsTxPwrBare + 1, R14
   \   000014   4C9E         CMP.B   R14, R12
   \   000016   0134         JGE     ??macRadioSetTxPower_1
    257            {
    258              /* smaller than the lowest power level -- out of table range */
    259              txPower = pTable[MAC_RADIO_DEFS_TBL_TXPWR_LAST_ENTRY];
   \   000018   4A4E         MOV.B   R14, R10
    260            }
    261          
    262            /*
    263             *  Set the global variable reqTxPower.  This variable is referenced
    264             *  by the function macRadioUpdateTxPower() to write the radio register.
    265             *
    266             *  A lookup table is used to translate the power level to the register
    267             *  value.
    268             */
    269            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macRadioSetTxPower_1:
   \   00001A   0E42         MOV.W   SR, R14
   \   00001C   32C2         dint
   \   00001E   0343         nop
    270            /* When calculating index to the power register value table,
    271             * either txPower (of uint8 type) has to be explicitly type-casted to int8
    272             * or the subtraction expression has to be type-casted to uint8 to work
    273             * with the integral promotions.
    274             * The latter is more code size efficient and hence the latter is used.
    275             */
    276            {
    277              uint8 index = pTable[MAC_RADIO_DEFS_TBL_TXPWR_FIRST_ENTRY] - txPower
    278                + MAC_RADIO_DEFS_TBL_TXPWR_ENTRIES;
    279              reqTxPower = pTable[index];
   \   000020   4F8A         SUB.B   R10, R15
   \   000022   6F53         ADD.B   #0x2, R15
   \   000024   D24F........ MOV.B   macRadioDefsTxPwrBare(R15), &reqTxPower
    280            }
    281            HAL_EXIT_CRITICAL_SECTION(s);
   \   00002A   024E         MOV.W   R14, SR
    282          
    283            /* update the radio power setting */
    284            macRadioUpdateTxPower();
   \   00002C   ........     CALLA   #macRadioUpdateTxPower
    285          
    286            return txPower;
   \   000030   4C4A         MOV.B   R10, R12
   \   000032   3A41         POP.W   R10
   \   000034   1001         RETA
    287          }
    288          
    289          #else
    290          /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    291          
    292          MAC_INTERNAL_API uint8 macRadioSetTxPower(uint8 txPower)
    293          {
    294            halIntState_t  s;
    295          
    296            /* same as above but with no lookup table, use raw register value */
    297            HAL_ENTER_CRITICAL_SECTION(s);
    298            reqTxPower = txPower;
    299            HAL_EXIT_CRITICAL_SECTION(s);
    300          
    301            /* update the radio power setting */
    302            macRadioUpdateTxPower();
    303          
    304            return txPower;
    305          }
    306          
    307          #endif
    308          
    309          
    310          /**************************************************************************************************
    311           * @fn          macRadioUpdateTxPower
    312           *
    313           * @brief       Update the radio's transmit power if a new power level has been requested
    314           *
    315           * @param       reqTxPower - file scope variable that holds the last request power level
    316           *              macPhyTxPower - global variable that holds radio's set power level
    317           *
    318           * @return      none
    319           **************************************************************************************************
    320           */

   \                                 In  segment CODE, align 2, keep-with-next
    321          MAC_INTERNAL_API void macRadioUpdateTxPower(void)
   \                     macRadioUpdateTxPower:
    322          {
   \   000000   0A12         PUSH.W  R10
    323            halIntState_t  s;
    324          
    325            /*
    326             *  If the requested power setting is different from the actual radio setting,
    327             *  attempt to udpate to the new power setting.
    328             */
    329            HAL_ENTER_CRITICAL_SECTION(s);
   \   000002   0A42         MOV.W   SR, R10
   \   000004   32C2         dint
   \   000006   0343         nop
    330            if (reqTxPower != macPhyTxPower)
   \   000008   5D42....     MOV.B   &reqTxPower, R13
   \   00000C   5D92....     CMP.B   &macPhyTxPower, R13
   \   000010   0C24         JEQ     ??macRadioUpdateTxPower_0
    331            {
    332              /*
    333               *  Radio power cannot be updated when the radio is physically transmitting.
    334               *  If there is a possibility radio is transmitting, do not change the power
    335               *  setting.  This function will be called again after the current transmit
    336               *  completes.
    337               */
    338              if (!macRxOutgoingAckFlag && !MAC_TX_IS_PHYSICALLY_ACTIVE())
   \   000012   C293....     CMP.B   #0x0, &macRxOutgoingAckFlag
   \   000016   0920         JNE     ??macRadioUpdateTxPower_0
   \   000018   C293....     CMP.B   #0x0, &macTxActive
   \   00001C   0638         JL      ??macRadioUpdateTxPower_0
    339              {
    340                /*
    341                 *  Set new power level;  update the shadow value and write
    342                 *  the new value to the radio hardware.
    343                 */
    344                macPhyTxPower = reqTxPower;
   \   00001E   C24D....     MOV.B   R13, &macPhyTxPower
    345                MAC_RADIO_SET_TX_POWER(macPhyTxPower);
   \   000022   7C403000     MOV.B   #0x30, R12
   \   000026   ........     CALLA   #macSpiWriteReg
    346              }
    347            }
    348            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macRadioUpdateTxPower_0:
   \   00002A   024A         MOV.W   R10, SR
    349          }
   \   00002C   3A41         POP.W   R10
   \   00002E   1001         RETA
    350          
    351          
    352          /**************************************************************************************************
    353           * @fn          macRadioSetChannel
    354           *
    355           * @brief       Set radio channel.
    356           *
    357           * @param       channel - channel number, valid range is 11 through 26. Allow
    358           *              channels 27 and 28 for some Japanese customers.
    359           *
    360           * @return      none
    361           **************************************************************************************************
    362           */

   \                                 In  segment CODE, align 2, keep-with-next
    363          MAC_INTERNAL_API void macRadioSetChannel(uint8 channel)
   \                     macRadioSetChannel:
    364          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   4A4C         MOV.B   R12, R10
    365            halIntState_t  s;
    366          
    367            MAC_ASSERT((channel >= 11) && (channel <= 28));  /* illegal channel */
   \   000004   4E4C         MOV.B   R12, R14
   \   000006   7E50F500     ADD.B   #0xf5, R14
   \   00000A   7E901200     CMP.B   #0x12, R14
   \   00000E   0228         JNC     ??macRadioSetChannel_0
   \   000010   ........     CALLA   #halAssertHandler
    368          
    369            /* critical section to make sure transmit does not start while updating channel */
    370            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macRadioSetChannel_0:
   \   000014   0B42         MOV.W   SR, R11
   \   000016   32C2         dint
   \   000018   0343         nop
    371          
    372            /* set requested channel */
    373            reqChannel = channel;
   \   00001A   C24A....     MOV.B   R10, &reqChannel
    374          
    375            /*
    376             *  If transmit is not active, update the radio hardware immediately.  If transmit is active,
    377             *  the channel will be updated at the end of the current transmit.
    378             */
    379            if (!macTxActive)
   \   00001E   C293....     CMP.B   #0x0, &macTxActive
   \   000022   0220         JNE     ??macRadioSetChannel_1
    380            {
    381              macRadioUpdateChannel();
   \   000024   ........     CALLA   #macRadioUpdateChannel
    382            }
    383          
    384            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macRadioSetChannel_1:
   \   000028   024B         MOV.W   R11, SR
    385          }
   \   00002A   1A17         POPM.W  #0x2, R11
   \   00002C   1001         RETA
    386          
    387          
    388          /**************************************************************************************************
    389           * @fn          macRadioUpdateChannel
    390           *
    391           * @brief       Update the radio channel if a new channel has been requested.
    392           *
    393           * @param       none
    394           *
    395           * @return      none
    396           **************************************************************************************************
    397           */

   \                                 In  segment CODE, align 2, keep-with-next
    398          MAC_INTERNAL_API void macRadioUpdateChannel(void)
   \                     macRadioUpdateChannel:
    399          {
    400            halIntState_t  s;
    401          
    402            MAC_ASSERT(!macTxActive); /* cannot change channel during a transmit */
   \   000000   C293....     CMP.B   #0x0, &macTxActive
   \   000004   0224         JEQ     ??macRadioUpdateChannel_0
   \   000006   ........     CALLA   #halAssertHandler
    403          
    404            /* if the channel has changed, set the radio to the new channel */
    405            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macRadioUpdateChannel_0:
   \   00000A   0F42         MOV.W   SR, R15
   \   00000C   32C2         dint
   \   00000E   0343         nop
    406            if (reqChannel != macPhyChannel)
   \   000010   5E42....     MOV.B   &reqChannel, R14
   \   000014   5E92....     CMP.B   &macPhyChannel, R14
   \   000018   1324         JEQ     ??macRadioUpdateChannel_1
    407            {
    408              macPhyChannel = reqChannel;
   \   00001A   C24E....     MOV.B   R14, &macPhyChannel
    409              HAL_EXIT_CRITICAL_SECTION(s);
   \   00001E   024F         MOV.W   R15, SR
    410          
    411              /* changing the channel stops any receive in progress */
    412              macRxOff();
   \   000020   ........     CALLA   #macRxOff
    413              MAC_RADIO_SET_CHANNEL(macPhyChannel);
   \   000024   5E42....     MOV.B   &macPhyChannel, R14
   \   000028   7D40D400     MOV.B   #0xd4, R13
   \   00002C                RPT     #0x5
   \   00002C   44184D5E     ADDX.B  R14, R13
   \   000030   7C402E00     MOV.B   #0x2e, R12
   \   000034   ........     CALLA   #macSpiWriteReg
    414          
    415              /* If the channel is updated in the middle of receiving a frame, we must
    416               * clean up the Rx logic.
    417               */
    418              macRxHaltCleanup();
   \   000038   ........     CALLA   #macRxHaltCleanup
    419          
    420              macRxOnRequest();
   \   00003C   ........     BRA     #macRxOnRequest
    421            }
    422            else
    423            {
    424              HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macRadioUpdateChannel_1:
   \   000040   024F         MOV.W   R15, SR
    425            }
    426          }
   \   000042   1001         RETA
    427          
    428          
    429          /**************************************************************************************************
    430           * @fn          macRadioStartScan
    431           *
    432           * @brief       Puts radio into selected scan mode.
    433           *
    434           * @param       scanMode - scan mode, see #defines in .h file
    435           *
    436           * @return      none
    437           **************************************************************************************************
    438           */

   \                                 In  segment CODE, align 2, keep-with-next
    439          MAC_INTERNAL_API void macRadioStartScan(uint8 scanMode)
   \                     macRadioStartScan:
    440          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
    441            MAC_ASSERT(macSleepState == MAC_SLEEP_STATE_AWAKE); /* radio must be awake */
   \   000004   C293....     CMP.B   #0x0, &macSleepState
   \   000008   0224         JEQ     ??macRadioStartScan_0
   \   00000A   ........     CALLA   #halAssertHandler
    442            MAC_ASSERT(macRxFilter == RX_FILTER_OFF); /* all filtering must be off to start scan */
   \                     ??macRadioStartScan_0:
   \   00000E   C293....     CMP.B   #0x0, &macRxFilter
   \   000012   0224         JEQ     ??macRadioStartScan_1
   \   000014   ........     CALLA   #halAssertHandler
    443          
    444            /* set the receive filter based on the selected scan mode */
    445            if (scanMode == MAC_SCAN_ED)
   \                     ??macRadioStartScan_1:
   \   000018   4A93         CMP.B   #0x0, R10
   \   00001A   0320         JNE     ??macRadioStartScan_2
    446            {
    447              macRxFilter = RX_FILTER_ALL;
   \   00001C   D243....     MOV.B   #0x1, &macRxFilter
   \   000020   143C         JMP     ??macRadioStartScan_3
    448            }
    449            else if (scanMode == MAC_SCAN_ORPHAN)
   \                     ??macRadioStartScan_2:
   \   000022   7A900300     CMP.B   #0x3, R10
   \   000026   0420         JNE     ??macRadioStartScan_4
    450            {
    451              macRxFilter = RX_FILTER_NON_COMMAND_FRAMES;
   \   000028   F2400300.... MOV.B   #0x3, &macRxFilter
   \   00002E   0D3C         JMP     ??macRadioStartScan_3
    452            }
    453            else
    454            {
    455              MAC_ASSERT((scanMode == MAC_SCAN_ACTIVE) || (scanMode == MAC_SCAN_PASSIVE)); /* invalid scan type */
   \                     ??macRadioStartScan_4:
   \   000030   5A93         CMP.B   #0x1, R10
   \   000032   0424         JEQ     ??macRadioStartScan_5
   \   000034   6A93         CMP.B   #0x2, R10
   \   000036   0224         JEQ     ??macRadioStartScan_5
   \   000038   ........     CALLA   #halAssertHandler
    456              macRxFilter = RX_FILTER_NON_BEACON_FRAMES;
   \                     ??macRadioStartScan_5:
   \   00003C   E243....     MOV.B   #0x2, &macRxFilter
    457          
    458              /* for active and passive scans, per spec the pan ID must be 0xFFFF */
    459              MAC_RADIO_SET_PAN_ID(0xFFFF);
   \   000040   3D43         MOV.W   #0xffff, R13
   \   000042   3C40F203     MOV.W   #0x3f2, R12
   \   000046   ........     CALLA   #macSpiWriteRamUint16
    460            }
    461          }
   \                     ??macRadioStartScan_3:
   \   00004A   3A41         POP.W   R10
   \   00004C   1001         RETA
    462          
    463          
    464          /**************************************************************************************************
    465           * @fn          macRadioStopScan
    466           *
    467           * @brief       Takes radio out of scan mode.  Note can be called if
    468           *
    469           * @param       none
    470           *
    471           * @return      none
    472           **************************************************************************************************
    473           */

   \                                 In  segment CODE, align 2, keep-with-next
    474          MAC_INTERNAL_API void macRadioStopScan(void)
   \                     macRadioStopScan:
    475          {
    476            macRxFilter = RX_FILTER_OFF;
   \   000000   C243....     MOV.B   #0x0, &macRxFilter
    477          
    478            /* restore the pan ID (passive and active scans set pan ID to 0xFFFF) */
    479            MAC_RADIO_SET_PAN_ID(macPib.panId);
   \   000004   1D42....     MOV.W   &macPib + 32, R13
   \   000008                REQUIRE ?Subroutine0
   \   000008                // Fall through to label ?Subroutine0
    480          }
    481          
    482          
    483          /**************************************************************************************************
    484           * @fn          macRadioEnergyDetectStart
    485           *
    486           * @brief       Initiates energy detect.  The highest energy detected is recorded from the time
    487           *              when this function is called until the energy detect is stopped.
    488           *
    489           * @param       none
    490           *
    491           * @return      none
    492           **************************************************************************************************
    493           */

   \                                 In  segment CODE, align 2
    494          void macRadioEnergyDetectStart(void)
   \                     macRadioEnergyDetectStart:
    495          {
    496            /* Energy Detection Scan should be run with CC2591 compresson workaround off */
    497            COMPRESSION_WORKAROUND_OFF();
    498          
    499            MAC_RADIO_RECORD_MAX_RSSI_START();
   \   000000   ........     BRA     #macDualchipRecordMaxRssiStart
    500          }
    501          
    502          
    503          /**************************************************************************************************
    504           * @fn          macRadioEnergyDetectStop
    505           *
    506           * @brief       Called at completion of an energy detect.  Note: can be called even if energy
    507           *              detect is already stopped (needed by reset).
    508           *
    509           * @param       none
    510           *
    511           * @return      highest energy detect measurement
    512           **************************************************************************************************
    513           */

   \                                 In  segment CODE, align 2
    514          uint8 macRadioEnergyDetectStop(void)
   \                     macRadioEnergyDetectStop:
    515          {
    516            uint8 rssiDbm;
    517            uint8 energyDetectMeasurement;
    518          
    519            rssiDbm = MAC_RADIO_RECORD_MAX_RSSI_STOP() + MAC_RADIO_RSSI_OFFSET;
   \   000000   ........     CALLA   #macDualchipRecordMaxRssiStop
    520            MAC_RADIO_RSSI_LNA_OFFSET(rssiDbm);
    521            energyDetectMeasurement = radioComputeED(rssiDbm);
    522          
    523            /* Trun on CC2591 compresson workaround */
    524            COMPRESSION_WORKAROUND_ON();
    525          
    526            return(energyDetectMeasurement);
   \   000004   7C50B400     ADD.B   #0xb4, R12
   \   000008   ........     BRA     #radioComputeED
    527          }
    528          
    529          /*=================================================================================================
    530           * @fn          radioComputeED
    531           *
    532           * @brief       Compute energy detect measurement.
    533           *
    534           * @param       rssi - raw RSSI value from radio hardware
    535           *
    536           * @return      energy detect measurement in the range of 0x00-0xFF
    537           *=================================================================================================
    538           */

   \                                 In  segment CODE, align 2
    539          static uint8 radioComputeED(int8 rssiDbm)
   \                     radioComputeED:
    540          {
    541            uint8 ed;
    542          
    543            /*
    544             *  Keep RF power between minimum and maximum values.
    545             *  This min/max range is derived from datasheet and specification.
    546             */
    547            if (rssiDbm < ED_RF_POWER_MIN_DBM)
   \   000000   7C90A800     CMP.B   #0xa8, R12
   \   000004   0334         JGE     ??radioComputeED_0
    548            {
    549              rssiDbm = ED_RF_POWER_MIN_DBM;
   \   000006   7C40A800     MOV.B   #0xa8, R12
   \   00000A   053C         JMP     ??radioComputeED_1
    550            }
    551            else if (rssiDbm > ED_RF_POWER_MAX_DBM)
   \                     ??radioComputeED_0:
   \   00000C   7C900700     CMP.B   #0x7, R12
   \   000010   0238         JL      ??radioComputeED_1
    552            {
    553              rssiDbm = ED_RF_POWER_MAX_DBM;
   \   000012   7C400600     MOV.B   #0x6, R12
    554            }
    555          
    556            /*
    557             *  Create energy detect measurement by normalizing and scaling RF power level.
    558             *
    559             *  Note : The division operation below is designed for maximum accuracy and
    560             *         best granularity.  This is done by grouping the math operations to
    561             *         compute the entire numerator before doing any division.
    562             */
    563            ed = (MAC_SPEC_ED_MAX * (rssiDbm - ED_RF_POWER_MIN_DBM)) / (ED_RF_POWER_MAX_DBM - ED_RF_POWER_MIN_DBM);
    564          
    565            return(ed);
   \                     ??radioComputeED_1:
   \   000016   8C11         SXT     R12
   \   000018   3C505800     ADD.W   #0x58, R12
   \   00001C   0212         PUSH.W  SR
   \   00001E   32C2         DINT
   \   000020   0343         NOP
   \   000022   824C3001     MOV.W   R12, &0x130
   \   000026   B240FF003801 MOV.W   #0xff, &0x138
   \   00002C   1C423A01     MOV.W   &0x13a, R12
   \   000030   3241         POP.W   SR
   \   000032   3E405E00     MOV.W   #0x5e, R14
   \   000036   ........     BRA     #?DivMod16s
    566          }
    567          
    568          
    569          /**************************************************************************************************
    570           * @fn          macRadioComputeLQI
    571           *
    572           * @brief       Compute link quality indication.
    573           *
    574           * @param       rssi - raw RSSI value from radio hardware
    575           *              corr - correlation value from radio hardware
    576           *
    577           * @return      link quality indicator value
    578           **************************************************************************************************
    579           */

   \                                 In  segment CODE, align 2
    580          MAC_INTERNAL_API uint8 macRadioComputeLQI(int8 rssiDbm, uint8 corr)
   \                     macRadioComputeLQI:
    581          {
    582            (void) corr; /* suppress compiler warning of unused parameter */
    583          
    584            /*
    585             *  Note : Currently the LQI value is simply the energy detect measurement.
    586             *         A more accurate value could be derived by using the correlation
    587             *         value along with the RSSI value.
    588             */
    589            return(radioComputeED(rssiDbm));
   \   000000   ........     BRA     #radioComputeED
    590          }
    591          
    592          
    593          /**************************************************************************************************
    594          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   macRadioComputeLQI
        4   -> radioComputeED
      4   macRadioEnergyDetectStart
        4   -> macDualchipRecordMaxRssiStart
      4   macRadioEnergyDetectStop
        4   -> macDualchipRecordMaxRssiStop
        4   -> radioComputeED
      4   macRadioInit
      4   macRadioRandomByte
        4   -> macDualchipRandomByte
      4   macRadioReset
        4   -> macRadioEnergyDetectStop
        4   -> macRadioStopScan
      8   macRadioSetChannel
        8   -> halAssertHandler
        8   -> macRadioUpdateChannel
      4   macRadioSetIEEEAddr
        4   -> macSpiWriteRam
      4   macRadioSetPanCoordinator
        4   -> macDualchipAndFRMFILT0
        4   -> macDualchipOrFRMFILT0
      4   macRadioSetPanID
        4   -> macSpiWriteRamUint16
      4   macRadioSetShortAddr
        4   -> macSpiWriteRamUint16
      6   macRadioSetTxPower
        6   -> macRadioUpdateTxPower
      6   macRadioStartScan
        6   -> halAssertHandler
        6   -> macSpiWriteRamUint16
      4   macRadioStopScan
        4   -> macSpiWriteRamUint16
      4   macRadioUpdateChannel
        4   -> halAssertHandler
        4   -> macRxHaltCleanup
        4   -> macRxOff
        4   -> macRxOnRequest
        4   -> macSpiWriteReg
      6   macRadioUpdateTxPower
        6   -> macSpiWriteReg
      6   radioComputeED


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?Subroutine0
       1  macPhyChannel
       1  macPhyTxPower
       4  macRadioComputeLQI
       4  macRadioEnergyDetectStart
      12  macRadioEnergyDetectStop
      20  macRadioInit
       4  macRadioRandomByte
       8  macRadioReset
      46  macRadioSetChannel
      12  macRadioSetIEEEAddr
      18  macRadioSetPanCoordinator
       4  macRadioSetPanID
      10  macRadioSetShortAddr
      54  macRadioSetTxPower
      78  macRadioStartScan
       8  macRadioStopScan
      68  macRadioUpdateChannel
      48  macRadioUpdateTxPower
      58  radioComputeED
       1  reqChannel
       1  reqTxPower

 
 464 bytes in segment CODE
   4 bytes in segment DATA16_Z
 
 464 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none

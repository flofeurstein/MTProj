///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430      10/Jun/2013  17:10:45 /
// Copyright 1996-2013 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\m /
//                     ac\low_level\srf04\dual_chip\mac_spi.c                 /
//    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\..\ /
//                     Tools\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0   /
//                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                      /
//                     -DDEFAULT_CHANLIST=0x00000800                          /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100     /
//                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                  /
//                     -DBEACON_REQUEST_DELAY=100                             /
//                     -DBEACON_REQ_DELAY_MASK=0x00FF                         /
//                     -DLINK_STATUS_JITTER_MASK=0x007F                       /
//                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED /
//                     =3000 -DNWK_INDIRECT_MSG_TIMEOUT=7                     /
//                     -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3        /
//                     -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2  /
//                     -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16                      /
//                     -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4       /
//                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,      /
//                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,  /
//                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                   /
//                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS= /
//                     20 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000         /
//                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100        /
//                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618 /
//                     \f8wEndev.cfg" (-DCPU6MHZ -DMAC_CFG_TX_DATA_MAX=3      /
//                     -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "C:\Texas    /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618 /
//                     \f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC       /
//                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH        /
//                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4         /
//                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10        /
//                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10       /
//                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING               /
//                     -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING            /
//                     -DZCL_TOU) -DZCL_DEVICE_MGMT "C:\Texas                 /
//                     Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_le /
//                     vel\srf04\dual_chip\mac_spi.c" -D MSP430F2618 -D       /
//                     NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC    /
//                     -D MT_ZDO_FUNC -D LCD_SUPPORTED -lC "C:\Texas          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\EndDevice\List\" -lA   /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\Li /
//                     st\" --remarks --diag_suppress                         /
//                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\EndDevice\Obj\"        /
//                     --debug -D__MSP430F2618__ -e --double=32 --clib -I     /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleSwitch\CC2520DB\" -I         /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleSwitch\CC2520DB\..\Source\"  /
//                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\Sou /
//                     rce\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pr /
//                     ojects\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\ /
//                     ..\..\ZMain\MSP2618\" -I "C:\Texas                     /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\hal\include\" -I "C:\Texas                         /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\hal\target\MSP2618CC2520\" -I "C:\Texas            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\mac\include\" -I "C:\Texas                         /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\mac\high_level\" -I "C:\Texas                      /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\mac\low_level\srf04\" -I "C:\Texas                 /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\mac\low_level\srf04\dual_chip\" -I "C:\Texas       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1 /
//                     \Projects\zstack\HomeAutomation\SampleSwitch\CC2520DB\ /
//                     ..\..\..\..\..\Components\osal\include\" -I "C:\Texas  /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\osal\mcu\msp430\" -I "C:\Texas                     /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\services\saddr\" -I "C:\Texas                      /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\services\sdata\" -I "C:\Texas                      /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\af\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\nwk\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\sec\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\sapi\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\sys\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\zcl\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\zdo\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5 /
//                     .1\Projects\zstack\HomeAutomation\SampleSwitch\CC2520D /
//                     B\..\..\..\..\..\Components\zmac\f8w\" --core=430X     /
//                     --data_model=small -Ohz --multiplier=16s               /
//                     --require_prototypes                                   /
//    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst /
//                     ack\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\Lis /
//                     t\mac_spi.s43                                          /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME mac_spi

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBWEAK P5OUT
        PUBWEAK UC1IFG
        PUBWEAK UCB1BR0
        PUBWEAK UCB1BR1
        PUBWEAK UCB1CTL0
        PUBWEAK UCB1CTL1
        PUBWEAK UCB1RXBUF
        PUBWEAK UCB1TXBUF
        PUBLIC macSpiCmdStrobe
        FUNCTION macSpiCmdStrobe,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC macSpiInit
        FUNCTION macSpiInit,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macSpiRadioPower
        PUBLIC macSpiRandomByte
        FUNCTION macSpiRandomByte,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC macSpiReadRam
        FUNCTION macSpiReadRam,0a1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC macSpiReadReg
        FUNCTION macSpiReadReg,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC macSpiReadRxFifo
        FUNCTION macSpiReadRxFifo,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC macSpiSendECBO
        FUNCTION macSpiSendECBO,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 16, STACK
        PUBLIC macSpiWriteRam
        FUNCTION macSpiWriteRam,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC macSpiWriteRamUint16
        FUNCTION macSpiWriteRamUint16,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC macSpiWriteReg
        FUNCTION macSpiWriteReg,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC macSpiWriteTxFifo
        FUNCTION macSpiWriteTxFifo,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION spiFifoAccess,0a1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        FUNCTION spiSendBytes,0a1203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        FUNCTION spiWriteRamByte,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        EXTERN halAssertHandler
        FUNCTION halAssertHandler,0202H

// C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_level\srf04\dual_chip\mac_spi.c
//    1 /**************************************************************************************************
//    2   Filename:       mac_spi.c
//    3   Revised:        $Date: 2007-05-02 13:41:12 -0700 (Wed, 02 May 2007) $
//    4   Revision:       $Revision: 14174 $
//    5 
//    6   Description:    Describe the purpose and contents of the file.
//    7 
//    8 
//    9   Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /* ------------------------------------------------------------------------------------------------
//   41  *                                          Includes
//   42  * ------------------------------------------------------------------------------------------------
//   43  */
//   44 
//   45 /* hal */
//   46 #include "hal_types.h"
//   47 #include "hal_mac_cfg.h"

        ASEGN DATA16_AN:DATA:NOROOT,07H
// unsigned char volatile UC1IFG
UC1IFG:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,031H
// unsigned char volatile P5OUT
P5OUT:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0d8H
// unsigned char volatile UCB1CTL0
UCB1CTL0:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0d9H
// unsigned char volatile UCB1CTL1
UCB1CTL1:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0daH
// unsigned char volatile UCB1BR0
UCB1BR0:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0dbH
// unsigned char volatile UCB1BR1
UCB1BR1:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0deH
// unsigned char const volatile UCB1RXBUF
UCB1RXBUF:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,0dfH
// unsigned char volatile UCB1TXBUF
UCB1TXBUF:
        DS8 1
//   48 
//   49 /* low-level specific */
//   50 #include "mac_spi.h"
//   51 
//   52 /* SPI registers */
//   53 #include "mac_radio_defs.h"
//   54 
//   55 /* debug */
//   56 #include "mac_assert.h"
//   57 
//   58 
//   59 /* ------------------------------------------------------------------------------------------------
//   60  *                                            Defines
//   61  * ------------------------------------------------------------------------------------------------
//   62  */
//   63 #define SPI_ACCESS_BUF_LEN          3
//   64 
//   65 #define NUM_BYTES_STROBE_CMD        1
//   66 #define NUM_BYTES_REG_ACCESS        2
//   67 #define NUM_BYTES_MEM_ACCESS        3
//   68 #define NUM_BYTES_RANDOM            3
//   69 
//   70 #define FIFO_ACCESS_TX_WRITE        0
//   71 #define FIFO_ACCESS_RX_READ         1
//   72 
//   73 
//   74 /* ------------------------------------------------------------------------------------------------
//   75  *                                         Global Variables
//   76  * ------------------------------------------------------------------------------------------------
//   77  */

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//   78 MAC_ASSERT_DECLARATION( uint8 macSpiRadioPower; )
macSpiRadioPower:
        DS8 1
//   79 
//   80 
//   81 /* ------------------------------------------------------------------------------------------------
//   82  *                                       Local Prototypes
//   83  * ------------------------------------------------------------------------------------------------
//   84  */
//   85 static void spiFifoAccess(uint8 * pData, uint8 len, uint8 writeFlag);
//   86 static uint8 spiSendBytes(uint8 * pBytes, uint8 numBytes);
//   87 static void spiWriteRamByte(uint16 ramAddr, uint8 byte);
//   88 
//   89 
//   90 /**************************************************************************************************
//   91  * @fn          macSpiInit
//   92  *
//   93  * @brief       Initialize SPI.
//   94  *
//   95  * @param       none
//   96  *
//   97  * @return      none
//   98  **************************************************************************************************
//   99  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  100 void macSpiInit(void)
macSpiInit:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function macSpiInit
//  101 {
//  102   HAL_MAC_SPI_SET_CHIP_SELECT_OFF();
        BIS.B   #0x1, &0x31
//  103   HAL_MAC_SPI_INIT();
        MOV.B   #0x81, &0xd9
        MOV.B   #0xa9, &0xd8
        MOV.B   #0x0, &0xda
        MOV.B   #0x0, &0xdb
        BIC.B   #0x1, &0xd9
//  104 }
        RETA
          CFI EndBlock cfiBlock0
        REQUIRE P5OUT
        REQUIRE UCB1CTL1
        REQUIRE UCB1CTL0
        REQUIRE UCB1BR0
        REQUIRE UCB1BR1

        RSEG CODE:CODE:NOROOT(1)
macSpiRandomByte:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function macSpiRandomByte
        FUNCALL macSpiRandomByte, spiSendBytes
        LOCFRAME CSTACK, 8, STACK
        SUB.W   #0x4, SP
          CFI CFA SP+8
        MOV.B   #0x3c, 0(SP)
        MOV.B   #0x3, R13
        JMP     ?Subroutine0
          CFI EndBlock cfiBlock1

        RSEG CODE:CODE:NOROOT(1)
spiFifoAccess:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function spiFifoAccess
        FUNCALL spiFifoAccess, halAssertHandler
        LOCFRAME CSTACK, 12, STACK
        FUNCALL spiFifoAccess, halAssertHandler
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R8
        MOV.B   R13, R10
        MOV.B   R14, R11
        BIT.B   #0x2, &macSpiRadioPower
        JC      ??spiFifoAccess_6
        CALLA   #halAssertHandler
??spiFifoAccess_6:
        CMP.B   #0x0, R10
        JNE     ??spiFifoAccess_7
        CALLA   #halAssertHandler
??spiFifoAccess_7:
        MOV.W   SR, R15
        dint
        nop
        CALLA   #?Subroutine2
??spiFifoAccess_2:
        CMP.B   #0x0, R11
        BIC.B   #0x4, &0x7
        JNE     ??spiFifoAccess_8
        MOV.B   #0x3a, &0xdf
        JMP     ??spiFifoAccess_0
??spiFifoAccess_8:
        MOV.B   #0x30, &0xdf
??spiFifoAccess_0:
        CALLA   #?Subroutine3
??spiFifoAccess_3:
        BIC.B   #0x4, &0x7
        MOV.B   @R8, &0xdf
        ADD.B   #0xff, R10
        CALLA   #?Subroutine3
??CrossCallReturnLabel_4:
        CMP.B   #0x0, R11
        JEQ     ??spiFifoAccess_9
        MOV.B   &0xde, 0(R8)
??spiFifoAccess_9:
        MOV.W   R15, SR
        ADD.W   #0x1, R8
        MOV.W   SR, R15
        dint
        nop
        BIT.B   #0x1, &0x31
        JNC     ??spiFifoAccess_10
        BIC.B   #0x1, &0x31
        CMP.B   #0x0, R10
        JNE     ??spiFifoAccess_2
        JMP     ??spiFifoAccess_11
??spiFifoAccess_10:
        CMP.B   #0x0, R10
        JNE     ??spiFifoAccess_3
??spiFifoAccess_11:
        BIS.B   #0x1, &0x31
        MOV.W   R15, SR
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
        REQUIRE P5OUT
        REQUIRE UC1IFG
        REQUIRE UCB1TXBUF
        REQUIRE UCB1RXBUF

        RSEG CODE:CODE:NOROOT(1)
macSpiReadRxFifo:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function macSpiReadRxFifo
        FUNCALL macSpiReadRxFifo, spiFifoAccess
        LOCFRAME CSTACK, 4, STACK
        MOV.B   #0x1, R14
        BRA     #spiFifoAccess
          CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(1)
macSpiWriteTxFifo:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function macSpiWriteTxFifo
        FUNCALL macSpiWriteTxFifo, spiFifoAccess
        LOCFRAME CSTACK, 4, STACK
        MOV.B   #0x0, R14
        BRA     #spiFifoAccess
          CFI EndBlock cfiBlock4

        RSEG CODE:CODE:NOROOT(1)
macSpiReadRam:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function macSpiReadRam
        FUNCALL macSpiReadRam, halAssertHandler
        LOCFRAME CSTACK, 12, STACK
        FUNCALL macSpiReadRam, halAssertHandler
        LOCFRAME CSTACK, 12, STACK
        FUNCALL macSpiReadRam, halAssertHandler
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R11
        MOV.W   R13, R8
        MOV.B   R14, R10
        CMP.W   #0x1000, R12
        JNC     ??macSpiReadRam_7
        CALLA   #halAssertHandler
??macSpiReadRam_7:
        CMP.W   #0x0, R8
        JNE     ??macSpiReadRam_8
        CALLA   #halAssertHandler
??macSpiReadRam_8:
        BIT.B   #0x1, &macSpiRadioPower
        JC      ??macSpiReadRam_9
        CALLA   #halAssertHandler
??macSpiReadRam_9:
        MOV.W   SR, R14
        dint
        nop
        CALLA   #?Subroutine2
??CrossCallReturnLabel_3:
        BIC.B   #0x4, &0x7
        MOV.W   R11, R15
        RPT     #0x8
        RRUX.W  R15
        BIS.B   #0x10, R15
        MOV.B   R15, &0xdf
        CALLA   #?Subroutine3
??CrossCallReturnLabel_5:
        BIC.B   #0x4, &0x7
        MOV.B   R11, &0xdf
        CALLA   #?Subroutine3
??CrossCallReturnLabel_6:
        MOV.B   #0x0, R15
        JMP     ??macSpiReadRam_10
??macSpiReadRam_3:
        BIC.B   #0x4, &0x7
        MOV.B   #0x0, &0xdf
        CALLA   #?Subroutine3
??CrossCallReturnLabel_7:
        MOV.B   &0xde, 0(R8)
        ADD.W   #0x1, R8
        ADD.B   #0x1, R15
??macSpiReadRam_10:
        CMP.B   R10, R15
        JNC     ??macSpiReadRam_3
        BIS.B   #0x1, &0x31
        MOV.W   R14, SR
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock5
        REQUIRE P5OUT
        REQUIRE UC1IFG
        REQUIRE UCB1TXBUF
        REQUIRE UCB1RXBUF

        RSEG CODE:CODE:NOROOT(1)
?Subroutine3:
          CFI Block cfiCond6 Using cfiCommon0
          CFI Function spiFifoAccess
          CFI Conditional ??spiFifoAccess_3
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
          CFI Block cfiCond7 Using cfiCommon0
          CFI (cfiCond7) Function spiFifoAccess
          CFI (cfiCond7) Conditional ??CrossCallReturnLabel_4
          CFI (cfiCond7) R8L Frame(CFA, -12)
          CFI (cfiCond7) R9L Frame(CFA, -10)
          CFI (cfiCond7) R10L Frame(CFA, -8)
          CFI (cfiCond7) R11L Frame(CFA, -6)
          CFI (cfiCond7) CFA SP+16
          CFI Block cfiCond8 Using cfiCommon0
          CFI (cfiCond8) Function macSpiReadRam
          CFI (cfiCond8) Conditional ??CrossCallReturnLabel_5
          CFI (cfiCond8) R8L Frame(CFA, -12)
          CFI (cfiCond8) R9L Frame(CFA, -10)
          CFI (cfiCond8) R10L Frame(CFA, -8)
          CFI (cfiCond8) R11L Frame(CFA, -6)
          CFI (cfiCond8) CFA SP+16
          CFI Block cfiCond9 Using cfiCommon0
          CFI (cfiCond9) Function macSpiReadRam
          CFI (cfiCond9) Conditional ??CrossCallReturnLabel_6
          CFI (cfiCond9) R8L Frame(CFA, -12)
          CFI (cfiCond9) R9L Frame(CFA, -10)
          CFI (cfiCond9) R10L Frame(CFA, -8)
          CFI (cfiCond9) R11L Frame(CFA, -6)
          CFI (cfiCond9) CFA SP+16
          CFI Block cfiCond10 Using cfiCommon0
          CFI (cfiCond10) Function macSpiReadRam
          CFI (cfiCond10) Conditional ??CrossCallReturnLabel_7
          CFI (cfiCond10) R8L Frame(CFA, -12)
          CFI (cfiCond10) R9L Frame(CFA, -10)
          CFI (cfiCond10) R10L Frame(CFA, -8)
          CFI (cfiCond10) R11L Frame(CFA, -6)
          CFI (cfiCond10) CFA SP+16
          CFI Block cfiPicker11 Using cfiCommon1
          CFI (cfiPicker11) NoFunction
          CFI (cfiPicker11) Picker
        BIT.B   #0x4, &0x7
        JNC     ?Subroutine3
        RETA
          CFI EndBlock cfiCond6
          CFI EndBlock cfiCond7
          CFI EndBlock cfiCond8
          CFI EndBlock cfiCond9
          CFI EndBlock cfiCond10
          CFI EndBlock cfiPicker11
//  105 
//  106 
//  107 /**************************************************************************************************
//  108  * @fn          macSpiCmdStrobe
//  109  *
//  110  * @brief       Send command strobe to the radio.  Returns status byte read during transfer
//  111  *              of strobe command.
//  112  *
//  113  * @param       opCode - op code of the strobe command
//  114  *
//  115  * @return      status byte of radio
//  116  **************************************************************************************************
//  117  */
//  118 uint8 macSpiCmdStrobe(uint8 opCode)
//  119 {
//  120   uint8 buf[SPI_ACCESS_BUF_LEN];
//  121 
//  122   /* set first byte of array as op code */
//  123   buf[0] = opCode;
//  124 
//  125   /* send strobe command and pass up return value */
//  126   return( spiSendBytes(&buf[0], NUM_BYTES_STROBE_CMD) );
//  127 }
//  128 
//  129 
//  130 /**************************************************************************************************
//  131  * @fn          macSpiReadReg
//  132  *
//  133  * @brief       Read value from radio regiser.
//  134  *
//  135  * @param       regAddr - address of register
//  136  *
//  137  * @return      register value
//  138  **************************************************************************************************
//  139  */
//  140 uint8 macSpiReadReg(uint8 regAddr)
//  141 {
//  142   uint8 buf[SPI_ACCESS_BUF_LEN];
//  143   uint8 len;
//  144 
//  145   /* fast register access is available for registers in first 0x40 bytes */
//  146   if (regAddr <= 0x3F)
//  147   {
//  148     /* set up a register read command */
//  149     buf[0] = REGRD | regAddr;
//  150     len = NUM_BYTES_REG_ACCESS;
//  151   }
//  152   else
//  153   {
//  154     /* set up a memory read command, note memory above 0xFF not accessible via this function */
//  155     buf[0] = MEMRD;
//  156     buf[1] = regAddr;
//  157     len = NUM_BYTES_MEM_ACCESS;
//  158   }
//  159 
//  160   /* send read command and pass up return value */
//  161   return( spiSendBytes(&buf[0], len) );
//  162 }
//  163 
//  164 
//  165 /**************************************************************************************************
//  166  * @fn          macSpiWriteReg
//  167  *
//  168  * @brief       Write value to radio register.
//  169  *
//  170  * @param       regAddr  - address of register
//  171  * @param       regValue - register value to write
//  172  *
//  173  * @return      none
//  174  **************************************************************************************************
//  175  */
//  176 void macSpiWriteReg(uint8 regAddr, uint8 regValue)
//  177 {
//  178   uint8 buf[SPI_ACCESS_BUF_LEN];
//  179   uint8 len;
//  180 
//  181   /* fast register access is available for registers in first 0x40 bytes */
//  182   if (regAddr <= 0x3F)
//  183   {
//  184     /* set up a register write command */
//  185     buf[0] = REGWR | regAddr;
//  186     buf[1] = regValue;
//  187     len = NUM_BYTES_REG_ACCESS;
//  188   }
//  189   else
//  190   {
//  191     /* set up a memory write command, note memory above 0xFF not accessible via this function */
//  192     buf[0] = MEMWR;
//  193     buf[1] = regAddr;
//  194     buf[2] = regValue;
//  195     len = NUM_BYTES_MEM_ACCESS;
//  196   }
//  197 
//  198   /* send write command */
//  199   spiSendBytes(&buf[0], len);
//  200 }
//  201 
//  202 
//  203 /*=================================================================================================
//  204  * @fn          spiSendBytes
//  205  *
//  206  * @brief       Primitive for sending byte via SPI.  Returns SPI transferred during sending
//  207  *              of last byte.
//  208  *
//  209  * @param       pSendBytes   - pointer to bytes to send over SPI
//  210  * @param       numSendBytes - number of bytes to send
//  211  *
//  212  * @return      byte read from SPI after last byte sent
//  213  *=================================================================================================
//  214  */

        RSEG CODE:CODE:NOROOT(1)
?Subroutine2:
          CFI Block cfiCond12 Using cfiCommon0
          CFI Function spiFifoAccess
          CFI Conditional ??spiFifoAccess_2
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
          CFI Block cfiCond13 Using cfiCommon0
          CFI (cfiCond13) Function macSpiReadRam
          CFI (cfiCond13) Conditional ??CrossCallReturnLabel_3
          CFI (cfiCond13) R8L Frame(CFA, -12)
          CFI (cfiCond13) R9L Frame(CFA, -10)
          CFI (cfiCond13) R10L Frame(CFA, -8)
          CFI (cfiCond13) R11L Frame(CFA, -6)
          CFI (cfiCond13) CFA SP+16
          CFI Block cfiCond14 Using cfiCommon0
          CFI (cfiCond14) Function spiSendBytes
          CFI (cfiCond14) Conditional ??spiSendBytes_0
          CFI (cfiCond14) R10L Frame(CFA, -8)
          CFI (cfiCond14) R11L Frame(CFA, -6)
          CFI (cfiCond14) CFA SP+12
          CFI Block cfiPicker15 Using cfiCommon1
          CFI (cfiPicker15) NoFunction
          CFI (cfiPicker15) Picker
//  215 static uint8 spiSendBytes(uint8 * pBytes, uint8 numBytes)
//  216 {
//  217   halMacSpiIntState_t s;
//  218   uint8 returnValue;
//  219 
//  220   MAC_ASSERT(macSpiRadioPower & MAC_SPI_RADIO_POWER_VREG_ON);  /* radio must be powered */
//  221 
//  222   /*-------------------------------------------------------------------------------
//  223    *  Disable interrupts that call SPI functions.
//  224    */
//  225   HAL_MAC_SPI_ENTER_CRITICAL_SECTION(s);
//  226 
//  227   /*-------------------------------------------------------------------------------
//  228    *  Turn chip select "off" and then "on" to clear any current SPI access.
//  229    */
//  230   HAL_MAC_SPI_SET_CHIP_SELECT_OFF();
        BIS.B   #0x1, &0x31
//  231   HAL_MAC_SPI_SET_CHIP_SELECT_ON();
        BIC.B   #0x1, &0x31
        RETA
          CFI EndBlock cfiCond12
          CFI EndBlock cfiCond13
          CFI EndBlock cfiCond14
          CFI EndBlock cfiPicker15

        RSEG CODE:CODE:NOROOT(1)
spiWriteRamByte:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function spiWriteRamByte
        FUNCALL spiWriteRamByte, halAssertHandler
        LOCFRAME CSTACK, 12, STACK
        FUNCALL spiWriteRamByte, spiSendBytes
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        SUB.W   #0x4, SP
          CFI CFA SP+12
        MOV.W   R12, R11
        MOV.B   R13, R10
        CMP.W   #0x1000, R12
        JNC     ??spiWriteRamByte_0
        CALLA   #halAssertHandler
??spiWriteRamByte_0:
        MOV.W   R11, R15
        RPT     #0x8
        RRUX.W  R15
        BIS.B   #0x20, R15
        MOV.B   R15, 0(SP)
        MOV.B   R11, 0x1(SP)
        MOV.B   R10, 0x2(SP)
        MOV.B   #0x3, R13
        CALLA   #?Subroutine1
??CrossCallReturnLabel_1:
        ADD.W   #0x4, SP
          CFI CFA SP+8
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock16

        RSEG CODE:CODE:NOROOT(1)
?Subroutine1:
          CFI Block cfiCond17 Using cfiCommon0
          CFI Function macSpiSendECBO
          CFI Conditional ??CrossCallReturnLabel_2
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
          CFI Block cfiCond18 Using cfiCommon0
          CFI (cfiCond18) Function spiWriteRamByte
          CFI (cfiCond18) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond18) R10L Frame(CFA, -8)
          CFI (cfiCond18) R11L Frame(CFA, -6)
          CFI (cfiCond18) CFA SP+16
          CFI Block cfiCond19 Using cfiCommon0
          CFI (cfiCond19) Function macSpiRandomByte
          CFI (cfiCond19) Conditional ??CrossCallReturnLabel_0
          CFI (cfiCond19) CFA SP+12
          CFI Block cfiCond20 Using cfiCommon0
          CFI (cfiCond20) Function macSpiWriteReg
          CFI (cfiCond20) Conditional ??CrossCallReturnLabel_0
          CFI (cfiCond20) CFA SP+12
          CFI Block cfiCond21 Using cfiCommon0
          CFI (cfiCond21) Function macSpiReadReg
          CFI (cfiCond21) Conditional ??CrossCallReturnLabel_0
          CFI (cfiCond21) CFA SP+12
          CFI Block cfiCond22 Using cfiCommon0
          CFI (cfiCond22) Function macSpiCmdStrobe
          CFI (cfiCond22) Conditional ??CrossCallReturnLabel_0
          CFI (cfiCond22) CFA SP+12
          CFI Block cfiPicker23 Using cfiCommon1
          CFI (cfiPicker23) NoFunction
          CFI (cfiPicker23) Picker
        MOV.W   SP, R12
        ADD.W   #0x4, R12
        BRA     #spiSendBytes
          CFI EndBlock cfiCond17
          CFI EndBlock cfiCond18
          CFI EndBlock cfiCond19
          CFI EndBlock cfiCond20
          CFI EndBlock cfiCond21
          CFI EndBlock cfiCond22
          CFI EndBlock cfiPicker23

        RSEG CODE:CODE:NOROOT(1)
macSpiWriteRam:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function macSpiWriteRam
        FUNCALL macSpiWriteRam, spiWriteRamByte
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R11
        MOV.W   R13, R8
        MOV.B   R14, R10
        JMP     ??macSpiWriteRam_1
??macSpiWriteRam_0:
        MOV.B   @R8+, R13
        MOV.W   R11, R12
        CALLA   #spiWriteRamByte
        ADD.W   #0x1, R11
        ADD.B   #0xff, R10
??macSpiWriteRam_1:
        CMP.B   #0x0, R10
        JNE     ??macSpiWriteRam_0
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock24

        RSEG CODE:CODE:NOROOT(1)
macSpiWriteRamUint16:
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function macSpiWriteRamUint16
        FUNCALL macSpiWriteRamUint16, spiWriteRamByte
        LOCFRAME CSTACK, 8, STACK
        FUNCALL macSpiWriteRamUint16, spiWriteRamByte
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.W   R12, R11
        MOV.W   R13, R10
        CALLA   #spiWriteRamByte
        RPT     #0x8
        RRUX.W  R10
        MOV.B   R10, R13
        ADD.W   #0x1, R11
        MOV.W   R11, R12
        CALLA   #spiWriteRamByte
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock25

        RSEG CODE:CODE:NOROOT(1)
spiSendBytes:
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function spiSendBytes
        FUNCALL spiSendBytes, halAssertHandler
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.W   R12, R11
        MOV.B   R13, R10
        BIT.B   #0x1, &macSpiRadioPower
        JC      ??spiSendBytes_2
        CALLA   #halAssertHandler
??spiSendBytes_2:
        MOV.W   SR, R15
        dint
        nop
        CALLA   #?Subroutine2
??spiSendBytes_0:
        CMP.B   #0x0, R10
        JEQ     ??spiSendBytes_3
        BIC.B   #0x4, &0x7
        MOV.B   @R11+, &0xdf
        ADD.B   #0xff, R10
??spiSendBytes_1:
        BIT.B   #0x4, &0x7
        JC      ??spiSendBytes_0
        JMP     ??spiSendBytes_1
??spiSendBytes_3:
        MOV.B   &0xde, R12
        BIS.B   #0x1, &0x31
        MOV.W   R15, SR
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock26
        REQUIRE P5OUT
        REQUIRE UC1IFG
        REQUIRE UCB1TXBUF
        REQUIRE UCB1RXBUF

        RSEG CODE:CODE:NOROOT(1)
macSpiWriteReg:
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function macSpiWriteReg
        FUNCALL macSpiWriteReg, spiSendBytes
        LOCFRAME CSTACK, 8, STACK
        SUB.W   #0x4, SP
          CFI CFA SP+8
        CMP.B   #0x40, R12
        JC      ??macSpiWriteReg_0
        BIS.B   #0xc0, R12
        MOV.B   R12, 0(SP)
        MOV.B   R13, 0x1(SP)
        MOV.B   #0x2, R13
        JMP     ??macSpiWriteReg_1
??macSpiWriteReg_0:
        MOV.B   #0x20, 0(SP)
        MOV.B   R12, 0x1(SP)
        MOV.B   R13, 0x2(SP)
        MOV.B   #0x3, R13
??macSpiWriteReg_1:
        JMP     ?Subroutine0
          CFI EndBlock cfiBlock27

        RSEG CODE:CODE:NOROOT(1)
macSpiReadReg:
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function macSpiReadReg
        FUNCALL macSpiReadReg, spiSendBytes
        LOCFRAME CSTACK, 8, STACK
        SUB.W   #0x4, SP
          CFI CFA SP+8
        CMP.B   #0x40, R12
        JC      ??macSpiReadReg_0
        BIS.B   #0x80, R12
        MOV.B   R12, 0(SP)
        MOV.B   #0x2, R13
        JMP     ??macSpiReadReg_1
??macSpiReadReg_0:
        MOV.B   #0x10, 0(SP)
        MOV.B   R12, 0x1(SP)
        MOV.B   #0x3, R13
          CFI EndBlock cfiBlock28
??macSpiReadReg_1:
        REQUIRE ?Subroutine0
        // Fall through to label ?Subroutine0

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
          CFI Block cfiBlock29 Using cfiCommon0
          CFI NoFunction
          CFI CFA SP+8
        CALLA   #?Subroutine1
??CrossCallReturnLabel_0:
        ADD.W   #0x4, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock29

        RSEG CODE:CODE:REORDER:NOROOT(1)
macSpiCmdStrobe:
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function macSpiCmdStrobe
        FUNCALL macSpiCmdStrobe, spiSendBytes
        LOCFRAME CSTACK, 8, STACK
        SUB.W   #0x4, SP
          CFI CFA SP+8
        MOV.B   R12, 0(SP)
        MOV.B   #0x1, R13
        JMP     ?Subroutine0
          CFI EndBlock cfiBlock30
//  232 
//  233   /*-------------------------------------------------------------------------------
//  234    *  execute based on type of access
//  235    */
//  236   while (numBytes)
//  237   {
//  238     HAL_MAC_SPI_WRITE_BYTE(*pBytes);
//  239     pBytes++;
//  240     numBytes--;
//  241     HAL_MAC_SPI_WAIT_DONE();
//  242 
//  243    /*-------------------------------------------------------------------------------
//  244     *  SPI data register now contains the status byte. The status byte is
//  245     *  discarded.
//  246     */
//  247     if (numBytes > 0)
//  248     {
//  249       HAL_MAC_SPI_LUMINARY_READ_DUMMY_BYTE();
//  250     }
//  251   }
//  252 
//  253   /*-------------------------------------------------------------------------------
//  254    *  SPI data register now contains the status byte. The status byte is
//  255    *  discarded.
//  256    */
//  257   returnValue = HAL_MAC_SPI_READ_BYTE();
//  258 
//  259   /*-------------------------------------------------------------------------------
//  260    *  Turn off chip select.  Enable interrupts that call SPI functions.
//  261    */
//  262   HAL_MAC_SPI_SET_CHIP_SELECT_OFF();
//  263   HAL_MAC_SPI_EXIT_CRITICAL_SECTION(s);
//  264 
//  265   return(returnValue);
//  266 }
//  267 
//  268 /**************************************************************************************************
//  269  * @fn          macSpiWriteRamUint16
//  270  *
//  271  * @brief       Write unsigned 16-bit value to radio RAM.
//  272  *
//  273  * @param       ramAddr    - radio RAM address
//  274  * @param       pWriteData - pointer to data to write
//  275  * @param       len        - length of data in bytes
//  276  *
//  277  * @return      none
//  278  **************************************************************************************************
//  279  */
//  280 void macSpiWriteRamUint16(uint16 ramAddr, uint16 data)
//  281 {
//  282   spiWriteRamByte(ramAddr,   data & 0xFF);
//  283   spiWriteRamByte(ramAddr+1, data >> 8);
//  284 }
//  285 
//  286 
//  287 /**************************************************************************************************
//  288  * @fn          macSpiWriteRam
//  289  *
//  290  * @brief       Write data to radio RAM.
//  291  *
//  292  * @param       ramAddr - radio RAM address
//  293  * @param       pData   - pointer to data to write
//  294  * @param       len     - length of data in bytes
//  295  *
//  296  * @return      none
//  297  **************************************************************************************************
//  298  */
//  299 void macSpiWriteRam(uint16 ramAddr, uint8 * pData, uint8 len)
//  300 {
//  301   while (len)
//  302   {
//  303     spiWriteRamByte(ramAddr, *pData);
//  304     ramAddr++;
//  305     pData++;
//  306     len--;
//  307   }
//  308 }
//  309 
//  310 
//  311 /*=================================================================================================
//  312  * @fn          spiWriteRamByte
//  313  *
//  314  * @brief       Write a byte to radio RAM.
//  315  *
//  316  * @param       ramAddr - radio RAM address
//  317  * @param       byte    - data byte to write to RAM
//  318  *
//  319  * @return      none
//  320  *=================================================================================================
//  321  */
//  322 static void spiWriteRamByte(uint16 ramAddr, uint8 byte)
//  323 {
//  324   uint8 buf[SPI_ACCESS_BUF_LEN];
//  325 
//  326   MAC_ASSERT(ramAddr <= 0xFFF); /* address out of range */
//  327 
//  328   /* setup for a memory write */
//  329   buf[0] = MEMWR | (ramAddr >> 8);
//  330   buf[1] = ramAddr & 0xFF;
//  331   buf[2] = byte;
//  332 
//  333   /* send bytes out via SPI */
//  334   spiSendBytes(&buf[0], NUM_BYTES_MEM_ACCESS);
//  335 }
//  336 
//  337 
//  338 /**************************************************************************************************
//  339  * @fn          macSpiReadRam
//  340  *
//  341  * @brief       Read data from radio RAM.
//  342  *
//  343  * @param       ramAddr     - radio RAM address
//  344  * @param       pReadData   - pointer to read data
//  345  * @param       len         - length of data in bytes
//  346  *
//  347  * @return      none
//  348  **************************************************************************************************
//  349  */
//  350 void macSpiReadRam(uint16 ramAddr, uint8 *pReadData, uint8 len)
//  351 {
//  352   halMacSpiIntState_t s;
//  353   uint8 i;
//  354 
//  355   /* Address out of range */
//  356   MAC_ASSERT(ramAddr <= 0xFFF);
//  357 
//  358   /* Buffer must be valid */
//  359   MAC_ASSERT(pReadData != NULL);
//  360 
//  361   /* Radio must be powered */
//  362   MAC_ASSERT(macSpiRadioPower & MAC_SPI_RADIO_POWER_VREG_ON);
//  363 
//  364   /* Disable interrupts that call SPI functions. */
//  365   HAL_MAC_SPI_ENTER_CRITICAL_SECTION(s);
//  366 
//  367   /*-------------------------------------------------------------------------------
//  368    *  Turn chip select "off" and then "on" to clear any current SPI access.
//  369    */
//  370   HAL_MAC_SPI_SET_CHIP_SELECT_OFF();
//  371   HAL_MAC_SPI_SET_CHIP_SELECT_ON();
//  372 
//  373   /* Send MEMRD via SPI */
//  374   HAL_MAC_SPI_WRITE_BYTE(MEMRD | (ramAddr >> 8));
//  375   HAL_MAC_SPI_WAIT_DONE();
//  376 
//  377   /* Dummy read to clear the SPI Rx buffer */
//  378   HAL_MAC_SPI_LUMINARY_READ_DUMMY_BYTE();
//  379 
//  380   HAL_MAC_SPI_WRITE_BYTE(ramAddr & 0xFF);
//  381   HAL_MAC_SPI_WAIT_DONE();
//  382 
//  383   /* Dummy read to clear the SPI Rx buffer */
//  384   HAL_MAC_SPI_LUMINARY_READ_DUMMY_BYTE();
//  385 
//  386   /* Get the data */
//  387   for (i=0; i<len; i++)
//  388   {
//  389     /* Write 0 to SPI to get the data */
//  390     HAL_MAC_SPI_WRITE_BYTE(0);
//  391     /* Wait for Done */
//  392     HAL_MAC_SPI_WAIT_DONE();
//  393     /* Fill up the buffer*/
//  394     *pReadData++ = HAL_MAC_SPI_READ_BYTE();
//  395   }
//  396 
//  397   /*-------------------------------------------------------------------------------
//  398    *  Turn off chip select and re-enable interrupts that use SPI.
//  399    */
//  400   HAL_MAC_SPI_SET_CHIP_SELECT_OFF();
//  401   HAL_MAC_SPI_EXIT_CRITICAL_SECTION(s);
//  402 }
//  403 
//  404 
//  405 /**************************************************************************************************
//  406  * @fn          macSpiWriteTxFifo
//  407  *
//  408  * @brief       Write data to radio FIFO.
//  409  *
//  410  * @param       pData - pointer for storing write data
//  411  * @param       len   - length of data in bytes
//  412  *
//  413  * @return      none
//  414  **************************************************************************************************
//  415  */
//  416 void macSpiWriteTxFifo(uint8 * pData, uint8 len)
//  417 {
//  418   spiFifoAccess(pData, len, FIFO_ACCESS_TX_WRITE);
//  419 }
//  420 
//  421 
//  422 /**************************************************************************************************
//  423  * @fn          macSpiReadRxFifo
//  424  *
//  425  * @brief       Read data from radio FIFO.
//  426  *
//  427  * @param       pData - pointer for storing read data
//  428  * @param       len   - length of data in bytes
//  429  *
//  430  * @return      none
//  431  **************************************************************************************************
//  432  */
//  433 void macSpiReadRxFifo(uint8 * pData, uint8 len)
//  434 {
//  435   spiFifoAccess(pData, len, FIFO_ACCESS_RX_READ);
//  436 }
//  437 
//  438 
//  439 /*=================================================================================================
//  440  * @fn          spiFifoAccess
//  441  *
//  442  * @brief       Read/write data to or from radio FIFO.
//  443  *
//  444  * @param       pData - pointer to data to read or write
//  445  * @param       len   - length of data in bytes
//  446  *
//  447  * @return      none
//  448  *=================================================================================================
//  449  */
//  450 static void spiFifoAccess(uint8 * pData, uint8 len, uint8 accessType)
//  451 {
//  452   halMacSpiIntState_t s;
//  453 
//  454   MAC_ASSERT(macSpiRadioPower & MAC_SPI_RADIO_POWER_OSC_ON);  /* oscillator must be on */
//  455   MAC_ASSERT(len != 0); /* zero length is not allowed */
//  456 
//  457   /*-------------------------------------------------------------------------------
//  458    *  Disable interrupts that call SPI functions.
//  459    */
//  460   HAL_MAC_SPI_ENTER_CRITICAL_SECTION(s);
//  461 
//  462   /*-------------------------------------------------------------------------------
//  463    *  Turn chip select "off" and then "on" to clear any current SPI access.
//  464    */
//  465   HAL_MAC_SPI_SET_CHIP_SELECT_OFF();
//  466   HAL_MAC_SPI_SET_CHIP_SELECT_ON();
//  467 
//  468   /*-------------------------------------------------------------------------------
//  469    *  Main loop.  If the SPI access is interrupted, execution comes back to
//  470    *  the start of this loop.  Loop exits when nothing left to transfer.
//  471    *  (Note: previous test guarantees at least one byte to transfer.)
//  472    */
//  473   do
//  474   {
//  475     /*-------------------------------------------------------------------------------
//  476      *  Send FIFO access command byte.  Wait for SPI access to complete.
//  477      */
//  478     if (accessType == FIFO_ACCESS_TX_WRITE)
//  479     {
//  480       HAL_MAC_SPI_WRITE_BYTE( TXBUF );
//  481     }
//  482     else
//  483     {
//  484       HAL_MAC_SPI_WRITE_BYTE( RXBUF );
//  485     }
//  486     HAL_MAC_SPI_WAIT_DONE();
//  487 
//  488     /* Make a Dummy read to empty the SPI Rx buffer */
//  489     HAL_MAC_SPI_LUMINARY_READ_DUMMY_BYTE();
//  490 
//  491     /*-------------------------------------------------------------------------------
//  492      *  Inner loop.  This loop executes as long as the SPI access is not interrupted.
//  493      *  Loop completes when nothing left to transfer.
//  494      *  (Note: previous test guarantees at least one byte to transfer.)
//  495      */
//  496     do
//  497     {
//  498       HAL_MAC_SPI_WRITE_BYTE(*pData);
//  499 
//  500       /*-------------------------------------------------------------------------------
//  501        *  Use idle time.  Perform increment/decrement operations before pending on
//  502        *  completion of SPI access.
//  503        *
//  504        *  Decrement the length counter.  Wait for SPI access to complete.
//  505        */
//  506       len--;
//  507       HAL_MAC_SPI_WAIT_DONE();
//  508 
//  509       /*-------------------------------------------------------------------------------
//  510        *  SPI data register holds data just read, store the value
//  511        *  into memory.
//  512        */
//  513       if (accessType != FIFO_ACCESS_TX_WRITE)
//  514       {
//  515         *pData = HAL_MAC_SPI_READ_BYTE();
//  516       }
//  517       else
//  518       {
//  519         /* Dummy read to clear the SPI Rx buffer */
//  520         HAL_MAC_SPI_LUMINARY_READ_DUMMY_BYTE();
//  521       }
//  522 
//  523       /*-------------------------------------------------------------------------------
//  524        *  At least one byte of data has transferred.  Briefly enable (and then disable)
//  525        *  interrupts that call SPI functions.  This provides a window for any timing
//  526        *  critical interrupts that might be pending.
//  527        *
//  528        *  To improve latency, take care of pointer increment within the interrupt
//  529        *  enabled window.
//  530        */
//  531       HAL_MAC_SPI_EXIT_CRITICAL_SECTION(s);
//  532       pData++;
//  533       HAL_MAC_SPI_ENTER_CRITICAL_SECTION(s);
//  534 
//  535       /*-------------------------------------------------------------------------------
//  536        *  If chip select is "off" the SPI access was interrupted.  In this case,
//  537        *  turn back on chip select and break to the main loop.  The main loop will
//  538        *  pick up where the access was interrupted.
//  539        */
//  540       if (HAL_MAC_SPI_CHIP_SELECT_IS_OFF())
//  541       {
//  542         HAL_MAC_SPI_SET_CHIP_SELECT_ON();
//  543         break;
//  544       }
//  545 
//  546     /*-------------------------------------------------------------------------------
//  547      */
//  548     } while (len); /* inner loop */
//  549   } while (len);   /* main loop */
//  550 
//  551   /*-------------------------------------------------------------------------------
//  552    *  Turn off chip select and re-enable interrupts that use SPI.
//  553    */
//  554   HAL_MAC_SPI_SET_CHIP_SELECT_OFF();
//  555   HAL_MAC_SPI_EXIT_CRITICAL_SECTION(s);
//  556 }
//  557 
//  558 
//  559 /**************************************************************************************************
//  560  * @fn          macSpiRandomByte
//  561  *
//  562  * @brief       returns a random byte
//  563  *
//  564  * @param       none
//  565  *
//  566  * @return      a random byte
//  567  **************************************************************************************************
//  568  */
//  569 uint8 macSpiRandomByte(void)
//  570 {
//  571   uint8 sendBytes[SPI_ACCESS_BUF_LEN];
//  572 
//  573   /* setup to send RANDOM command to radio*/
//  574   sendBytes[0] = RANDOM;
//  575 
//  576   /*
//  577    *  Send RANDOM command via SPI. Note that valid return value needs
//  578    *  two dummy writes (i.e. NUM_BYTES_RANDOM equals 3). */
//  579   return( spiSendBytes(&sendBytes[0], NUM_BYTES_RANDOM) );
//  580 }
//  581 
//  582 /**************************************************************************************************
//  583  * @fn          macSpiSendECBO
//  584  *
//  585  * @brief       Send a ECBO command to spi
//  586  *
//  587  * @param       p - 0/1 low/high
//  588  *              k - address of the key at 16xk address
//  589  *              c - 16-c bytes of plaintext
//  590  *              a - input/output address where plaintext and converted text is stored
//  591  *
//  592  * @return      none
//  593  **************************************************************************************************
//  594  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  595 void macSpiSendECBO(uint8 p, uint8 k, uint8 c, uint16 a)
macSpiSendECBO:
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function macSpiSendECBO
//  596 {
        FUNCALL macSpiSendECBO, halAssertHandler
        LOCFRAME CSTACK, 16, STACK
        FUNCALL macSpiSendECBO, spiSendBytes
        LOCFRAME CSTACK, 16, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x4, SP
          CFI CFA SP+16
        MOV.B   R12, R10
        MOV.B   R13, R11
        MOV.B   R14, R8
        MOV.W   R15, R9
//  597   uint8 pBuf[4];
//  598 
//  599   /* Address out of range */
//  600   MAC_ASSERT(a <= 0xFFF);
        CMP.W   #0x1000, R15
        JNC     ??macSpiSendECBO_0
        CALLA   #halAssertHandler
//  601 
//  602   /* Apply Encryption */
//  603   pBuf[0] = ECBO | (p & 0x01);
??macSpiSendECBO_0:
        AND.B   #0x1, R10
        BIS.B   #0x72, R10
        MOV.B   R10, 0(SP)
//  604   pBuf[1] = k;
        MOV.B   R11, 0x1(SP)
//  605   pBuf[2] = ((c & 0x0F) << 4) | (a >> 8);
        MOV.W   R9, R15
        RPT     #0x8
        RRUX.W  R15
        RPT     #0x4
        RLAX.B  R8
        BIS.B   R15, R8
        MOV.B   R8, 0x2(SP)
//  606   pBuf[3] = a & 0xFF;
        MOV.B   R9, 0x3(SP)
//  607 
//  608   /* send bytes out via SPI */
//  609   spiSendBytes(&pBuf[0], 4);
        MOV.B   #0x4, R13
        CALLA   #?Subroutine1
//  610 }
??CrossCallReturnLabel_2:
        ADD.W   #0x4, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock31

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  611 
//  612 /**************************************************************************************************
//  613  *                                  Compile Time Integrity Checks
//  614  **************************************************************************************************
//  615  */
//  616 #if (MAC_SPI_RADIO_POWER_VREG_ON & MAC_SPI_RADIO_POWER_OSC_ON)
//  617 #error "ERROR!  Non-unique bit values for SPI radio power states."
//  618 #endif
//  619 
//  620 #if (FIFO_ACCESS_TX_WRITE != 0)
//  621 #error "ERROR!  Code optimized for FIFO_ACCESS_TX_WRITE equal to zero."
//  622 #endif
//  623 
//  624 /**************************************************************************************************
//  625 */
// 
// 666 bytes in segment CODE
//   8 bytes in segment DATA16_AN
//   1 byte  in segment DATA16_Z
// 
// 666 bytes of CODE memory
//   1 byte  of DATA memory (+ 8 bytes shared)
//
//Errors: none
//Warnings: none

///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430      10/Jun/2013  17:10:33 /
// Copyright 1996-2013 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\s /
//                     tack\af\AF.c                                           /
//    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\..\ /
//                     Tools\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0   /
//                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                      /
//                     -DDEFAULT_CHANLIST=0x00000800                          /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100     /
//                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                  /
//                     -DBEACON_REQUEST_DELAY=100                             /
//                     -DBEACON_REQ_DELAY_MASK=0x00FF                         /
//                     -DLINK_STATUS_JITTER_MASK=0x007F                       /
//                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED /
//                     =3000 -DNWK_INDIRECT_MSG_TIMEOUT=7                     /
//                     -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3        /
//                     -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2  /
//                     -DMAX_BCAST=9 -DAPS_MAX_GROUPS=16                      /
//                     -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4       /
//                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,      /
//                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,  /
//                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                   /
//                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS= /
//                     20 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000         /
//                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100        /
//                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618 /
//                     \f8wEndev.cfg" (-DCPU6MHZ -DMAC_CFG_TX_DATA_MAX=3      /
//                     -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "C:\Texas    /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618 /
//                     \f8wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC       /
//                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH        /
//                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4         /
//                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10        /
//                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10       /
//                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING               /
//                     -DZCL_PRICING -DZCL_MESSAGE -DZCL_TUNNELING            /
//                     -DZCL_TOU) -DZCL_DEVICE_MGMT "C:\Texas                 /
//                     Instruments\ZStack-MSP2618-2.5.1\Components\stack\af\A /
//                     F.c" -D MSP430F2618 -D NWK_AUTO_POLL -D ZTOOL_P1 -D    /
//                     MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D               /
//                     LCD_SUPPORTED -lC "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\EndDevice\List\" -lA   /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\Li /
//                     st\" --remarks --diag_suppress                         /
//                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                   /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\EndDevice\Obj\"        /
//                     --debug -D__MSP430F2618__ -e --double=32 --clib -I     /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleSwitch\CC2520DB\" -I         /
//                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zs /
//                     tack\HomeAutomation\SampleSwitch\CC2520DB\..\Source\"  /
//                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects /
//                     \zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\Sou /
//                     rce\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pr /
//                     ojects\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\ /
//                     ..\..\ZMain\MSP2618\" -I "C:\Texas                     /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\hal\include\" -I "C:\Texas                         /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\hal\target\MSP2618CC2520\" -I "C:\Texas            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\mac\include\" -I "C:\Texas                         /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\mac\high_level\" -I "C:\Texas                      /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\mac\low_level\srf04\" -I "C:\Texas                 /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\mac\low_level\srf04\dual_chip\" -I "C:\Texas       /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1 /
//                     \Projects\zstack\HomeAutomation\SampleSwitch\CC2520DB\ /
//                     ..\..\..\..\..\Components\osal\include\" -I "C:\Texas  /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\osal\mcu\msp430\" -I "C:\Texas                     /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\services\saddr\" -I "C:\Texas                      /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\services\sdata\" -I "C:\Texas                      /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\af\" -I "C:\Texas                            /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\nwk\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\sec\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\sapi\" -I "C:\Texas                          /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\sys\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\zcl\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\stack\zdo\" -I "C:\Texas                           /
//                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeA /
//                     utomation\SampleSwitch\CC2520DB\..\..\..\..\..\Compone /
//                     nts\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5 /
//                     .1\Projects\zstack\HomeAutomation\SampleSwitch\CC2520D /
//                     B\..\..\..\..\..\Components\zmac\f8w\" --core=430X     /
//                     --data_model=small -Ohz --multiplier=16s               /
//                     --require_prototypes                                   /
//    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst /
//                     ack\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\Lis /
//                     t\AF.s43                                               /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME AF

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?IndCallR9
        EXTERN ?IndCallR15
        EXTERN ?cstart_init_copy
        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC AF_DataRequest
        FUNCTION AF_DataRequest,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 54, STACK
        PUBLIC AF_DataRequestDiscoverRoute
        PUBLIC AF_DataRequestSrcRtg
        FUNCTION AF_DataRequestSrcRtg,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC afAPSF_ConfigGet
        FUNCTION afAPSF_ConfigGet,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC afAPSF_ConfigSet
        FUNCTION afAPSF_ConfigSet,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        FUNCTION afBuildMSGIncoming,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 24, STACK
        PUBLIC afCopyAddress
        FUNCTION afCopyAddress,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC afDataConfirm
        FUNCTION afDataConfirm,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC afDataReqMTU
        FUNCTION afDataReqMTU,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC afDelete
        FUNCTION afDelete,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC afEndPoints
        FUNCTION afEndPoints,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC afFindEndPointDesc
        FUNCTION afFindEndPointDesc,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION afFindEndPointDescList,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC afFindSimpleDesc
        FUNCTION afFindSimpleDesc,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC afGetMatch
        FUNCTION afGetMatch,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC afIncomingData
        FUNCTION afIncomingData,061203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 36, STACK
        PUBLIC afNumEndPoints
        FUNCTION afNumEndPoints,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC afRegister
        FUNCTION afRegister,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC afRegisterExtended
        FUNCTION afRegisterExtended,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC afSetMatch
        FUNCTION afSetMatch,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC epList
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        EXTERN osal_memcpy
        FUNCTION osal_memcpy,0202H
        EXTERN sAddrExtCpy
        FUNCTION sAddrExtCpy,0202H
        EXTERN APSDE_DataReqMTU
        FUNCTION APSDE_DataReqMTU,0202H
        EXTERN RTG_AddSrcRtgEntry_Guaranteed
        FUNCTION RTG_AddSrcRtgEntry_Guaranteed,0202H
        EXTERN NLME_GetShortAddr
        FUNCTION NLME_GetShortAddr,0202H
        EXTERN RTG_CheckRtStatus
        FUNCTION RTG_CheckRtStatus,0202H
        EXTERN NLME_IsAddressBroadcast
        FUNCTION NLME_IsAddressBroadcast,0202H
        EXTERN osal_mem_free
        FUNCTION osal_mem_free,0202H
        EXTERN apsfSendFragmented
        EXTERN APSDE_DataReq
        FUNCTION APSDE_DataReq,0202H
        EXTERN osal_msg_allocate
        FUNCTION osal_msg_allocate,0202H
        EXTERN osal_msg_send
        FUNCTION osal_msg_send,0202H
        EXTERN aps_FindGroupForEndpoint
        FUNCTION aps_FindGroupForEndpoint,0202H
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H

// C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\stack\af\AF.c
//    1 /**************************************************************************************************
//    2   Filename:       AF.c
//    3   Revised:        $Date: 2011-11-18 16:03:29 -0800 (Fri, 18 Nov 2011) $
//    4   Revision:       $Revision: 28423 $
//    5 
//    6   Description:    Application Framework - Device Description helper functions
//    7 
//    8 
//    9   Copyright 2004-2011 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 
//   44 #include "OSAL.h"
//   45 #include "AF.h"
//   46 #include "nwk_globals.h"
//   47 #include "nwk_util.h"
//   48 #include "aps_groups.h"
//   49 #include "ZDProfile.h"
//   50 #include "aps_frag.h"
//   51 #include "rtg.h"
//   52 
//   53 #if defined ( MT_AF_CB_FUNC )
//   54   #include "MT_AF.h"
//   55 #endif
//   56 
//   57 #if defined ( INTER_PAN )
//   58   #include "stub_aps.h"
//   59 #endif
//   60 
//   61 /*********************************************************************
//   62  * MACROS
//   63  */
//   64 
//   65 /*********************************************************************
//   66  * @fn      afSend
//   67  *
//   68  * @brief   Helper macro for V1 API to invoke V2 API.
//   69  *
//   70  * input parameters
//   71  *
//   72  * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
//   73  * @param   srcEP - Origination (i.e. respond to or ack to) End Point.
//   74  * @param   cID - A valid cluster ID as specified by the Profile.
//   75  * @param   len - Number of bytes of data pointed to by next param.
//   76  * @param  *buf - A pointer to the data bytes to send.
//   77  * @param   options - Valid bit mask of AF Tx Options as defined in AF.h.
//   78  * @param  *transID - A pointer to a byte which can be modified and which will
//   79  *                    be used as the transaction sequence number of the msg.
//   80  *
//   81  * output parameters
//   82  *
//   83  * @param  *transID - Incremented by one if the return value is success.
//   84  *
//   85  * @return  afStatus_t - See previous definition of afStatus_... types.
//   86  */
//   87 #define afSend( dstAddr, srcEP, cID, len, buf, transID, options, radius ) \ 
//   88         AF_DataRequest( (dstAddr), afFindEndPointDesc( (srcEP) ), \ 
//   89                           (cID), (len), (buf), (transID), (options), (radius) )
//   90 
//   91 /*********************************************************************
//   92  * GLOBAL VARIABLES
//   93  */
//   94 

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//   95 epList_t *epList;
epList:
        DS8 2
//   96 
//   97 /*********************************************************************
//   98  * LOCAL FUNCTIONS
//   99  */
//  100 
//  101 static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
//  102                 zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig,
//  103                 uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp );
//  104 
//  105 static epList_t *afFindEndPointDescList( uint8 EndPoint );
//  106 
//  107 static pDescCB afGetDescCB( endPointDesc_t *epDesc );
//  108 
//  109 /*********************************************************************
//  110  * PUBLIC FUNCTIONS
//  111  */
//  112 
//  113 /*********************************************************************
//  114  * @fn      afInit
//  115  *
//  116  * @brief   Initialization function for the AF.
//  117  *
//  118  * @param   none
//  119  *
//  120  * @return  none
//  121 void afInit( void )
//  122 {
//  123 }
//  124  */
//  125 
//  126 /*********************************************************************
//  127  * @fn      afRegisterExtended
//  128  *
//  129  * @brief   Register an Application's EndPoint description.
//  130  *
//  131  * @param   epDesc - pointer to the Application's endpoint descriptor.
//  132  * @param   descFn - pointer to descriptor callback function
//  133  *
//  134  * NOTE:  The memory that epDesc is pointing to must exist after this call.
//  135  *
//  136  * @return  Pointer to epList_t on success, NULL otherwise.
//  137  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  138 epList_t *afRegisterExtended( endPointDesc_t *epDesc, pDescCB descFn )
afRegisterExtended:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function afRegisterExtended
//  139 {
        FUNCALL afRegisterExtended, osal_mem_alloc
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R8
        MOV.W   R14, R10
        MOV.W   R15, R11
//  140   epList_t *ep = osal_mem_alloc(sizeof(epList_t));
        MOV.W   #0xc, R12
        CALLA   #osal_mem_alloc
//  141 
//  142   if (ep != NULL)
        CMP.W   #0x0, R12
        JEQ     ??afRegisterExtended_0
//  143   {
//  144     ep->nextDesc = epList;
        MOV.W   &epList, 0(R12)
//  145     epList = ep;
        MOV.W   R12, &epList
//  146     ep->epDesc = epDesc;
        MOV.W   R8, 0x2(R12)
//  147     ep->pfnDescCB = descFn;
        MOV.W   R10, 0x4(R12)
        MOV.W   R11, 0x6(R12)
//  148     ep->apsfCfg.frameDelay = APSF_DEFAULT_INTERFRAME_DELAY;
        MOV.B   #0x32, 0x8(R12)
//  149     ep->apsfCfg.windowSize = APSF_DEFAULT_WINDOW_SIZE;
        MOV.B   #0x1, 0x9(R12)
//  150     ep->flags = eEP_AllowMatch;  // Default to allow Match Descriptor.
        MOV.B   #0x1, 0xa(R12)
//  151   }
//  152 
//  153   return ep;
??afRegisterExtended_0:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock0
//  154 }
//  155 
//  156 /*********************************************************************
//  157  * @fn      afRegister
//  158  *
//  159  * @brief   Register an Application's EndPoint description.
//  160  *
//  161  * @param   epDesc - pointer to the Application's endpoint descriptor.
//  162  *
//  163  * NOTE:  The memory that epDesc is pointing to must exist after this call.
//  164  *
//  165  * @return  afStatus_SUCCESS - Registered
//  166  *          afStatus_MEM_FAIL - not enough memory to add descriptor
//  167  *          afStatus_INVALID_PARAMETER - duplicate endpoint
//  168  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  169 afStatus_t afRegister( endPointDesc_t *epDesc )
afRegister:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function afRegister
//  170 {
        FUNCALL afRegister, afFindEndPointDescList
        LOCFRAME CSTACK, 4, STACK
        FUNCALL afRegister, afRegisterExtended
        LOCFRAME CSTACK, 4, STACK
        MOV.W   R12, R13
//  171   if (afFindEndPointDescList(epDesc->endPoint))  // Look for duplicate endpoint.
        MOV.B   @R13, R12
        CALLA   #afFindEndPointDescList
        CMP.W   #0x0, R12
        JEQ     ??afRegister_1
//  172   {
//  173     return afStatus_INVALID_PARAMETER;
        MOV.B   #0x2, R12
        RETA
//  174   }
//  175 
//  176   return ((NULL == afRegisterExtended(epDesc, NULL)) ? afStatus_MEM_FAIL : afStatus_SUCCESS);
??afRegister_1:
        MOV.W   #0x0, R14
        MOV.W   #0x0, R15
        MOV.W   R13, R12
        CALLA   #afRegisterExtended
        CMP.W   #0x0, R12
        JEQ     ??afRegister_2
        MOV.B   #0x0, R12
        RETA
??afRegister_2:
        MOV.B   #0x10, R12
        RETA
          CFI EndBlock cfiBlock1
//  177 }
//  178 
//  179 /*********************************************************************
//  180  * @fn      afDelete
//  181  *
//  182  * @brief   Delete an Application's EndPoint descriptor and frees the memory
//  183  *
//  184  * @param   EndPoint - Application Endpoint to delete
//  185  *
//  186  * @return  afStatus_SUCCESS - endpoint deleted
//  187  *          afStatus_INVALID_PARAMETER - endpoint not found
//  188  *          afStatus_FAILED - endpoint list empty
//  189  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  190 afStatus_t afDelete( uint8 EndPoint )
afDelete:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function afDelete
//  191 {
        FUNCALL afDelete, osal_mem_free
        LOCFRAME CSTACK, 6, STACK
        FUNCALL afDelete, osal_mem_free
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
//  192   epList_t *epCurrent;
//  193   epList_t *epPrevious;
//  194 
//  195   if (epList != NULL)
        MOV.W   &epList, R15
        CMP.W   #0x0, R15
        JEQ     ??afDelete_1
//  196   {
//  197     epPrevious = epCurrent = epList;
        MOV.W   R15, R14
//  198 
//  199     // first element of the list matches
//  200     if (epCurrent->epDesc->endPoint == EndPoint)
        MOV.W   @R15, R13
        MOV.W   0x2(R15), R10
        CMP.B   R12, 0(R10)
        JNE     ??afDelete_2
//  201     {
//  202       epList = epCurrent->nextDesc;
        MOV.W   R13, &epList
//  203       osal_mem_free(epCurrent);
        JMP     ??afDelete_3
//  204 
//  205       return (afStatus_SUCCESS);
//  206     }
//  207     else
//  208     {
//  209       // search the list
//  210       for (epCurrent = epPrevious->nextDesc; epCurrent != NULL; epPrevious = epCurrent)
??afDelete_2:
        MOV.W   R13, R15
        CMP.W   #0x0, R13
        JNE     ??afDelete_4
//  211       {
//  212         if (epCurrent->epDesc->endPoint == EndPoint)
//  213         {
//  214           epPrevious->nextDesc = epCurrent->nextDesc;
//  215           osal_mem_free(epCurrent);
//  216 
//  217           // delete the entry and free the memory
//  218           return (afStatus_SUCCESS);
//  219         }
//  220       }
//  221     }
//  222 
//  223     // no endpoint found
//  224     return (afStatus_INVALID_PARAMETER);
        MOV.B   #0x2, R12
        JMP     ??afDelete_5
??afDelete_0:
        MOV.W   R15, R14
??afDelete_4:
        MOV.W   0x2(R15), R13
        CMP.B   R12, 0(R13)
        JNE     ??afDelete_0
        MOV.W   @R15, 0(R14)
??afDelete_3:
        MOV.W   R15, R12
        CALLA   #osal_mem_free
        MOV.B   #0x0, R12
        JMP     ??afDelete_5
//  225   }
//  226   else
//  227   {
//  228     // epList is empty
//  229     return (afStatus_FAILED);
??afDelete_1:
        MOV.B   #0x1, R12
??afDelete_5:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
//  230   }
//  231 }
//  232 
//  233 /*********************************************************************
//  234  * @fn          afDataConfirm
//  235  *
//  236  * @brief       This function will generate the Data Confirm back to
//  237  *              the application.
//  238  *
//  239  * @param       endPoint - confirm end point
//  240  * @param       transID - transaction ID from APSDE_DATA_REQUEST
//  241  * @param       status - status of APSDE_DATA_REQUEST
//  242  *
//  243  * @return      none
//  244  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  245 void afDataConfirm( uint8 endPoint, uint8 transID, ZStatus_t status )
afDataConfirm:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function afDataConfirm
//  246 {
        FUNCALL afDataConfirm, afFindEndPointDesc
        LOCFRAME CSTACK, 12, STACK
        FUNCALL afDataConfirm, osal_msg_allocate
        LOCFRAME CSTACK, 12, STACK
        FUNCALL afDataConfirm, osal_msg_send
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.B   R12, R8
        MOV.B   R13, R10
        MOV.B   R14, R11
//  247   endPointDesc_t *epDesc;
//  248   afDataConfirm_t *msgPtr;
//  249 
//  250   // Find the endpoint description
//  251   epDesc = afFindEndPointDesc( endPoint );
        CALLA   #afFindEndPointDesc
        MOV.W   R12, R9
//  252   if ( epDesc == NULL )
        CMP.W   #0x0, R12
        JEQ     ??afDataConfirm_0
//  253     return;
//  254 
//  255   // Determine the incoming command type
//  256   msgPtr = (afDataConfirm_t *)osal_msg_allocate( sizeof(afDataConfirm_t) );
        MOV.W   #0x4, R12
        CALLA   #osal_msg_allocate
//  257   if ( msgPtr )
        CMP.W   #0x0, R12
        JEQ     ??afDataConfirm_0
//  258   {
//  259     // Build the Data Confirm message
//  260     msgPtr->hdr.event = AF_DATA_CONFIRM_CMD;
        MOV.B   #0xfd, 0(R12)
//  261     msgPtr->hdr.status = status;
        MOV.B   R11, 0x1(R12)
//  262     msgPtr->endpoint = endPoint;
        MOV.B   R8, 0x2(R12)
//  263     msgPtr->transID = transID;
        MOV.B   R10, 0x3(R12)
//  264 
//  265 #if defined ( MT_AF_CB_FUNC )
//  266     /* If MT has subscribed for this callback, don't send as a message. */
//  267     if ( AFCB_CHECK(CB_ID_AF_DATA_CNF,*(epDesc->task_id)) )
//  268     {
//  269       /* Send callback if it's subscribed */
//  270       MT_AfDataConfirm ((void *)msgPtr);
//  271       /* Release the memory. */
//  272       osal_msg_deallocate( (void *)msgPtr );
//  273     }
//  274     else
//  275 #endif
//  276     {
//  277       /* send message through task message */
//  278       osal_msg_send( *(epDesc->task_id), (uint8 *)msgPtr );
        MOV.W   R12, R13
        CALLA   #?Subroutine0
//  279     }
//  280   }
//  281 }
??afDataConfirm_0:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine0:
          CFI Block cfiCond4 Using cfiCommon0
          CFI Function afBuildMSGIncoming
          CFI Conditional ??afBuildMSGIncoming_1
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+28
          CFI Block cfiCond5 Using cfiCommon0
          CFI (cfiCond5) Function afDataConfirm
          CFI (cfiCond5) Conditional ??afDataConfirm_0
          CFI (cfiCond5) R8L Frame(CFA, -12)
          CFI (cfiCond5) R9L Frame(CFA, -10)
          CFI (cfiCond5) R10L Frame(CFA, -8)
          CFI (cfiCond5) R11L Frame(CFA, -6)
          CFI (cfiCond5) CFA SP+16
          CFI Block cfiPicker6 Using cfiCommon1
          CFI (cfiPicker6) NoFunction
          CFI (cfiPicker6) Picker
        MOV.W   0x2(R9), R15
        MOV.B   @R15, R12
        BRA     #osal_msg_send
          CFI EndBlock cfiCond4
          CFI EndBlock cfiCond5
          CFI EndBlock cfiPicker6
//  282 
//  283 /*********************************************************************
//  284  * @fn          afIncomingData
//  285  *
//  286  * @brief       Transfer a data PDU (ASDU) from the APS sub-layer to the AF.
//  287  *
//  288  * @param       aff  - pointer to APS frame format
//  289  * @param       SrcAddress  - Source address
//  290  * @param       SrcPanId  - Source PAN ID
//  291  * @param       sig - incoming message's link quality
//  292  * @param       nwkSeqNum - incoming network sequence number (from nwk header frame)
//  293  * @param       SecurityUse - Security enable/disable
//  294  * @param       timestamp - the MAC Timer2 timestamp at Rx.
//  295  *
//  296  * @return      none
//  297  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  298 void afIncomingData( aps_FrameFormat_t *aff, zAddrType_t *SrcAddress, uint16 SrcPanId,
afIncomingData:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function afIncomingData
//  299                      NLDE_Signal_t *sig, uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp )
//  300 {
        FUNCALL afIncomingData, aps_FindGroupForEndpoint
        LOCFRAME CSTACK, 26, STACK
        FUNCALL afIncomingData, afFindEndPointDesc
        LOCFRAME CSTACK, 26, STACK
        FUNCALL afIncomingData, afFindEndPointDesc
        LOCFRAME CSTACK, 26, STACK
        FUNCALL afIncomingData, afFindEndPointDescList
        LOCFRAME CSTACK, 26, STACK
        FUNCALL afIncomingData, afFindEndPointDescList
        LOCFRAME CSTACK, 26, STACK
        FUNCALL afIncomingData
        LOCFRAME CSTACK, 26, STACK
        FUNCALL afIncomingData, osal_mem_free
        LOCFRAME CSTACK, 26, STACK
        FUNCALL afIncomingData, afBuildMSGIncoming
        LOCFRAME CSTACK, 36, STACK
        FUNCALL afIncomingData, aps_FindGroupForEndpoint
        LOCFRAME CSTACK, 26, STACK
        FUNCALL afIncomingData, afFindEndPointDesc
        LOCFRAME CSTACK, 26, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        PUSH.W  R13
          CFI CFA SP+22
        PUSH.W  R14
          CFI CFA SP+24
        PUSH.W  R15
          CFI CFA SP+26
        MOV.W   R12, R11
//  301   endPointDesc_t *epDesc = NULL;
//  302   epList_t *pList = epList;
        MOV.W   &epList, R8
//  303 #if !defined ( APS_NO_GROUPS )
//  304   uint8 grpEp = APS_GROUPS_EP_NOT_FOUND;
        MOV.B   #0xfe, R7
        MOV.B   R7, R9
//  305 #endif
//  306 
//  307   if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
        MOV.B   #0xc, R6
        MOV.B   R6, R14
        AND.B   @R12, R14
        CMP.B   R6, R14
        JNE     ??afIncomingData_7
//  308   {
//  309 #if !defined ( APS_NO_GROUPS )
//  310     // Find the first endpoint for this group
//  311     grpEp = aps_FindGroupForEndpoint( aff->GroupID, APS_GROUPS_FIND_FIRST );
        MOV.B   R7, R13
        CALLA   #?Subroutine1
//  312     if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
??CrossCallReturnLabel_0:
        JEQ     ??afIncomingData_6
//  313       return;   // No endpoint found
//  314 
//  315     epDesc = afFindEndPointDesc( grpEp );
        CALLA   #?Subroutine2
//  316     if ( epDesc == NULL )
??CrossCallReturnLabel_2:
        JNE     ??afIncomingData_8
//  317       return;   // Endpoint descriptor not found
        JMP     ??afIncomingData_6
//  318 
//  319     pList = afFindEndPointDescList( epDesc->endPoint );
//  320 #else
//  321     return; // Not supported
//  322 #endif
//  323   }
//  324   else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
??afIncomingData_7:
        MOV.B   0x2(R11), R12
        CMP.B   #0xff, R12
        JNE     ??afIncomingData_9
//  325   {
//  326     // Set the list
//  327     if ( pList != NULL )
        CMP.W   #0x0, R8
        JEQ     ??afIncomingData_6
//  328     {
//  329       epDesc = pList->epDesc;
        MOV.W   0x2(R8), R10
??afIncomingData_0:
        MOV.B   0x1a(SP), 0x1a(SP)
        MOV.B   0x1c(SP), R5
        MOV.W   0x1e(SP), 0x1e(SP)
        MOV.W   0x20(SP), 0x20(SP)
        JMP     ??afIncomingData_10
//  330     }
//  331   }
//  332   else if ( (epDesc = afFindEndPointDesc( aff->DstEndPoint )) )
??afIncomingData_9:
        CALLA   #?Subroutine2
??CrossCallReturnLabel_3:
        JEQ     ??afIncomingData_0
//  333   {
//  334     pList = afFindEndPointDescList( epDesc->endPoint );
??afIncomingData_8:
        MOV.B   @R10, R12
        CALLA   #afFindEndPointDescList
        MOV.W   R12, R8
        JMP     ??afIncomingData_0
//  335   }
//  336 
//  337   while ( epDesc )
//  338   {
//  339     uint16 epProfileID = 0xFFFF;  // Invalid Profile ID
//  340 
//  341     if ( pList->pfnDescCB )
//  342     {
//  343       uint16 *pID = (uint16 *)(pList->pfnDescCB(
//  344                                  AF_DESCRIPTOR_PROFILE_ID, epDesc->endPoint ));
//  345       if ( pID )
//  346       {
//  347         epProfileID = *pID;
//  348         osal_mem_free( pID );
//  349       }
//  350     }
//  351     else if ( epDesc->simpleDesc )
//  352     {
//  353       epProfileID = epDesc->simpleDesc->AppProfId;
//  354     }
//  355 
//  356     if ( (aff->ProfileID == epProfileID) ||
//  357          ((epDesc->endPoint == ZDO_EP) && (aff->ProfileID == ZDO_PROFILE_ID)) )
//  358     {
//  359       {
//  360         // Save original endpoint
//  361         uint8 endpoint = aff->DstEndPoint;
//  362 
//  363         // overwrite with descriptor's endpoint
//  364         aff->DstEndPoint = epDesc->endPoint;
//  365 
//  366         afBuildMSGIncoming( aff, epDesc, SrcAddress, SrcPanId, sig,
//  367                            nwkSeqNum, SecurityUse, timestamp );
//  368 
//  369         // Restore with original endpoint
//  370         aff->DstEndPoint = endpoint;
//  371       }
//  372     }
//  373 
//  374     if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
//  375     {
//  376 #if !defined ( APS_NO_GROUPS )
//  377       // Find the next endpoint for this group
//  378       grpEp = aps_FindGroupForEndpoint( aff->GroupID, grpEp );
//  379       if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
//  380         return;   // No endpoint found
//  381 
//  382       epDesc = afFindEndPointDesc( grpEp );
//  383       if ( epDesc == NULL )
//  384         return;   // Endpoint descriptor not found
//  385 
//  386       pList = afFindEndPointDescList( epDesc->endPoint );
//  387 #else
//  388       return;
//  389 #endif
//  390     }
//  391     else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
//  392     {
//  393       pList = pList->nextDesc;
//  394       if ( pList )
//  395         epDesc = pList->epDesc;
??afIncomingData_2:
        MOV.W   0x2(R8), R10
??afIncomingData_10:
        CMP.W   #0x0, R10
        JEQ     ??afIncomingData_6
        JMP     ??afIncomingData_11
??afIncomingData_1:
        MOV.B   @R10, R12
        CALLA   #afFindEndPointDescList
        MOV.W   R12, R8
??afIncomingData_11:
        MOV.W   #0xffff, R4
        MOV.W   0x4(R8), R14
        MOV.W   0x6(R8), R15
        MOV.W   R14, R13
        BIS.W   R15, R13
        CMP.W   #0x0, R13
        JEQ     ??afIncomingData_12
        MOV.B   @R10, R13
        MOV.B   #0x2, R12
        CALLA   #?IndCallR15
        CMP.W   #0x0, R12
        JEQ     ??afIncomingData_13
        MOV.W   @R12, R4
        CALLA   #osal_mem_free
        JMP     ??afIncomingData_13
??afIncomingData_12:
        MOV.W   0x4(R10), R15
        CMP.W   #0x0, R15
        JEQ     ??afIncomingData_13
        MOV.W   0x2(R15), R4
??afIncomingData_13:
        MOV.W   0x8(R11), R15
        MOV.B   @R10, R14
        CMP.W   R4, R15
        JEQ     ??afIncomingData_14
        CMP.B   #0x0, R14
        JNE     ??afIncomingData_15
        CMP.W   #0x0, R15
        JNE     ??afIncomingData_15
??afIncomingData_14:
        MOV.B   0x2(R11), R4
        MOV.B   R14, 0x2(R11)
        PUSH.W  0x22(SP)
          CFI CFA SP+28
        PUSH.W  0x22(SP)
          CFI CFA SP+30
        PUSH.B  R5
          CFI CFA SP+32
        PUSH.B  0x22(SP)
          CFI CFA SP+34
        PUSH.W  0xa(SP)
          CFI CFA SP+36
        MOV.W   0xc(SP), R15
        MOV.W   0xe(SP), R14
        MOV.W   R10, R13
        MOV.W   R11, R12
        CALLA   #afBuildMSGIncoming
        MOV.B   R4, 0x2(R11)
        ADD.W   #0xa, SP
          CFI CFA SP+26
??afIncomingData_15:
        MOV.B   R6, R14
        AND.B   @R11, R14
        CMP.B   R6, R14
        JNE     ??afIncomingData_16
        MOV.B   R9, R13
        CALLA   #?Subroutine1
??CrossCallReturnLabel_1:
        JEQ     ??afIncomingData_6
        CALLA   #?Subroutine2
??CrossCallReturnLabel_4:
        JNE     ??afIncomingData_1
        JMP     ??afIncomingData_6
??afIncomingData_16:
        CMP.B   #0xff, 0x2(R11)
        JNE     ??afIncomingData_6
        MOV.W   @R8, R8
        CMP.W   #0x0, R8
        JNE     ??afIncomingData_2
//  396       else
//  397         epDesc = NULL;
//  398     }
//  399     else
//  400       epDesc = NULL;
//  401   }
//  402 }
??afIncomingData_6:
        ADD.W   #0x6, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock7

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine2:
          CFI Block cfiCond8 Using cfiCommon0
          CFI Function afIncomingData
          CFI Conditional ??CrossCallReturnLabel_2
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+30
          CFI Block cfiCond9 Using cfiCommon0
          CFI (cfiCond9) Function afIncomingData
          CFI (cfiCond9) Conditional ??CrossCallReturnLabel_3
          CFI (cfiCond9) R4L Frame(CFA, -20)
          CFI (cfiCond9) R5L Frame(CFA, -18)
          CFI (cfiCond9) R6L Frame(CFA, -16)
          CFI (cfiCond9) R7L Frame(CFA, -14)
          CFI (cfiCond9) R8L Frame(CFA, -12)
          CFI (cfiCond9) R9L Frame(CFA, -10)
          CFI (cfiCond9) R10L Frame(CFA, -8)
          CFI (cfiCond9) R11L Frame(CFA, -6)
          CFI (cfiCond9) CFA SP+30
          CFI Block cfiCond10 Using cfiCommon0
          CFI (cfiCond10) Function afIncomingData
          CFI (cfiCond10) Conditional ??CrossCallReturnLabel_4
          CFI (cfiCond10) R4L Frame(CFA, -20)
          CFI (cfiCond10) R5L Frame(CFA, -18)
          CFI (cfiCond10) R6L Frame(CFA, -16)
          CFI (cfiCond10) R7L Frame(CFA, -14)
          CFI (cfiCond10) R8L Frame(CFA, -12)
          CFI (cfiCond10) R9L Frame(CFA, -10)
          CFI (cfiCond10) R10L Frame(CFA, -8)
          CFI (cfiCond10) R11L Frame(CFA, -6)
          CFI (cfiCond10) CFA SP+30
          CFI Block cfiPicker11 Using cfiCommon1
          CFI (cfiPicker11) NoFunction
          CFI (cfiPicker11) Picker
        CALLA   #afFindEndPointDesc
        MOV.W   R12, R10
        CMP.W   #0x0, R12
        RETA
          CFI EndBlock cfiCond8
          CFI EndBlock cfiCond9
          CFI EndBlock cfiCond10
          CFI EndBlock cfiPicker11

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine1:
          CFI Block cfiCond12 Using cfiCommon0
          CFI Function afIncomingData
          CFI Conditional ??CrossCallReturnLabel_0
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+30
          CFI Block cfiCond13 Using cfiCommon0
          CFI (cfiCond13) Function afIncomingData
          CFI (cfiCond13) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond13) R4L Frame(CFA, -20)
          CFI (cfiCond13) R5L Frame(CFA, -18)
          CFI (cfiCond13) R6L Frame(CFA, -16)
          CFI (cfiCond13) R7L Frame(CFA, -14)
          CFI (cfiCond13) R8L Frame(CFA, -12)
          CFI (cfiCond13) R9L Frame(CFA, -10)
          CFI (cfiCond13) R10L Frame(CFA, -8)
          CFI (cfiCond13) R11L Frame(CFA, -6)
          CFI (cfiCond13) CFA SP+30
          CFI Block cfiPicker14 Using cfiCommon1
          CFI (cfiPicker14) NoFunction
          CFI (cfiPicker14) Picker
        MOV.W   0x4(R11), R12
        CALLA   #aps_FindGroupForEndpoint
        MOV.B   R12, R9
        CMP.B   R7, R12
        RETA
          CFI EndBlock cfiCond12
          CFI EndBlock cfiCond13
          CFI EndBlock cfiPicker14
//  403 
//  404 /*********************************************************************
//  405  * @fn          afBuildMSGIncoming
//  406  *
//  407  * @brief       Build the message for the app
//  408  *
//  409  * @param
//  410  *
//  411  * @return      pointer to next in data buffer
//  412  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  413 static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
afBuildMSGIncoming:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function afBuildMSGIncoming
//  414                  zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig,
//  415                  uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp )
//  416 {
        FUNCALL afBuildMSGIncoming, osal_msg_allocate
        LOCFRAME CSTACK, 24, STACK
        FUNCALL afBuildMSGIncoming, afCopyAddress
        LOCFRAME CSTACK, 24, STACK
        FUNCALL afBuildMSGIncoming, osal_memcpy
        LOCFRAME CSTACK, 24, STACK
        FUNCALL afBuildMSGIncoming, osal_msg_send
        LOCFRAME CSTACK, 24, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        PUSH.W  R14
          CFI CFA SP+22
        PUSH.W  R15
          CFI CFA SP+24
        MOV.W   R12, R8
        MOV.W   R13, R9
        MOV.B   0x1a(SP), R6
        MOV.B   0x1c(SP), R7
        MOV.W   0x1e(SP), R10
        MOV.W   0x20(SP), R11
//  417   afIncomingMSGPacket_t *MSGpkt;
//  418   const uint8 len = sizeof( afIncomingMSGPacket_t ) + aff->asduLength;
//  419   uint8 *asdu = aff->asdu;
        MOV.W   0xe(R12), R4
//  420   MSGpkt = (afIncomingMSGPacket_t *)osal_msg_allocate( len );
        MOV.B   0x10(R8), R12
        ADD.B   #0x26, R12
        CALLA   #osal_msg_allocate
        MOV.W   R12, R5
//  421 
//  422   if ( MSGpkt == NULL )
        CMP.W   #0x0, R12
        JEQ     ??afBuildMSGIncoming_1
//  423   {
//  424     return;
//  425   }
//  426 
//  427   MSGpkt->hdr.event = AF_INCOMING_MSG_CMD;
        MOV.B   #0x1a, 0(R12)
//  428   MSGpkt->groupId = aff->GroupID;
        MOV.W   0x4(R8), 0x2(R12)
//  429   MSGpkt->clusterId = aff->ClusterID;
        MOV.W   0x6(R8), 0x4(R12)
//  430   afCopyAddress( &MSGpkt->srcAddr, SrcAddress );
        MOV.W   0x2(SP), R13
        ADD.W   #0x6, R12
        CALLA   #afCopyAddress
//  431   MSGpkt->srcAddr.endPoint = aff->SrcEndPoint;
        MOV.B   0x3(R8), 0xf(R5)
//  432   MSGpkt->endPoint = epDesc->endPoint;
        MOV.B   @R9, 0x14(R5)
//  433   MSGpkt->wasBroadcast = aff->wasBroadcast;
        MOV.B   0xc(R8), 0x15(R5)
        MOV.W   0x18(SP), R15
//  434   MSGpkt->LinkQuality = sig->LinkQuality;
        MOV.B   @R15, 0x16(R5)
//  435   MSGpkt->correlation = sig->correlation;
        MOV.B   0x1(R15), 0x17(R5)
//  436   MSGpkt->rssi = sig->rssi;
        MOV.B   0x2(R15), 0x18(R5)
//  437   MSGpkt->SecurityUse = SecurityUse;
        MOV.B   R7, 0x19(R5)
//  438   MSGpkt->timestamp = timestamp;
        MOV.W   R10, 0x1a(R5)
        MOV.W   R11, 0x1c(R5)
//  439   MSGpkt->nwkSeqNum = nwkSeqNum;
        MOV.B   R6, 0x1e(R5)
//  440   MSGpkt->macDestAddr = aff->macDestAddr;
        MOV.W   0xa(R8), 0x12(R5)
//  441   MSGpkt->srcAddr.panId = SrcPanId;
        MOV.W   @SP, 0x10(R5)
//  442   MSGpkt->cmd.TransSeqNumber = 0;
        MOV.B   #0x0, 0x20(R5)
//  443   MSGpkt->cmd.DataLength = aff->asduLength;
        MOV.B   0x10(R8), R14
        MOV.W   R14, 0x22(R5)
//  444 
//  445   if ( MSGpkt->cmd.DataLength )
        CMP.B   #0x0, R14
        JEQ     ??afBuildMSGIncoming_2
//  446   {
//  447     MSGpkt->cmd.Data = (uint8 *)(MSGpkt + 1);
        MOV.W   R5, R12
        ADD.W   #0x26, R12
        MOV.W   R12, 0x24(R5)
//  448     osal_memcpy( MSGpkt->cmd.Data, asdu, MSGpkt->cmd.DataLength );
        MOV.W   0x22(R5), R14
        MOV.W   R4, R13
        CALLA   #osal_memcpy
        JMP     ??afBuildMSGIncoming_3
//  449   }
//  450   else
//  451   {
//  452     MSGpkt->cmd.Data = NULL;
??afBuildMSGIncoming_2:
        MOV.W   #0x0, 0x24(R5)
//  453   }
//  454 
//  455 #if defined ( MT_AF_CB_FUNC )
//  456   // If ZDO or SAPI have registered for this endpoint, dont intercept it here
//  457   if (AFCB_CHECK(CB_ID_AF_DATA_IND, *(epDesc->task_id)))
//  458   {
//  459     MT_AfIncomingMsg( (void *)MSGpkt );
//  460     // Release the memory.
//  461     osal_msg_deallocate( (void *)MSGpkt );
//  462   }
//  463   else
//  464 #endif
//  465   {
//  466     // Send message through task message.
//  467     osal_msg_send( *(epDesc->task_id), (uint8 *)MSGpkt );
??afBuildMSGIncoming_3:
        MOV.W   R5, R13
        CALLA   #?Subroutine0
//  468   }
//  469 }
??afBuildMSGIncoming_1:
        ADD.W   #0x4, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock15
//  470 
//  471 /*********************************************************************
//  472  * @fn      AF_DataRequest
//  473  *
//  474  * @brief   Common functionality for invoking APSDE_DataReq() for both
//  475  *          SendMulti and MSG-Send.
//  476  *
//  477  * input parameters
//  478  *
//  479  * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
//  480  * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
//  481  * @param   cID - A valid cluster ID as specified by the Profile.
//  482  * @param   len - Number of bytes of data pointed to by next param.
//  483  * @param  *buf - A pointer to the data bytes to send.
//  484  * @param  *transID - A pointer to a byte which can be modified and which will
//  485  *                    be used as the transaction sequence number of the msg.
//  486  * @param   options - Valid bit mask of Tx options.
//  487  * @param   radius - Normally set to AF_DEFAULT_RADIUS.
//  488  *
//  489  * output parameters
//  490  *
//  491  * @param  *transID - Incremented by one if the return value is success.
//  492  *
//  493  * @return  afStatus_t - See previous definition of afStatus_... types.
//  494  */

        RSEG DATA16_I:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_copy
//  495 uint8 AF_DataRequestDiscoverRoute = TRUE;
AF_DataRequestDiscoverRoute:
        DS8 1
        REQUIRE `?<Initializer for AF_DataRequestDiscoverRoute>`

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  496 afStatus_t AF_DataRequest( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
AF_DataRequest:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function AF_DataRequest
//  497                            uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
//  498                            uint8 options, uint8 radius )
//  499 {
        FUNCALL AF_DataRequest, NLME_GetShortAddr
        LOCFRAME CSTACK, 54, STACK
        FUNCALL AF_DataRequest, RTG_CheckRtStatus
        LOCFRAME CSTACK, 54, STACK
        FUNCALL AF_DataRequest, NLME_IsAddressBroadcast
        LOCFRAME CSTACK, 54, STACK
        FUNCALL AF_DataRequest, sAddrExtCpy
        LOCFRAME CSTACK, 54, STACK
        FUNCALL AF_DataRequest
        LOCFRAME CSTACK, 54, STACK
        FUNCALL AF_DataRequest, osal_mem_free
        LOCFRAME CSTACK, 54, STACK
        FUNCALL AF_DataRequest, afDataReqMTU
        LOCFRAME CSTACK, 54, STACK
        FUNCALL AF_DataRequest
        LOCFRAME CSTACK, 54, STACK
        FUNCALL AF_DataRequest, APSDE_DataReq
        LOCFRAME CSTACK, 54, STACK
        FUNCALL AF_DataRequest, NLME_GetShortAddr
        LOCFRAME CSTACK, 54, STACK
        FUNCALL AF_DataRequest, afDataConfirm
        LOCFRAME CSTACK, 54, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        PUSH.W  R14
          CFI CFA SP+22
        SUB.W   #0x20, SP
          CFI CFA SP+54
        MOV.W   R12, R10
        MOV.W   R13, R11
        MOV.W   R15, R7
        MOV.W   0x36(SP), R5
        MOV.B   0x3c(SP), R4
//  500   pDescCB pfnDescCB;
//  501   ZStatus_t stat;
//  502   APSDE_DataReq_t req;
//  503   afDataReqMTU_t mtu;
//  504 
//  505   // Verify source end point
//  506   if ( srcEP == NULL )
        CMP.W   #0x0, R13
        JEQ     ??AF_DataRequest_2
        MOV.B   0x3a(SP), R8
//  507   {
//  508     return afStatus_INVALID_PARAMETER;
//  509   }
//  510 
//  511 #if !defined( REFLECTOR )
//  512   if ( dstAddr->addrMode == afAddrNotPresent )
//  513   {
//  514     return afStatus_INVALID_PARAMETER;
//  515   }
//  516 #endif
//  517 
//  518   // Check if route is available before sending data
//  519   if ( options & AF_LIMIT_CONCENTRATOR  )
        BIT.B   #0x8, R8
        JNC     ??AF_DataRequest_3
//  520   {
//  521     if ( dstAddr->addrMode != afAddr16Bit )
        CMP.B   #0x2, 0x8(R12)
        JNE     ??AF_DataRequest_2
//  522     {
//  523       return ( afStatus_INVALID_PARAMETER );
//  524     }
//  525 
//  526     // First, make sure the destination is not its self, then check for an existing route.
//  527     if ( (dstAddr->addr.shortAddr != NLME_GetShortAddr())
//  528         && (RTG_CheckRtStatus( dstAddr->addr.shortAddr, RT_ACTIVE, (MTO_ROUTE | NO_ROUTE_CACHE) ) != RTG_SUCCESS) )
        CALLA   #NLME_GetShortAddr
        MOV.W   R12, R15
        MOV.W   @R10, R12
        CMP.W   R15, R12
        JEQ     ??AF_DataRequest_3
        MOV.B   #0x3, R14
        MOV.B   #0x1, R13
        CALLA   #RTG_CheckRtStatus
        CMP.B   #0x0, R12
        JEQ     ??AF_DataRequest_3
//  529     {
//  530       // A valid route to a concentrator wasn't found
//  531       return ( afStatus_NO_ROUTE );
        MOV.B   #0xcd, R12
        JMP     ??AF_DataRequest_4
//  532     }
//  533   }
//  534 
//  535   // Validate broadcasting
//  536   if ( ( dstAddr->addrMode == afAddr16Bit     ) ||
//  537        ( dstAddr->addrMode == afAddrBroadcast )    )
??AF_DataRequest_3:
        MOV.B   0x8(R10), R14
        MOV.B   #0xf, R9
        CMP.B   #0x2, R14
        JEQ     ??AF_DataRequest_5
        CMP.B   R9, R14
        JNE     ??AF_DataRequest_6
//  538   {
//  539     // Check for valid broadcast values
//  540     if( ADDR_NOT_BCAST != NLME_IsAddressBroadcast( dstAddr->addr.shortAddr )  )
??AF_DataRequest_5:
        MOV.W   @R10, R12
        CALLA   #NLME_IsAddressBroadcast
        CMP.B   #0x0, R12
        JEQ     ??AF_DataRequest_7
//  541     {
//  542       // Force mode to broadcast
//  543       dstAddr->addrMode = afAddrBroadcast;
        MOV.B   R9, 0x8(R10)
//  544     }
//  545     else
//  546     {
//  547       // Address is not a valid broadcast type
//  548       if ( dstAddr->addrMode == afAddrBroadcast )
//  549       {
//  550         return afStatus_INVALID_PARAMETER;
//  551       }
//  552     }
//  553   }
//  554   else if ( dstAddr->addrMode != afAddr64Bit &&
//  555             dstAddr->addrMode != afAddrGroup &&
//  556             dstAddr->addrMode != afAddrNotPresent )
//  557   {
//  558     return afStatus_INVALID_PARAMETER;
//  559   }
//  560 
//  561   // Set destination address
//  562   req.dstAddr.addrMode = dstAddr->addrMode;
??AF_DataRequest_0:
        MOV.B   0x8(R10), 0xa(SP)
//  563   if ( dstAddr->addrMode == afAddr64Bit )
        MOV.W   SP, R6
        ADD.W   #0x2, R6
        CMP.B   #0x3, 0x8(R10)
        JNE     ??AF_DataRequest_8
//  564     osal_cpyExtAddr( req.dstAddr.addr.extAddr, dstAddr->addr.extAddr );
        MOV.W   R10, R13
        MOV.W   R6, R12
        CALLA   #sAddrExtCpy
        JMP     ??AF_DataRequest_9
??AF_DataRequest_7:
        CMP.B   R9, 0x8(R10)
        JNE     ??AF_DataRequest_0
        JMP     ??AF_DataRequest_2
??AF_DataRequest_6:
        CMP.B   #0x3, R14
        JEQ     ??AF_DataRequest_0
        CMP.B   #0x1, R14
        JEQ     ??AF_DataRequest_0
        CMP.B   #0x0, R14
        JEQ     ??AF_DataRequest_0
??AF_DataRequest_2:
        MOV.B   #0x2, R12
        JMP     ??AF_DataRequest_4
//  565   else
//  566     req.dstAddr.addr.shortAddr = dstAddr->addr.shortAddr;
??AF_DataRequest_8:
        MOV.W   @R10, 0x2(SP)
//  567 
//  568   req.profileID = ZDO_PROFILE_ID;
??AF_DataRequest_9:
        MOV.W   #0x0, 0x12(SP)
//  569 
//  570   if ( (pfnDescCB = afGetDescCB( srcEP )) )
        MOV.W   &epList, R15
        JMP     ??AF_DataRequest_10
??AF_DataRequest_1:
        MOV.W   @R15, R15
??AF_DataRequest_10:
        CMP.W   #0x0, R15
        JEQ     ??AF_DataRequest_11
        CMP.W   R11, 0x2(R15)
        JNE     ??AF_DataRequest_1
        MOV.W   0x4(R15), R14
        MOV.W   0x6(R15), R15
        MOV.W   R14, R13
        BIS.W   R15, R13
        CMP.W   #0x0, R13
        JEQ     ??AF_DataRequest_11
//  571   {
//  572     uint16 *pID = (uint16 *)(pfnDescCB(
//  573                                  AF_DESCRIPTOR_PROFILE_ID, srcEP->endPoint ));
        MOV.B   @R11, R13
        MOV.B   #0x2, R12
        CALLA   #?IndCallR15
//  574     if ( pID )
        CMP.W   #0x0, R12
        JEQ     ??AF_DataRequest_12
//  575     {
//  576       req.profileID = *pID;
        MOV.W   @R12, 0x12(SP)
//  577       osal_mem_free( pID );
        CALLA   #osal_mem_free
        JMP     ??AF_DataRequest_12
//  578     }
//  579   }
//  580   else if ( srcEP->simpleDesc )
??AF_DataRequest_11:
        MOV.W   0x4(R11), R15
        CMP.W   #0x0, R15
        JEQ     ??AF_DataRequest_12
//  581   {
//  582     req.profileID = srcEP->simpleDesc->AppProfId;
        MOV.W   0x2(R15), 0x12(SP)
//  583   }
//  584 
//  585   req.txOptions = 0;
??AF_DataRequest_12:
        MOV.W   #0x0, 0x18(SP)
//  586 
//  587   if ( ( options & AF_ACK_REQUEST              ) &&
//  588        ( req.dstAddr.addrMode != AddrBroadcast ) &&
//  589        ( req.dstAddr.addrMode != AddrGroup     )    )
        BIT.B   #0x10, R8
        JNC     ??AF_DataRequest_13
        MOV.B   0xa(SP), R14
        CMP.B   R9, R14
        JEQ     ??AF_DataRequest_13
        CMP.B   #0x1, R14
        JEQ     ??AF_DataRequest_13
//  590   {
//  591     req.txOptions |=  APS_TX_OPTIONS_ACK;
        MOV.W   #0x4, 0x18(SP)
//  592   }
//  593 
//  594   if ( options & AF_SKIP_ROUTING )
??AF_DataRequest_13:
        CMP.B   #0x0, R8
        JGE     ??AF_DataRequest_14
//  595   {
//  596     req.txOptions |=  APS_TX_OPTIONS_SKIP_ROUTING;
        BIS.W   #0x10, 0x18(SP)
//  597   }
//  598 
//  599   if ( options & AF_EN_SECURITY )
??AF_DataRequest_14:
        BIT.B   #0x40, R8
        JNC     ??AF_DataRequest_15
//  600   {
//  601     req.txOptions |= APS_TX_OPTIONS_SECURITY_ENABLE;
        BIS.W   #0x1, 0x18(SP)
//  602     mtu.aps.secure = TRUE;
        MOV.B   #0x1, 0x1(SP)
        JMP     ??AF_DataRequest_16
//  603   }
//  604   else
//  605   {
//  606     mtu.aps.secure = FALSE;
??AF_DataRequest_15:
        MOV.B   #0x0, 0x1(SP)
//  607   }
//  608 
//  609   if ( options & AF_PREPROCESS )
??AF_DataRequest_16:
        BIT.B   #0x4, R8
        JNC     ??AF_DataRequest_17
//  610   {
//  611     req.txOptions |=  APS_TX_OPTIONS_PREPROCESS;
        BIS.W   #0x40, 0x18(SP)
//  612   }
//  613 
//  614   mtu.kvp = FALSE;
??AF_DataRequest_17:
        MOV.B   #0x0, 0(SP)
        MOV.W   0x38(SP), R8
//  615 
//  616   req.transID       = *transID;
        MOV.B   @R8, 0x1a(SP)
//  617   req.srcEP         = srcEP->endPoint;
        MOV.B   @R11, 0xc(SP)
//  618   req.dstEP         = dstAddr->endPoint;
        MOV.B   0x9(R10), 0xd(SP)
//  619   req.clusterID     = cID;
        MOV.W   0x20(SP), 0x10(SP)
//  620   req.asduLen       = len;
        MOV.W   R7, 0x14(SP)
//  621   req.asdu          = buf;
        MOV.W   R5, 0x16(SP)
//  622   req.discoverRoute = AF_DataRequestDiscoverRoute;//(uint8)((options & AF_DISCV_ROUTE) ? 1 : 0);
        MOV.B   &AF_DataRequestDiscoverRoute, 0x1b(SP)
//  623   req.radiusCounter = radius;
        MOV.B   R4, 0x1c(SP)
//  624 #if defined ( INTER_PAN )
//  625   req.dstPanId      = dstAddr->panId;
//  626 
//  627   if ( StubAPS_InterPan( dstAddr->panId, dstAddr->endPoint ) )
//  628   {
//  629     if ( len > INTERP_DataReqMTU() )
//  630     {
//  631       stat = afStatus_INVALID_PARAMETER;
//  632     }
//  633     else
//  634     {
//  635       stat = INTERP_DataReq( &req );
//  636     }
//  637   }
//  638   else
//  639 #endif // INTER_PAN
//  640   {
//  641     if (len > afDataReqMTU( &mtu ) )
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #afDataReqMTU
        MOV.B   R12, R12
        CMP.W   R7, R12
        JC      ??AF_DataRequest_18
//  642     {
//  643       if (apsfSendFragmented)
        MOV.W   &apsfSendFragmented, R15
        BIS.W   &apsfSendFragmented + 2, R15
        CMP.W   #0x0, R15
        JEQ     ??AF_DataRequest_19
//  644       {
//  645         stat = (*apsfSendFragmented)( &req );
        MOV.W   R6, R12
        CALLA   &apsfSendFragmented
        JMP     ??AF_DataRequest_20
//  646       }
//  647       else
//  648       {
//  649         stat = afStatus_INVALID_PARAMETER;
??AF_DataRequest_19:
        MOV.B   #0x2, R10
        JMP     ??AF_DataRequest_21
//  650       }
//  651     }
//  652     else
//  653     {
//  654       stat = APSDE_DataReq( &req );
??AF_DataRequest_18:
        MOV.W   R6, R12
        CALLA   #APSDE_DataReq
??AF_DataRequest_20:
        MOV.B   R12, R10
//  655     }
//  656   }
//  657 
//  658   /*
//  659    * If this is an EndPoint-to-EndPoint message on the same device, it will not
//  660    * get added to the NWK databufs. So it will not go OTA and it will not get
//  661    * a MACCB_DATA_CONFIRM_CMD callback. Thus it is necessary to generate the
//  662    * AF_DATA_CONFIRM_CMD here. Note that APSDE_DataConfirm() only generates one
//  663    * message with the first in line TransSeqNumber, even on a multi message.
//  664    * Also note that a reflected msg will not have its confirmation generated
//  665    * here.
//  666    */
//  667   if ( (req.dstAddr.addrMode == Addr16Bit) &&
//  668        (req.dstAddr.addr.shortAddr == NLME_GetShortAddr()) )
??AF_DataRequest_21:
        CMP.B   #0x2, 0xa(SP)
        JNE     ??AF_DataRequest_22
        CALLA   #NLME_GetShortAddr
        CMP.W   R12, 0x2(SP)
        JNE     ??AF_DataRequest_22
//  669   {
//  670     afDataConfirm( srcEP->endPoint, *transID, stat );
        MOV.B   R10, R14
        MOV.B   @R8, R13
        MOV.B   @R11, R12
        CALLA   #afDataConfirm
//  671   }
//  672 
//  673   if ( stat == afStatus_SUCCESS )
??AF_DataRequest_22:
        CMP.B   #0x0, R10
        JNE     ??AF_DataRequest_23
//  674   {
//  675     (*transID)++;
        ADD.B   #0x1, 0(R8)
//  676   }
//  677 
//  678   return (afStatus_t)stat;
??AF_DataRequest_23:
        MOV.B   R10, R12
??AF_DataRequest_4:
        ADD.W   #0x22, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock16
//  679 }
//  680 
//  681 #if defined ( ZIGBEE_SOURCE_ROUTING )
//  682 /*********************************************************************
//  683  * @fn      AF_DataRequestSrcRtg
//  684  *
//  685  * @brief   Common functionality for invoking APSDE_DataReq() for both
//  686  *          SendMulti and MSG-Send.
//  687  *
//  688  * input parameters
//  689  *
//  690  * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
//  691  * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
//  692  * @param   cID - A valid cluster ID as specified by the Profile.
//  693  * @param   len - Number of bytes of data pointed to by next param.
//  694  * @param  *buf - A pointer to the data bytes to send.
//  695  * @param  *transID - A pointer to a byte which can be modified and which will
//  696  *                    be used as the transaction sequence number of the msg.
//  697  * @param   options - Valid bit mask of Tx options.
//  698  * @param   radius - Normally set to AF_DEFAULT_RADIUS.
//  699  * @param   relayCnt - Number of devices in the relay list
//  700  * @param   pRelayList - Pointer to the relay list
//  701  *
//  702  * output parameters
//  703  *
//  704  * @param  *transID - Incremented by one if the return value is success.
//  705  *
//  706  * @return  afStatus_t - See previous definition of afStatus_... types.
//  707  */
//  708 

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  709 afStatus_t AF_DataRequestSrcRtg( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
AF_DataRequestSrcRtg:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function AF_DataRequestSrcRtg
//  710                            uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
//  711                            uint8 options, uint8 radius, uint8 relayCnt, uint16* pRelayList )
//  712 {
        FUNCALL AF_DataRequestSrcRtg, RTG_AddSrcRtgEntry_Guaranteed
        LOCFRAME CSTACK, 20, STACK
        FUNCALL AF_DataRequestSrcRtg, AF_DataRequest
        LOCFRAME CSTACK, 28, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        MOV.W   R12, R10
        MOV.W   R13, R5
        MOV.W   R14, R4
        MOV.W   R15, R11
        MOV.W   0x14(SP), R8
        MOV.W   0x16(SP), R9
        MOV.B   0x18(SP), R6
        MOV.B   0x1a(SP), R7
        MOV.B   0x1c(SP), R13
        MOV.W   0x1e(SP), R14
//  713   uint8 status;
//  714 
//  715   /* Add the source route to the source routing table */
//  716   status = RTG_AddSrcRtgEntry_Guaranteed( dstAddr->addr.shortAddr, relayCnt,
//  717                                          pRelayList );
        MOV.W   @R10, R12
        CALLA   #RTG_AddSrcRtgEntry_Guaranteed
//  718 
//  719   if( status == RTG_SUCCESS)
        CMP.B   #0x0, R12
        JNE     ??AF_DataRequestSrcRtg_1
//  720   {
//  721     /* Call AF_DataRequest to send the data */
//  722     status = AF_DataRequest( dstAddr, srcEP, cID, len, buf, transID, options, radius );
        PUSH.B  R7
          CFI CFA SP+22
        PUSH.B  R6
          CFI CFA SP+24
        PUSH.W  R9
          CFI CFA SP+26
        PUSH.W  R8
          CFI CFA SP+28
        MOV.W   R11, R15
        MOV.W   R4, R14
        MOV.W   R5, R13
        MOV.W   R10, R12
        CALLA   #AF_DataRequest
        ADD.W   #0x8, SP
          CFI CFA SP+20
        JMP     ??AF_DataRequestSrcRtg_0
//  723   }
//  724   else if( status == RTG_INVALID_PATH )
??AF_DataRequestSrcRtg_1:
        CMP.B   #0x5, R12
        JEQ     ??AF_DataRequestSrcRtg_2
        MOV.B   #0x10, R12
        JMP     ??AF_DataRequestSrcRtg_0
??AF_DataRequestSrcRtg_2:
        MOV.B   #0x2, R12
//  725   {
//  726     /* The source route relay count is exceeding the network limit */
//  727     status = afStatus_INVALID_PARAMETER;
//  728   }
//  729   else
//  730   {
//  731     /* The guaranteed adding entry fails due to memory failure */
//  732     status = afStatus_MEM_FAIL;
//  733   }
//  734   return status;
??AF_DataRequestSrcRtg_0:
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock17
//  735 }
//  736 
//  737 #endif
//  738 
//  739 /*********************************************************************
//  740  * @fn      afFindEndPointDescList
//  741  *
//  742  * @brief   Find the endpoint description entry from the endpoint
//  743  *          number.
//  744  *
//  745  * @param   EndPoint - Application Endpoint to look for
//  746  *
//  747  * @return  the address to the endpoint/interface description entry
//  748  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  749 static epList_t *afFindEndPointDescList( uint8 EndPoint )
afFindEndPointDescList:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function afFindEndPointDescList
//  750 {
//  751   epList_t *epSearch;
//  752 
//  753   for (epSearch = epList; epSearch != NULL; epSearch = epSearch->nextDesc)
        MOV.W   &epList, R15
        JMP     ??afFindEndPointDescList_1
??afFindEndPointDescList_0:
        MOV.W   @R15, R15
??afFindEndPointDescList_1:
        CMP.W   #0x0, R15
        JEQ     ??afFindEndPointDescList_2
//  754   {
//  755     if (epSearch->epDesc->endPoint == EndPoint)
        MOV.W   0x2(R15), R14
        CMP.B   R12, 0(R14)
        JNE     ??afFindEndPointDescList_0
//  756     {
//  757       break;
//  758     }
//  759   }
//  760 
//  761   return epSearch;
??afFindEndPointDescList_2:
        MOV.W   R15, R12
        RETA
          CFI EndBlock cfiBlock18
//  762 }
//  763 
//  764 /*********************************************************************
//  765  * @fn      afFindEndPointDesc
//  766  *
//  767  * @brief   Find the endpoint description entry from the endpoint
//  768  *          number.
//  769  *
//  770  * @param   EndPoint - Application Endpoint to look for
//  771  *
//  772  * @return  the address to the endpoint/interface description entry
//  773  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  774 endPointDesc_t *afFindEndPointDesc( uint8 EndPoint )
afFindEndPointDesc:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function afFindEndPointDesc
//  775 {
//  776   epList_t *epSearch;
//  777 
//  778   // Look for the endpoint
//  779   epSearch = afFindEndPointDescList( EndPoint );
        FUNCALL afFindEndPointDesc, afFindEndPointDescList
        LOCFRAME CSTACK, 4, STACK
        CALLA   #afFindEndPointDescList
//  780 
//  781   if ( epSearch )
        CMP.W   #0x0, R12
        JEQ     ??afFindEndPointDesc_0
//  782     return ( epSearch->epDesc );
        MOV.W   0x2(R12), R12
        RETA
//  783   else
//  784     return ( (endPointDesc_t *)NULL );
??afFindEndPointDesc_0:
        MOV.W   #0x0, R12
        RETA
          CFI EndBlock cfiBlock19
//  785 }
//  786 
//  787 /*********************************************************************
//  788  * @fn      afFindSimpleDesc
//  789  *
//  790  * @brief   Find the Simple Descriptor from the endpoint number.
//  791  *
//  792  * @param   EP - Application Endpoint to look for.
//  793  *
//  794  * @return  Non-zero to indicate that the descriptor memory must be freed.
//  795  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  796 uint8 afFindSimpleDesc( SimpleDescriptionFormat_t **ppDesc, uint8 EP )
afFindSimpleDesc:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function afFindSimpleDesc
//  797 {
        FUNCALL afFindSimpleDesc, afFindEndPointDescList
        LOCFRAME CSTACK, 12, STACK
        FUNCALL afFindSimpleDesc
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R11
        MOV.B   R13, R10
//  798   epList_t *epItem = afFindEndPointDescList( EP );
        MOV.B   R13, R12
        CALLA   #afFindEndPointDescList
        MOV.W   R12, R15
//  799   uint8 rtrn = FALSE;
        MOV.B   #0x0, R12
//  800 
//  801   if ( epItem )
        CMP.W   #0x0, R15
        JEQ     ??afFindSimpleDesc_0
//  802   {
//  803     if ( epItem->pfnDescCB )
        MOV.W   0x4(R15), R8
        MOV.W   0x6(R15), R9
        MOV.W   R8, R14
        BIS.W   R9, R14
        CMP.W   #0x0, R14
        JEQ     ??afFindSimpleDesc_1
//  804     {
//  805       *ppDesc = epItem->pfnDescCB( AF_DESCRIPTOR_SIMPLE, EP );
        MOV.B   R10, R13
        MOV.B   #0x1, R12
        CALLA   #?IndCallR9
        MOV.W   R12, 0(R11)
//  806       rtrn = TRUE;
        MOV.B   #0x1, R12
        JMP     ??afFindSimpleDesc_2
//  807     }
//  808     else
//  809     {
//  810       *ppDesc = epItem->epDesc->simpleDesc;
??afFindSimpleDesc_1:
        MOV.W   0x2(R15), R15
        MOV.W   0x4(R15), 0(R11)
        JMP     ??afFindSimpleDesc_2
//  811     }
//  812   }
//  813   else
//  814   {
//  815     *ppDesc = NULL;
??afFindSimpleDesc_0:
        MOV.W   #0x0, 0(R11)
//  816   }
//  817 
//  818   return rtrn;
??afFindSimpleDesc_2:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock20
//  819 }
//  820 
//  821 /*********************************************************************
//  822  * @fn      afGetDescCB
//  823  *
//  824  * @brief   Get the Descriptor callback function.
//  825  *
//  826  * @param   epDesc - pointer to the endpoint descriptor
//  827  *
//  828  * @return  function pointer or NULL
//  829  */
//  830 static pDescCB afGetDescCB( endPointDesc_t *epDesc )
//  831 {
//  832   epList_t *epSearch;
//  833 
//  834   // Start at the beginning
//  835   epSearch = epList;
//  836 
//  837   // Look through the list until the end
//  838   while ( epSearch )
//  839   {
//  840     // Is there a match?
//  841     if ( epSearch->epDesc == epDesc )
//  842     {
//  843       return ( epSearch->pfnDescCB );
//  844     }
//  845     else
//  846       epSearch = epSearch->nextDesc;  // Next entry
//  847   }
//  848 
//  849   return ( (pDescCB)NULL );
//  850 }
//  851 
//  852 /*********************************************************************
//  853  * @fn      afDataReqMTU
//  854  *
//  855  * @brief   Get the Data Request MTU(Max Transport Unit).
//  856  *
//  857  * @param   fields - afDataReqMTU_t
//  858  *
//  859  * @return  uint8(MTU)
//  860  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  861 uint8 afDataReqMTU( afDataReqMTU_t* fields )
afDataReqMTU:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function afDataReqMTU
//  862 {
        FUNCALL afDataReqMTU, APSDE_DataReqMTU
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
//  863   uint8 len;
//  864   uint8 hdr;
//  865 
//  866   if ( fields->kvp == TRUE )
        CMP.B   #0x1, 0(R12)
        JEQ     ??afDataReqMTU_0
        MOV.B   #0x0, R10
        JMP     ??afDataReqMTU_1
??afDataReqMTU_0:
        MOV.B   #0x8, R10
//  867   {
//  868     hdr = AF_HDR_KVP_MAX_LEN;
//  869   }
//  870   else
//  871   {
//  872     hdr = AF_HDR_V1_1_MAX_LEN;
//  873   }
//  874 
//  875   len = (uint8)(APSDE_DataReqMTU(&fields->aps) - hdr);
//  876 
//  877   return len;
??afDataReqMTU_1:
        ADD.W   #0x1, R12
        CALLA   #APSDE_DataReqMTU
        SUB.B   R10, R12
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock21
//  878 }
//  879 
//  880 /*********************************************************************
//  881  * @fn      afGetMatch
//  882  *
//  883  * @brief   Set the allow response flag.
//  884  *
//  885  * @param   ep - Application Endpoint to look for
//  886  * @param   action - true - allow response, false - no response
//  887  *
//  888  * @return  TRUE allow responses, FALSE no response
//  889  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  890 uint8 afGetMatch( uint8 ep )
afGetMatch:
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function afGetMatch
//  891 {
//  892   epList_t *epSearch;
//  893 
//  894   // Look for the endpoint
//  895   epSearch = afFindEndPointDescList( ep );
        FUNCALL afGetMatch, afFindEndPointDescList
        LOCFRAME CSTACK, 4, STACK
        CALLA   #afFindEndPointDescList
//  896 
//  897   if ( epSearch )
        CMP.W   #0x0, R12
        JEQ     ??afGetMatch_0
//  898   {
//  899     if ( epSearch->flags & eEP_AllowMatch )
        BIT.B   #0x1, 0xa(R12)
        JNC     ??afGetMatch_0
//  900       return ( TRUE );
        MOV.B   #0x1, R12
        RETA
//  901     else
//  902       return ( FALSE );
//  903   }
//  904   else
//  905     return ( FALSE );
??afGetMatch_0:
        MOV.B   #0x0, R12
        RETA
          CFI EndBlock cfiBlock22
//  906 }
//  907 
//  908 /*********************************************************************
//  909  * @fn      afSetMatch
//  910  *
//  911  * @brief   Set the allow response flag.
//  912  *
//  913  * @param   ep - Application Endpoint to look for
//  914  * @param   action - true - allow response, false - no response
//  915  *
//  916  * @return  TRUE if success, FALSE if endpoint not found
//  917  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  918 uint8 afSetMatch( uint8 ep, uint8 action )
afSetMatch:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function afSetMatch
//  919 {
        FUNCALL afSetMatch, afFindEndPointDescList
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.B   R13, R10
//  920   epList_t *epSearch;
//  921 
//  922   // Look for the endpoint
//  923   epSearch = afFindEndPointDescList( ep );
        CALLA   #afFindEndPointDescList
//  924 
//  925   if ( epSearch )
        CMP.W   #0x0, R12
        JEQ     ??afSetMatch_0
//  926   {
//  927     if ( action )
        MOV.B   0xa(R12), R14
        CMP.B   #0x0, R10
        JEQ     ??afSetMatch_1
//  928     {
//  929       epSearch->flags |= eEP_AllowMatch;
        BIS.B   #0x1, R14
        JMP     ??afSetMatch_2
//  930     }
//  931     else
//  932     {
//  933       epSearch->flags &= (eEP_AllowMatch ^ 0xFFFF);
??afSetMatch_1:
        BIC.B   #0x1, R14
??afSetMatch_2:
        MOV.B   R14, 0xa(R12)
//  934     }
//  935     return ( TRUE );
        MOV.B   #0x1, R12
        JMP     ??afSetMatch_3
//  936   }
//  937   else
//  938     return ( FALSE );
??afSetMatch_0:
        MOV.B   #0x0, R12
??afSetMatch_3:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock23
//  939 }
//  940 
//  941 /*********************************************************************
//  942  * @fn      afNumEndPoints
//  943  *
//  944  * @brief   Returns the number of endpoints defined (including 0)
//  945  *
//  946  * @param   none
//  947  *
//  948  * @return  number of endpoints
//  949  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  950 uint8 afNumEndPoints( void )
afNumEndPoints:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function afNumEndPoints
//  951 {
//  952   epList_t *epSearch;
//  953   uint8 endpoints;
//  954 
//  955   // Start at the beginning
//  956   epSearch = epList;
        MOV.W   &epList, R15
//  957   endpoints = 0;
        MOV.B   #0x0, R12
        JMP     ??afNumEndPoints_1
//  958 
//  959   while ( epSearch )
//  960   {
//  961     endpoints++;
??afNumEndPoints_0:
        ADD.B   #0x1, R12
//  962     epSearch = epSearch->nextDesc;
        MOV.W   @R15, R15
//  963   }
??afNumEndPoints_1:
        CMP.W   #0x0, R15
        JNE     ??afNumEndPoints_0
//  964 
//  965   return ( endpoints );
        RETA
          CFI EndBlock cfiBlock24
//  966 }
//  967 
//  968 /*********************************************************************
//  969  * @fn      afEndPoints
//  970  *
//  971  * @brief   Fills in the passed in buffer with the endpoint (numbers).
//  972  *          Use afNumEndPoints to find out how big a buffer to supply.
//  973  *
//  974  * @param   epBuf - pointer to mem used
//  975  *
//  976  * @return  void
//  977  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  978 void afEndPoints( uint8 *epBuf, uint8 skipZDO )
afEndPoints:
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function afEndPoints
//  979 {
//  980   epList_t *epSearch;
//  981   uint8 endPoint;
//  982 
//  983   // Start at the beginning
//  984   epSearch = epList;
        MOV.W   &epList, R15
        JMP     ??afEndPoints_1
//  985 
//  986   while ( epSearch )
//  987   {
//  988     endPoint = epSearch->epDesc->endPoint;
??afEndPoints_0:
        MOV.W   0x2(R15), R14
        MOV.B   @R14, R14
//  989 
//  990     if ( !skipZDO || endPoint != 0 )
        CMP.B   #0x0, R13
        JEQ     ??afEndPoints_2
        CMP.B   #0x0, R14
        JEQ     ??afEndPoints_3
//  991       *epBuf++ = endPoint;
??afEndPoints_2:
        MOV.B   R14, 0(R12)
        ADD.W   #0x1, R12
//  992 
//  993     epSearch = epSearch->nextDesc;
??afEndPoints_3:
        MOV.W   @R15, R15
//  994   }
??afEndPoints_1:
        CMP.W   #0x0, R15
        JNE     ??afEndPoints_0
//  995 }
        RETA
          CFI EndBlock cfiBlock25
//  996 
//  997 /*********************************************************************
//  998  * @fn      afCopyAddress
//  999  *
// 1000  * @brief   Fills in the passed in afAddrType_t parameter with the corresponding information
// 1001  *          from the zAddrType_t parameter.
// 1002  *
// 1003  * @param   epBuf - pointer to mem used
// 1004  *
// 1005  * @return  void
// 1006  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1007 void afCopyAddress( afAddrType_t *afAddr, zAddrType_t *zAddr )
afCopyAddress:
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function afCopyAddress
// 1008 {
        FUNCALL afCopyAddress, sAddrExtCpy
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.W   R12, R10
// 1009   afAddr->addrMode = (afAddrMode_t)zAddr->addrMode;
        MOV.B   0x8(R13), 0x8(R12)
// 1010   if ( zAddr->addrMode == Addr64Bit )
        CMP.B   #0x3, 0x8(R13)
        JNE     ??afCopyAddress_0
// 1011   {
// 1012     (void)osal_cpyExtAddr( afAddr->addr.extAddr, zAddr->addr.extAddr );
        CALLA   #sAddrExtCpy
        JMP     ??afCopyAddress_1
// 1013   }
// 1014   else
// 1015   {
// 1016     afAddr->addr.shortAddr = zAddr->addr.shortAddr;
??afCopyAddress_0:
        MOV.W   @R13, 0(R12)
// 1017   }
// 1018 
// 1019   // Since zAddrType_t has no INTER-PAN information, set the panId member to zero.
// 1020   afAddr->panId = 0;
??afCopyAddress_1:
        MOV.W   #0x0, 0xa(R10)
// 1021 }
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock26
// 1022 
// 1023 /**************************************************************************************************
// 1024  * @fn          afAPSF_ConfigGet
// 1025  *
// 1026  * @brief       This function ascertains the fragmentation configuration that corresponds to
// 1027  *              the specified EndPoint.
// 1028  *
// 1029  * input parameters
// 1030  *
// 1031  * @param       endPoint - The source EP of a Tx or destination EP of a Rx fragmented message.
// 1032  *
// 1033  * output parameters
// 1034  *
// 1035  * @param       pCfg - A pointer to an APSF configuration structure to fill with values.
// 1036  *
// 1037  * @return      None.
// 1038  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1039 void afAPSF_ConfigGet(uint8 endPoint, afAPSF_Config_t *pCfg)
afAPSF_ConfigGet:
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function afAPSF_ConfigGet
// 1040 {
        FUNCALL afAPSF_ConfigGet, afFindEndPointDescList
        LOCFRAME CSTACK, 6, STACK
        FUNCALL afAPSF_ConfigGet, osal_memcpy
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.W   R13, R10
// 1041   epList_t *pList = afFindEndPointDescList(endPoint);
        CALLA   #afFindEndPointDescList
        MOV.W   R12, R13
// 1042 
// 1043   if (pList == NULL)
        CMP.W   #0x0, R12
        JNE     ??afAPSF_ConfigGet_0
// 1044   {
// 1045     pCfg->frameDelay = APSF_DEFAULT_INTERFRAME_DELAY;
        MOV.B   #0x32, 0(R10)
// 1046     pCfg->windowSize = APSF_DEFAULT_WINDOW_SIZE;
        MOV.B   #0x1, 0x1(R10)
        JMP     ??afAPSF_ConfigGet_1
// 1047   }
// 1048   else
// 1049   {
// 1050     (void)osal_memcpy(pCfg, &pList->apsfCfg, sizeof(afAPSF_Config_t));
??afAPSF_ConfigGet_0:
        MOV.W   #0x2, R14
        ADD.W   #0x8, R13
        MOV.W   R10, R12
        CALLA   #osal_memcpy
// 1051   }
// 1052 }
??afAPSF_ConfigGet_1:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock27
// 1053 
// 1054 /**************************************************************************************************
// 1055  * @fn          afAPSF_ConfigSet
// 1056  *
// 1057  * @brief       This function attempts to set the fragmentation configuration that corresponds to
// 1058  *              the specified EndPoint.
// 1059  *
// 1060  * input parameters
// 1061  *
// 1062  * @param       endPoint - The specific EndPoint for which to set the fragmentation configuration.
// 1063  * @param       pCfg - A pointer to an APSF configuration structure to fill with values.
// 1064  *
// 1065  * output parameters
// 1066  *
// 1067  * None.
// 1068  *
// 1069  * @return      afStatus_SUCCESS for success.
// 1070  *              afStatus_INVALID_PARAMETER if the specified EndPoint is not registered.
// 1071  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1072 afStatus_t afAPSF_ConfigSet(uint8 endPoint, afAPSF_Config_t *pCfg)
afAPSF_ConfigSet:
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function afAPSF_ConfigSet
// 1073 {
        FUNCALL afAPSF_ConfigSet, afFindEndPointDescList
        LOCFRAME CSTACK, 6, STACK
        FUNCALL afAPSF_ConfigSet, osal_memcpy
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.W   R13, R10
// 1074   epList_t *pList = afFindEndPointDescList(endPoint);
        CALLA   #afFindEndPointDescList
// 1075 
// 1076   if (pList == NULL)
        CMP.W   #0x0, R12
        JNE     ??afAPSF_ConfigSet_0
// 1077   {
// 1078     return afStatus_INVALID_PARAMETER;
        MOV.B   #0x2, R12
        JMP     ??afAPSF_ConfigSet_1
// 1079   }
// 1080 
// 1081   (void)osal_memcpy(&pList->apsfCfg, pCfg, sizeof(afAPSF_Config_t));
??afAPSF_ConfigSet_0:
        MOV.W   #0x2, R14
        MOV.W   R10, R13
        ADD.W   #0x8, R12
        CALLA   #osal_memcpy
// 1082   return afStatus_SUCCESS;
        MOV.B   #0x0, R12
??afAPSF_ConfigSet_1:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock28
// 1083 }

        RSEG DATA16_ID:CONST:SORT:NOROOT(0)
`?<Initializer for AF_DataRequestDiscoverRoute>`:
        DC8 1

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 1084 
// 1085 /**************************************************************************************************
// 1086 */
// 
// 1 626 bytes in segment CODE
//     1 byte  in segment DATA16_I
//     1 byte  in segment DATA16_ID
//     2 bytes in segment DATA16_Z
// 
// 1 626 bytes of CODE  memory
//     1 byte  of CONST memory
//     3 bytes of DATA  memory
//
//Errors: none
//Warnings: none

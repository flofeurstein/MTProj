###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       10/Jun/2013  16:30:20 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\ma #
#                     c\low_level\srf04\dual_chip\mac_dualchip.c              #
#    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\..\To #
#                     ols\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0      #
#                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                       #
#                     -DDEFAULT_CHANLIST=0x00000800                           #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100      #
#                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                   #
#                     -DBEACON_REQUEST_DELAY=100                              #
#                     -DBEACON_REQ_DELAY_MASK=0x00FF                          #
#                     -DLINK_STATUS_JITTER_MASK=0x007F                        #
#                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED= #
#                     3000 -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8  #
#                     -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2     #
#                     -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9              #
#                     -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40                #
#                     -DNWK_MAX_BINDING_ENTRIES=4                             #
#                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,       #
#                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,   #
#                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                    #
#                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=2 #
#                     0 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000           #
#                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100         #
#                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wRouter.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE=TR #
#                     UE -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8           #
#                     -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "C:\Texas              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC          #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)                #
#                     -DZCL_DEVICE_MGMT "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_lev #
#                     el\srf04\dual_chip\mac_dualchip.c" -D MSP430F2618 -D    #
#                     ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D    #
#                     LCD_SUPPORTED -lC "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\Router\List\" -lA        #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\Router\List\"  #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\Router\Obj\"   #
#                     --debug -D__MSP430F2618__ -e --double=32 --clib -I      #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\" -I           #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\..\Source\"    #
#                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\Sourc #
#                     e\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Proje #
#                     cts\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\. #
#                     .\ZMain\MSP2618\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\target\MSP2618CC2520\" -I "C:\Texas               #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\high_level\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\" -I "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\dual_chip\" -I "C:\Texas          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pr #
#                     ojects\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\. #
#                     .\..\..\..\Components\osal\include\" -I "C:\Texas       #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\osal\mcu\msp430\" -I "C:\Texas                        #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\saddr\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\sdata\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\af\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2520D #
#                     B\..\..\..\..\..\Components\stack\nwk\" -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sec\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sapi\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sys\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zcl\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zdo\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ #
#                     Projects\zstack\HomeAutomation\SampleSwitch\CC2520DB\.. #
#                     \..\..\..\..\Components\zmac\f8w\" --core=430X          #
#                     --data_model=small -Ohz --multiplier=16s                #
#                     --require_prototypes                                    #
#    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\Router\List\mac #
#                     _dualchip.lst                                           #
#    Object file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\Router\Obj\mac_ #
#                     dualchip.r43                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_level\srf04\dual_chip\mac_dualchip.c
      1          /**************************************************************************************************
      2            Filename:       mac_dualchip.c
      3            Revised:        $Date: 2011-07-12 09:54:47 -0700 (Tue, 12 Jul 2011) $
      4            Revision:       $Revision: 26749 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2011 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_types.h"
     47          #include "hal_mac_cfg.h"

   \                                 In  segment DATA16_AN, at 0x21
   \   unsigned char volatile P1OUT
   \                     P1OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x22
   \   unsigned char volatile P1DIR
   \                     P1DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x23
   \   unsigned char volatile P1IFG
   \                     P1IFG:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x24
   \   unsigned char volatile P1IES
   \                     P1IES:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x25
   \   unsigned char volatile P1IE
   \                     P1IE:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x26
   \   unsigned char volatile P1SEL
   \                     P1SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x30
   \   unsigned char const volatile P5IN
   \                     P5IN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x31
   \   unsigned char volatile P5OUT
   \                     P5OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x170
   \   unsigned short volatile TAR
   \                     TAR:
   \   000000                DS8 2
     48          
     49          /* high-level */
     50          #include "mac_pib.h"
     51          #include "mac_spec.h"
     52          
     53          /* exported low-level */
     54          #include "mac_low_level.h"
     55          
     56          /* low-level */
     57          #include "mac_spi.h"
     58          #include "mac_dualchip.h"
     59          #include "mac_sleep.h"
     60          #include "mac_rx.h"
     61          #include "mac_tx.h"
     62          #include "mac_rx_onoff.h"
     63          #include "mac_radio.h"
     64          #include "mac_backoff_timer.h"
     65          #include "mac_mcu_timer.h"
     66          #include "mac_dualchip_tx.h"
     67          
     68          /* radio sepcific */
     69          #include "mac_radio_defs.h"
     70          
     71          /* debug */
     72          #include "hal_board.h"
     73          #include "mac_assert.h"
     74          
     75          
     76          /* ------------------------------------------------------------------------------------------------
     77           *                                           Defines
     78           * ------------------------------------------------------------------------------------------------
     79           */
     80          #define RANDOM_POLY             0x1021
     81          #define RANDOM_TOP_MOST_BIT     0x8000
     82          
     83          /* calculation of phy bytes (actual over-the-air bytes) received per backoff */
     84          #define PHY_BYTES_PER_OCTET     1
     85          #define PHY_OCTETS_PER_SYMBOL   MAC_SPEC_OCTETS_PER_SYMBOL
     86          #define PHY_BYTES_PER_BACKOFF   (PHY_BYTES_PER_OCTET * PHY_OCTETS_PER_SYMBOL * MAC_A_UNIT_BACKOFF_PERIOD)
     87          
     88          
     89          /* ------------------------------------------------------------------------------------------------
     90           *                                        Local Prototypes
     91           * ------------------------------------------------------------------------------------------------
     92           */
     93          static void dualchipTurnOnRadioPowerVREG(void);
     94          
     95          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn);
     96          
     97          /* ------------------------------------------------------------------------------------------------
     98           *                                         Local Variables
     99           * ------------------------------------------------------------------------------------------------
    100           */

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    101          uint8          macChipVersion = 0;
   \                     macChipVersion:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    102          static uint16  random;
   \                     random:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    103          static uint8   frmfilt0 = (FRMFILT0_RESET_VALUE & ~MAX_FRAME_VERSION_MASK);
   \                     frmfilt0:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for frmfilt0>`

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    104          static int8    maxRssi;
   \                     maxRssi:
   \   000000                DS8 1
    105          
    106          #if (defined HAL_PA_LNA || defined HAL_PA_LNA_CC2590)
    107          uint8          macRxGain = 1;
    108          #endif
    109          
    110          /* Function pointer for the random seed callback */

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    111          static macRNGFcn_t pRandomSeedCB = NULL;
   \                     pRandomSeedCB:
   \   000000                DS8 4
    112          
    113          /**************************************************************************************************
    114           * @fn          MAC_SetRandomSeedCB
    115           *
    116           * @brief       Set the function pointer for the random seed callback.
    117           *
    118           * @param       pCBFcn - function pointer of the random seed callback
    119           *
    120           * @return      none
    121           **************************************************************************************************
    122           */

   \                                 In  segment CODE, align 2
    123          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn)
   \                     MAC_SetRandomSeedCB:
    124          {
    125            pRandomSeedCB = pCBFcn;
   \   000000   824C....     MOV.W   R12, &pRandomSeedCB
   \   000004   824D....     MOV.W   R13, &pRandomSeedCB + 2
    126          }
   \   000008   1001         RETA
    127          
    128          /**************************************************************************************************
    129           * @fn          macDualchipSystemInit
    130           *
    131           * @brief       Initialize all code dualchip system code.
    132           *
    133           * @param       none
    134           *
    135           * @return      none
    136           **************************************************************************************************
    137           */

   \                                 In  segment CODE, align 2
    138          void macDualchipSystemInit(void)
   \                     macDualchipSystemInit:
    139          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31801000     SUB.W   #0x10, SP
    140            /* initialize modules */
    141            halMacInit();
   \   000006   ........     CALLA   #halMacInit
    142            macMcuTimerInit();
   \   00000A   ........     CALLA   #macMcuTimerInit
    143            macSpiInit();
   \   00000E   ........     CALLA   #macSpiInit
    144          
    145            /* minimal power-up of radio chip */
    146            dualchipTurnOnRadioPowerVREG();
   \   000012   ........     CALLA   #dualchipTurnOnRadioPowerVREG
    147          
    148            /* make sure correct radio chip is attached */
    149            MAC_ASSERT(macSpiReadReg(CHIPID) == CHIPID_RESET_VALUE); /* incorrect radio chip or SPI not operating */
   \   000016   7C404000     MOV.B   #0x40, R12
   \   00001A   ........     CALLA   #macSpiReadReg
   \   00001E   7C908400     CMP.B   #0x84, R12
   \   000022   0224         JEQ     ??macDualchipSystemInit_2
   \   000024   ........     CALLA   #halAssertHandler
    150          
    151            /* Save the chip version for workarounds */
    152            macChipVersion = macSpiReadReg(VERSION);
   \                     ??macDualchipSystemInit_2:
   \   000028   7C404200     MOV.B   #0x42, R12
   \   00002C   ........     CALLA   #macSpiReadReg
   \   000030   C24C....     MOV.B   R12, &macChipVersion
    153          
    154           /*----------------------------------------------------------------------------------------------
    155            *  Initialize random seed value.
    156            */
    157          
    158            /*
    159             *  Set radio for infinite reception.  Once radio reaches this state,
    160             *  it will stay in receive mode regardless of RF activity.
    161             */
    162            macSpiWriteReg(FRMCTRL0, FRMCTRL0_RESET_VALUE | RX_MODE_INFINITE_RECEPTION);
   \   000034   7D404800     MOV.B   #0x48, R13
   \   000038   7C400C00     MOV.B   #0xc, R12
   \   00003C   ........     CALLA   #macSpiWriteReg
    163          
    164            /* turn on the receiver */
    165            macSpiCmdStrobe(SRXON);
   \   000040   7C404200     MOV.B   #0x42, R12
   \   000044   ........     CALLA   #macSpiCmdStrobe
    166          
    167            /*
    168             *  Wait for radio to reach infinite reception state.  Once it does,
    169             *  RANDOM command strobe can be used to generate random number.
    170             */
    171            while ((macSpiReadReg(FSMSTAT0) & FSM_FFCTRL_STATE_RX_MASK) != FSM_FFCTRL_STATE_RX_INF);
   \                     ??macDualchipSystemInit_0:
   \   000048   7C403200     MOV.B   #0x32, R12
   \   00004C   ........     CALLA   #macSpiReadReg
   \   000050   7CF03F00     AND.B   #0x3f, R12
   \   000054   7C901F00     CMP.B   #0x1f, R12
   \   000058   F723         JNE     ??macDualchipSystemInit_0
    172          
    173            /* use customized RANDOM strobe command to get random seed number */
    174            random = (macSpiRandomByte() << 8) + macSpiRandomByte();
   \   00005A   ........     CALLA   #macSpiRandomByte
   \   00005E   4A4C         MOV.B   R12, R10
   \   000060                RPT     #0x8
   \   000060   47180A5A     RLAX.W  R10
   \   000064   ........     CALLA   #macSpiRandomByte
   \   000068   4C4C         MOV.B   R12, R12
   \   00006A   0A5C         ADD.W   R12, R10
    175          
    176            /*
    177             *  The seed value must not be zero or 0xF01F.  If it is zero, the pseudo random sequence will 
    178             *  always be zero. If it is 0xF01F, the pseudo random sequence will always be 0xF01F.
    179             *  There is an extremely small chance this seed could randomly be zero (more likely some type of
    180             *  hardware problem would cause this).  The following check makes sure this does not happen.
    181             */
    182            if (random == 0x0000 || random == 0xF01F)
   \   00006C   0324         JEQ     ??macDualchipSystemInit_3
   \   00006E   3A901FF0     CMP.W   #0xf01f, R10
   \   000072   0220         JNE     ??macDualchipSystemInit_4
    183            {
    184              random = 0xBEEF; /* completely arbitrary "random" value */
   \                     ??macDualchipSystemInit_3:
   \   000074   3A40EFBE     MOV.W   #0xbeef, R10
   \                     ??macDualchipSystemInit_4:
   \   000078   824A....     MOV.W   R10, &random
    185            }
    186          
    187            /* Read 16*8 random bits and store them in flash for future use in random
    188               key generation for CBKE key establishment */
    189            if( pRandomSeedCB )
   \   00007C   1F42....     MOV.W   &pRandomSeedCB, R15
   \   000080   1FD2....     BIS.W   &pRandomSeedCB + 2, R15
   \   000084   0F93         CMP.W   #0x0, R15
   \   000086   0F24         JEQ     ??macDualchipSystemInit_5
    190            {
    191              uint8 randomSeed[MAC_RANDOM_SEED_LEN];
    192              uint8 i;
    193          
    194              for(i = 0; i < 16; i++)
   \   000088   4A43         MOV.B   #0x0, R10
    195              {
    196                randomSeed[i] = macSpiRandomByte();
   \                     ??macDualchipSystemInit_1:
   \   00008A   ........     CALLA   #macSpiRandomByte
   \   00008E   4F4A         MOV.B   R10, R15
   \   000090   0F51         ADD.W   SP, R15
   \   000092   CF4C0000     MOV.B   R12, 0(R15)
    197              }
   \   000096   5A53         ADD.B   #0x1, R10
   \   000098   7A901000     CMP.B   #0x10, R10
   \   00009C   F62B         JNC     ??macDualchipSystemInit_1
    198              pRandomSeedCB( randomSeed );
   \   00009E   0C41         MOV.W   SP, R12
   \   0000A0   0C53         ADD.W   #0x0, R12
   \   0000A2   ........     CALLA   &pRandomSeedCB
    199            }
    200            /*----------------------------------------------------------------------------------------------
    201             */
    202          
    203            /*
    204             *  No need to turn off the receiver or to exit infinite receptin mode.
    205             *  The entire radio chip is about to be turned off.
    206             */
    207          
    208            /* turn radio back off */
    209            macDualchipTurnOffRadioPower();
   \                     ??macDualchipSystemInit_5:
   \   0000A6   ........     CALLA   #macDualchipTurnOffRadioPower
    210          }
   \   0000AA   31501000     ADD.W   #0x10, SP
   \   0000AE   3A41         POP.W   R10
   \   0000B0   1001         RETA
    211          
    212          
    213          /**************************************************************************************************
    214           * @fn          macDualchipRandomByte
    215           *
    216           * @brief       Returns a random byte.  Initialization for random the random generation is
    217           *              performed by the module initialization function.
    218           *
    219           * @param       none
    220           *
    221           * @return      a random byte
    222           **************************************************************************************************
    223           */

   \                                 In  segment CODE, align 2
    224          uint8 macDualchipRandomByte(void)
   \                     macDualchipRandomByte:
    225          {
    226            uint8 i;
    227          
    228            for (i=0; i<8; i++)
   \   000000   ........     CALLA   #?Subroutine2
    229            {
    230              if (random & RANDOM_TOP_MOST_BIT)
    231              {
    232                random = (random << 1) ^ RANDOM_POLY;
    233              }
    234              else
    235              {
    236                random = (random << 1);
    237              }
    238            }
    239          
    240            return (random & 0xFF);
   \                     ??CrossCallReturnLabel_1:
   \   000004   4C4F         MOV.B   R15, R12
   \   000006   1001         RETA
    241          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   1F42....     MOV.W   &random, R15
   \   000004   7E42         MOV.B   #0x8, R14
   \                     ??macDualchipRandomWord_0:
   \   000006   0D4F         MOV.W   R15, R13
   \   000008   0D5D         RLA.W   R13
   \   00000A   0F93         CMP.W   #0x0, R15
   \   00000C   0F4D         MOV.W   R13, R15
   \   00000E   0234         JGE     ??macDualchipRandomWord_1
   \   000010   3FE02110     XOR.W   #0x1021, R15
   \                     ??macDualchipRandomWord_1:
   \   000014   7E53         ADD.B   #0xff, R14
   \   000016   F723         JNE     ??macDualchipRandomWord_0
   \   000018   824F....     MOV.W   R15, &random
   \   00001C   1001         RETA
    242          
    243          /**************************************************************************************************
    244           * @fn          macDualchipRandomWord
    245           *
    246           * @brief       Returns a random word.  Initialization for random the random generation is
    247           *              performed by the module initialization function.
    248           *
    249           * @param       none
    250           *
    251           * @return      a random word
    252           **************************************************************************************************
    253           */

   \                                 In  segment CODE, align 2
    254          uint16 macDualchipRandomWord(void)
   \                     macDualchipRandomWord:
    255          {
    256            uint8 i;
    257          
    258            for (i=0; i<8; i++)
   \   000000   ........     CALLA   #?Subroutine2
    259            {
    260              if (random & RANDOM_TOP_MOST_BIT)
    261              {
    262                random = (random << 1) ^ RANDOM_POLY;
    263              }
    264              else
    265              {
    266                random = (random << 1);
    267              }
    268            }
    269          
    270            return (random);
   \                     ??CrossCallReturnLabel_0:
   \   000004   0C4F         MOV.W   R15, R12
   \   000006   1001         RETA
    271          }
    272          
    273          
    274          /**************************************************************************************************
    275           * @fn          macDualchipOrFRMFILT0
    276           *
    277           * @brief       Specialized function that OR's bits into the FRMFILT0 register.  A shadow register
    278           *              for FRMFILT0 is maintained so only a register write, instead of a costly
    279           *              read-modify-write, is necessary.
    280           *
    281           * @param       bit - value to 'OR' into FRMFILT0 register
    282           *
    283           * @return      none
    284           **************************************************************************************************
    285           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   5D42....     MOV.B   &frmfilt0, R13
   \   000004   4C43         MOV.B   #0x0, R12
   \   000006   ........     BRA     #macSpiWriteReg

   \                                 In  segment CODE, align 2
    286          void macDualchipOrFRMFILT0(uint8 bit)
   \                     macDualchipOrFRMFILT0:
    287          {
    288            frmfilt0 |= bit;
   \   000000   C2DC....     BIS.B   R12, &frmfilt0
    289            macSpiWriteReg(FRMFILT0, frmfilt0);
   \   000004   ....         JMP     ?Subroutine1
    290          }
    291          
    292          
    293          /**************************************************************************************************
    294           * @fn          macDualchipAndFRMFILT0
    295           *
    296           * @brief       Specialized function that AND's bits into the FRMFILT0 register.  A shadow register
    297           *              for FRMFILT0 is  maintained so only a register write, instead of a costly
    298           *              read-modify-write, is necessary.
    299           *
    300           * @param       bit - value to 'AND' into FRMFILT0 register
    301           *
    302           * @return      none
    303           **************************************************************************************************
    304           */

   \                                 In  segment CODE, align 2, keep-with-next
    305          void macDualchipAndFRMFILT0(uint8 bit)
   \                     macDualchipAndFRMFILT0:
    306          {
    307            frmfilt0 &= bit;
   \   000000   C2FC....     AND.B   R12, &frmfilt0
    308            macSpiWriteReg(FRMFILT0, frmfilt0);
   \   000004                REQUIRE ?Subroutine1
   \   000004                // Fall through to label ?Subroutine1
    309          }
    310          
    311          
    312          /**************************************************************************************************
    313           * @fn          macDualchipTurnOnRadioPower
    314           *
    315           * @brief       Logic and sequence for powering up the radio.
    316           *
    317           * @param       none
    318           *
    319           * @return      none
    320           **************************************************************************************************
    321           */

   \                                 In  segment CODE, align 2
    322          void macDualchipTurnOnRadioPower(void)
   \                     macDualchipTurnOnRadioPower:
    323          {
    324            /* enable power to the radio chip */
    325            dualchipTurnOnRadioPowerVREG();
   \   000000   ........     CALLA   #dualchipTurnOnRadioPowerVREG
    326          
    327            /* configure GPIOs */
    328          
    329            /* There is a 2520 chip bug (#657, #1388) that causes undesirable behaviour
    330             * when reconfiguring a 2520 GPIO pin from output to input pin. There is a
    331             * software workaround for that. In the following sequence, we are just
    332             * changing the signals coming out on these pin but their direction are same
    333             * as the reset values. So the workaround is not needed.
    334             *
    335             * However if this is remapped again, see the previous version of this file
    336             * for an example of the workaround.
    337             */
    338          
    339            /* GPIO0 is high when TX_ACK_DONE or TX_FRM_DONE using exception channel A */
    340            macSpiWriteReg( EXCMASKA0,  TX_FRM_DONE_BIT       |  TX_ACK_DONE_BIT        );
   \   000004   7D400600     MOV.B   #0x6, R13
   \   000008   7C401400     MOV.B   #0x14, R12
   \   00000C   ........     CALLA   #macSpiWriteReg
    341            macSpiWriteReg( GPIOCTRL0,  GPIO_DIR_RADIO_OUTPUT |  EXCEPTION_CHANNEL_A    );
   \   000010   7D402100     MOV.B   #0x21, R13
   \   000014   7C402000     MOV.B   #0x20, R12
   \   000018   ........     CALLA   #macSpiWriteReg
    342          
    343            macSpiWriteReg( GPIOCTRL1,  GPIO_DIR_RADIO_OUTPUT |  EXCEPTION_RFC_FIFO     );
   \   00001C   7D402700     MOV.B   #0x27, R13
   \   000020   7C402100     MOV.B   #0x21, R12
   \   000024   ........     CALLA   #macSpiWriteReg
    344            macSpiWriteReg( GPIOCTRL2,  GPIO_DIR_RADIO_OUTPUT |  EXCEPTION_RFC_FIFOP    );
   \   000028   7D402800     MOV.B   #0x28, R13
   \   00002C   7C402200     MOV.B   #0x22, R12
   \   000030   ........     CALLA   #macSpiWriteReg
    345          
    346          #if (defined HAL_PA_LNA || defined HAL_PA_LNA_CC2590)
    347            
    348            /* PA/LNA register configurations. Note that the settings for GPIOCTRL4 and
    349             * GPIOCTRL5 are not documented in the datasheet.
    350             *
    351             * GPIOCTRL3    = 0x7F (HGM per macRxGain)
    352             * GPIOCTRL4    = 0x46 (EN set to lna_pd[1] inverted)
    353             * GPIOCTRL5    = 0x47 (PAEN set to pa_pd inverted)
    354             * GPIOPOLARITY = 0x0F (invert GPIO4 and GPIO5)
    355             */
    356            if (macRxGain == 1)
    357            {
    358              macSpiWriteReg( GPIOCTRL3, GPIO_DIR_RADIO_OUTPUT | 0x7F );
    359          
    360              /* Sets CCA threshold to -70dBm */
    361              macSpiWriteReg( CCACTRL0, 0x06 );
    362            }
    363            else
    364            {
    365              macSpiWriteReg( GPIOCTRL3, GPIO_DIR_RADIO_OUTPUT | 0x7E );
    366              
    367              /* Sets CCA threshold to -80dBm nominally */
    368              macSpiWriteReg( CCACTRL0, 0xFC );
    369            }
    370            macSpiWriteReg( GPIOCTRL4, GPIO_DIR_RADIO_OUTPUT | 0x46 );
    371            macSpiWriteReg( GPIOCTRL5, GPIO_DIR_RADIO_OUTPUT | 0x47 );
    372            macSpiWriteReg( GPIOPOLARITY, 0x0F );
    373          
    374            /* Increased AGC target gain. Fixed packet loss at some input levels - with PA/LNA */
    375            macSpiWriteReg( AGCCTRL1, 0x16 );
    376            
    377          #else
    378            
    379            /* SFD is required for Beacon mode */
    380            macSpiWriteReg( GPIOCTRL4,  GPIO_DIR_RADIO_OUTPUT |  EXCEPTION_RFC_SFD_SYNC );
   \   000034   7D402A00     MOV.B   #0x2a, R13
   \   000038   7C402400     MOV.B   #0x24, R12
   \   00003C   ........     CALLA   #macSpiWriteReg
    381          
    382            /* Configure CC2520 GPIO controls (GPIOCTRL3, GPIOCTRL5) for Sniffer mode.
    383             * Beacon related GPIOs will be turned on after the first beacon transmission.
    384             */
    385            HAL_MAC_CONFIG_SNIFFER_MODE_PINS();
   \   000040   F2C080002200 BIC.B   #0x80, &0x22
   \   000046   F2C080002600 BIC.B   #0x80, &0x26
   \   00004C   7D403200     MOV.B   #0x32, R13
   \   000050   7C402300     MOV.B   #0x23, R12
   \   000054   ........     CALLA   #macSpiWriteReg
   \   000058   7D403100     MOV.B   #0x31, R13
   \   00005C   7C402500     MOV.B   #0x25, R12
   \   000060   ........     CALLA   #macSpiWriteReg
    386          
    387            /* Increased AGC target gain. Fixed packet loss at some input levels - without PA/LNA */
    388            macSpiWriteReg( AGCCTRL1, 0x11 );
   \   000064   7D401100     MOV.B   #0x11, R13
   \   000068   7C405300     MOV.B   #0x53, R12
   \   00006C   ........     CALLA   #macSpiWriteReg
    389            
    390            /* Sets CCA threshold to -80dBm nominally */
    391            macSpiWriteReg( CCACTRL0, 0xFC );  
   \   000070   7D40FC00     MOV.B   #0xfc, R13
   \   000074   7C403600     MOV.B   #0x36, R12
   \   000078   ........     CALLA   #macSpiWriteReg
    392            
    393          #endif
    394          
    395            /* For best sensitivity and noise (false packets) immunity  */
    396            macSpiWriteReg( MDMCTRL0, 0x85 );
   \   00007C   7D408500     MOV.B   #0x85, R13
   \   000080   7C404600     MOV.B   #0x46, R12
   \   000084   ........     CALLA   #macSpiWriteReg
    397            macSpiWriteReg( MDMCTRL1, 0x14 );
   \   000088   7D401400     MOV.B   #0x14, R13
   \   00008C   7C404700     MOV.B   #0x47, R12
   \   000090   ........     CALLA   #macSpiWriteReg
    398          
    399            /* For best sensitivity */
    400            macSpiWriteReg( RXCTRL, 0x3F );
   \   000094   7D403F00     MOV.B   #0x3f, R13
   \   000098   7C404A00     MOV.B   #0x4a, R12
   \   00009C   ........     CALLA   #macSpiWriteReg
    401          
    402            /* For better sensitivity and improved lock stability at high temp */
    403            macSpiWriteReg( FSCTRL, 0x5A );
   \   0000A0   7D405A00     MOV.B   #0x5a, R13
   \   0000A4   7C404C00     MOV.B   #0x4c, R12
   \   0000A8   ........     CALLA   #macSpiWriteReg
    404          
    405            /* For better EVM and improved lock stability at high temp */
    406            macSpiWriteReg( FSCAL1, 0x2B );
   \   0000AC   7D402B00     MOV.B   #0x2b, R13
   \   0000B0   7C404F00     MOV.B   #0x4f, R12
   \   0000B4   ........     CALLA   #macSpiWriteReg
    407          
    408            /* For best sensitivity */
    409            macSpiWriteReg( ADCTEST0, 0x10 );
   \   0000B8   7D401000     MOV.B   #0x10, R13
   \   0000BC   7C405600     MOV.B   #0x56, R12
   \   0000C0   ........     CALLA   #macSpiWriteReg
    410          
    411            /* For stable ADC, and best RSSI performance */
    412            macSpiWriteReg( ADCTEST1, 0x0E );
   \   0000C4   7D400E00     MOV.B   #0xe, R13
   \   0000C8   7C405700     MOV.B   #0x57, R12
   \   0000CC   ........     CALLA   #macSpiWriteReg
    413          
    414            /* For stable ADC */
    415            macSpiWriteReg( ADCTEST2, 0x03 );
   \   0000D0   7D400300     MOV.B   #0x3, R13
   \   0000D4   7C405800     MOV.B   #0x58, R12
   \   0000D8   ........     CALLA   #macSpiWriteReg
    416          
    417            /* turn off source address pending match feature */
    418            MAC_RADIO_TURN_OFF_SRC_MATCH();
   \   0000DC   7D400600     MOV.B   #0x6, R13
   \   0000E0   6C43         MOV.B   #0x2, R12
   \   0000E2   ........     CALLA   #macSpiWriteReg
    419          
    420            /* restore radio values lost when chip is powered down */
    421            macRadioSetChannel(macPib.logicalChannel);
   \   0000E6   5C42....     MOV.B   &macPib + 52, R12
   \   0000EA   ........     CALLA   #macRadioSetChannel
    422            macRadioSetTxPower(macPib.phyTransmitPower);
   \   0000EE   5C42....     MOV.B   &macPib + 51, R12
   \   0000F2   ........     CALLA   #macRadioSetTxPower
    423            macRadioSetPanCoordinator(macPanCoordinator);
   \   0000F6   5C42....     MOV.B   &macPanCoordinator, R12
   \   0000FA   ........     CALLA   #macRadioSetPanCoordinator
    424            macRadioSetPanID(macPib.panId);
   \   0000FE   1C42....     MOV.W   &macPib + 32, R12
   \   000102   ........     CALLA   #macRadioSetPanID
    425            macRadioSetShortAddr(macPib.shortAddress);
   \   000106   1C42....     MOV.W   &macPib + 36, R12
   \   00010A   ........     CALLA   #macRadioSetShortAddr
    426            macRadioSetIEEEAddr(macPib.extendedAddress.addr.extAddr);
   \   00010E   3C40....     MOV.W   #macPib + 54, R12
   \   000112   ........     CALLA   #macRadioSetIEEEAddr
    427          
    428            /* Turn on autoack. All frames that are accepted by address filtering, have the acknowledge request
    429             * flag set and have a valid CRC, are automatically acknowledged 12 symbol periods after being received.
    430             */
    431            MAC_RADIO_TURN_ON_AUTO_ACK();
   \   000116   7D406000     MOV.B   #0x60, R13
   \   00011A   7C400C00     MOV.B   #0xc, R12
   \   00011E   ........     CALLA   #macSpiWriteReg
    432          
    433            /* Turn on Frame Filter */
    434            MAC_RADIO_TURN_ON_RX_FRAME_FILTERING();
   \   000122   7C400500     MOV.B   #0x5, R12
   \   000126   ........     CALLA   #macDualchipOrFRMFILT0
    435          
    436            /* Prepare TX_ACK_DONE and TX_FRM_DONE shared interrupt */
    437            MAC_RADIO_CLEAR_TX_ACK_AND_TX_FRM_DONE_PIN();
   \   00012A   7D40F900     MOV.B   #0xf9, R13
   \   00012E   7C401000     MOV.B   #0x10, R12
   \   000132   ........     CALLA   #macSpiWriteReg
    438            HAL_MAC_CLEAR_TX_ACK_DONE_INT_FLAG();
   \   000136   F2C22300     BIC.B   #0x8, &0x23
    439            HAL_MAC_ENABLE_TX_ACK_DONE_INT();
   \   00013A   F2D22500     BIS.B   #0x8, &0x25
    440            
    441            /* enable rx overflow interrupt on falling edge */
    442            HAL_MAC_ENABLE_FIFO_INT();
   \   00013E   F2D020002500 BIS.B   #0x20, &0x25
    443            HAL_MAC_CONFIG_FIFO_FALLING_EDGE_INT();
   \   000144   F2D020002400 BIS.B   #0x20, &0x24
    444          }
   \   00014A   1001         RETA
   \   00014C                REQUIRE P1DIR
   \   00014C                REQUIRE P1SEL
   \   00014C                REQUIRE P1IFG
   \   00014C                REQUIRE P1IE
   \   00014C                REQUIRE P1IES
    445          
    446          
    447          /*=================================================================================================
    448           * @fn          dualchipEnableVREG
    449           *
    450           * @brief       Sequence for enabling power to the radio chip.  Oscillator is
    451           *              automatically when VREG is turned on.
    452           *
    453           * @param       none
    454           *
    455           * @return      none
    456           *=================================================================================================
    457           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   D2C33100     BIC.B   #0x1, &0x31
   \                     ??macDualchipTurnOnRadioOscillator_0:
   \   000004   E2B23000     BIT.B   #0x4, &0x30
   \   000008   FD2B         JNC     ??macDualchipTurnOnRadioOscillator_0
   \   00000A   D2D33100     BIS.B   #0x1, &0x31
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2
    458          static void dualchipTurnOnRadioPowerVREG(void)
   \                     dualchipTurnOnRadioPowerVREG:
    459          {
    460            MAC_ASSERT(macSpiRadioPower == MAC_SPI_RADIO_POWER_OFF);
   \   000000   C293....     CMP.B   #0x0, &macSpiRadioPower
   \   000004   ........     CALLA   #?Subroutine4
    461            MAC_ASSERT_STATEMENT( macSpiRadioPower = MAC_SPI_RADIO_POWER_VREG_ON | MAC_SPI_RADIO_POWER_OSC_ON; );
    462          
    463            /* put radio chip into reset */
    464            HAL_MAC_DRIVE_RESETN_PIN_LOW();
   \                     ??CrossCallReturnLabel_6:
   \   000008   F2C080003100 BIC.B   #0x80, &0x31
    465          
    466            /* enable the voltage regulator */
    467            HAL_MAC_DRIVE_VREG_EN_PIN_HIGH();
   \   00000E   D2D32100     BIS.B   #0x1, &0x21
    468          
    469            /* wait for the chip to power up */
    470            MAC_MCU_TIMER_WAIT_USECS( HAL_MAC_VREG_SETTLE_TIME_USECS );
   \   000012   92427001.... MOV.W   &0x170, &macMcuTimerCount
   \   000018   3C403200     MOV.W   #0x32, R12
   \   00001C   ........     CALLA   #macMcuTimerWaitUsecs
    471          
    472            /* release from reset */
    473            HAL_MAC_DRIVE_RESETN_PIN_HIGH();
   \   000020   F2D080003100 BIS.B   #0x80, &0x31
    474          
    475            /* wait for oscillator to stabilize */
    476          
    477            /*
    478             * Cannot access the SO pin directly.
    479             * Luminary workaround.
    480             */
    481            HAL_MAC_SPI_LUMINARY_SO_AS_GPIO();
    482          
    483            HAL_MAC_SPI_SET_CHIP_SELECT_ON();
   \   000026   ....         JMP     ?Subroutine0
   \   000028                REQUIRE P5OUT
   \   000028                REQUIRE P1OUT
   \   000028                REQUIRE TAR
   \   000028                REQUIRE P5IN
    484            while (!HAL_MAC_SPI_READ_SO_PIN());
    485            HAL_MAC_SPI_SET_CHIP_SELECT_OFF();
    486          
    487            HAL_MAC_SPI_LUMINARY_SO_RESTORE();
    488          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine4:
   \   000000   0224         JEQ     ??macDualchipTurnOnRadioOscillator_1
   \   000002   ........     CALLA   #halAssertHandler
   \                     ??macDualchipTurnOnRadioOscillator_1:
   \   000006   F2400300.... MOV.B   #0x3, &macSpiRadioPower
   \   00000C   1001         RETA
    489          
    490          
    491          /**************************************************************************************************
    492           * @fn          macDualchipTurnOffRadioPower
    493           *
    494           * @brief       Sequence for disabling power to the radio chip.
    495           *
    496           * @param       none
    497           *
    498           * @return      none
    499           **************************************************************************************************
    500           */

   \                                 In  segment CODE, align 2, keep-with-next
    501          void macDualchipTurnOffRadioPower(void)
   \                     macDualchipTurnOffRadioPower:
    502          {
    503            MAC_ASSERT(macSpiRadioPower != MAC_SPI_RADIO_POWER_OFF);
   \   000000   C293....     CMP.B   #0x0, &macSpiRadioPower
   \   000004   0220         JNE     ??macDualchipTurnOffRadioPower_0
   \   000006   ........     CALLA   #halAssertHandler
    504            MAC_ASSERT_STATEMENT( macSpiRadioPower = MAC_SPI_RADIO_POWER_OFF; );
   \                     ??macDualchipTurnOffRadioPower_0:
   \   00000A   C243....     MOV.B   #0x0, &macSpiRadioPower
    505          
    506            /*
    507             *  Re-initialize radio software module when powering off chip.
    508             *  The shadow values of certan radio parameters need to match
    509             *  the power-on state.
    510             */
    511            macRadioInit();
   \   00000E   ........     CALLA   #macRadioInit
    512          
    513            /* put chip into reset and then turn off voltage regulator */
    514            HAL_MAC_DRIVE_RESETN_PIN_LOW();
   \   000012   F2C080003100 BIC.B   #0x80, &0x31
    515            HAL_MAC_DRIVE_VREG_EN_PIN_LOW();
   \   000018   D2C32100     BIC.B   #0x1, &0x21
    516          }
   \   00001C   1001         RETA
   \   00001E                REQUIRE P5OUT
   \   00001E                REQUIRE P1OUT
    517          
    518          
    519          /**************************************************************************************************
    520           * @fn          macDualchipTurnOnRadioOscillator
    521           *
    522           * @brief       Logic and sequence for turning on the radio oscillator.
    523           *
    524           * @param       none
    525           *
    526           * @return      none
    527           **************************************************************************************************
    528           */

   \                                 In  segment CODE, align 2, keep-with-next
    529          void macDualchipTurnOnRadioOscillator(void)
   \                     macDualchipTurnOnRadioOscillator:
    530          {
    531            MAC_ASSERT(macSpiRadioPower == MAC_SPI_RADIO_POWER_VREG_ON);
   \   000000   D293....     CMP.B   #0x1, &macSpiRadioPower
   \   000004   ........     CALLA   #?Subroutine4
    532            MAC_ASSERT_STATEMENT( macSpiRadioPower = MAC_SPI_RADIO_POWER_VREG_ON | MAC_SPI_RADIO_POWER_OSC_ON; );
    533          
    534            /* turn on the oscillator */
    535            macSpiCmdStrobe(SXOSCON);
   \                     ??CrossCallReturnLabel_5:
   \   000008   7C404000     MOV.B   #0x40, R12
   \   00000C   ........     CALLA   #macSpiCmdStrobe
    536          
    537            /* wait for oscillator to stabilize */
    538          
    539            /*
    540             * Cannot access the SO pin directly.
    541             * Luminary workaround.
    542             */
    543            HAL_MAC_SPI_LUMINARY_SO_AS_GPIO();
    544          
    545            HAL_MAC_SPI_SET_CHIP_SELECT_ON();
   \   000010                REQUIRE ?Subroutine0
   \   000010                REQUIRE P5OUT
   \   000010                REQUIRE P5IN
   \   000010                // Fall through to label ?Subroutine0
    546            while (!HAL_MAC_SPI_READ_SO_PIN());
    547            HAL_MAC_SPI_SET_CHIP_SELECT_OFF();
    548          
    549            HAL_MAC_SPI_LUMINARY_SO_RESTORE();
    550          }
    551          
    552          
    553          /**************************************************************************************************
    554           * @fn          macDualchipTurnOffRadioOscillator
    555           *
    556           * @brief       Sequence for disabling the radio oscillator.
    557           *
    558           * @param       none
    559           *
    560           * @return      none
    561           **************************************************************************************************
    562           */

   \                                 In  segment CODE, align 2
    563          void macDualchipTurnOffRadioOscillator(void)
   \                     macDualchipTurnOffRadioOscillator:
    564          {
    565            MAC_ASSERT( macSpiRadioPower & MAC_SPI_RADIO_POWER_OSC_ON);
   \   000000   E2B3....     BIT.B   #0x2, &macSpiRadioPower
   \   000004   022C         JC      ??macDualchipTurnOffRadioOscillator_0
   \   000006   ........     CALLA   #halAssertHandler
    566            MAC_ASSERT_STATEMENT( macSpiRadioPower = MAC_SPI_RADIO_POWER_VREG_ON; );
   \                     ??macDualchipTurnOffRadioOscillator_0:
   \   00000A   D243....     MOV.B   #0x1, &macSpiRadioPower
    567          
    568            macSpiCmdStrobe(SXOSCOFF);
   \   00000E   7C404600     MOV.B   #0x46, R12
   \   000012   ........     BRA     #macSpiCmdStrobe
    569          }
    570          
    571          
    572          /**************************************************************************************************
    573           * @fn          macDualchipRecordMaxRssiStart
    574           *
    575           * @brief       Starts recording of the maximum received RSSI value.
    576           *
    577           * @param       none
    578           *
    579           * @return      none
    580           **************************************************************************************************
    581           */

   \                                 In  segment CODE, align 2
    582          void macDualchipRecordMaxRssiStart(void)
   \                     macDualchipRecordMaxRssiStart:
    583          {
    584            /* start maximum recorded value at the lowest possible value */
    585            maxRssi = -128;
   \   000000   F2408000.... MOV.B   #0x80, &maxRssi
    586          
    587            /* enable timer overflow interrupt */
    588            MAC_MCU_TIMER_ENABLE_ENERGY_DETECT();
   \   000006   D243....     MOV.B   #0x1, &macMcuTimerRecordMaxRssiFlag
    589          }
   \   00000A   1001         RETA
    590          
    591          
    592          /**************************************************************************************************
    593           * @fn          macDualchipRecordMaxRssiStop
    594           *
    595           * @brief       Stops recording of the maximum received RSSI.  It returns the maximum value
    596           *              received since starting the recording.
    597           *
    598           * @param       none
    599           *
    600           * @return      maximum received RSSI value
    601           **************************************************************************************************
    602           */

   \                                 In  segment CODE, align 2
    603          int8 macDualchipRecordMaxRssiStop(void)
   \                     macDualchipRecordMaxRssiStop:
    604          {
    605            /* disable timer overflow interrupt */
    606            MAC_MCU_TIMER_DISABLE_ENERGY_DETECT();
   \   000000   C243....     MOV.B   #0x0, &macMcuTimerRecordMaxRssiFlag
    607          
    608            /* return maximum recorded RSSI value */
    609            return(maxRssi);
   \   000004   5C42....     MOV.B   &maxRssi, R12
   \   000008   1001         RETA
    610          }
    611          
    612          
    613          /**************************************************************************************************
    614           * @fn          macDualchipRecordMaxRssiIsr
    615           *
    616           * @brief       Interrupt service routine called during recording of max RSSI value.
    617           *
    618           * @param       none
    619           *
    620           * @return      none
    621           **************************************************************************************************
    622           */

   \                                 In  segment CODE, align 2
    623          void macDualchipRecordMaxRssiIsr(void)
   \                     macDualchipRecordMaxRssiIsr:
    624          {
   \   000000   1B15         PUSHM.W #0x2, R11
    625            int8 rssi;
    626            int8 rssi2;
    627            int8 rssi3;
    628          
    629            /* read three values, this is a workaround for an older chip bug. New errata does not show
    630             * this anymore but keep it for backward compatibility.
    631             */
    632            rssi  = macSpiReadReg(RSSI) & 0xff;
   \   000002   ........     CALLA   #?Subroutine3
   \                     ??CrossCallReturnLabel_4:
   \   000006   4A4C         MOV.B   R12, R10
    633            rssi2 = macSpiReadReg(RSSI) & 0xff;
   \   000008   ........     CALLA   #?Subroutine3
   \                     ??CrossCallReturnLabel_3:
   \   00000C   4B4C         MOV.B   R12, R11
    634            rssi3 = macSpiReadReg(RSSI) & 0xff;
   \   00000E   ........     CALLA   #?Subroutine3
    635          
    636            /* if the first two values are equal, use that value, if not, use the third value */
    637            if (rssi != rssi2)
   \                     ??CrossCallReturnLabel_2:
   \   000012   4A9B         CMP.B   R11, R10
   \   000014   0124         JEQ     ??macDualchipRecordMaxRssiIsr_0
    638            {
    639              rssi = rssi3;
   \   000016   4A4C         MOV.B   R12, R10
    640            }
    641          
    642            /* store maximum RSSI value */
    643            if (rssi > maxRssi)
   \                     ??macDualchipRecordMaxRssiIsr_0:
   \   000018   C29A....     CMP.B   R10, &maxRssi
   \   00001C   0234         JGE     ??macDualchipRecordMaxRssiIsr_1
    644            {
    645              maxRssi = rssi;
   \   00001E   C24A....     MOV.B   R10, &maxRssi
    646            }
    647          }
   \                     ??macDualchipRecordMaxRssiIsr_1:
   \   000022   1A17         POPM.W  #0x2, R11
   \   000024   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   7C403800     MOV.B   #0x38, R12
   \   000004   ........     BRA     #macSpiReadReg

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for frmfilt0>`:
   \   000000   01           DC8 1
    648          
    649          
    650          /**************************************************************************************************
    651           */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   MAC_SetRandomSeedCB
      4   dualchipTurnOnRadioPowerVREG
        4   -> halAssertHandler
        4   -> macMcuTimerWaitUsecs
      4   macDualchipAndFRMFILT0
        4   -> macSpiWriteReg
      4   macDualchipOrFRMFILT0
        4   -> macSpiWriteReg
      4   macDualchipRandomByte
      4   macDualchipRandomWord
      8   macDualchipRecordMaxRssiIsr
        8   -> macSpiReadReg
      4   macDualchipRecordMaxRssiStart
      4   macDualchipRecordMaxRssiStop
     22   macDualchipSystemInit
       22   -- Indirect call
       22   -> dualchipTurnOnRadioPowerVREG
       22   -> halAssertHandler
       22   -> halMacInit
       22   -> macDualchipTurnOffRadioPower
       22   -> macMcuTimerInit
       22   -> macSpiCmdStrobe
       22   -> macSpiInit
       22   -> macSpiRandomByte
       22   -> macSpiReadReg
       22   -> macSpiWriteReg
      4   macDualchipTurnOffRadioOscillator
        4   -> halAssertHandler
        4   -> macSpiCmdStrobe
      4   macDualchipTurnOffRadioPower
        4   -> halAssertHandler
        4   -> macRadioInit
      4   macDualchipTurnOnRadioOscillator
        4   -> halAssertHandler
        4   -> macSpiCmdStrobe
      4   macDualchipTurnOnRadioPower
        4   -> dualchipTurnOnRadioPowerVREG
        4   -> macDualchipOrFRMFILT0
        4   -> macRadioSetChannel
        4   -> macRadioSetIEEEAddr
        4   -> macRadioSetPanCoordinator
        4   -> macRadioSetPanID
        4   -> macRadioSetShortAddr
        4   -> macRadioSetTxPower
        4   -> macSpiWriteReg


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for frmfilt0>
      16  ?Subroutine0
      10  ?Subroutine1
      30  ?Subroutine2
       8  ?Subroutine3
      14  ?Subroutine4
      10  MAC_SetRandomSeedCB
       1  P1DIR
       1  P1IE
       1  P1IES
       1  P1IFG
       1  P1OUT
       1  P1SEL
       1  P5IN
       1  P5OUT
       2  TAR
      40  dualchipTurnOnRadioPowerVREG
       1  frmfilt0
       1  macChipVersion
       4  macDualchipAndFRMFILT0
       6  macDualchipOrFRMFILT0
       8  macDualchipRandomByte
       8  macDualchipRandomWord
      38  macDualchipRecordMaxRssiIsr
      12  macDualchipRecordMaxRssiStart
      10  macDualchipRecordMaxRssiStop
     178  macDualchipSystemInit
      22  macDualchipTurnOffRadioOscillator
      30  macDualchipTurnOffRadioPower
      16  macDualchipTurnOnRadioOscillator
     332  macDualchipTurnOnRadioPower
       1  maxRssi
       4  pRandomSeedCB
       2  random

 
 792 bytes in segment CODE
  10 bytes in segment DATA16_AN
   1 byte  in segment DATA16_I
   1 byte  in segment DATA16_ID
   8 bytes in segment DATA16_Z
 
 792 bytes of CODE  memory
   1 byte  of CONST memory
   9 bytes of DATA  memory (+ 10 bytes shared)

Errors: none
Warnings: none

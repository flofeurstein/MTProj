###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       10/Jun/2013  16:30:18 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\st #
#                     ack\zdo\ZDSecMgr.c                                      #
#    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\..\To #
#                     ols\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0      #
#                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                       #
#                     -DDEFAULT_CHANLIST=0x00000800                           #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100      #
#                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                   #
#                     -DBEACON_REQUEST_DELAY=100                              #
#                     -DBEACON_REQ_DELAY_MASK=0x00FF                          #
#                     -DLINK_STATUS_JITTER_MASK=0x007F                        #
#                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED= #
#                     3000 -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8  #
#                     -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2     #
#                     -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9              #
#                     -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40                #
#                     -DNWK_MAX_BINDING_ENTRIES=4                             #
#                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,       #
#                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,   #
#                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                    #
#                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=2 #
#                     0 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000           #
#                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100         #
#                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wRouter.cfg" (-DCPU6MHZ -DMAC_CFG_APP_PENDING_QUEUE=TR #
#                     UE -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8           #
#                     -DMAC_CFG_RX_MAX=5 -DRTR_NWK) -f "C:\Texas              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC          #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)                #
#                     -DZCL_DEVICE_MGMT "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Components\stack\zdo\Z #
#                     DSecMgr.c" -D MSP430F2618 -D ZTOOL_P1 -D MT_TASK -D     #
#                     MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED -lC         #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\Router\List\"  #
#                     -lA "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects #
#                     \zstack\HomeAutomation\SampleSwitch\CC2520DB\Router\Lis #
#                     t\" --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826   #
#                     -o "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\Router\Obj\ #
#                     " --debug -D__MSP430F2618__ -e --double=32 --clib -I    #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\" -I           #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\..\Source\"    #
#                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\Sourc #
#                     e\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Proje #
#                     cts\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\. #
#                     .\ZMain\MSP2618\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\target\MSP2618CC2520\" -I "C:\Texas               #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\high_level\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\" -I "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\dual_chip\" -I "C:\Texas          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pr #
#                     ojects\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\. #
#                     .\..\..\..\Components\osal\include\" -I "C:\Texas       #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\osal\mcu\msp430\" -I "C:\Texas                        #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\saddr\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\sdata\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\af\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2520D #
#                     B\..\..\..\..\..\Components\stack\nwk\" -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sec\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sapi\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sys\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zcl\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zdo\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ #
#                     Projects\zstack\HomeAutomation\SampleSwitch\CC2520DB\.. #
#                     \..\..\..\..\Components\zmac\f8w\" --core=430X          #
#                     --data_model=small -Ohz --multiplier=16s                #
#                     --require_prototypes                                    #
#    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\Router\List\ZDS #
#                     ecMgr.lst                                               #
#    Object file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\Router\Obj\ZDSe #
#                     cMgr.r43                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\stack\zdo\ZDSecMgr.c
      1          /******************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2012-02-16 13:22:48 -0800 (Thu, 16 Feb 2012) $
      4            Revision:       $Revision: 29339 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2012 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          ******************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "ZDConfig.h"
     60          #include "ZDSecMgr.h"
     61          
     62          /******************************************************************************
     63           * CONSTANTS
     64           */
     65          // maximum number of devices managed by this Security Manager
     66          #if !defined ( ZDSECMGR_DEVICE_MAX )
     67            #define ZDSECMGR_DEVICE_MAX 3
     68          #endif
     69          
     70          // total number of preconfigured devices (EXT address, MASTER key)
     71          //devtag.pro.security
     72          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     73          #define ZDSECMGR_PRECONFIG_MAX 0
     74          
     75          // maximum number of MASTER keys this device may hold
     76          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     77          
     78          // maximum number of LINK keys this device may store
     79          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // total number of devices under control - authentication, SKKE, etc.
     82          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of stored devices
     85          #if !defined ( ZDSECMGR_STORED_DEVICES )
     86            #define ZDSECMGR_STORED_DEVICES 3
     87          #endif
     88          
     89          // Total number of preconfigured trust center link key
     90          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     91            #define ZDSECMGR_TC_DEVICE_MAX 1
     92          #endif
     93          
     94          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     95            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     96          #endif
     97          
     98          #define ZDSECMGR_CTRL_NONE       0
     99          #define ZDSECMGR_CTRL_INIT       1
    100          #define ZDSECMGR_CTRL_TK_MASTER  2
    101          #define ZDSECMGR_CTRL_SKKE_INIT  3
    102          #define ZDSECMGR_CTRL_SKKE_WAIT  4
    103          #define ZDSECMGR_CTRL_SKKE_DONE  5
    104          #define ZDSECMGR_CTRL_SKKE_FAIL  6
    105          #define ZDSECMGR_CTRL_TK_NWK     7
    106          
    107          #define ZDSECMGR_CTRL_BASE_CNTR      1
    108          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    109          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    110          
    111          // set SKA slot maximum
    112          #define ZDSECMGR_SKA_SLOT_MAX 1
    113          
    114          // APSME Stub Implementations
    115          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    116          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    117          #define ZDSecMgrLinkKeyNVIdGet APSME_LinkKeyNVIdGet
    118          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    119          #define ZDSecMgrIsLinkKeyValid APSME_IsLinkKeyValid
    120          
    121          /******************************************************************************
    122           * TYPEDEFS
    123           */
    124          typedef struct
    125          {
    126            uint8 extAddr[Z_EXTADDR_LEN];
    127            uint8 key[SEC_KEY_LEN];
    128          } ZDSecMgrPreConfigData_t;
    129          
    130          typedef struct
    131          {
    132            uint16 ami;
    133            uint8  key[SEC_KEY_LEN];
    134          } ZDSecMgrMasterKeyData_t;
    135          
    136          typedef struct
    137          {
    138            uint16            ami;
    139            uint16            keyNvId;   // index to the Link Key table in NV
    140            ZDSecMgr_Authentication_Option authenticateOption;
    141          } ZDSecMgrEntry_t;
    142          
    143          typedef struct
    144          {
    145            ZDSecMgrEntry_t* entry;
    146            uint16           parentAddr;
    147            uint8            secure;
    148            uint8            state;
    149            uint8            cntr;
    150          } ZDSecMgrCtrl_t;
    151          
    152          typedef struct
    153          {
    154            uint16          nwkAddr;
    155            uint8*          extAddr;
    156            uint16          parentAddr;
    157            uint8           secure;
    158            uint8           devStatus;
    159            ZDSecMgrCtrl_t* ctrl;
    160          } ZDSecMgrDevice_t;
    161          
    162          /******************************************************************************
    163           * LOCAL VARIABLES
    164           */
    165          #if 0 // Taken out because the following functionality is only used for test
    166                // purpose. A more efficient (above) way is used. It can be put
    167                // back in if customers request for a white/black list feature.
    168          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    169          {
    170            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    171            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    172            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    173          };
    174          #endif
    175          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    176          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS8 8
    177            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    178          
    179          // Key data is put in CONST area for security reasons

   \                                 In  segment DATA16_C, align 1, align-sorted
    180          CONST uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000   000000000000 DC8 0, 0, 0, 0, 0, 0, 0, 0, 137, 103, 69, 35, 1, 239, 205, 171
   \            000089674523
   \            01EFCDAB    
    181            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    182             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    183          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    184          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS8 1
    185          
    186          //devtag.pro.security - remove this
    187          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    188          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    189          {
    190            //---------------------------------------------------------------------------
    191            // DEVICE A
    192            //---------------------------------------------------------------------------
    193            {
    194              // extAddr
    195              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    196          
    197              // key
    198              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    199               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    200            },
    201            //---------------------------------------------------------------------------
    202            // DEVICE B
    203            //---------------------------------------------------------------------------
    204            {
    205              // extAddr
    206              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    207          
    208              // key
    209              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    210               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    211            },
    212            //---------------------------------------------------------------------------
    213            // DEVICE C
    214            //---------------------------------------------------------------------------
    215            {
    216              // extAddr
    217              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    218          
    219              // key
    220              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    221               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    222            },
    223          };
    224          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    225          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    226          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    227          ZDSecMgrCtrl_t*  ZDSecMgrCtrlData = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS8 2
    228          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    229          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    230          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    231          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    232          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS8 1
    233          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    234          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS8 32
    235          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    236          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
   \                     ApsLinkKeyFrmCntr:
   \   000000                DS8 30

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    237          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
   \                     TCLinkKeyFrmCntr:
   \   000000                DS8 10
    238          
    239          /******************************************************************************
    240           * PRIVATE FUNCTIONS
    241           *
    242           *   ZDSecMgrMasterKeyInit
    243           *   ZDSecMgrAddrStore
    244           *   ZDSecMgrExtAddrStore
    245           *   ZDSecMgrExtAddrLookup
    246           *   ZDSecMgrMasterKeyLookup
    247           *   ZDSecMgrMasterKeyStore
    248           *   ZDSecMgrEntryInit
    249           *   ZDSecMgrEntryLookup
    250           *   ZDSecMgrEntryLookupAMI
    251           *   ZDSecMgrEntryLookupExt
    252           *   ZDSecMgrEntryLookupExtGetIndex
    253           *   ZDSecMgrEntryFree
    254           *   ZDSecMgrEntryNew
    255           *   ZDSecMgrCtrlInit
    256           *   ZDSecMgrCtrlRelease
    257           *   ZDSecMgrCtrlLookup
    258           *   ZDSecMgrCtrlSet
    259           *   ZDSecMgrCtrlAdd
    260           *   ZDSecMgrCtrlTerm
    261           *   ZDSecMgrCtrlReset
    262           *   ZDSecMgrMasterKeyLoad
    263           *   ZDSecMgrAppKeyGet
    264           *   ZDSecMgrAppKeyReq
    265           *   ZDSecMgrEstablishKey
    266           *   ZDSecMgrSendMasterKey
    267           *   ZDSecMgrSendNwkKey
    268           *   ZDSecMgrDeviceEntryRemove
    269           *   ZDSecMgrDeviceEntryAdd
    270           *   ZDSecMgrDeviceCtrlHandler
    271           *   ZDSecMgrDeviceCtrlSetup
    272           *   ZDSecMgrDeviceCtrlUpdate
    273           *   ZDSecMgrDeviceRemove
    274           *   ZDSecMgrDeviceValidateSKKE
    275           *   ZDSecMgrDeviceValidateRM
    276           *   ZDSecMgrDeviceValidateCM
    277           *   ZDSecMgrDeviceValidate
    278           *   ZDSecMgrDeviceJoin
    279           *   ZDSecMgrDeviceJoinDirect
    280           *   ZDSecMgrDeviceJoinFwd
    281           *   ZDSecMgrDeviceNew
    282           *   ZDSecMgrAssocDeviceAuth
    283           *   ZDSecMgrAuthInitiate
    284           *   ZDSecMgrAuthNwkKey
    285           *   APSME_TCLinkKeyInit
    286           *   APSME_IsDefaultTCLK
    287           */
    288          //-----------------------------------------------------------------------------
    289          // master key data
    290          //-----------------------------------------------------------------------------
    291          void ZDSecMgrMasterKeyInit( void );
    292          
    293          //-----------------------------------------------------------------------------
    294          // address management
    295          //-----------------------------------------------------------------------------
    296          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    297          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    298          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    299          
    300          //-----------------------------------------------------------------------------
    301          // Trust Center management
    302          //-----------------------------------------------------------------------------
    303          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );
    304          void ZDSecMgrTCDataLoad( uint8* extAddr );
    305          
    306          //-----------------------------------------------------------------------------
    307          // MASTER key data
    308          //-----------------------------------------------------------------------------
    309          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId );
    310          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    311          
    312          //-----------------------------------------------------------------------------
    313          // entry data
    314          //-----------------------------------------------------------------------------
    315          void ZDSecMgrEntryInit(uint8 state);
    316          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    318          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    319          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    320          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex );
    321          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    322          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    323          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    324          void ZDSecMgrApsLinkKeyInit(void);
    325          #if defined ( NV_RESTORE )
    326          static void ZDSecMgrWriteNV(void);
    327          static void ZDSecMgrRestoreFromNV(void);
    328          static void ZDSecMgrUpdateNV( uint16 index );
    329          #endif
    330          
    331          //-----------------------------------------------------------------------------
    332          // control data
    333          //-----------------------------------------------------------------------------
    334          void ZDSecMgrCtrlInit( void );
    335          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    336          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    337          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    338                                ZDSecMgrEntry_t*  entry,
    339                                ZDSecMgrCtrl_t*   ctrl );
    340          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    341          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    342          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    343                                       ZDSecMgrEntry_t*  entry );
    344          
    345          //-----------------------------------------------------------------------------
    346          // key support
    347          //-----------------------------------------------------------------------------
    348          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    349          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    350                                       uint8*  initExtAddr,
    351                                       uint16  partNwkAddr,
    352                                       uint8*  partExtAddr,
    353                                       uint8** key,
    354                                       uint8*  keyType );
    355          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    356          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    357          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    358          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    359          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    360          
    361          //-----------------------------------------------------------------------------
    362          // device entry
    363          //-----------------------------------------------------------------------------
    364          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    365          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    366          
    367          //-----------------------------------------------------------------------------
    368          // device control
    369          //-----------------------------------------------------------------------------
    370          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    371          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    372          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    373          
    374          //-----------------------------------------------------------------------------
    375          // device management
    376          //-----------------------------------------------------------------------------
    377          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    378          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    379          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    380          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    381          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    382          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    383          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    384          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    385          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    386          
    387          //-----------------------------------------------------------------------------
    388          // association management
    389          //-----------------------------------------------------------------------------
    390          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    391          
    392          //-----------------------------------------------------------------------------
    393          // authentication management
    394          //-----------------------------------------------------------------------------
    395          void ZDSecMgrAuthInitiate( uint8* responder );
    396          void ZDSecMgrAuthNwkKey( void );
    397          
    398          //-----------------------------------------------------------------------------
    399          // APSME function
    400          //-----------------------------------------------------------------------------
    401          void APSME_TCLinkKeyInit( uint8 setDefault );
    402          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    403          
    404          /******************************************************************************
    405           * @fn          ZDSecMgrMasterKeyInit                     ]
    406           *
    407           * @brief       Initialize master key data in NV
    408           *
    409           * @param       none
    410           *
    411           * @return      none
    412           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine29:
   \   000000   0C48         MOV.W   R8, R12
   \   000002                REQUIRE ??Subroutine29_0
   \   000002                // Fall through to label ??Subroutine29_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine29_0:
   \   000000   ........     CALLA   #osal_nv_item_init
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   31501200     ADD.W   #0x12, SP
   \   000004   3817         POPM.W  #0x4, R11
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
    413          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    414          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801200     SUB.W   #0x12, SP
    415            uint16 index;
    416            ZDSecMgrMasterKeyData_t   masterKeyData;
    417          
    418            masterKeyData.ami = INVALID_NODE_ADDR;
   \   000006   B140FEFF0000 MOV.W   #0xfffe, 0(SP)
    419          
    420            osal_memset( &masterKeyData.key, 0x00, SEC_KEY_LEN );
   \   00000C   0A41         MOV.W   SP, R10
   \   00000E   0A53         ADD.W   #0x0, R10
   \   000010   3E401000     MOV.W   #0x10, R14
   \   000014   4D43         MOV.B   #0x0, R13
   \   000016   0C4A         MOV.W   R10, R12
   \   000018   2C53         ADD.W   #0x2, R12
   \   00001A   ........     CALLA   #osal_memset
    421          
    422            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   00001E   0B43         MOV.W   #0x0, R11
    423            {
    424              if ( osal_nv_item_init( (ZCD_NV_MASTER_KEY_DATA_START + index),
    425                                 sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData) == SUCCESS)
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   000020   084B         MOV.W   R11, R8
   \   000022   38500103     ADD.W   #0x301, R8
   \   000026   0E4A         MOV.W   R10, R14
   \   000028   3D401200     MOV.W   #0x12, R13
   \   00002C   ........     CALLA   #?Subroutine29
   \                     ??CrossCallReturnLabel_50:
   \   000030   0720         JNE     ??ZDSecMgrMasterKeyInit_1
    426              {
    427                // the item already exists in NV just needs to be set to default values
    428                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    429                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \   000032   0F4A         MOV.W   R10, R15
   \   000034   3E401200     MOV.W   #0x12, R14
   \   000038   0D43         MOV.W   #0x0, R13
   \   00003A   0C48         MOV.W   R8, R12
   \   00003C   ........     CALLA   #osal_nv_write
    430              }
    431            }
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   000040   1B53         ADD.W   #0x1, R11
   \   000042   3B900300     CMP.W   #0x3, R11
   \   000046   EC2B         JNC     ??ZDSecMgrMasterKeyInit_0
    432          }
   \   000048   ........     BRA     #?Subroutine6
    433          
    434          /******************************************************************************
    435           * @fn          ZDSecMgrAddrStore
    436           *
    437           * @brief       Store device addresses.
    438           *
    439           * @param       nwkAddr - [in] NWK address
    440           * @param       extAddr - [in] EXT address
    441           * @param       ami     - [out] Address Manager index
    442           *
    443           * @return      ZStatus_t
    444           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   0A12         PUSH.W  R10
   \   000002   31800E00     SUB.W   #0xe, SP
   \   000006   0A4E         MOV.W   R14, R10
   \   000008   ........     CALLA   #?Subroutine30
   \                     ??Subroutine0_1:
   \   00000C   5C93         CMP.B   #0x1, R12
   \   00000E   1F410C00     MOV.W   0xc(SP), R15
   \   000012   0220         JNE     ??Subroutine0_2
   \   000014   4C43         MOV.B   #0x0, R12
   \   000016   023C         JMP     ??Subroutine0_3
   \                     ??Subroutine0_2:
   \   000018   7C40C800     MOV.B   #0xc8, R12
   \                     ??Subroutine0_3:
   \   00001C   8A4F0000     MOV.W   R15, 0(R10)
   \   000020                REQUIRE ??Subroutine0_0
   \   000020                // Fall through to label ??Subroutine0_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine0_0:
   \   000000   31500E00     ADD.W   #0xe, SP
   \   000004   3A41         POP.W   R10
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine30:
   \   000000   E1430400     MOV.B   #0x2, 0x4(SP)
   \   000004   814C0600     MOV.W   R12, 0x6(SP)
   \   000008   0C41         MOV.W   SP, R12
   \   00000A   3C52         ADD.W   #0x8, R12
   \   00000C   ........     CALLA   #AddrMgrExtAddrSet
   \   000010   0C41         MOV.W   SP, R12
   \   000012   2C52         ADD.W   #0x4, R12
   \   000014   ........     BRA     #AddrMgrEntryUpdate

   \                                 In  segment CODE, align 2, keep-with-next
    445          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
   \   000000   ....         JMP     ?Subroutine0
    446          {
    447            ZStatus_t      status;
    448            AddrMgrEntry_t entry;
    449          
    450          
    451            // add entry
    452            entry.user    = ADDRMGR_USER_SECURITY;
    453            entry.nwkAddr = nwkAddr;
    454            AddrMgrExtAddrSet( entry.extAddr, extAddr );
    455          
    456            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
    457            {
    458              // return successful results
    459              *ami   = entry.index;
    460              status = ZSuccess;
    461            }
    462            else
    463            {
    464              // return failed results
    465              *ami   = entry.index;
    466              status = ZNwkUnknownDevice;
    467            }
    468          
    469            return status;
    470          }
    471          
    472          /******************************************************************************
    473           * @fn          ZDSecMgrExtAddrStore
    474           *
    475           * @brief       Store EXT address.
    476           *
    477           * @param       extAddr - [in] EXT address
    478           * @param       ami     - [out] Address Manager index
    479           *
    480           * @return      ZStatus_t
    481           */

   \                                 In  segment CODE, align 2, keep-with-next
    482          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
   \   000000   ....         JMP     ?Subroutine0
    483          {
    484            ZStatus_t      status;
    485            AddrMgrEntry_t entry;
    486          
    487          
    488            // add entry
    489            entry.user    = ADDRMGR_USER_SECURITY;
    490            entry.nwkAddr = nwkAddr;
    491            AddrMgrExtAddrSet( entry.extAddr, extAddr );
    492          
    493            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
    494            {
    495              // return successful results
    496              *ami   = entry.index;
    497              status = ZSuccess;
    498            }
    499            else
    500            {
    501              // return failed results
    502              *ami   = entry.index;
    503              status = ZNwkUnknownDevice;
    504            }
    505          
    506            return status;
    507          }
    508          
    509          /******************************************************************************
    510           * @fn          ZDSecMgrExtAddrLookup
    511           *
    512           * @brief       Lookup index for specified EXT address.
    513           *
    514           * @param       extAddr - [in] EXT address
    515           * @param       ami     - [out] Address Manager index
    516           *
    517           * @return      ZStatus_t
    518           */

   \                                 In  segment CODE, align 2, keep-with-next
    519          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    520          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31800E00     SUB.W   #0xe, SP
   \   000006   0A4D         MOV.W   R13, R10
    521            ZStatus_t      status;
    522            AddrMgrEntry_t entry;
    523          
    524          
    525            // lookup entry
    526            entry.user = ADDRMGR_USER_SECURITY;
   \   000008   E1430000     MOV.B   #0x2, 0(SP)
    527            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   00000C   0D4C         MOV.W   R12, R13
   \   00000E   0C41         MOV.W   SP, R12
   \   000010   2C52         ADD.W   #0x4, R12
   \   000012   ........     CALLA   #AddrMgrExtAddrSet
    528          
    529            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   000016   0C41         MOV.W   SP, R12
   \   000018   0C53         ADD.W   #0x0, R12
   \   00001A   ........     CALLA   #AddrMgrEntryLookupExt
   \   00001E   ....         JMP     ??Subroutine0_1
    530            {
    531              // return successful results
    532              *ami   = entry.index;
    533              status = ZSuccess;
    534            }
    535            else
    536            {
    537              // return failed results
    538              *ami   = entry.index;
    539              status = ZNwkUnknownDevice;
    540            }
    541          
    542            return status;
    543          }
    544          
    545          /******************************************************************************
    546           * @fn          ZDSecMgrAddrClear
    547           *
    548           * @brief       Clear security bit from Address Manager for specific device.
    549           *
    550           * @param       extAddr - [in] EXT address
    551           *
    552           * @return      ZStatus_t
    553           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   31501000     ADD.W   #0x10, SP
   \   000004   3A41         POP.W   R10
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine35:
   \   000000   0D41         MOV.W   SP, R13
   \   000002   2D52         ADD.W   #0x4, R13
   \   000004   ........     BRA     #ZDSecMgrExtAddrLookup

   \                                 In  segment CODE, align 2, keep-with-next
    554          ZStatus_t ZDSecMgrAddrClear( uint8* extAddr )
   \                     ZDSecMgrAddrClear:
    555          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31801000     SUB.W   #0x10, SP
    556            ZStatus_t status;
    557            uint16 entryAmi;
    558          
    559            // get Address Manager Index
    560            status = ZDSecMgrExtAddrLookup( extAddr, &entryAmi );
   \   000006   ........     CALLA   #?Subroutine35
   \                     ??CrossCallReturnLabel_31:
   \   00000A   4A4C         MOV.B   R12, R10
    561          
    562            if ( status == ZSuccess )
   \   00000C   4C93         CMP.B   #0x0, R12
   \   00000E   0B20         JNE     ??ZDSecMgrAddrClear_0
    563            {
    564              AddrMgrEntry_t addrEntry;
    565          
    566              // Clear SECURITY User bit from the address manager
    567              addrEntry.user = ADDRMGR_USER_SECURITY;
   \   000010   E1430200     MOV.B   #0x2, 0x2(SP)
    568              addrEntry.index = entryAmi;
   \   000014   A1410E00     MOV.W   @SP, 0xe(SP)
    569          
    570              if ( AddrMgrEntryRelease( &addrEntry ) != TRUE )
   \   000018   0C41         MOV.W   SP, R12
   \   00001A   2C53         ADD.W   #0x2, R12
   \   00001C   ........     CALLA   #AddrMgrEntryRelease
   \   000020   5C93         CMP.B   #0x1, R12
   \   000022   0124         JEQ     ??ZDSecMgrAddrClear_0
    571              {
    572                // return failure results
    573                status = ZFailure;
   \   000024   5A43         MOV.B   #0x1, R10
    574              }
    575            }
    576          
    577            return status;
   \                     ??ZDSecMgrAddrClear_0:
   \   000026   4C4A         MOV.B   R10, R12
   \   000028   ........     BRA     #?Subroutine5
    578          }
    579          
    580          /******************************************************************************
    581           * @fn          ZDSecMgrMasterKeyLookup
    582           *
    583           * @brief       Lookup MASTER key for specified address index.
    584           *
    585           * @param       ami - [in] Address Manager index
    586           * @param       pKeyNvId - [out] MASTER key NV ID
    587           *
    588           * @return      ZStatus_t
    589           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   31501200     ADD.W   #0x12, SP
   \   000004   5617         POPM.W  #0x6, R11
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine25:
   \   000000   3E401200     MOV.W   #0x12, R14
   \   000004                REQUIRE ??Subroutine49_0
   \   000004                // Fall through to label ??Subroutine49_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine49_0:
   \   000000   4D43         MOV.B   #0x0, R13
   \   000002   0C49         MOV.W   R9, R12
   \   000004   ........     BRA     #osal_memset

   \                                 In  segment CODE, align 2, keep-with-next
    590          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint16* pKeyNvId )
   \                     ZDSecMgrMasterKeyLookup:
    591          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   31801200     SUB.W   #0x12, SP
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0B4D         MOV.W   R13, R11
    592            uint16 index;
    593            ZDSecMgrMasterKeyData_t masterKeyData;
    594          
    595          
    596            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   00000A   0843         MOV.W   #0x0, R8
   \   00000C   0941         MOV.W   SP, R9
   \   00000E   0953         ADD.W   #0x0, R9
    597            {
    598              // Read entry index of the Master key table from NV
    599              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    600                            sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   000010   ........     CALLA   #?Subroutine20
    601          
    602              if ( masterKeyData.ami == ami )
   \                     ??CrossCallReturnLabel_10:
   \   000014   819A0000     CMP.W   R10, 0(SP)
   \   000018   0620         JNE     ??ZDSecMgrMasterKeyLookup_1
    603              {
    604                // return successful results
    605                *pKeyNvId   = ZCD_NV_MASTER_KEY_DATA_START + index;
   \   00001A   8B460000     MOV.W   R6, 0(R11)
    606          
    607                // clear copy of key in RAM
    608                osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \   00001E   ........     CALLA   #?Subroutine25
    609          
    610                return ZSuccess;
   \                     ??CrossCallReturnLabel_76:
   \   000022   4C43         MOV.B   #0x0, R12
   \   000024   083C         JMP     ??ZDSecMgrMasterKeyLookup_2
    611              }
    612            }
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   000026   1853         ADD.W   #0x1, R8
   \   000028   38900300     CMP.W   #0x3, R8
   \   00002C   F12B         JNC     ??ZDSecMgrMasterKeyLookup_0
    613          
    614            *pKeyNvId = SEC_NO_KEY_NV_ID;
   \   00002E   8B430000     MOV.W   #0x0, 0(R11)
    615          
    616            // clear copy of key in RAM
    617            osal_memset(&masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t));
   \   000032   ........     CALLA   #?Subroutine24
    618          
    619            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   000036   ....         JMP     ?Subroutine7
    620          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine24:
   \   000000   3E401200     MOV.W   #0x12, R14
   \   000004   4D43         MOV.B   #0x0, R13
   \   000006   0C49         MOV.W   R9, R12
   \   000008   ........     CALLA   #osal_memset
   \   00000C   7C40C800     MOV.B   #0xc8, R12
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine20:
   \   000000   0648         MOV.W   R8, R6
   \   000002   36500103     ADD.W   #0x301, R6
   \   000006   0F49         MOV.W   R9, R15
   \   000008   3E401200     MOV.W   #0x12, R14
   \   00000C   0D43         MOV.W   #0x0, R13
   \   00000E   0C46         MOV.W   R6, R12
   \   000010   ........     BRA     #osal_nv_read
    621          
    622          /******************************************************************************
    623           * @fn          ZDSecMgrMasterKeyStore
    624           *
    625           * @brief       Store MASTER key for specified address index.
    626           *
    627           * @param       ami - [in] Address Manager index
    628           * @param       key - [in] valid key to store
    629           *
    630           * @return      ZStatus_t
    631           */

   \                                 In  segment CODE, align 2, keep-with-next
    632          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    633          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   31801200     SUB.W   #0x12, SP
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0B4D         MOV.W   R13, R11
    634            uint16    index;
    635            ZDSecMgrMasterKeyData_t   masterKeyData;
    636          
    637          
    638            for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   00000A   0843         MOV.W   #0x0, R8
   \   00000C   0941         MOV.W   SP, R9
   \   00000E   0953         ADD.W   #0x0, R9
    639            {
    640              // Read entry index of the Master key table from NV
    641              osal_nv_read( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    642                             sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000010   ........     CALLA   #?Subroutine20
    643          
    644              if ( masterKeyData.ami == INVALID_NODE_ADDR )
   \                     ??CrossCallReturnLabel_11:
   \   000014   B190FEFF0000 CMP.W   #0xfffe, 0(SP)
   \   00001A   1C20         JNE     ??ZDSecMgrMasterKeyStore_1
    645              {
    646                // store EXT address index
    647                masterKeyData.ami = ami;
   \   00001C   814A0000     MOV.W   R10, 0(SP)
    648          
    649                if ( key != NULL )
   \   000020   0B93         CMP.W   #0x0, R11
   \   000022   3E401000     MOV.W   #0x10, R14
   \   000026   0624         JEQ     ??ZDSecMgrMasterKeyStore_2
    650                {
    651                  osal_memcpy( masterKeyData.key, key,  SEC_KEY_LEN );
   \   000028   0D4B         MOV.W   R11, R13
   \   00002A   0C49         MOV.W   R9, R12
   \   00002C   2C53         ADD.W   #0x2, R12
   \   00002E   ........     CALLA   #osal_memcpy
   \   000032   053C         JMP     ??ZDSecMgrMasterKeyStore_3
    652                }
    653                else
    654                {
    655                  osal_memset( masterKeyData.key, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   000034   4D43         MOV.B   #0x0, R13
   \   000036   0C49         MOV.W   R9, R12
   \   000038   2C53         ADD.W   #0x2, R12
   \   00003A   ........     CALLA   #osal_memset
    656                }
    657          
    658                // set new values in NV
    659                osal_nv_write( (ZCD_NV_MASTER_KEY_DATA_START + index), 0,
    660                                sizeof(ZDSecMgrMasterKeyData_t), &masterKeyData );
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   00003E   0F49         MOV.W   R9, R15
   \   000040   3E401200     MOV.W   #0x12, R14
   \   000044   0D43         MOV.W   #0x0, R13
   \   000046   0C46         MOV.W   R6, R12
   \   000048   ........     CALLA   #osal_nv_write
    661          
    662                // clear copy of key in RAM
    663                osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   00004C   ........     CALLA   #?Subroutine25
    664          
    665                // return successful results
    666                return ZSuccess;
   \                     ??CrossCallReturnLabel_77:
   \   000050   4C43         MOV.B   #0x0, R12
   \   000052   063C         JMP     ??ZDSecMgrMasterKeyStore_4
    667              }
    668            }
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   000054   1853         ADD.W   #0x1, R8
   \   000056   38900300     CMP.W   #0x3, R8
   \   00005A   DA2B         JNC     ??ZDSecMgrMasterKeyStore_0
    669          
    670            // clear copy of key in RAM
    671            osal_memset( &masterKeyData, 0x00, sizeof(ZDSecMgrMasterKeyData_t) );
   \   00005C   ........     CALLA   #?Subroutine24
    672          
    673            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   000060                REQUIRE ?Subroutine7
   \   000060                // Fall through to label ?Subroutine7
    674          }
    675          
    676          /******************************************************************************
    677           * @fn          ZDSecMgrEntryInit
    678           *
    679           * @brief       Initialize entry sub module
    680           *
    681           * @param       state - device initialization state
    682           *
    683           * @return      none
    684           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine32:
   \   000000   1E53         ADD.W   #0x1, R14
   \   000002   3E900300     CMP.W   #0x3, R14
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
    685          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    686          {
    687            if (ZDSecMgrEntries == NULL)
   \   000000   8293....     CMP.W   #0x0, &ZDSecMgrEntries
   \   000004   1720         JNE     ??ZDSecMgrEntryInit_1
    688            {
    689              uint16 index;
    690          
    691              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   000006   3C401200     MOV.W   #0x12, R12
   \   00000A   ........     CALLA   #osal_mem_alloc
   \   00000E   824C....     MOV.W   R12, &ZDSecMgrEntries
   \   000012   0F4C         MOV.W   R12, R15
   \   000014   0C93         CMP.W   #0x0, R12
   \   000016   0E24         JEQ     ??ZDSecMgrEntryInit_1
    692              {
    693                return;
    694              }
    695          
    696              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   000018   0E43         MOV.W   #0x0, R14
    697              {
    698                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_0:
   \   00001A   0C4E         MOV.W   R14, R12
   \   00001C                RPT     #0x5
   \   00001C   44180C5E     ADDX.W  R14, R12
   \   000020   0D4F         MOV.W   R15, R13
   \   000022   0D5C         ADD.W   R12, R13
   \   000024   BD40FEFF0000 MOV.W   #0xfffe, 0(R13)
    699          
    700                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
   \   00002A   8D430200     MOV.W   #0x0, 0x2(R13)
    701              }
   \   00002E   ........     CALLA   #?Subroutine32
    702            }
   \                     ??CrossCallReturnLabel_24:
   \   000032   F32B         JNC     ??ZDSecMgrEntryInit_0
    703          
    704          #if defined NV_RESTORE
    705            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    706            {
    707              ZDSecMgrRestoreFromNV();
    708            }
    709          #else
    710            (void)state;
    711          #endif
    712          }
   \                     ??ZDSecMgrEntryInit_1:
   \   000034   1001         RETA
    713          
    714          /******************************************************************************
    715           * @fn          ZDSecMgrEntryLookup
    716           *
    717           * @brief       Lookup entry index using specified NWK address.
    718           *
    719           * @param       nwkAddr - [in] NWK address
    720           * @param       entry   - [out] valid entry
    721           *
    722           * @return      ZStatus_t
    723           */

   \                                 In  segment CODE, align 2, keep-with-next
    724          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    725          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31800E00     SUB.W   #0xe, SP
   \   000006   0A4D         MOV.W   R13, R10
    726            uint16         index;
    727            AddrMgrEntry_t addrMgrEntry;
    728          
    729            // initialize results
    730            *entry = NULL;
   \   000008   8D430000     MOV.W   #0x0, 0(R13)
    731          
    732            // verify data is available
    733            if ( ZDSecMgrEntries != NULL )
   \   00000C   8293....     CMP.W   #0x0, &ZDSecMgrEntries
   \   000010   1C24         JEQ     ??ZDSecMgrEntryLookup_1
    734            {
    735              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000012   E1430000     MOV.B   #0x2, 0(SP)
    736              addrMgrEntry.nwkAddr = nwkAddr;
   \   000016   814C0200     MOV.W   R12, 0x2(SP)
    737          
    738              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \   00001A   0C41         MOV.W   SP, R12
   \   00001C   0C53         ADD.W   #0x0, R12
   \   00001E   ........     CALLA   #AddrMgrEntryLookupNwk
   \   000022   5C93         CMP.B   #0x1, R12
   \   000024   1220         JNE     ??ZDSecMgrEntryLookup_1
    739              {
    740                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000026   0F43         MOV.W   #0x0, R15
    741                {
    742                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_0:
   \   000028   1E42....     MOV.W   &ZDSecMgrEntries, R14
   \   00002C   0D4F         MOV.W   R15, R13
   \   00002E                RPT     #0x5
   \   00002E   44180D5F     ADDX.W  R15, R13
   \   000032   0E5D         ADD.W   R13, R14
   \   000034   A19E0C00     CMP.W   @R14, 0xc(SP)
   \   000038   0420         JNE     ??ZDSecMgrEntryLookup_2
    743                  {
    744                    // return successful results
    745                    *entry = &ZDSecMgrEntries[index];
   \   00003A   8A4E0000     MOV.W   R14, 0(R10)
    746          
    747                    // break from loop
    748                    return ZSuccess;
   \   00003E   4C43         MOV.B   #0x0, R12
   \   000040   063C         JMP     ??ZDSecMgrEntryLookup_3
    749                  }
    750                }
   \                     ??ZDSecMgrEntryLookup_2:
   \   000042   1F53         ADD.W   #0x1, R15
   \   000044   3F900300     CMP.W   #0x3, R15
   \   000048   EF2B         JNC     ??ZDSecMgrEntryLookup_0
    751              }
    752            }
    753          
    754            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookup_1:
   \   00004A   7C40C800     MOV.B   #0xc8, R12
   \                     ??ZDSecMgrEntryLookup_3:
   \   00004E   ....         JMP     ??Subroutine0_0
    755          }
    756          
    757          /******************************************************************************
    758           * @fn          ZDSecMgrEntryLookupAMI
    759           *
    760           * @brief       Lookup entry using specified address index
    761           *
    762           * @param       ami   - [in] Address Manager index
    763           * @param       entry - [out] valid entry
    764           *
    765           * @return      ZStatus_t
    766           */

   \                                 In  segment CODE, align 2, keep-with-next
    767          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    768          {
   \   000000   1B15         PUSHM.W #0x2, R11
    769            uint16 index;
    770          
    771            // initialize results
    772            *entry = NULL;
   \   000002   8D430000     MOV.W   #0x0, 0(R13)
    773          
    774            // verify data is available
    775            if ( ZDSecMgrEntries != NULL )
   \   000006   1F42....     MOV.W   &ZDSecMgrEntries, R15
   \   00000A   0F93         CMP.W   #0x0, R15
   \   00000C   1024         JEQ     ??ZDSecMgrEntryLookupAMI_1
    776            {
    777              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000E   0E43         MOV.W   #0x0, R14
    778              {
    779                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   000010   0B4E         MOV.W   R14, R11
   \   000012                RPT     #0x5
   \   000012   44180B5E     ADDX.W  R14, R11
   \   000016   0A4F         MOV.W   R15, R10
   \   000018   0A5B         ADD.W   R11, R10
   \   00001A   8A9C0000     CMP.W   R12, 0(R10)
   \   00001E   0420         JNE     ??ZDSecMgrEntryLookupAMI_2
    780                {
    781                  // return successful results
    782                  *entry = &ZDSecMgrEntries[index];
   \   000020   8D4A0000     MOV.W   R10, 0(R13)
    783          
    784                  // break from loop
    785                  return ZSuccess;
   \   000024   4C43         MOV.B   #0x0, R12
   \   000026   053C         JMP     ??ZDSecMgrEntryLookupAMI_3
    786                }
    787              }
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000028   ........     CALLA   #?Subroutine32
    788            }
   \                     ??CrossCallReturnLabel_23:
   \   00002C   F12B         JNC     ??ZDSecMgrEntryLookupAMI_0
    789          
    790            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   00002E   7C40C800     MOV.B   #0xc8, R12
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000032   1A17         POPM.W  #0x2, R11
   \   000034   1001         RETA
    791          }
    792          
    793          /******************************************************************************
    794           * @fn          ZDSecMgrEntryLookupExt
    795           *
    796           * @brief       Lookup entry index using specified EXT address.
    797           *
    798           * @param       extAddr - [in] EXT address
    799           * @param       entry   - [out] valid entry
    800           *
    801           * @return      ZStatus_t
    802           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   4C4B         MOV.B   R11, R12
   \   000002                REQUIRE ??Subroutine2_0
   \   000002                // Fall through to label ??Subroutine2_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine2_0:
   \   000000   2153         ADD.W   #0x2, SP
   \   000002   1A17         POPM.W  #0x2, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
    803          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    804          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4D         MOV.W   R13, R10
    805            ZStatus_t status;
    806            uint16    ami;
    807          
    808            // initialize results
    809            *entry = NULL;
   \   000006   8D430000     MOV.W   #0x0, 0(R13)
    810            status = ZNwkUnknownDevice;
   \   00000A   7B40C800     MOV.B   #0xc8, R11
    811          
    812            // lookup address index
    813            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   00000E   ........     CALLA   #?Subroutine35
   \                     ??CrossCallReturnLabel_32:
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   0520         JNE     ??ZDSecMgrEntryLookupExt_0
    814            {
    815              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000016   0D4A         MOV.W   R10, R13
   \   000018   2C41         MOV.W   @SP, R12
   \   00001A   ........     CALLA   #ZDSecMgrEntryLookupAMI
   \   00001E   4B4C         MOV.B   R12, R11
    816            }
    817          
    818            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000020   ........     BRA     #?Subroutine2
    819          }
    820          
    821          /******************************************************************************
    822           * @fn          ZDSecMgrEntryLookupExtGetIndex
    823           *
    824           * @brief       Lookup entry index using specified EXT address.
    825           *
    826           * @param       extAddr - [in] EXT address
    827           * @param       entryIndex - [out] valid index to the entry table
    828           *
    829           * @return      ZStatus_t
    830           */

   \                                 In  segment CODE, align 2, keep-with-next
    831          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupExtGetIndex:
    832          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4D         MOV.W   R13, R10
   \   000006   0B4E         MOV.W   R14, R11
    833            uint16 ami;
    834            uint16 index;
    835          
    836            // lookup address index
    837            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000008   ........     CALLA   #?Subroutine35
   \                     ??CrossCallReturnLabel_33:
   \   00000C   4C93         CMP.B   #0x0, R12
   \   00000E   1620         JNE     ??ZDSecMgrEntryLookupExtGetIndex_1
    838            {
    839              // verify data is available
    840              if ( ZDSecMgrEntries != NULL )
   \   000010   1F42....     MOV.W   &ZDSecMgrEntries, R15
   \   000014   0F93         CMP.W   #0x0, R15
   \   000016   1224         JEQ     ??ZDSecMgrEntryLookupExtGetIndex_1
    841              {
    842                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000018   0E43         MOV.W   #0x0, R14
    843                {
    844                  if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupExtGetIndex_0:
   \   00001A   0C4E         MOV.W   R14, R12
   \   00001C                RPT     #0x5
   \   00001C   44180C5E     ADDX.W  R14, R12
   \   000020   0D4F         MOV.W   R15, R13
   \   000022   0D5C         ADD.W   R12, R13
   \   000024   AD910000     CMP.W   @SP, 0(R13)
   \   000028   0620         JNE     ??ZDSecMgrEntryLookupExtGetIndex_2
    845                  {
    846                    // return successful results
    847                    *entry = &ZDSecMgrEntries[index];
   \   00002A   8A4D0000     MOV.W   R13, 0(R10)
    848                    *entryIndex = index;
   \   00002E   8B4E0000     MOV.W   R14, 0(R11)
    849          
    850                    // break from loop
    851                    return ZSuccess;
   \   000032   4C43         MOV.B   #0x0, R12
   \   000034   053C         JMP     ??ZDSecMgrEntryLookupExtGetIndex_3
    852                  }
    853                }
   \                     ??ZDSecMgrEntryLookupExtGetIndex_2:
   \   000036   ........     CALLA   #?Subroutine32
    854              }
    855            }
   \                     ??CrossCallReturnLabel_22:
   \   00003A   EF2B         JNC     ??ZDSecMgrEntryLookupExtGetIndex_0
    856          
    857            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupExtGetIndex_1:
   \   00003C   7C40C800     MOV.B   #0xc8, R12
   \                     ??ZDSecMgrEntryLookupExtGetIndex_3:
   \   000040   ........     BRA     #??Subroutine2_0
    858          }
    859          
    860          /******************************************************************************
    861           * @fn          ZDSecMgrEntryLookupAMIGetIndex
    862           *
    863           * @brief       Lookup entry using specified address index
    864           *
    865           * @param       ami   - [in] Address Manager index
    866           * @param       entryIndex - [out] valid index to the entry table
    867           *
    868           * @return      ZStatus_t
    869           */

   \                                 In  segment CODE, align 2, keep-with-next
    870          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupAMIGetIndex:
    871          {
   \   000000   1B15         PUSHM.W #0x2, R11
    872            uint16 index;
    873          
    874            // verify data is available
    875            if ( ZDSecMgrEntries != NULL )
   \   000002   1F42....     MOV.W   &ZDSecMgrEntries, R15
   \   000006   0F93         CMP.W   #0x0, R15
   \   000008   1024         JEQ     ??ZDSecMgrEntryLookupAMIGetIndex_1
    876            {
    877              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000A   0E43         MOV.W   #0x0, R14
    878              {
    879                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_0:
   \   00000C   0A4E         MOV.W   R14, R10
   \   00000E                RPT     #0x5
   \   00000E   44180A5E     ADDX.W  R14, R10
   \   000012   0B4F         MOV.W   R15, R11
   \   000014   0B5A         ADD.W   R10, R11
   \   000016   8B9C0000     CMP.W   R12, 0(R11)
   \   00001A   0420         JNE     ??ZDSecMgrEntryLookupAMIGetIndex_2
    880                {
    881                  // return successful results
    882                  *entryIndex = index;
   \   00001C   8D4E0000     MOV.W   R14, 0(R13)
    883          
    884                  // break from loop
    885                  return ZSuccess;
   \   000020   4C43         MOV.B   #0x0, R12
   \   000022   053C         JMP     ??ZDSecMgrEntryLookupAMIGetIndex_3
    886                }
    887              }
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_2:
   \   000024   ........     CALLA   #?Subroutine32
    888            }
   \                     ??CrossCallReturnLabel_21:
   \   000028   F12B         JNC     ??ZDSecMgrEntryLookupAMIGetIndex_0
    889          
    890            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_1:
   \   00002A   7C40C800     MOV.B   #0xc8, R12
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_3:
   \   00002E   1A17         POPM.W  #0x2, R11
   \   000030   1001         RETA
    891          }
    892          
    893          /******************************************************************************
    894           * @fn          ZDSecMgrEntryFree
    895           *
    896           * @brief       Free entry.
    897           *
    898           * @param       entry - [in] valid entry
    899           *
    900           * @return      ZStatus_t
    901           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine28:
   \   000000   0F4B         MOV.W   R11, R15
   \   000002                REQUIRE ??Subroutine28_0
   \   000002                // Fall through to label ??Subroutine28_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   3E401800     MOV.W   #0x18, R14
   \   000004   0D43         MOV.W   #0x0, R13
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine15:
   \   000000   3C401800     MOV.W   #0x18, R12
   \   000004   ........     BRA     #osal_mem_alloc

   \                                 In  segment CODE, align 2, keep-with-next
    902          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    903          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
    904            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
    905          
    906          #if defined ( NV_RESTORE )
    907            ZStatus_t status;
    908            uint16 entryIndex;
    909          
    910            status = ZDSecMgrEntryLookupAMIGetIndex( entry->ami, &entryIndex );
    911          #endif
    912          
    913            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000004   ........     CALLA   #?Subroutine15
   \                     ??CrossCallReturnLabel_0:
   \   000008   0B4C         MOV.W   R12, R11
    914          
    915            if (pApsLinkKey != NULL)
   \   00000A   0C93         CMP.W   #0x0, R12
   \   00000C   0D24         JEQ     ??ZDSecMgrEntryFree_0
    916            {
    917              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000E   ........     CALLA   #?Subroutine27
    918          
    919              // Clear the APS Link key in NV
    920              osal_nv_write( entry->keyNvId, 0,
    921                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \                     ??CrossCallReturnLabel_14:
   \   000012   ........     CALLA   #?Subroutine28
   \                     ??CrossCallReturnLabel_62:
   \   000016   1C4A0200     MOV.W   0x2(R10), R12
   \   00001A   ........     CALLA   #osal_nv_write
    922          
    923              // set entry to invalid Key
    924              entry->keyNvId = SEC_NO_KEY_NV_ID;
   \   00001E   8A430200     MOV.W   #0x0, 0x2(R10)
    925          
    926              osal_mem_free(pApsLinkKey);
   \   000022   0C4B         MOV.W   R11, R12
   \   000024   ........     CALLA   #osal_mem_free
    927            }
    928          
    929            // marking the entry as INVALID_NODE_ADDR
    930            entry->ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryFree_0:
   \   000028   BA40FEFF0000 MOV.W   #0xfffe, 0(R10)
    931          
    932            // set to default value
    933            entry->authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00002E   CA430400     MOV.B   #0x0, 0x4(R10)
    934          
    935          #if defined ( NV_RESTORE )
    936            if ( status == ZSuccess )
    937            {
    938              ZDSecMgrUpdateNV(entryIndex);
    939            }
    940          #endif
    941          }
   \   000032   1A17         POPM.W  #0x2, R11
   \   000034   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine27:
   \   000000   3E401800     MOV.W   #0x18, R14
   \   000004   4D43         MOV.B   #0x0, R13
   \   000006   ........     BRA     #osal_memset
    942          
    943          /******************************************************************************
    944           * @fn          ZDSecMgrEntryNew
    945           *
    946           * @brief       Get a new entry.
    947           *
    948           * @param       entry - [out] valid entry
    949           *
    950           * @return      ZStatus_t
    951           */

   \                                 In  segment CODE, align 2, keep-with-next
    952          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    953          {
   \   000000   0A12         PUSH.W  R10
    954            uint16 index;
    955          
    956            // initialize results
    957            *entry = NULL;
   \   000002   8C430000     MOV.W   #0x0, 0(R12)
    958          
    959            // verify data is available
    960            if ( ZDSecMgrEntries != NULL )
   \   000006   1F42....     MOV.W   &ZDSecMgrEntries, R15
   \   00000A   0F93         CMP.W   #0x0, R15
   \   00000C   1624         JEQ     ??ZDSecMgrEntryNew_1
    961            {
    962              // find available entry
    963              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000E   0E43         MOV.W   #0x0, R14
    964              {
    965                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_0:
   \   000010   0D4E         MOV.W   R14, R13
   \   000012                RPT     #0x5
   \   000012   44180D5E     ADDX.W  R14, R13
   \   000016   0A4F         MOV.W   R15, R10
   \   000018   0A5D         ADD.W   R13, R10
   \   00001A   BA90FEFF0000 CMP.W   #0xfffe, 0(R10)
   \   000020   0920         JNE     ??ZDSecMgrEntryNew_2
    966                {
    967                  // return successful result
    968                  *entry = &ZDSecMgrEntries[index];
   \   000022   8C4A0000     MOV.W   R10, 0(R12)
    969          
    970                  // Set the authentication option to default
    971                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   000026   1F42....     MOV.W   &ZDSecMgrEntries, R15
   \   00002A   0F5D         ADD.W   R13, R15
   \   00002C   CF430400     MOV.B   #0x0, 0x4(R15)
    972          
    973                  // break from loop
    974                  return ZSuccess;
   \   000030   4C43         MOV.B   #0x0, R12
   \   000032   053C         JMP     ??ZDSecMgrEntryNew_3
    975                }
    976              }
   \                     ??ZDSecMgrEntryNew_2:
   \   000034   ........     CALLA   #?Subroutine32
    977            }
   \                     ??CrossCallReturnLabel_20:
   \   000038   EB2B         JNC     ??ZDSecMgrEntryNew_0
    978          
    979            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryNew_1:
   \   00003A   7C40C800     MOV.B   #0xc8, R12
   \                     ??ZDSecMgrEntryNew_3:
   \   00003E   3A41         POP.W   R10
   \   000040   1001         RETA
    980          }
    981          
    982          /******************************************************************************
    983           * @fn          ZDSecMgrCtrlInit
    984           *
    985           * @brief       Initialize control sub module
    986           *
    987           * @param       none
    988           *
    989           * @return      none
    990           */

   \                                 In  segment CODE, align 2, keep-with-next
    991          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    992          {
    993            uint16 size;
    994            uint16 index;
    995          
    996            // allocate entry data
    997            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    998          
    999            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000000   ........     CALLA   #?Subroutine15
   \                     ??CrossCallReturnLabel_1:
   \   000004   824C....     MOV.W   R12, &ZDSecMgrCtrlData
   1000          
   1001            // initialize data
   1002            if ( ZDSecMgrCtrlData != NULL )
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0B24         JEQ     ??ZDSecMgrCtrlInit_1
   1003            {
   1004              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00000C   0E43         MOV.W   #0x0, R14
   1005              {
   1006                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_0:
   \   00000E   1D42....     MOV.W   &ZDSecMgrCtrlData, R13
   \   000012   0F4E         MOV.W   R14, R15
   \   000014   5F0A         RLAM.W  #0x3, R15
   \   000016   0D5F         ADD.W   R15, R13
   \   000018   CD430500     MOV.B   #0x0, 0x5(R13)
   1007              }
   \   00001C   ........     CALLA   #?Subroutine32
   1008            }
   \                     ??CrossCallReturnLabel_19:
   \   000020   F62B         JNC     ??ZDSecMgrCtrlInit_0
   1009          }
   \                     ??ZDSecMgrCtrlInit_1:
   \   000022   1001         RETA
   1010          
   1011          /******************************************************************************
   1012           * @fn          ZDSecMgrCtrlRelease
   1013           *
   1014           * @brief       Release control data.
   1015           *
   1016           * @param       ctrl - [in] valid control data
   1017           *
   1018           * @return      none
   1019           */

   \                                 In  segment CODE, align 2, keep-with-next
   1020          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
   1021          {
   1022            // should always be enough entry control data
   1023            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000000   CC430500     MOV.B   #0x0, 0x5(R12)
   1024          }
   \   000004   1001         RETA
   1025          
   1026          /******************************************************************************
   1027           * @fn          ZDSecMgrCtrlLookup
   1028           *
   1029           * @brief       Lookup control data.
   1030           *
   1031           * @param       entry - [in] valid entry data
   1032           * @param       ctrl  - [out] control data - NULL if not found
   1033           *
   1034           * @return      none
   1035           */

   \                                 In  segment CODE, align 2, keep-with-next
   1036          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
   1037          {
   \   000000   1B15         PUSHM.W #0x2, R11
   1038            uint16 index;
   1039          
   1040            // initialize search results
   1041            *ctrl = NULL;
   \   000002   8D430000     MOV.W   #0x0, 0(R13)
   1042          
   1043            // verify data is available
   1044            if ( ZDSecMgrCtrlData != NULL )
   \   000006   1E42....     MOV.W   &ZDSecMgrCtrlData, R14
   \   00000A   0E93         CMP.W   #0x0, R14
   \   00000C   1224         JEQ     ??ZDSecMgrCtrlLookup_1
   1045            {
   1046              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00000E   0A43         MOV.W   #0x0, R10
   1047              {
   1048                // make sure control data is in use
   1049                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_0:
   \   000010   0F4A         MOV.W   R10, R15
   \   000012   5F0A         RLAM.W  #0x3, R15
   \   000014   0B4E         MOV.W   R14, R11
   \   000016   0B5F         ADD.W   R15, R11
   \   000018   CB930500     CMP.B   #0x0, 0x5(R11)
   \   00001C   0624         JEQ     ??ZDSecMgrCtrlLookup_2
   1050                {
   1051                  // check for entry match
   1052                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   00001E   8B9C0000     CMP.W   R12, 0(R11)
   \   000022   0320         JNE     ??ZDSecMgrCtrlLookup_2
   1053                  {
   1054                    // return this control data
   1055                    *ctrl = &ZDSecMgrCtrlData[index];
   \   000024   8D4B0000     MOV.W   R11, 0(R13)
   1056          
   1057                    // break from loop
   1058                    return;
   \   000028   043C         JMP     ??ZDSecMgrCtrlLookup_1
   1059                  }
   1060                }
   1061              }
   \                     ??ZDSecMgrCtrlLookup_2:
   \   00002A   1A53         ADD.W   #0x1, R10
   \   00002C   3A900300     CMP.W   #0x3, R10
   \   000030   EF2B         JNC     ??ZDSecMgrCtrlLookup_0
   1062            }
   1063          }
   \                     ??ZDSecMgrCtrlLookup_1:
   \   000032   1A17         POPM.W  #0x2, R11
   \   000034   1001         RETA
   1064          
   1065          /******************************************************************************
   1066           * @fn          ZDSecMgrCtrlSet
   1067           *
   1068           * @brief       Set control data.
   1069           *
   1070           * @param       device - [in] valid device data
   1071           * @param       entry  - [in] valid entry data
   1072           * @param       ctrl   - [in] valid control data
   1073           *
   1074           * @return      none
   1075           */

   \                                 In  segment CODE, align 2, keep-with-next
   1076          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
   1077                                ZDSecMgrEntry_t*  entry,
   1078                                ZDSecMgrCtrl_t*   ctrl )
   1079          {
   1080            // set control date
   1081            ctrl->parentAddr = device->parentAddr;
   \   000000   9E4C04000200 MOV.W   0x4(R12), 0x2(R14)
   1082            ctrl->secure     = device->secure;
   \   000006   DE4C06000400 MOV.B   0x6(R12), 0x4(R14)
   1083            ctrl->entry      = entry;
   \   00000C   8E4D0000     MOV.W   R13, 0(R14)
   1084            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \   000010   DE430500     MOV.B   #0x1, 0x5(R14)
   1085            ctrl->cntr       = 0;
   \   000014   CE430600     MOV.B   #0x0, 0x6(R14)
   1086          
   1087            // set device pointer
   1088            device->ctrl = ctrl;
   \   000018   8C4E0800     MOV.W   R14, 0x8(R12)
   1089          }
   \   00001C   1001         RETA
   1090          
   1091          /******************************************************************************
   1092           * @fn          ZDSecMgrCtrlAdd
   1093           *
   1094           * @brief       Add control data.
   1095           *
   1096           * @param       device - [in] valid device data
   1097           * @param       entry  - [in] valid entry data
   1098           *
   1099           * @return      ZStatus_t
   1100           */

   \                                 In  segment CODE, align 2, keep-with-next
   1101          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1102          {
   \   000000   1B15         PUSHM.W #0x2, R11
   1103            uint16 index;
   1104          
   1105            // verify data is available
   1106            if ( ZDSecMgrCtrlData != NULL )
   \   000002   1A42....     MOV.W   &ZDSecMgrCtrlData, R10
   \   000006   0A93         CMP.W   #0x0, R10
   \   000008   1024         JEQ     ??ZDSecMgrCtrlAdd_1
   1107            {
   1108              // look for an empty slot
   1109              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00000A   0B43         MOV.W   #0x0, R11
   1110              {
   1111                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_0:
   \   00000C   0F4B         MOV.W   R11, R15
   \   00000E   5F0A         RLAM.W  #0x3, R15
   \   000010   0E4A         MOV.W   R10, R14
   \   000012   0E5F         ADD.W   R15, R14
   \   000014   CE930500     CMP.B   #0x0, 0x5(R14)
   \   000018   0420         JNE     ??ZDSecMgrCtrlAdd_2
   1112                {
   1113                  // return successful results
   1114                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   00001A   ........     CALLA   #ZDSecMgrCtrlSet
   1115          
   1116                  // break from loop
   1117                  return ZSuccess;
   \   00001E   4C43         MOV.B   #0x0, R12
   \   000020   063C         JMP     ??ZDSecMgrCtrlAdd_3
   1118                }
   1119              }
   \                     ??ZDSecMgrCtrlAdd_2:
   \   000022   1B53         ADD.W   #0x1, R11
   \   000024   3B900300     CMP.W   #0x3, R11
   \   000028   F12B         JNC     ??ZDSecMgrCtrlAdd_0
   1120            }
   1121          
   1122            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrCtrlAdd_1:
   \   00002A   7C40C800     MOV.B   #0xc8, R12
   \                     ??ZDSecMgrCtrlAdd_3:
   \   00002E   1A17         POPM.W  #0x2, R11
   \   000030   1001         RETA
   1123          }
   1124          
   1125          /******************************************************************************
   1126           * @fn          ZDSecMgrCtrlTerm
   1127           *
   1128           * @brief       Terminate device control.
   1129           *
   1130           * @param       entry - [in] valid entry data
   1131           *
   1132           * @return      none
   1133           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine40:
   \   000000   ........     CALLA   #ZDSecMgrCtrlLookup
   \   000004   81930400     CMP.W   #0x0, 0x4(SP)
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1134          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1135          {
   \   000000   2183         SUB.W   #0x2, SP
   1136            ZDSecMgrCtrl_t* ctrl;
   1137          
   1138            // remove device from control data
   1139            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000002   0D41         MOV.W   SP, R13
   \   000004   0D53         ADD.W   #0x0, R13
   \   000006   ........     CALLA   #?Subroutine40
   1140          
   1141            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_45:
   \   00000A   0324         JEQ     ??ZDSecMgrCtrlTerm_0
   1142            {
   1143              ZDSecMgrCtrlRelease ( ctrl );
   \   00000C   2F41         MOV.W   @SP, R15
   \   00000E   CF430500     MOV.B   #0x0, 0x5(R15)
   1144            }
   1145          }
   \                     ??ZDSecMgrCtrlTerm_0:
   \   000012   2153         ADD.W   #0x2, SP
   \   000014   1001         RETA
   1146          
   1147          /******************************************************************************
   1148           * @fn          ZDSecMgrCtrlReset
   1149           *
   1150           * @brief       Reset control data.
   1151           *
   1152           * @param       device - [in] valid device data
   1153           * @param       entry  - [in] valid entry data
   1154           *
   1155           * @return      ZStatus_t
   1156           */

   \                                 In  segment CODE, align 2, keep-with-next
   1157          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1158          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4C         MOV.W   R12, R10
   \   000006   0B4D         MOV.W   R13, R11
   1159            ZStatus_t       status;
   1160            ZDSecMgrCtrl_t* ctrl;
   1161          
   1162            // initialize results
   1163            status = ZNwkUnknownDevice;
   1164          
   1165            // look for a match for the entry
   1166            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000008   0D41         MOV.W   SP, R13
   \   00000A   0D53         ADD.W   #0x0, R13
   \   00000C   0C4B         MOV.W   R11, R12
   \   00000E   ........     CALLA   #?Subroutine40
   1167          
   1168            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_44:
   \   000012   0724         JEQ     ??ZDSecMgrCtrlReset_0
   1169            {
   1170              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   000014   2E41         MOV.W   @SP, R14
   \   000016   0D4B         MOV.W   R11, R13
   \   000018   0C4A         MOV.W   R10, R12
   \   00001A   ........     CALLA   #ZDSecMgrCtrlSet
   1171          
   1172              status = ZSuccess;
   \   00001E   4C43         MOV.B   #0x0, R12
   \   000020   043C         JMP     ??ZDSecMgrCtrlReset_1
   1173            }
   1174            else
   1175            {
   1176              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_0:
   \   000022   0D4B         MOV.W   R11, R13
   \   000024   0C4A         MOV.W   R10, R12
   \   000026   ........     CALLA   #ZDSecMgrCtrlAdd
   1177            }
   1178          
   1179            return status;
   \                     ??ZDSecMgrCtrlReset_1:
   \   00002A   ........     BRA     #??Subroutine2_0
   1180          }
   1181          
   1182          /******************************************************************************
   1183           * @fn          ZDSecMgrMasterKeyLoad
   1184           *
   1185           * @brief       Load the MASTER key for device with specified EXT
   1186           *              address.
   1187           *
   1188           * @param       extAddr - [in] EXT address of device
   1189           * @param       key     - [in] MASTER key shared with device
   1190           *
   1191           * @return      ZStatus_t
   1192           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine33:
   \   000000   0D41         MOV.W   SP, R13
   \   000002   3D500600     ADD.W   #0x6, R13
   \   000006   1C410400     MOV.W   0x4(SP), R12
   \   00000A   ........     CALLA   #ZDSecMgrMasterKeyLookup
   \   00000E   4C93         CMP.B   #0x0, R12
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1193          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1194          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2182         SUB.W   #0x4, SP
   \   000004   ........     CALLA   #?Subroutine31
   1195            ZStatus_t status;
   1196            uint16 ami;
   1197            uint16 keyNvId;
   1198          
   1199            // set status based on policy
   1200            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   1201          
   1202            if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_18:
   \   000008   1120         JNE     ??ZDSecMgrMasterKeyLoad_0
   1203            {
   1204              // get the address NV ID
   1205              if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) == ZSuccess )
   \   00000A   ........     CALLA   #?Subroutine33
   \                     ??CrossCallReturnLabel_27:
   \   00000E   0920         JNE     ??ZDSecMgrMasterKeyLoad_1
   1206              {
   1207                // overwrite old key in NV
   1208                osal_nv_write( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key),
   1209                               SEC_KEY_LEN, key );
   \   000010   0F4A         MOV.W   R10, R15
   \   000012   3E401000     MOV.W   #0x10, R14
   \   000016   2D43         MOV.W   #0x2, R13
   \   000018   1C410200     MOV.W   0x2(SP), R12
   \   00001C   ........     CALLA   #osal_nv_write
   \   000020   053C         JMP     ??ZDSecMgrMasterKeyLoad_0
   1210              }
   1211              else
   1212              {
   1213                // store new key -- NULL will zero key
   1214                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   000022   0D4A         MOV.W   R10, R13
   \   000024   2C41         MOV.W   @SP, R12
   \   000026   ........     CALLA   #ZDSecMgrMasterKeyStore
   \   00002A   4B4C         MOV.B   R12, R11
   1215              }
   1216            }
   1217          
   1218            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   00002C   4C4B         MOV.B   R11, R12
   \   00002E                REQUIRE ?Subroutine9
   \   00002E                // Fall through to label ?Subroutine9
   1219          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   2152         ADD.W   #0x4, SP
   \   000002   1A17         POPM.W  #0x2, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine31:
   \   000000   0A4D         MOV.W   R13, R10
   \   000002   0D41         MOV.W   SP, R13
   \   000004   2D52         ADD.W   #0x4, R13
   \   000006   ........     CALLA   #ZDSecMgrExtAddrLookup
   \   00000A   4B4C         MOV.B   R12, R11
   \   00000C   4C93         CMP.B   #0x0, R12
   \   00000E   1001         RETA
   1220          
   1221          /******************************************************************************
   1222           * @fn          ZDSecMgrAppKeyGet
   1223           *
   1224           * @brief       get an APP key - option APP(MASTER or LINK) key
   1225           *
   1226           * @param       initNwkAddr - [in] NWK address of initiator device
   1227           * @param       initExtAddr - [in] EXT address of initiator device
   1228           * @param       partNwkAddr - [in] NWK address of partner device
   1229           * @param       partExtAddr - [in] EXT address of partner device
   1230           * @param       key         - [out] APP(MASTER or LINK) key
   1231           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1232           *
   1233           * @return      ZStatus_t
   1234           */

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   1235          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   1236                                                           // to KEY_TYPE_APP_LINK since
   1237                                                           // only specific requirement
   1238                                                           // right now comes from SE profile
   1239          

   \                                 In  segment CODE, align 2, keep-with-next
   1240          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1241                                       uint8*  initExtAddr,
   1242                                       uint16  partNwkAddr,
   1243                                       uint8*  partExtAddr,
   1244                                       uint8** key,
   1245                                       uint8*  keyType )
   1246          {
   \   000000   0A12         PUSH.W  R10
   \   000002   1F410600     MOV.W   0x6(SP), R15
   \   000006   1A410800     MOV.W   0x8(SP), R10
   1247            // Intentionally unreferenced parameters
   1248            (void)initNwkAddr;
   1249            (void)initExtAddr;
   1250            (void)partNwkAddr;
   1251            (void)partExtAddr;
   1252          
   1253            //---------------------------------------------------------------------------
   1254            // note:
   1255            // should use a robust mechanism to generate keys, for example
   1256            // combine EXT addresses and call a hash function
   1257            //---------------------------------------------------------------------------
   1258            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   00000A   2D4F         MOV.W   @R15, R13
   \   00000C   7C401000     MOV.B   #0x10, R12
   \   000010   ........     CALLA   #SSP_GetTrueRand
   1259          
   1260            *keyType = ZDSecMgrAppKeyType;
   \   000014   DA42....0000 MOV.B   &ZDSecMgrAppKeyType, 0(R10)
   1261          
   1262            return ZSuccess;
   \   00001A   4C43         MOV.B   #0x0, R12
   \   00001C   3A41         POP.W   R10
   \   00001E   1001         RETA
   1263          }
   1264          
   1265          /******************************************************************************
   1266           * @fn          ZDSecMgrAppKeyReq
   1267           *
   1268           * @brief       Process request for APP key between two devices.
   1269           *
   1270           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1271           *
   1272           * @return      none
   1273           */

   \                                 In  segment CODE, align 2, keep-with-next
   1274          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1275          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31802800     SUB.W   #0x28, SP
   \   000006   0A4C         MOV.W   R12, R10
   1276            APSME_TransportKeyReq_t req;
   1277            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1278            uint16                  partNwkAddr;
   1279            uint8                   key[SEC_KEY_LEN];
   1280          
   1281          
   1282            // validate initiator and partner
   1283            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1284                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   000008   0D41         MOV.W   SP, R13
   \   00000A   0D53         ADD.W   #0x0, R13
   \   00000C   3C500500     ADD.W   #0x5, R12
   \   000010   ........     CALLA   #APSME_LookupNwkAddr
   \   000014   5C93         CMP.B   #0x1, R12
   \   000016   4720         JNE     ??ZDSecMgrAppKeyReq_0
   \   000018   0B41         MOV.W   SP, R11
   \   00001A   3B501000     ADD.W   #0x10, R11
   \   00001E   0D4B         MOV.W   R11, R13
   \   000020   1C4A0200     MOV.W   0x2(R10), R12
   \   000024   ........     CALLA   #APSME_LookupExtAddr
   \   000028   5C93         CMP.B   #0x1, R12
   \   00002A   3D20         JNE     ??ZDSecMgrAppKeyReq_0
   1285            {
   1286              // point the key to some memory
   1287              req.key = key;
   \   00002C   0F41         MOV.W   SP, R15
   \   00002E   3F501800     ADD.W   #0x18, R15
   \   000032   814F0600     MOV.W   R15, 0x6(SP)
   1288          
   1289              // get an APP key - option APP (MASTER or LINK) key
   1290              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1291                                      initExtAddr,
   1292                                      partNwkAddr,
   1293                                      ind->partExtAddr,
   1294                                      &req.key,
   1295                                      &req.keyType ) == ZSuccess )
   \   000036   0841         MOV.W   SP, R8
   \   000038   2853         ADD.W   #0x2, R8
   \   00003A   0F48         MOV.W   R8, R15
   \   00003C   2F53         ADD.W   #0x2, R15
   \   00003E   0F12         PUSH.W  R15
   \   000040   0F48         MOV.W   R8, R15
   \   000042   2F52         ADD.W   #0x4, R15
   \   000044   0F12         PUSH.W  R15
   \   000046   0F4A         MOV.W   R10, R15
   \   000048   3F500500     ADD.W   #0x5, R15
   \   00004C   1E410400     MOV.W   0x4(SP), R14
   \   000050   0D4B         MOV.W   R11, R13
   \   000052   1C4A0200     MOV.W   0x2(R10), R12
   \   000056   ........     CALLA   #ZDSecMgrAppKeyGet
   \   00005A   2152         ADD.W   #0x4, SP
   \   00005C   4C93         CMP.B   #0x0, R12
   \   00005E   2320         JNE     ??ZDSecMgrAppKeyReq_0
   1296              {
   1297                // always secure
   1298                req.nwkSecure = TRUE;
   \   000060   D1430C00     MOV.B   #0x1, 0xc(SP)
   1299                req.apsSecure = TRUE;
   \   000064   D1430B00     MOV.B   #0x1, 0xb(SP)
   1300                req.tunnel    = NULL;
   \   000068   81430E00     MOV.W   #0x0, 0xe(SP)
   1301          
   1302                // send key to initiator device
   1303                req.dstAddr   = ind->srcAddr;
   \   00006C   914A02000200 MOV.W   0x2(R10), 0x2(SP)
   1304                req.extAddr   = ind->partExtAddr;
   \   000072   3A500500     ADD.W   #0x5, R10
   \   000076   814A0800     MOV.W   R10, 0x8(SP)
   1305                req.initiator = TRUE;
   \   00007A   D1430A00     MOV.B   #0x1, 0xa(SP)
   1306                APSME_TransportKeyReq( &req );
   \   00007E   0C48         MOV.W   R8, R12
   \   000080   ........     CALLA   #APSME_TransportKeyReq
   1307          
   1308                // send key to partner device
   1309                req.dstAddr   = partNwkAddr;
   \   000084   A1410200     MOV.W   @SP, 0x2(SP)
   1310                req.extAddr   = initExtAddr;
   \   000088   814B0800     MOV.W   R11, 0x8(SP)
   1311                req.initiator = FALSE;
   \   00008C   C1430A00     MOV.B   #0x0, 0xa(SP)
   1312          
   1313                APSME_TransportKeyReq( &req );
   \   000090   0C48         MOV.W   R8, R12
   \   000092   ........     CALLA   #APSME_TransportKeyReq
   1314          
   1315                // clear copy of key in RAM
   1316                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   000096   3E401000     MOV.W   #0x10, R14
   \   00009A   4D43         MOV.B   #0x0, R13
   \   00009C   0C41         MOV.W   SP, R12
   \   00009E   3C501800     ADD.W   #0x18, R12
   \   0000A2   ........     CALLA   #osal_memset
   1317          
   1318              }
   1319            }
   1320          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   0000A6   31502800     ADD.W   #0x28, SP
   \   0000AA   3817         POPM.W  #0x4, R11
   \   0000AC   1001         RETA
   1321          
   1322          /******************************************************************************
   1323           * @fn          ZDSecMgrEstablishKey
   1324           *
   1325           * @brief       Start SKKE with device joining network.
   1326           *
   1327           * @param       device - [in] ZDSecMgrDevice_t, device info
   1328           *
   1329           * @return      ZStatus_t
   1330           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine11:
   \   000000   3152         ADD.W   #0x8, SP
   \   000002   3A41         POP.W   R10
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine38:
   \   000000   ........     CALLA   #NLME_GetShortAddr
   \   000004   1F4A0400     MOV.W   0x4(R10), R15
   \   000008   0F9C         CMP.W   R12, R15
   \   00000A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1331          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1332          {
   \   000000   0A12         PUSH.W  R10
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0A4C         MOV.W   R12, R10
   1333            ZStatus_t               status;
   1334            APSME_EstablishKeyReq_t req;
   1335          
   1336          
   1337            req.respExtAddr = device->extAddr;
   \   000006   914C02000200 MOV.W   0x2(R12), 0x2(SP)
   1338            req.method      = APSME_SKKE_METHOD;
   \   00000C   C1430400     MOV.B   #0x0, 0x4(SP)
   1339          
   1340            if ( device->parentAddr == NLME_GetShortAddr() )
   \   000010   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_41:
   \   000014   0720         JNE     ??ZDSecMgrEstablishKey_0
   1341            {
   1342              req.dstAddr   = device->nwkAddr;
   \   000016   A14A0000     MOV.W   @R10, 0(SP)
   1343              //devtag.0604.todo - remove obsolete
   1344              req.apsSecure = FALSE;
   \   00001A   C1430500     MOV.B   #0x0, 0x5(SP)
   1345              req.nwkSecure = FALSE;
   \   00001E   C1430600     MOV.B   #0x0, 0x6(SP)
   \   000022   063C         JMP     ??ZDSecMgrEstablishKey_1
   1346            }
   1347            else
   1348            {
   1349              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_0:
   \   000024   814F0000     MOV.W   R15, 0(SP)
   1350              //devtag.0604.todo - remove obsolete
   1351              req.apsSecure = TRUE;
   \   000028   D1430500     MOV.B   #0x1, 0x5(SP)
   1352              req.nwkSecure = TRUE;
   \   00002C   D1430600     MOV.B   #0x1, 0x6(SP)
   1353            }
   1354          
   1355            status = APSME_EstablishKeyReq( &req );
   1356          
   1357            return status;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000030   0C41         MOV.W   SP, R12
   \   000032   0C53         ADD.W   #0x0, R12
   \   000034   ........     CALLA   #APSME_EstablishKeyReq
   \   000038   ........     BRA     #?Subroutine11
   1358          }
   1359          
   1360          /******************************************************************************
   1361           * @fn          ZDSecMgrSendMasterKey
   1362           *
   1363           * @brief       Send MASTER key to device joining network.
   1364           *
   1365           * @param       device - [in] ZDSecMgrDevice_t, device info
   1366           *
   1367           * @return      ZStatus_t
   1368           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine21:
   \   000000   3E401000     MOV.W   #0x10, R14
   \   000004                REQUIRE ??Subroutine21_0
   \   000004                // Fall through to label ??Subroutine21_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine21_0:
   \   000000   4D43         MOV.B   #0x0, R13
   \   000002   0C4B         MOV.W   R11, R12
   \   000004   ........     BRA     #osal_memset

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   ........     CALLA   #??Subroutine21_0
   \                     ??CrossCallReturnLabel_72:
   \   000004   4C4A         MOV.B   R10, R12
   \   000006   31502000     ADD.W   #0x20, SP
   \   00000A   1A17         POPM.W  #0x2, R11
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1369          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1370          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31802000     SUB.W   #0x20, SP
   \   000006   0A4C         MOV.W   R12, R10
   1371            ZStatus_t status;
   1372            APSME_TransportKeyReq_t req;
   1373            uint16 keyNvId;
   1374            uint8 masterKey[SEC_KEY_LEN];
   1375          
   1376          
   1377            req.keyType = KEY_TYPE_TC_MASTER;
   \   000008   C1430400     MOV.B   #0x0, 0x4(SP)
   1378            req.extAddr = device->extAddr;
   \   00000C   914C02000800 MOV.W   0x2(R12), 0x8(SP)
   1379            req.tunnel  = NULL;
   \   000012   81430E00     MOV.W   #0x0, 0xe(SP)
   1380          
   1381            if ( ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &keyNvId ) == ZSuccess )
   \   000016   0B41         MOV.W   SP, R11
   \   000018   3B501000     ADD.W   #0x10, R11
   \   00001C   0D41         MOV.W   SP, R13
   \   00001E   0D53         ADD.W   #0x0, R13
   \   000020   1F4C0800     MOV.W   0x8(R12), R15
   \   000024   2F4F         MOV.W   @R15, R15
   \   000026   2C4F         MOV.W   @R15, R12
   \   000028   ........     CALLA   #ZDSecMgrMasterKeyLookup
   \   00002C   4C93         CMP.B   #0x0, R12
   \   00002E   0820         JNE     ??ZDSecMgrSendMasterKey_0
   1382            {
   1383              osal_nv_read( keyNvId, osal_offsetof(ZDSecMgrMasterKeyData_t, key),
   1384                            SEC_KEY_LEN, masterKey );
   \   000030   0F4B         MOV.W   R11, R15
   \   000032   3E401000     MOV.W   #0x10, R14
   \   000036   2D43         MOV.W   #0x2, R13
   \   000038   2C41         MOV.W   @SP, R12
   \   00003A   ........     CALLA   #osal_nv_read
   \   00003E   023C         JMP     ??ZDSecMgrSendMasterKey_1
   1385            }
   1386            else
   1387            {
   1388              // in case read from NV fails
   1389              osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \                     ??ZDSecMgrSendMasterKey_0:
   \   000040   ........     CALLA   #?Subroutine21
   1390            }
   1391          
   1392            req.key = masterKey;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   000044   814B0600     MOV.W   R11, 0x6(SP)
   1393          
   1394            //check if using secure hop to to parent
   1395            if ( device->parentAddr != NLME_GetShortAddr() )
   \   000048   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_40:
   \   00004C   0724         JEQ     ??ZDSecMgrSendMasterKey_2
   1396            {
   1397              //send to parent with security
   1398              req.dstAddr   = device->parentAddr;
   \   00004E   814F0200     MOV.W   R15, 0x2(SP)
   1399              req.nwkSecure = TRUE;
   \   000052   D1430C00     MOV.B   #0x1, 0xc(SP)
   1400              req.apsSecure = TRUE;
   \   000056   D1430B00     MOV.B   #0x1, 0xb(SP)
   \   00005A   063C         JMP     ??ZDSecMgrSendMasterKey_3
   1401            }
   1402            else
   1403            {
   1404              //direct with no security
   1405              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_2:
   \   00005C   A14A0200     MOV.W   @R10, 0x2(SP)
   1406              req.nwkSecure = FALSE;
   \   000060   C1430C00     MOV.B   #0x0, 0xc(SP)
   1407              req.apsSecure = FALSE;
   \   000064   C1430B00     MOV.B   #0x0, 0xb(SP)
   1408            }
   1409          
   1410            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendMasterKey_3:
   \   000068   0C41         MOV.W   SP, R12
   \   00006A   2C53         ADD.W   #0x2, R12
   \   00006C   ........     CALLA   #APSME_TransportKeyReq
   \   000070   4A4C         MOV.B   R12, R10
   1411          
   1412            // clear copy of key in RAM
   1413            osal_memset( masterKey, 0x00, SEC_KEY_LEN);
   \   000072   3E401000     MOV.W   #0x10, R14
   \   000076   ....         JMP     ?Subroutine1
   1414          
   1415            return status;
   1416          }
   1417          
   1418          /******************************************************************************
   1419           * @fn          ZDSecMgrSendNwkKey
   1420           *
   1421           * @brief       Send NWK key to device joining network.
   1422           *
   1423           * @param       device - [in] ZDSecMgrDevice_t, device info
   1424           *
   1425           * @return      ZStatus_t
   1426           */

   \                                 In  segment CODE, align 2, keep-with-next
   1427          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1428          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31802000     SUB.W   #0x20, SP
   \   000006   0A4C         MOV.W   R12, R10
   1429            ZStatus_t status;
   1430            APSME_TransportKeyReq_t req;
   1431            APSDE_FrameTunnel_t tunnel;
   1432            nwkKeyDesc tmpKey;
   1433          
   1434            req.dstAddr   = device->nwkAddr;
   \   000008   A14C0000     MOV.W   @R12, 0(SP)
   1435            req.extAddr   = device->extAddr;
   \   00000C   914C02000600 MOV.W   0x2(R12), 0x6(SP)
   1436          
   1437            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1438            {
   1439              req.keyType   = KEY_TYPE_NWK_HIGH;
   1440            }
   1441            else
   1442            {
   1443              req.keyType   = KEY_TYPE_NWK;
   \   000012   D1430200     MOV.B   #0x1, 0x2(SP)
   1444            }
   1445          
   1446            // get the Active Key into a local variable
   1447            if( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
   1448                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   \   000016   0B41         MOV.W   SP, R11
   \   000018   3B500E00     ADD.W   #0xe, R11
   \   00001C   3F403A00     MOV.W   #0x3a, R15
   \   000020   0E4B         MOV.W   R11, R14
   \   000022   3D401100     MOV.W   #0x11, R13
   \   000026   0C43         MOV.W   #0x0, R12
   \   000028   ........     CALLA   #NLME_ReadNwkKeyInfo
   \   00002C   4C93         CMP.B   #0x0, R12
   \   00002E   0424         JEQ     ??ZDSecMgrSendNwkKey_0
   1449            {
   1450              // set key data to all 0s if NV read fails
   1451              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   \   000030   3E401100     MOV.W   #0x11, R14
   \   000034   ........     CALLA   #??Subroutine21_0
   1452            }
   1453          
   1454            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1455                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1456            {
   1457              // set values
   1458              req.keySeqNum = tmpKey.keySeqNum;
   1459              req.key       = tmpKey.key;
   1460          
   1461              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1462              //key isn't used to secure the frame at the APS layer -- since the receiving
   1463              //device may not have a NWK key yet
   1464              req.apsSecure = TRUE;
   1465          
   1466              // check if using secure hop to to parent
   1467              if ( device->parentAddr == NLME_GetShortAddr() )
   1468              {
   1469                req.nwkSecure = FALSE;
   1470                req.tunnel    = NULL;
   1471              }
   1472              else
   1473              {
   1474                req.nwkSecure   = TRUE;
   1475                req.tunnel      = &tunnel;
   1476                req.tunnel->tna = device->parentAddr;
   1477                req.tunnel->dea = device->extAddr;
   1478              }
   1479            }
   1480            else
   1481            {
   1482              // default values
   1483              //devtag.0604.verify
   1484              req.nwkSecure = TRUE;
   \                     ??ZDSecMgrSendNwkKey_0:
   \   000038   D1430A00     MOV.B   #0x1, 0xa(SP)
   1485              req.apsSecure = FALSE;
   \   00003C   C1430900     MOV.B   #0x0, 0x9(SP)
   1486              req.tunnel    = NULL;
   \   000040   81430C00     MOV.W   #0x0, 0xc(SP)
   1487          
   1488              if ( device->parentAddr != NLME_GetShortAddr() )
   \   000044   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_39:
   \   000048   0224         JEQ     ??ZDSecMgrSendNwkKey_1
   1489              {
   1490                req.dstAddr = device->parentAddr;
   \   00004A   814F0000     MOV.W   R15, 0(SP)
   1491              }
   1492          
   1493              // special cases
   1494              //devtag.0604.todo - modify to preconfig flag
   1495              if ( device->secure == FALSE )
   \                     ??ZDSecMgrSendNwkKey_1:
   \   00004E   CA930600     CMP.B   #0x0, 0x6(R10)
   \   000052   0F20         JNE     ??ZDSecMgrSendNwkKey_2
   1496              {
   1497                req.keySeqNum = tmpKey.keySeqNum;
   \   000054   D1410E000300 MOV.B   0xe(SP), 0x3(SP)
   1498                req.key       = tmpKey.key;
   \   00005A   0F4B         MOV.W   R11, R15
   \   00005C   1F53         ADD.W   #0x1, R15
   \   00005E   814F0400     MOV.W   R15, 0x4(SP)
   1499          
   1500                // check if using secure hop to to parent
   1501                if ( device->parentAddr == NLME_GetShortAddr() )
   \   000062   ........     CALLA   #NLME_GetShortAddr
   \   000066   8A9C0400     CMP.W   R12, 0x4(R10)
   \   00006A   0720         JNE     ??ZDSecMgrSendNwkKey_3
   1502                {
   1503                  req.nwkSecure = FALSE;
   \   00006C   C1430A00     MOV.B   #0x0, 0xa(SP)
   \   000070   043C         JMP     ??ZDSecMgrSendNwkKey_3
   1504                }
   1505              }
   1506              else
   1507              {
   1508                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_2:
   \   000072   81430400     MOV.W   #0x0, 0x4(SP)
   1509                req.keySeqNum = 0;
   \   000076   C1430300     MOV.B   #0x0, 0x3(SP)
   1510              }
   1511            }
   1512          
   1513            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendNwkKey_3:
   \   00007A   0C41         MOV.W   SP, R12
   \   00007C   0C53         ADD.W   #0x0, R12
   \   00007E   ........     CALLA   #APSME_TransportKeyReq
   \   000082   4A4C         MOV.B   R12, R10
   1514          
   1515            // clear copy of key in RAM before return
   1516            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   \   000084   3E401100     MOV.W   #0x11, R14
   \   000088                REQUIRE ?Subroutine1
   \   000088                // Fall through to label ?Subroutine1
   1517          
   1518            return status;
   1519          }
   1520          
   1521          /******************************************************************************
   1522           * @fn          ZDSecMgrDeviceEntryRemove
   1523           *
   1524           * @brief       Remove device entry.
   1525           *
   1526           * @param       entry - [in] valid entry
   1527           *
   1528           * @return      none
   1529           */

   \                                 In  segment CODE, align 2, keep-with-next
   1530          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   1531          {
   1532            // terminate device control
   1533            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1534            {
   1535              ZDSecMgrCtrlTerm( entry );
   1536            }
   1537          
   1538            // remove device from entry data
   1539            ZDSecMgrEntryFree( entry );
   \   000000   ........     BRA     #ZDSecMgrEntryFree
   1540          
   1541          }
   1542          
   1543          /******************************************************************************
   1544           * @fn          ZDSecMgrDeviceRemoveByExtAddr
   1545           *
   1546           * @brief       Remove device entry by its ext address.
   1547           *
   1548           * @param       pAddr - pointer to the extended address
   1549           *
   1550           * @return      ZStatus_t
   1551           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine10:
   \   000000   2153         ADD.W   #0x2, SP
   \   000002   3A41         POP.W   R10
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine34:
   \   000000   0D41         MOV.W   SP, R13
   \   000002   2D52         ADD.W   #0x4, R13
   \   000004   ........     BRA     #ZDSecMgrEntryLookupExt

   \                                 In  segment CODE, align 2, keep-with-next
   1552          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
   1553          {
   \   000000   0A12         PUSH.W  R10
   \   000002   2183         SUB.W   #0x2, SP
   1554            ZDSecMgrEntry_t *pEntry;
   1555            uint8           retValue;
   1556          
   1557            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   000004   ........     CALLA   #?Subroutine34
   \                     ??CrossCallReturnLabel_28:
   \   000008   4A4C         MOV.B   R12, R10
   1558          
   1559            if( retValue == ZSuccess )
   \   00000A   4C93         CMP.B   #0x0, R12
   \   00000C   0320         JNE     ??ZDSecMgrDeviceRemoveByExtAddr_0
   1560            {
   1561              ZDSecMgrDeviceEntryRemove( pEntry );
   \   00000E   2C41         MOV.W   @SP, R12
   \   000010   ........     CALLA   #ZDSecMgrEntryFree
   1562            }
   1563          
   1564            return retValue;
   \                     ??ZDSecMgrDeviceRemoveByExtAddr_0:
   \   000014   4C4A         MOV.B   R10, R12
   \   000016   ........     BRA     #?Subroutine10
   1565          }
   1566          
   1567          /******************************************************************************
   1568           * @fn          ZDSecMgrDeviceEntryAdd
   1569           *
   1570           * @brief       Add entry.
   1571           *
   1572           * @param       device - [in] ZDSecMgrDevice_t, device info
   1573           * @param       ami    - [in] Address Manager index
   1574           *
   1575           * @return      ZStatus_t
   1576           */

   \                                 In  segment CODE, align 2, keep-with-next
   1577          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1578          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31800E00     SUB.W   #0xe, SP
   \   000006   0A4D         MOV.W   R13, R10
   1579            AddrMgrEntry_t entry;
   1580          
   1581            // get the ami data
   1582            entry.user  = ADDRMGR_USER_SECURITY;
   \   000008   E1430000     MOV.B   #0x2, 0(SP)
   1583            entry.index = ami;
   \   00000C   814C0C00     MOV.W   R12, 0xc(SP)
   1584          
   1585            AddrMgrEntryGet( &entry );
   \   000010   0C41         MOV.W   SP, R12
   \   000012   0C53         ADD.W   #0x0, R12
   \   000014   ........     CALLA   #AddrMgrEntryGet
   1586          
   1587            // check if NWK address is same
   1588            if ( entry.nwkAddr != nwkAddr )
   \   000018   819A0200     CMP.W   R10, 0x2(SP)
   \   00001C   0624         JEQ     ??ZDSecMgrAddrMgrUpdate_0
   1589            {
   1590              // update NWK address
   1591              entry.nwkAddr = nwkAddr;
   \   00001E   814A0200     MOV.W   R10, 0x2(SP)
   1592          
   1593              AddrMgrEntryUpdate( &entry );
   \   000022   0C41         MOV.W   SP, R12
   \   000024   0C53         ADD.W   #0x0, R12
   \   000026   ........     CALLA   #AddrMgrEntryUpdate
   1594            }
   1595          }
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   00002A   ........     BRA     #??Subroutine0_0
   1596          

   \                                 In  segment CODE, align 2, keep-with-next
   1597          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1598          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4C         MOV.W   R12, R10
   \   000006   0B4D         MOV.W   R13, R11
   1599            ZStatus_t        status;
   1600            ZDSecMgrEntry_t* entry;
   1601          
   1602            // initialize as unknown until completion
   1603            status = ZNwkUnknownDevice;
   \   000008   7840C800     MOV.B   #0xc8, R8
   1604          
   1605            device->ctrl = NULL;
   \   00000C   8C430800     MOV.W   #0x0, 0x8(R12)
   1606          
   1607            // make sure not already registered
   1608            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \   000010   0D41         MOV.W   SP, R13
   \   000012   0D53         ADD.W   #0x0, R13
   \   000014   2C4A         MOV.W   @R10, R12
   \   000016   ........     CALLA   #ZDSecMgrEntryLookup
   \   00001A   4C93         CMP.B   #0x0, R12
   \   00001C   0A20         JNE     ??ZDSecMgrDeviceEntryAdd_1
   1609            {
   1610              // verify that address index is same
   1611              if ( entry->ami != ami )
   \   00001E   2C41         MOV.W   @SP, R12
   \   000020   8C9B0000     CMP.W   R11, 0(R12)
   \   000024   0D24         JEQ     ??ZDSecMgrDeviceEntryAdd_2
   1612              {
   1613                // remove conflicting entry
   1614                ZDSecMgrDeviceEntryRemove( entry );
   \   000026   ........     CALLA   #ZDSecMgrEntryFree
   1615          
   1616                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \   00002A   ........     CALLA   #?Subroutine36
   1617                {
   1618                  // update NWK address
   1619                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1620                }
   1621              }
   1622            }
   \                     ??CrossCallReturnLabel_34:
   \   00002E   0820         JNE     ??ZDSecMgrDeviceEntryAdd_2
   \   000030   033C         JMP     ??ZDSecMgrDeviceEntryAdd_3
   1623            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   000032   ........     CALLA   #?Subroutine36
   \                     ??CrossCallReturnLabel_35:
   \   000036   0420         JNE     ??ZDSecMgrDeviceEntryAdd_2
   1624            {
   1625              // update NWK address
   1626              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000038   2D4A         MOV.W   @R10, R13
   \   00003A   0C4B         MOV.W   R11, R12
   \   00003C   ........     CALLA   #ZDSecMgrAddrMgrUpdate
   1627            }
   1628          
   1629            // check if a new entry needs to be created
   1630            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   000040   81930000     CMP.W   #0x0, 0(SP)
   \   000044   0D20         JNE     ??ZDSecMgrDeviceEntryAdd_0
   1631            {
   1632              // get new entry
   1633              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000046   0C41         MOV.W   SP, R12
   \   000048   0C53         ADD.W   #0x0, R12
   \   00004A   ........     CALLA   #ZDSecMgrEntryNew
   \   00004E   4C93         CMP.B   #0x0, R12
   \   000050   0820         JNE     ??ZDSecMgrDeviceEntryAdd_4
   1634              {
   1635                // reset entry lkd
   1636          
   1637                // finish setting up entry
   1638                entry->ami = ami;
   \   000052   2F41         MOV.W   @SP, R15
   \   000054   8F4B0000     MOV.W   R11, 0(R15)
   1639          
   1640                // update NWK address
   1641                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   000058   2D4A         MOV.W   @R10, R13
   \   00005A   0C4B         MOV.W   R11, R12
   \   00005C   ........     CALLA   #ZDSecMgrAddrMgrUpdate
   1642          
   1643                // enter new device into device control
   1644                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1645                {
   1646                  status = ZDSecMgrCtrlAdd( device, entry );
   1647                }
   1648                else
   1649                {
   1650                  status = ZSuccess;
   1651                }
   1652              }
   1653            }
   1654            else
   1655            {
   1656              // reset entry lkd
   1657          
   1658              // reset entry in entry control
   1659              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1660              {
   1661                status = ZDSecMgrCtrlReset( device, entry );
   1662              }
   1663              else
   1664              {
   1665                status = ZSuccess;
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   000060   4843         MOV.B   #0x0, R8
   1666              }
   1667            }
   1668          
   1669            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   000062   4C48         MOV.B   R8, R12
   \   000064   2153         ADD.W   #0x2, SP
   \   000066   3817         POPM.W  #0x4, R11
   \   000068   1001         RETA
   1670          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine36:
   \   000000   0D41         MOV.W   SP, R13
   \   000002   2D52         ADD.W   #0x4, R13
   \   000004   0C4B         MOV.W   R11, R12
   \   000006   ........     CALLA   #ZDSecMgrEntryLookupAMI
   \   00000A   4C93         CMP.B   #0x0, R12
   \   00000C   1001         RETA
   1671          
   1672          /******************************************************************************
   1673           * @fn          ZDSecMgrDeviceCtrlHandler
   1674           *
   1675           * @brief       Device control handler.
   1676           *
   1677           * @param       device - [in] ZDSecMgrDevice_t, device info
   1678           *
   1679           * @return      none
   1680           */

   \                                 In  segment CODE, align 2, keep-with-next
   1681          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1682          {
   \   000000   1B15         PUSHM.W #0x2, R11
   1683            uint8 state;
   1684            uint8 cntr;
   1685          
   1686            state = device->ctrl->state;
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   3A52         ADD.W   #0x8, R10
   \   000006   2F4A         MOV.W   @R10, R15
   \   000008   5B4F0500     MOV.B   0x5(R15), R11
   1687            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1688          
   1689            switch ( state )
   \   00000C   4E4B         MOV.B   R11, R14
   \   00000E   6E83         SUB.B   #0x2, R14
   \   000010   0824         JEQ     ??ZDSecMgrDeviceCtrlHandler_0
   \   000012   5E83         SUB.B   #0x1, R14
   \   000014   0D24         JEQ     ??ZDSecMgrDeviceCtrlHandler_1
   \   000016   5E83         SUB.B   #0x1, R14
   \   000018   1524         JEQ     ??ZDSecMgrDeviceCtrlHandler_2
   \   00001A   7E800300     SUB.B   #0x3, R14
   \   00001E   0E24         JEQ     ??ZDSecMgrDeviceCtrlHandler_3
   \   000020   1A3C         JMP     ??ZDSecMgrDeviceCtrlHandler_4
   1690            {
   1691              case ZDSECMGR_CTRL_TK_MASTER:
   1692                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   000022   ........     CALLA   #ZDSecMgrSendMasterKey
   \   000026   4C93         CMP.B   #0x0, R12
   \   000028   0D20         JNE     ??ZDSecMgrDeviceCtrlHandler_2
   1693                {
   1694                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   00002A   7B400300     MOV.B   #0x3, R11
   1695                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   00002E   0A3C         JMP     ??ZDSecMgrDeviceCtrlHandler_2
   1696                }
   1697                break;
   1698          
   1699              case ZDSECMGR_CTRL_SKKE_INIT:
   1700                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   000030   ........     CALLA   #ZDSecMgrEstablishKey
   \   000034   4C93         CMP.B   #0x0, R12
   \   000036   0620         JNE     ??ZDSecMgrDeviceCtrlHandler_2
   1701                {
   1702                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000038   6B42         MOV.B   #0x4, R11
   \   00003A   043C         JMP     ??ZDSecMgrDeviceCtrlHandler_2
   1703                }
   1704                break;
   1705          
   1706              case ZDSECMGR_CTRL_SKKE_WAIT:
   1707                // continue to wait for SKA control timeout
   1708                break;
   1709          
   1710              case ZDSECMGR_CTRL_TK_NWK:
   1711                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   00003C   ........     CALLA   #ZDSecMgrSendNwkKey
   \   000040   4C93         CMP.B   #0x0, R12
   \   000042   0924         JEQ     ??ZDSecMgrDeviceCtrlHandler_4
   1712                {
   1713                  state = ZDSECMGR_CTRL_NONE;
   1714                }
   1715                break;
   1716          
   1717              default:
   1718                state = ZDSECMGR_CTRL_NONE;
   1719                break;
   1720            }
   1721          
   1722            if ( state != ZDSECMGR_CTRL_NONE )
   1723            {
   1724              device->ctrl->state = state;
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   000044   2F4A         MOV.W   @R10, R15
   \   000046   CF4B0500     MOV.B   R11, 0x5(R15)
   1725              device->ctrl->cntr  = cntr;
   \   00004A   2F4A         MOV.W   @R10, R15
   \   00004C   DF430600     MOV.B   #0x1, 0x6(R15)
   1726          
   1727              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   000050   ........     CALLA   #?Subroutine39
   1728            }
   \                     ??CrossCallReturnLabel_42:
   \   000054   033C         JMP     ??ZDSecMgrDeviceCtrlHandler_5
   1729            else
   1730            {
   1731              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   000056   2F4A         MOV.W   @R10, R15
   \   000058   CF430500     MOV.B   #0x0, 0x5(R15)
   1732            }
   1733          }
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   00005C   1A17         POPM.W  #0x2, R11
   \   00005E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine39:
   \   000000   3E406400     MOV.W   #0x64, R14
   \   000004   3D400001     MOV.W   #0x100, R13
   \   000008   5C42....     MOV.B   &ZDAppTaskID, R12
   \   00000C   ........     BRA     #osal_start_timerEx
   1734          
   1735          /******************************************************************************
   1736           * @fn          ZDSecMgrDeviceCtrlSetup
   1737           *
   1738           * @brief       Setup device control.
   1739           *
   1740           * @param       device - [in] ZDSecMgrDevice_t, device info
   1741           *
   1742           * @return      ZStatus_t
   1743           */

   \                                 In  segment CODE, align 2, keep-with-next
   1744          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1745          {
   1746            if ( device->ctrl != NULL )
   \   000000   1F4C0800     MOV.W   0x8(R12), R15
   \   000004   0F93         CMP.W   #0x0, R15
   \   000006   0B24         JEQ     ??ZDSecMgrDeviceCtrlSetup_0
   1747            {
   1748              if ( device->secure == FALSE )
   \   000008   CC930600     CMP.B   #0x0, 0x6(R12)
   \   00000C   0324         JEQ     ??ZDSecMgrDeviceCtrlSetup_1
   \   00000E   7E400300     MOV.B   #0x3, R14
   \   000012   013C         JMP     ??ZDSecMgrDeviceCtrlSetup_2
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   000014   6E43         MOV.B   #0x2, R14
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   000016   CF4E0500     MOV.B   R14, 0x5(R15)
   1749              {
   1750                // send the master key data to the joining device
   1751                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   1752              }
   1753              else
   1754              {
   1755                // start SKKE
   1756                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   1757              }
   1758          
   1759              ZDSecMgrDeviceCtrlHandler( device );
   \   00001A   ........     CALLA   #ZDSecMgrDeviceCtrlHandler
   1760            }
   1761          }
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   00001E   1001         RETA
   1762          
   1763          /******************************************************************************
   1764           * @fn          ZDSecMgrDeviceCtrlUpdate
   1765           *
   1766           * @brief       Update control data.
   1767           *
   1768           * @param       extAddr - [in] EXT address
   1769           * @param       state   - [in] new control state
   1770           *
   1771           * @return      none
   1772           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine12:
   \   000000   2152         ADD.W   #0x4, SP
   \   000002   3A41         POP.W   R10
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1773          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1774          {
   \   000000   0A12         PUSH.W  R10
   \   000002   2182         SUB.W   #0x4, SP
   \   000004   4A4D         MOV.B   R13, R10
   1775            ZDSecMgrEntry_t* entry;
   1776            ZDSecMgrCtrl_t*  ctrl;
   1777          
   1778            // lookup device entry data
   1779            (void)ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000006   0D41         MOV.W   SP, R13
   \   000008   2D53         ADD.W   #0x2, R13
   \   00000A   ........     CALLA   #ZDSecMgrEntryLookupExt
   1780          
   1781            if ( entry != NULL )
   \   00000E   81930200     CMP.W   #0x0, 0x2(SP)
   \   000012   1B24         JEQ     ??ZDSecMgrDeviceCtrlUpdate_0
   1782            {
   1783              // lookup device control data
   1784              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000014   0D41         MOV.W   SP, R13
   \   000016   0D53         ADD.W   #0x0, R13
   \   000018   1C410200     MOV.W   0x2(SP), R12
   \   00001C   ........     CALLA   #?Subroutine40
   1785          
   1786              // make sure control data is valid
   1787              if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_43:
   \   000020   1424         JEQ     ??ZDSecMgrDeviceCtrlUpdate_0
   1788              {
   1789                // possible state transitions
   1790                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   000022   2F41         MOV.W   @SP, R15
   \   000024   EF920500     CMP.B   #0x4, 0x5(R15)
   \   000028   1020         JNE     ??ZDSecMgrDeviceCtrlUpdate_0
   1791                {
   1792                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   00002A   7A900500     CMP.B   #0x5, R10
   \   00002E   0420         JNE     ??ZDSecMgrDeviceCtrlUpdate_1
   1793                  {
   1794                    // send the network key
   1795                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   000030   FF4007000500 MOV.B   #0x7, 0x5(R15)
   1796                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   \   000036   063C         JMP     ??ZDSecMgrDeviceCtrlUpdate_2
   1797                  }
   1798                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   000038   7A900600     CMP.B   #0x6, R10
   \   00003C   0620         JNE     ??ZDSecMgrDeviceCtrlUpdate_0
   1799                  {
   1800                    // force default timeout in order to cleanup control logic
   1801                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   00003E   FF4006000500 MOV.B   #0x6, 0x5(R15)
   1802                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   \                     ??ZDSecMgrDeviceCtrlUpdate_2:
   \   000044   2F41         MOV.W   @SP, R15
   \   000046   DF430600     MOV.B   #0x1, 0x6(R15)
   1803                  }
   1804                }
   1805                // timer should be active
   1806              }
   1807            }
   1808          }
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   00004A   ....         JMP     ?Subroutine12
   1809          
   1810          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment CODE, align 2, keep-with-next
   1811          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1812          {
   1813            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1814            {
   1815              if ( initiator == TRUE )
   1816              {
   1817                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1818              }
   1819            }
   1820          }
   \   000000   1001         RETA
   1821          
   1822          /******************************************************************************
   1823           * @fn          ZDSecMgrDeviceRemove
   1824           *
   1825           * @brief       Remove device from network.
   1826           *
   1827           * @param       device - [in] ZDSecMgrDevice_t, device info
   1828           *
   1829           * @return      none
   1830           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   31500A00     ADD.W   #0xa, SP
   \   000004   3A41         POP.W   R10
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1831          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1832          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31800A00     SUB.W   #0xa, SP
   \   000006   0A4C         MOV.W   R12, R10
   1833            APSME_RemoveDeviceReq_t remDevReq;
   1834            NLME_LeaveReq_t         leaveReq;
   1835            associated_devices_t*   assoc;
   1836          
   1837            // check if parent, remove the device
   1838            if ( device->parentAddr == NLME_GetShortAddr() )
   \   000008   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_38:
   \   00000C   1F20         JNE     ??ZDSecMgrDeviceRemove_0
   1839            {
   1840              // this is the parent of the device
   1841              leaveReq.extAddr        = device->extAddr;
   \   00000E   914A02000000 MOV.W   0x2(R10), 0(SP)
   1842              leaveReq.removeChildren = FALSE;
   \   000014   C1430200     MOV.B   #0x0, 0x2(SP)
   1843              leaveReq.rejoin         = FALSE;
   \   000018   C1430300     MOV.B   #0x0, 0x3(SP)
   1844          
   1845              // find child association
   1846              assoc = AssocGetWithExt( device->extAddr );
   \   00001C   1C4A0200     MOV.W   0x2(R10), R12
   \   000020   ........     CALLA   #AssocGetWithExt
   1847          
   1848              if ( ( assoc != NULL                            ) &&
   1849                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1850                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   000024   0C93         CMP.W   #0x0, R12
   \   000026   1C24         JEQ     ??ZDSecMgrDeviceRemove_1
   \   000028   5E4C0400     MOV.B   0x4(R12), R14
   \   00002C   4E93         CMP.B   #0x0, R14
   \   00002E   1824         JEQ     ??ZDSecMgrDeviceRemove_1
   \   000030   7E900500     CMP.B   #0x5, R14
   \   000034   152C         JC      ??ZDSecMgrDeviceRemove_1
   1851              {
   1852                // check if associated device is authenticated
   1853                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   000036   FCB20500     BIT.B   #0x8, 0x5(R12)
   \   00003A   4E7E         SUBC.B  R14, R14
   \   00003C   5EF3         AND.B   #0x1, R14
   \   00003E   C14E0400     MOV.B   R14, 0x4(SP)
   1854                {
   1855                  leaveReq.silent = FALSE;
   1856                }
   1857                else
   1858                {
   1859                  leaveReq.silent = TRUE;
   1860                }
   1861          
   1862                NLME_LeaveReq( &leaveReq );
   \   000042   0C41         MOV.W   SP, R12
   \   000044   0C53         ADD.W   #0x0, R12
   \   000046   ........     CALLA   #NLME_LeaveReq
   \   00004A   0A3C         JMP     ??ZDSecMgrDeviceRemove_1
   1863              }
   1864            }
   1865            else
   1866            {
   1867              // this is not the parent of the device
   1868              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00004C   814F0600     MOV.W   R15, 0x6(SP)
   1869              remDevReq.childExtAddr = device->extAddr;
   \   000050   914A02000800 MOV.W   0x2(R10), 0x8(SP)
   1870          
   1871              APSME_RemoveDeviceReq( &remDevReq );
   \   000056   0C41         MOV.W   SP, R12
   \   000058   3C500600     ADD.W   #0x6, R12
   \   00005C   ........     CALLA   #APSME_RemoveDeviceReq
   1872            }
   1873          }
   \                     ??ZDSecMgrDeviceRemove_1:
   \   000060   ........     BRA     #?Subroutine4
   1874          
   1875          /******************************************************************************
   1876           * @fn          ZDSecMgrDeviceValidateSKKE
   1877           *
   1878           * @brief       Decide whether device is allowed for SKKE.
   1879           *
   1880           * @param       device - [in] ZDSecMgrDevice_t, device info
   1881           *
   1882           * @return      ZStatus_t
   1883           */

   \                                 In  segment CODE, align 2, keep-with-next
   1884          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1885          {
   \   000000   0A12         PUSH.W  R10
   \   000002   2182         SUB.W   #0x4, SP
   \   000004   0A4C         MOV.W   R12, R10
   1886            ZStatus_t status;
   1887            uint16 ami;
   1888            uint16 keyNvId;
   1889          
   1890            // get EXT address
   1891            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   000006   0D41         MOV.W   SP, R13
   \   000008   0D53         ADD.W   #0x0, R13
   \   00000A   1C4A0200     MOV.W   0x2(R10), R12
   \   00000E   ........     CALLA   #ZDSecMgrExtAddrLookup
   1892          
   1893            if ( status == ZSuccess )
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   0720         JNE     ??ZDSecMgrDeviceValidateSKKE_0
   1894            {
   1895              // get MASTER key
   1896              status = ZDSecMgrMasterKeyLookup( ami, &keyNvId );
   \   000016   ........     CALLA   #?Subroutine33
   1897          
   1898              if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_26:
   \   00001A   0420         JNE     ??ZDSecMgrDeviceValidateSKKE_0
   1899              {
   1900                status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00001C   2D41         MOV.W   @SP, R13
   \   00001E   0C4A         MOV.W   R10, R12
   \   000020   ........     CALLA   #ZDSecMgrDeviceEntryAdd
   1901              }
   1902            }
   1903          
   1904            return status;
   \                     ??ZDSecMgrDeviceValidateSKKE_0:
   \   000024                REQUIRE ?Subroutine12
   \   000024                // Fall through to label ?Subroutine12
   1905          }
   1906          
   1907          /******************************************************************************
   1908           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1909           *
   1910           * @brief       Decide whether device is allowed.
   1911           *
   1912           * @param       device - [in] ZDSecMgrDevice_t, device info
   1913           *
   1914           * @return      ZStatus_t
   1915           */

   \                                 In  segment CODE, align 2, keep-with-next
   1916          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1917          {
   1918            ZStatus_t status;
   1919          
   1920            status = ZSuccess;
   \   000000   4C43         MOV.B   #0x0, R12
   1921          
   1922            (void)device;  // Intentionally unreferenced parameter
   1923          
   1924            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1925            // the trust center to reject any newly joining devices by sending
   1926            // Remove-device to the parents.
   1927            if ( zgSecurePermitJoin == FALSE )
   \   000002   C293....     CMP.B   #0x0, &zgSecurePermitJoin
   \   000006   0220         JNE     ??ZDSecMgrDeviceValidateRM_0
   1928            {
   1929              status = ZNwkUnknownDevice;
   \   000008   7C40C800     MOV.B   #0xc8, R12
   1930            }
   1931          
   1932          
   1933          
   1934          #if 0  // Taken out because the following functionality is only used for test
   1935                 // purpose. A more efficient (above) way is used. It can be put
   1936                 // back in if customers request for a white/black list feature.
   1937                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1938          
   1939            // The following code processes the device black list (stored device list)
   1940            // If the joining device is not part of the forbidden device list
   1941            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1942            // will send Remove-device and ban the device from joining.
   1943          
   1944            uint8     index;
   1945            uint8*    restricted;
   1946          
   1947            // Look through the stored device list - used for restricted devices
   1948            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1949            {
   1950              restricted = ZDSecMgrStoredDeviceList[index];
   1951          
   1952              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1953              {
   1954                // return as unknown device in regards to validation
   1955                status = ZNwkUnknownDevice;
   1956          
   1957                // break from loop
   1958                index = ZDSECMGR_STORED_DEVICES;
   1959              }
   1960            }
   1961          
   1962          #endif
   1963          
   1964            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000C   1001         RETA
   1965          }
   1966          
   1967          /******************************************************************************
   1968           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1969           *
   1970           * @brief       Decide whether device is allowed.
   1971           *
   1972           * @param       device - [in] ZDSecMgrDevice_t, device info
   1973           *
   1974           * @return      ZStatus_t
   1975           */
   1976          //devtag.pro.security

   \                                 In  segment CODE, align 2, keep-with-next
   1977          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1978          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801200     SUB.W   #0x12, SP
   \   000006   0A4C         MOV.W   R12, R10
   1979            ZStatus_t status;
   1980            uint16    ami;
   1981            uint8     key[SEC_KEY_LEN];
   1982          
   1983            // implement EXT address and MASTER key policy here -- the total number of
   1984            // Security Manager entries should never exceed the number of EXT addresses
   1985            // and MASTER keys available
   1986          
   1987            // set status based on policy
   1988            //status = ZNwkUnknownDevice;
   1989          
   1990            // set status based on policy
   1991            status = ZSuccess; // ZNwkUnknownDevice;
   1992          
   1993            // get key based on policy
   1994            osal_memcpy( key, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   000008   0B41         MOV.W   SP, R11
   \   00000A   2B53         ADD.W   #0x2, R11
   \   00000C   3E401000     MOV.W   #0x10, R14
   \   000010   3D40....     MOV.W   #ZDSecMgrTCMasterKey, R13
   \   000014   0C4B         MOV.W   R11, R12
   \   000016   ........     CALLA   #osal_memcpy
   1995          
   1996            // if policy, store new EXT address
   1997            status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00001A   0E41         MOV.W   SP, R14
   \   00001C   0E53         ADD.W   #0x0, R14
   \   00001E   1D4A0200     MOV.W   0x2(R10), R13
   \   000022   2C4A         MOV.W   @R10, R12
   \   000024   ........     CALLA   #ZDSecMgrAddrStore
   \   000028   484C         MOV.B   R12, R8
   1998          
   1999            // set the key
   2000            ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   00002A   0D4B         MOV.W   R11, R13
   \   00002C   1C4A0200     MOV.W   0x2(R10), R12
   \   000030   ........     CALLA   #ZDSecMgrMasterKeyLoad
   2001          
   2002            // if EXT address and MASTER key available -- add device
   2003            if ( status == ZSuccess )
   \   000034   4893         CMP.B   #0x0, R8
   \   000036   0520         JNE     ??ZDSecMgrDeviceValidateCM_0
   2004            {
   2005              // add device to internal data - with control
   2006              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000038   2D41         MOV.W   @SP, R13
   \   00003A   0C4A         MOV.W   R10, R12
   \   00003C   ........     CALLA   #ZDSecMgrDeviceEntryAdd
   \   000040   484C         MOV.B   R12, R8
   2007            }
   2008          
   2009            // remove copy of key in RAM
   2010            osal_memset( key, 0x00, SEC_KEY_LEN );
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   000042   ........     CALLA   #?Subroutine21
   2011          
   2012            return status;
   \                     ??CrossCallReturnLabel_74:
   \   000046   4C48         MOV.B   R8, R12
   \   000048                REQUIRE ?Subroutine6
   \   000048                // Fall through to label ?Subroutine6
   2013          }
   2014          
   2015          /******************************************************************************
   2016           * @fn          ZDSecMgrDeviceValidate
   2017           *
   2018           * @brief       Decide whether device is allowed.
   2019           *
   2020           * @param       device - [in] ZDSecMgrDevice_t, device info
   2021           *
   2022           * @return      ZStatus_t
   2023           */

   \                                 In  segment CODE, align 2, keep-with-next
   2024          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   2025          {
   2026            ZStatus_t status;
   2027          
   2028          
   2029            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000000   D293....     CMP.B   #0x1, &ZDSecMgrPermitJoiningEnabled
   \   000004   0A20         JNE     ??ZDSecMgrDeviceValidate_0
   2030            {
   2031              // device may be joining with a secure flag but it is ultimately the Trust
   2032              // Center that decides -- check if expected pre configured device --
   2033              // override settings
   2034              if ( zgPreConfigKeys == TRUE )
   \   000006   D293....     CMP.B   #0x1, &zgPreConfigKeys
   \   00000A   0224         JEQ     ??ZDSecMgrDeviceValidate_1
   \   00000C   4E43         MOV.B   #0x0, R14
   \   00000E   013C         JMP     ??ZDSecMgrDeviceValidate_2
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000010   5E43         MOV.B   #0x1, R14
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000012   CC4E0600     MOV.B   R14, 0x6(R12)
   2035              {
   2036                device->secure = TRUE;
   2037              }
   2038              else
   2039              {
   2040                device->secure = FALSE;
   2041              }
   2042          
   2043              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2044              {
   2045                status = ZDSecMgrDeviceValidateCM( device );
   2046              }
   2047              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2048              {
   2049                status = ZDSecMgrDeviceValidateRM( device );
   \   000016   ........     BRA     #ZDSecMgrDeviceValidateRM
   2050              }
   2051            }
   2052            else
   2053            {
   2054              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00001A   7C40C800     MOV.B   #0xc8, R12
   2055            }
   2056          
   2057            return status;
   \   00001E   1001         RETA
   2058          }
   2059          
   2060          /******************************************************************************
   2061           * @fn          ZDSecMgrDeviceJoin
   2062           *
   2063           * @brief       Try to join this device.
   2064           *
   2065           * @param       device - [in] ZDSecMgrDevice_t, device info
   2066           *
   2067           * @return      ZStatus_t
   2068           */

   \                                 In  segment CODE, align 2, keep-with-next
   2069          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2070          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0B4C         MOV.W   R12, R11
   2071            ZStatus_t status;
   2072            uint16    ami;
   2073          
   2074            // attempt to validate device
   2075            status = ZDSecMgrDeviceValidate( device );
   \   000006   ........     CALLA   #ZDSecMgrDeviceValidate
   \   00000A   4A4C         MOV.B   R12, R10
   2076          
   2077            if ( status == ZSuccess )
   \   00000C   4C93         CMP.B   #0x0, R12
   \   00000E   0C20         JNE     ??ZDSecMgrDeviceJoin_0
   2078            {
   2079              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2080              {
   2081                ZDSecMgrDeviceCtrlSetup( device );
   2082              }
   2083              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2084              {
   2085                // Add the device to the address manager
   2086                ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   000010   0E41         MOV.W   SP, R14
   \   000012   0E53         ADD.W   #0x0, R14
   \   000014   1D4B0200     MOV.W   0x2(R11), R13
   \   000018   2C4B         MOV.W   @R11, R12
   \   00001A   ........     CALLA   #ZDSecMgrAddrStore
   2087                //send the nwk key data to the joining device
   2088                status = ZDSecMgrSendNwkKey( device );
   \   00001E   0C4B         MOV.W   R11, R12
   \   000020   ........     CALLA   #ZDSecMgrSendNwkKey
   \   000024   4A4C         MOV.B   R12, R10
   \   000026   033C         JMP     ??ZDSecMgrDeviceJoin_1
   2089              }
   2090            }
   2091            else
   2092            {
   2093              // not allowed, remove the device
   2094              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   000028   0C4B         MOV.W   R11, R12
   \   00002A   ........     CALLA   #ZDSecMgrDeviceRemove
   2095            }
   2096          
   2097            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   00002E   4C4A         MOV.B   R10, R12
   \   000030   ....         JMP     ??Subroutine2_0
   2098          }
   2099          
   2100          /******************************************************************************
   2101           * @fn          ZDSecMgrDeviceJoinDirect
   2102           *
   2103           * @brief       Try to join this device as a direct child.
   2104           *
   2105           * @param       device - [in] ZDSecMgrDevice_t, device info
   2106           *
   2107           * @return      ZStatus_t
   2108           */

   \                                 In  segment CODE, align 2, keep-with-next
   2109          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2110          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0B4C         MOV.W   R12, R11
   2111            ZStatus_t status;
   2112          
   2113            status = ZDSecMgrDeviceJoin( device );
   \   000004   ........     CALLA   #ZDSecMgrDeviceJoin
   \   000008   4A4C         MOV.B   R12, R10
   2114          
   2115            if ( status == ZSuccess )
   \   00000A   4C93         CMP.B   #0x0, R12
   \   00000C   0520         JNE     ??ZDSecMgrDeviceJoinDirect_0
   2116            {
   2117              // set association status to authenticated
   2118              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   00000E   2C4B         MOV.W   @R11, R12
   \   000010   ........     CALLA   #AssocGetWithShort
   \   000014   ........     CALLA   #ZDSecMgrAssocDeviceAuth
   2119            }
   2120          
   2121            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   000018   4C4A         MOV.B   R10, R12
   \   00001A   1A17         POPM.W  #0x2, R11
   \   00001C   1001         RETA
   2122          }
   2123          
   2124          /******************************************************************************
   2125           * @fn          ZDSecMgrDeviceJoinFwd
   2126           *
   2127           * @brief       Forward join to Trust Center.
   2128           *
   2129           * @param       device - [in] ZDSecMgrDevice_t, device info
   2130           *
   2131           * @return      ZStatus_t
   2132           */

   \                                 In  segment CODE, align 2, keep-with-next
   2133          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2134          {
   \   000000   3182         SUB.W   #0x8, SP
   2135            ZStatus_t               status;
   2136            APSME_UpdateDeviceReq_t req;
   2137          
   2138            // forward any joining device to the Trust Center -- the Trust Center will
   2139            // decide if the device is allowed to join
   2140            status = ZSuccess;
   2141          
   2142            // forward authorization to the Trust Center
   2143            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000002   81430000     MOV.W   #0x0, 0(SP)
   2144            req.devAddr    = device->nwkAddr;
   \   000006   A14C0200     MOV.W   @R12, 0x2(SP)
   2145            req.devExtAddr = device->extAddr;
   \   00000A   914C02000400 MOV.W   0x2(R12), 0x4(SP)
   2146          
   2147            // set security status, option for router to reject if policy set
   2148            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \   000010   CC930700     CMP.B   #0x0, 0x7(R12)
   \   000014   1034         JGE     ??ZDSecMgrDeviceJoinFwd_2
   2149            {
   2150              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   000016   FCB040000700 BIT.B   #0x40, 0x7(R12)
   \   00001C   0828         JNC     ??ZDSecMgrDeviceJoinFwd_3
   2151              {
   2152                if ( device->secure == TRUE )
   \   00001E   DC930600     CMP.B   #0x1, 0x6(R12)
   \   000022   0324         JEQ     ??ZDSecMgrDeviceJoinFwd_4
   \   000024   7E400700     MOV.B   #0x7, R14
   \   000028   113C         JMP     ??ZDSecMgrDeviceJoinFwd_0
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   00002A   6E42         MOV.B   #0x4, R14
   \   00002C   0F3C         JMP     ??ZDSecMgrDeviceJoinFwd_0
   2153                {
   2154                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   2155                }
   2156                else
   2157                {
   2158                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   2159                }
   2160              }
   2161              else
   2162              {
   2163                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   00002E   F14005000600 MOV.B   #0x5, 0x6(SP)
   \   000034   103C         JMP     ??ZDSecMgrDeviceJoinFwd_5
   2164              }
   2165            }
   2166            else
   2167            {
   2168              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   000036   FCB040000700 BIT.B   #0x40, 0x7(R12)
   \   00003C   0A28         JNC     ??ZDSecMgrDeviceJoinFwd_6
   2169              {
   2170                if ( device->secure == TRUE )
   \   00003E   DC930600     CMP.B   #0x1, 0x6(R12)
   \   000042   0324         JEQ     ??ZDSecMgrDeviceJoinFwd_7
   \   000044   7E400300     MOV.B   #0x3, R14
   \   000048   013C         JMP     ??ZDSecMgrDeviceJoinFwd_0
   \                     ??ZDSecMgrDeviceJoinFwd_7:
   \   00004A   4E43         MOV.B   #0x0, R14
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   00004C   C14E0600     MOV.B   R14, 0x6(SP)
   \   000050   023C         JMP     ??ZDSecMgrDeviceJoinFwd_5
   2171                {
   2172                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   2173                }
   2174                else
   2175                {
   2176                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   2177                }
   2178              }
   2179              else
   2180              {
   2181                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_6:
   \   000052   D1430600     MOV.B   #0x1, 0x6(SP)
   2182              }
   2183            }
   2184          
   2185            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2186            {
   2187              req.apsSecure = TRUE;
   2188            }
   2189            else
   2190            {
   2191              req.apsSecure = FALSE;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   000056   C1430700     MOV.B   #0x0, 0x7(SP)
   2192            }
   2193          
   2194            // send and APSME_UPDATE_DEVICE request to the trust center
   2195            status = APSME_UpdateDeviceReq( &req );
   2196          
   2197            return status;
   \   00005A   0C41         MOV.W   SP, R12
   \   00005C   0C53         ADD.W   #0x0, R12
   \   00005E   ........     CALLA   #APSME_UpdateDeviceReq
   \   000062   3152         ADD.W   #0x8, SP
   \   000064   1001         RETA
   2198          }
   2199          
   2200          /******************************************************************************
   2201           * @fn          ZDSecMgrDeviceNew
   2202           *
   2203           * @brief       Process a new device.
   2204           *
   2205           * @param       device - [in] ZDSecMgrDevice_t, device info
   2206           *
   2207           * @return      ZStatus_t
   2208           */

   \                                 In  segment CODE, align 2, keep-with-next
   2209          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2210          {
   2211            ZStatus_t status;
   2212          
   2213            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2214            {
   2215              // try to join this device
   2216              status = ZDSecMgrDeviceJoinDirect( joiner );
   2217            }
   2218            else
   2219            {
   2220              status = ZDSecMgrDeviceJoinFwd( joiner );
   2221            }
   2222          
   2223            return status;
   \   000000   ........     BRA     #ZDSecMgrDeviceJoinFwd
   2224          }
   2225          
   2226          /******************************************************************************
   2227           * @fn          ZDSecMgrAssocDeviceAuth
   2228           *
   2229           * @brief       Set associated device status to authenticated
   2230           *
   2231           * @param       assoc - [in, out] associated_devices_t
   2232           *
   2233           * @return      none
   2234           */

   \                                 In  segment CODE, align 2, keep-with-next
   2235          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2236          {
   2237            if ( assoc != NULL )
   \   000000   0C93         CMP.W   #0x0, R12
   \   000002   0224         JEQ     ??ZDSecMgrAssocDeviceAuth_0
   2238            {
   2239              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000004   FCD20500     BIS.B   #0x8, 0x5(R12)
   2240            }
   2241          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000008   1001         RETA
   2242          
   2243          /******************************************************************************
   2244           * @fn          ZDSecMgrAuthInitiate
   2245           *
   2246           * @brief       Initiate entity authentication
   2247           *
   2248           * @param       responder - [in] responder EXT address
   2249           *
   2250           * @return      none
   2251           */

   \                                 In  segment CODE, align 2, keep-with-next
   2252          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2253          {
   \   000000   0A12         PUSH.W  R10
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0A4C         MOV.W   R12, R10
   2254            APSME_AuthenticateReq_t req;
   2255          
   2256          
   2257            // make sure NWK address is available
   2258            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   000006   0D41         MOV.W   SP, R13
   \   000008   0D53         ADD.W   #0x0, R13
   \   00000A   ........     CALLA   #APSME_LookupNwkAddr
   \   00000E   4C93         CMP.B   #0x0, R12
   \   000010   0A24         JEQ     ??ZDSecMgrAuthInitiate_0
   2259            {
   2260              // set request fields
   2261              req.extAddr   = responder;
   \   000012   814A0200     MOV.W   R10, 0x2(SP)
   2262              req.action    = APSME_EA_INITIATE;
   \   000016   C1430600     MOV.B   #0x0, 0x6(SP)
   2263              req.challenge = NULL;
   \   00001A   81430400     MOV.W   #0x0, 0x4(SP)
   2264          
   2265              // start EA processing
   2266              APSME_AuthenticateReq( &req );
   \   00001E   0C41         MOV.W   SP, R12
   \   000020   0C53         ADD.W   #0x0, R12
   \   000022   ........     CALLA   #APSME_AuthenticateReq
   2267            }
   2268          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   000026                REQUIRE ?Subroutine11
   \   000026                // Fall through to label ?Subroutine11
   2269          
   2270          /******************************************************************************
   2271           * @fn          ZDSecMgrAuthNwkKey
   2272           *
   2273           * @brief       Handle next step in authentication process
   2274           *
   2275           * @param       none
   2276           *
   2277           * @return      none
   2278           */

   \                                 In  segment CODE, align 2, keep-with-next
   2279          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2280          {
   2281            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000000                REQUIRE ?Subroutine16
   \   000000                // Fall through to label ?Subroutine16

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine16:
   \   000000   F2900500.... CMP.B   #0x5, &devState
   \   000006   0620         JNE     ??ZDSecMgrAuthenticateCfm_1
   2282            {
   2283              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2284              {
   2285                uint8 parent[Z_EXTADDR_LEN];
   2286          
   2287                // get parent's EXT address
   2288                NLME_GetCoordExtAddr( parent );
   2289          
   2290                // begin entity authentication with parent
   2291                ZDSecMgrAuthInitiate( parent );
   2292              }
   2293              else
   2294              {
   2295                // inform ZDO that device has been authenticated
   2296                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   000008   3D408000     MOV.W   #0x80, R13
   \   00000C   5C42....     MOV.B   &ZDAppTaskID, R12
   \   000010   ........     CALLA   #osal_set_event
   2297              }
   2298            }
   2299          }
   \                     ??ZDSecMgrAuthenticateCfm_1:
   \   000014   1001         RETA
   2300          
   2301          /******************************************************************************
   2302           * PUBLIC FUNCTIONS
   2303           */
   2304          /******************************************************************************
   2305           * @fn          ZDSecMgrInit
   2306           *
   2307           * @brief       Initialize ZigBee Device Security Manager.
   2308           *
   2309           * @param       state - device initialization state
   2310           *
   2311           * @return      none
   2312           */
   2313          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2314          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2315          void ZDSecMgrAddrMgrCB( uint8           update,
   2316                                  AddrMgrEntry_t* newEntry,
   2317                                  AddrMgrEntry_t* oldEntry )
   2318          {
   2319            (void)update;
   2320            (void)newEntry;
   2321            (void)oldEntry;
   2322          }
   2323          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2324          

   \                                 In  segment CODE, align 2, keep-with-next
   2325          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   2326          {
   2327            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2328                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2329            {
   2330              // initialize sub modules
   2331              ZDSecMgrEntryInit(state);
   2332          
   2333              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2334              {
   2335                ZDSecMgrCtrlInit();
   2336              }
   2337          
   2338              // register with Address Manager
   2339          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2340              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2341          #endif
   2342            }
   2343          
   2344            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2345            {
   2346              // configure SKA slot data
   2347              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2348            }
   2349          
   2350            if ( ZG_SECURE_ENABLED )
   2351            {
   2352              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2353              {
   2354                // setup joining permissions
   2355                ZDSecMgrPermitJoiningEnabled = TRUE;
   2356                ZDSecMgrPermitJoiningTimed   = FALSE;
   2357              }
   2358            }
   2359          
   2360            // configure security based on security mode and type of device
   2361            ZDSecMgrConfig();
   \   000000   ........     BRA     #APSME_SecurityNM
   2362          }
   2363          
   2364          /******************************************************************************
   2365           * @fn          ZDSecMgrConfig
   2366           *
   2367           * @brief       Configure ZigBee Device Security Manager.
   2368           *
   2369           * @param       none
   2370           *
   2371           * @return      none
   2372           */

   \                                 In  segment CODE, align 2, keep-with-next
   2373          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   2374          {
   2375            if ( ZG_SECURE_ENABLED )
   2376            {
   2377              SSP_Init();
   2378          
   2379              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2380                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2381              {
   2382                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2383                {
   2384                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2385                  APSME_SecurityCM_CD();
   2386                }
   2387                else if ( ZSTACK_ROUTER_BUILD )
   2388                {
   2389                  // COMMERCIAL MODE - ROUTER DEVICE
   2390                  APSME_SecurityCM_RD();
   2391                }
   2392                else
   2393                {
   2394                  // COMMERCIAL MODE - END DEVICE
   2395                  APSME_SecurityCM_ED();
   2396                }
   2397              }
   2398              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2399              {
   2400                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2401                {
   2402                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2403                  APSME_SecurityRM_CD();
   2404                }
   2405                else if ( ZSTACK_ROUTER_BUILD )
   2406                {
   2407                  // RESIDENTIAL MODE - ROUTER DEVICE
   2408                  APSME_SecurityRM_RD();
   2409                }
   2410                else
   2411                {
   2412                  // RESIDENTIAL MODE - END DEVICE
   2413                  APSME_SecurityRM_ED();
   2414                }
   2415              }
   2416            }
   2417            else
   2418            {
   2419              // NO SECURITY
   2420              APSME_SecurityNM();
   \   000000   ........     BRA     #APSME_SecurityNM
   2421            }
   2422          }
   2423          
   2424          /******************************************************************************
   2425           * @fn          ZDSecMgrPermitJoining
   2426           *
   2427           * @brief       Process request to change joining permissions.
   2428           *
   2429           * @param       duration - [in] timed duration for join in seconds
   2430           *                         - 0x00 not allowed
   2431           *                         - 0xFF allowed without timeout
   2432           *
   2433           * @return      uint8 - success(TRUE:FALSE)
   2434           */

   \                                 In  segment CODE, align 2, keep-with-next
   2435          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2436          {
   2437            uint8 accept;
   2438          
   2439            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000000   4E43         MOV.B   #0x0, R14
   2440          
   2441            if ( duration > 0 )
   \   000002   4C93         CMP.B   #0x0, R12
   \   000004   0524         JEQ     ??ZDSecMgrPermitJoining_0
   2442            {
   2443              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000006   5F43         MOV.B   #0x1, R15
   2444          
   2445              if ( duration != 0xFF )
   \   000008   7C93         CMP.B   #0xff, R12
   \   00000A   0324         JEQ     ??ZDSecMgrPermitJoining_1
   2446              {
   2447                ZDSecMgrPermitJoiningTimed = TRUE;
   \   00000C   5E43         MOV.B   #0x1, R14
   \   00000E   013C         JMP     ??ZDSecMgrPermitJoining_1
   2448              }
   2449            }
   2450            else
   2451            {
   2452              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000010   4F43         MOV.B   #0x0, R15
   \                     ??ZDSecMgrPermitJoining_1:
   \   000012   C24E....     MOV.B   R14, &ZDSecMgrPermitJoiningTimed
   \   000016   C24F....     MOV.B   R15, &ZDSecMgrPermitJoiningEnabled
   2453            }
   2454          
   2455            accept = TRUE;
   2456          
   2457            return accept;
   \   00001A   5C43         MOV.B   #0x1, R12
   \   00001C   1001         RETA
   2458          }
   2459          
   2460          /******************************************************************************
   2461           * @fn          ZDSecMgrPermitJoiningTimeout
   2462           *
   2463           * @brief       Process permit joining timeout
   2464           *
   2465           * @param       none
   2466           *
   2467           * @return      none
   2468           */

   \                                 In  segment CODE, align 2, keep-with-next
   2469          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2470          {
   2471            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000000   D293....     CMP.B   #0x1, &ZDSecMgrPermitJoiningTimed
   \   000004   0420         JNE     ??ZDSecMgrPermitJoiningTimeout_0
   2472            {
   2473              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   000006   C243....     MOV.B   #0x0, &ZDSecMgrPermitJoiningEnabled
   2474              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   00000A   C243....     MOV.B   #0x0, &ZDSecMgrPermitJoiningTimed
   2475            }
   2476          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   00000E   1001         RETA
   2477          
   2478          /******************************************************************************
   2479           * @fn          ZDSecMgrNewDeviceEvent
   2480           *
   2481           * @brief       Process a the new device event, if found reset new device
   2482           *              event/timer.
   2483           *
   2484           * @param       none
   2485           *
   2486           * @return      uint8 - found(TRUE:FALSE)
   2487           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   31501800     ADD.W   #0x18, SP
   \   000004   3817         POPM.W  #0x4, R11
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2488          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2489          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801800     SUB.W   #0x18, SP
   2490            uint8                 found;
   2491            ZDSecMgrDevice_t      device;
   2492            AddrMgrEntry_t        addrEntry;
   2493            associated_devices_t* assoc;
   2494            ZStatus_t             status;
   2495          
   2496            // initialize return results
   2497            found = FALSE;
   \   000006   4A43         MOV.B   #0x0, R10
   2498          
   2499            // look for device in the security init state
   2500            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   000008   6C42         MOV.B   #0x4, R12
   \   00000A   ........     CALLA   #AssocMatchDeviceStatus
   \   00000E   0B4C         MOV.W   R12, R11
   2501          
   2502            if ( assoc != NULL )
   \   000010   0C93         CMP.W   #0x0, R12
   \   000012   3024         JEQ     ??ZDSecMgrNewDeviceEvent_0
   2503            {
   2504              // device found
   2505              found = TRUE;
   \   000014   5A43         MOV.B   #0x1, R10
   2506          
   2507              // check for preconfigured security
   2508              if ( zgPreConfigKeys == TRUE )
   \   000016   D293....     CMP.B   #0x1, &zgPreConfigKeys
   \   00001A   0220         JNE     ??ZDSecMgrNewDeviceEvent_1
   2509              {
   2510                // set association status to authenticated
   2511                ZDSecMgrAssocDeviceAuth( assoc );
   \   00001C   ........     CALLA   #ZDSecMgrAssocDeviceAuth
   2512              }
   2513          
   2514              // set up device info
   2515              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   000020   C1430A00     MOV.B   #0x0, 0xa(SP)
   2516              addrEntry.index = assoc->addrIdx;
   \   000024   914B02001600 MOV.W   0x2(R11), 0x16(SP)
   2517              AddrMgrEntryGet( &addrEntry );
   \   00002A   0841         MOV.W   SP, R8
   \   00002C   38500A00     ADD.W   #0xa, R8
   \   000030   0C48         MOV.W   R8, R12
   \   000032   ........     CALLA   #AddrMgrEntryGet
   2518          
   2519              device.nwkAddr    = assoc->shortAddr;
   \   000036   A14B0000     MOV.W   @R11, 0(SP)
   2520              device.extAddr    = addrEntry.extAddr;
   \   00003A   0F48         MOV.W   R8, R15
   \   00003C   2F52         ADD.W   #0x4, R15
   \   00003E   814F0200     MOV.W   R15, 0x2(SP)
   2521              device.parentAddr = NLME_GetShortAddr();
   \   000042   ........     CALLA   #NLME_GetShortAddr
   \   000046   814C0400     MOV.W   R12, 0x4(SP)
   2522              device.secure     = FALSE;
   \   00004A   C1430600     MOV.B   #0x0, 0x6(SP)
   2523              device.devStatus  = assoc->devStatus;
   \   00004E   D14B05000700 MOV.B   0x5(R11), 0x7(SP)
   2524          
   2525              // process new device
   2526              status = ZDSecMgrDeviceNew( &device );
   \   000054   0C41         MOV.W   SP, R12
   \   000056   0C53         ADD.W   #0x0, R12
   \   000058   ........     CALLA   #ZDSecMgrDeviceNew
   2527          
   2528              if ( status == ZSuccess )
   \   00005C   4C93         CMP.B   #0x0, R12
   \   00005E   0320         JNE     ??ZDSecMgrNewDeviceEvent_2
   2529              {
   2530                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   000060   EBC20500     BIC.B   #0x4, 0x5(R11)
   \   000064   073C         JMP     ??ZDSecMgrNewDeviceEvent_0
   2531              }
   2532              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   000066   7C90C800     CMP.B   #0xc8, R12
   \   00006A   0420         JNE     ??ZDSecMgrNewDeviceEvent_0
   2533              {
   2534                AssocRemove( addrEntry.extAddr );
   \   00006C   2852         ADD.W   #0x4, R8
   \   00006E   0C48         MOV.W   R8, R12
   \   000070   ........     CALLA   #AssocRemove
   2535              }
   2536            }
   2537          
   2538            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   000074   4C4A         MOV.B   R10, R12
   \   000076   ........     BRA     #?Subroutine3
   2539          }
   2540          
   2541          /******************************************************************************
   2542           * @fn          ZDSecMgrEvent
   2543           *
   2544           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2545           *
   2546           * @param       none
   2547           *
   2548           * @return      none
   2549           */

   \                                 In  segment CODE, align 2, keep-with-next
   2550          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2551          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801800     SUB.W   #0x18, SP
   2552            uint8            action;
   2553            uint8            restart;
   2554            uint16           index;
   2555            AddrMgrEntry_t   entry;
   2556            ZDSecMgrDevice_t device;
   2557          
   2558            // verify data is available
   2559            if ( ZDSecMgrCtrlData != NULL )
   \   000006   8293....     CMP.W   #0x0, &ZDSecMgrCtrlData
   \   00000A   4124         JEQ     ??ZDSecMgrEvent_1
   2560            {
   2561              action  = FALSE;
   \   00000C   4843         MOV.B   #0x0, R8
   2562              restart = FALSE;
   \   00000E   4A43         MOV.B   #0x0, R10
   2563          
   2564              // update all the counters
   2565              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   000010   0B43         MOV.W   #0x0, R11
   2566              {
   2567                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrEvent_0:
   \   000012   0F4B         MOV.W   R11, R15
   \   000014   5F0A         RLAM.W  #0x3, R15
   \   000016   1E42....     MOV.W   &ZDSecMgrCtrlData, R14
   \   00001A   0E5F         ADD.W   R15, R14
   \   00001C   CE930500     CMP.B   #0x0, 0x5(R14)
   \   000020   2E24         JEQ     ??ZDSecMgrEvent_2
   2568                {
   2569                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   000022   CE930600     CMP.B   #0x0, 0x6(R14)
   \   000026   0224         JEQ     ??ZDSecMgrEvent_3
   2570                  {
   2571                    ZDSecMgrCtrlData[index].cntr--;
   \   000028   FE530600     ADD.B   #0xff, 0x6(R14)
   2572                  }
   2573          
   2574                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_3:
   \   00002C   58B3         BIT.B   #0x1, R8
   \   00002E   262C         JC      ??ZDSecMgrEvent_4
   \   000030   1E42....     MOV.W   &ZDSecMgrCtrlData, R14
   \   000034   0E5F         ADD.W   R15, R14
   \   000036   CE930600     CMP.B   #0x0, 0x6(R14)
   \   00003A   2020         JNE     ??ZDSecMgrEvent_4
   2575                  {
   2576                    action = TRUE;
   \   00003C   5843         MOV.B   #0x1, R8
   2577          
   2578                    // update from control data
   2579                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   \   00003E   914E02000400 MOV.W   0x2(R14), 0x4(SP)
   2580                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \   000044   D14E04000600 MOV.B   0x4(R14), 0x6(SP)
   2581                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   00004A   814E0800     MOV.W   R14, 0x8(SP)
   2582          
   2583                    // set the user and address index
   2584                    entry.user  = ADDRMGR_USER_SECURITY;
   \   00004E   E1430A00     MOV.B   #0x2, 0xa(SP)
   2585                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \   000052   2F4E         MOV.W   @R14, R15
   \   000054   A14F1600     MOV.W   @R15, 0x16(SP)
   2586          
   2587                    // get the address data
   2588                    AddrMgrEntryGet( &entry );
   \   000058   0C41         MOV.W   SP, R12
   \   00005A   3C500A00     ADD.W   #0xa, R12
   \   00005E   ........     CALLA   #AddrMgrEntryGet
   2589          
   2590                    // set device address data
   2591                    device.nwkAddr = entry.nwkAddr;
   \   000062   91410C000000 MOV.W   0xc(SP), 0(SP)
   2592                    device.extAddr = entry.extAddr;
   \   000068   0F41         MOV.W   SP, R15
   \   00006A   3F500E00     ADD.W   #0xe, R15
   \   00006E   814F0200     MOV.W   R15, 0x2(SP)
   2593          
   2594                    // update from entry data
   2595                    ZDSecMgrDeviceCtrlHandler( &device );
   \   000072   0C41         MOV.W   SP, R12
   \   000074   0C53         ADD.W   #0x0, R12
   \   000076   ........     CALLA   #ZDSecMgrDeviceCtrlHandler
   \   00007A   013C         JMP     ??ZDSecMgrEvent_2
   2596                  }
   2597                  else
   2598                  {
   2599                    restart = TRUE;
   \                     ??ZDSecMgrEvent_4:
   \   00007C   5A43         MOV.B   #0x1, R10
   2600                  }
   2601                }
   2602              }
   \                     ??ZDSecMgrEvent_2:
   \   00007E   1B53         ADD.W   #0x1, R11
   \   000080   3B900300     CMP.W   #0x3, R11
   \   000084   C62B         JNC     ??ZDSecMgrEvent_0
   2603          
   2604              // check for timer restart
   2605              if ( restart == TRUE )
   \   000086   5AB3         BIT.B   #0x1, R10
   \   000088   0228         JNC     ??ZDSecMgrEvent_1
   2606              {
   2607                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   00008A   ........     CALLA   #?Subroutine39
   2608              }
   2609            }
   2610          }
   \                     ??ZDSecMgrEvent_1:
   \   00008E   ........     BRA     #?Subroutine3
   2611          
   2612          /******************************************************************************
   2613           * @fn          ZDSecMgrEstablishKeyCfm
   2614           *
   2615           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2616           *
   2617           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2618           *
   2619           * @return      none
   2620           */

   \                                 In  segment CODE, align 2, keep-with-next
   2621          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2622          {
   2623            // send the NWK key
   2624            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2625            {
   2626              // update control for specified EXT address
   2627              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2628            }
   2629            else
   2630            {
   2631              // this should be done when receiving the NWK key
   2632              // if devState ==
   2633              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2634                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2635          
   2636              // if not in joining state -- this should trigger an event for an
   2637              // end point that requested SKKE
   2638              // if ( devState == DEV_END_DEVICE )
   2639             //       devState == DEV_ROUTER;
   2640          
   2641            }
   2642          }
   \   000000   1001         RETA
   2643          
   2644          /******************************************************************************
   2645           * @fn          ZDSecMgrTCExtAddrCheck
   2646           *
   2647           * @brief       Verifies if received ext. address matches TC ext. address.
   2648           *
   2649           * @param       extAddr - Extended address to be verified.
   2650           *
   2651           * @return      TRUE - extended address matches
   2652           *              FALSE - otherwise
   2653           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000   3152         ADD.W   #0x8, SP
   \   000002   1A17         POPM.W  #0x2, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2654          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2655          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0A4C         MOV.W   R12, R10
   2656            uint8  match;
   2657            uint8  lookup[Z_EXTADDR_LEN];
   2658          
   2659            match = FALSE;
   \   000006   4B43         MOV.B   #0x0, R11
   2660          
   2661            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000008   0D41         MOV.W   SP, R13
   \   00000A   0D53         ADD.W   #0x0, R13
   \   00000C   0C43         MOV.W   #0x0, R12
   \   00000E   ........     CALLA   #AddrMgrExtAddrLookup
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   0624         JEQ     ??ZDSecMgrTCExtAddrCheck_0
   2662            {
   2663              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   000016   0D4A         MOV.W   R10, R13
   \   000018   0C41         MOV.W   SP, R12
   \   00001A   0C53         ADD.W   #0x0, R12
   \   00001C   ........     CALLA   #AddrMgrExtAddrEqual
   \   000020   4B4C         MOV.B   R12, R11
   2664            }
   2665          
   2666            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   000022   4C4B         MOV.B   R11, R12
   \   000024   ........     BRA     #?Subroutine8
   2667          }
   2668          
   2669          /******************************************************************************
   2670           * @fn          ZDSecMgrTCDataLoad
   2671           *
   2672           * @brief       Stores the address of TC into address manager and stores the
   2673           *              preconfigured ZDSecMgrTCMasterKey to NV if zgPreConfigKeys
   2674           *              is set to TRUE.
   2675           *
   2676           * @param       extAddr - Extended address to be verified.
   2677           *
   2678           * @return      none
   2679           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine23:
   \   000000   3E401000     MOV.W   #0x10, R14
   \   000004                REQUIRE ?Subroutine41
   \   000004                // Fall through to label ?Subroutine41

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine41:
   \   000000   4D43         MOV.B   #0x0, R13
   \   000002                REQUIRE ??Subroutine46_0
   \   000002                // Fall through to label ??Subroutine46_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine46_0:
   \   000000   0C4A         MOV.W   R10, R12
   \   000002   ........     BRA     #osal_memset

   \                                 In  segment CODE, align 2, keep-with-next
   2680          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2681          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31802200     SUB.W   #0x22, SP
   \   000006   0A4C         MOV.W   R12, R10
   2682            uint16 ami;
   2683            uint16 keyNvId;
   2684            uint8 masterKey[SEC_KEY_LEN];
   2685            AddrMgrEntry_t entry;
   2686          
   2687            // lookup using TC short address
   2688            entry.user    = ADDRMGR_USER_DEFAULT;
   \   000008   C1430400     MOV.B   #0x0, 0x4(SP)
   2689            entry.nwkAddr = zgTrustCenterAddr;
   \   00000C   9142....0600 MOV.W   &zgTrustCenterAddr, 0x6(SP)
   2690          
   2691            // Verify if TC address has been added to Address Manager
   2692            if ( AddrMgrEntryLookupNwk( &entry ) != TRUE )
   \   000012   0C41         MOV.W   SP, R12
   \   000014   2C52         ADD.W   #0x4, R12
   \   000016   ........     CALLA   #AddrMgrEntryLookupNwk
   \   00001A   5C93         CMP.B   #0x1, R12
   \   00001C   1F24         JEQ     ??ZDSecMgrTCDataLoad_0
   2693            {
   2694              if ( ZDSecMgrAddrStore( zgTrustCenterAddr, extAddr, &ami ) == ZSuccess )
   \   00001E   0E41         MOV.W   SP, R14
   \   000020   0E53         ADD.W   #0x0, R14
   \   000022   0D4A         MOV.W   R10, R13
   \   000024   1C42....     MOV.W   &zgTrustCenterAddr, R12
   \   000028   ........     CALLA   #ZDSecMgrAddrStore
   \   00002C   4C93         CMP.B   #0x0, R12
   \   00002E   1620         JNE     ??ZDSecMgrTCDataLoad_0
   2695              {
   2696                // if preconfigured load key
   2697                if ( zgPreConfigKeys == TRUE )
   \   000030   D293....     CMP.B   #0x1, &zgPreConfigKeys
   \   000034   1320         JNE     ??ZDSecMgrTCDataLoad_0
   2698                {
   2699                  if ( ZDSecMgrMasterKeyLookup( ami, &keyNvId ) != ZSuccess )
   \   000036   ........     CALLA   #?Subroutine33
   \                     ??CrossCallReturnLabel_25:
   \   00003A   1024         JEQ     ??ZDSecMgrTCDataLoad_0
   2700                  {
   2701                    // temporary copy
   2702                    osal_memcpy( masterKey, ZDSecMgrTCMasterKey, SEC_KEY_LEN);
   \   00003C   0A41         MOV.W   SP, R10
   \   00003E   3A501200     ADD.W   #0x12, R10
   \   000042   3E401000     MOV.W   #0x10, R14
   \   000046   3D40....     MOV.W   #ZDSecMgrTCMasterKey, R13
   \   00004A   0C4A         MOV.W   R10, R12
   \   00004C   ........     CALLA   #osal_memcpy
   2703          
   2704                    ZDSecMgrMasterKeyStore( ami, masterKey );
   \   000050   0D4A         MOV.W   R10, R13
   \   000052   2C41         MOV.W   @SP, R12
   \   000054   ........     CALLA   #ZDSecMgrMasterKeyStore
   2705          
   2706                    // remove copy of key in RAM
   2707                    osal_memset( masterKey, 0x00, SEC_KEY_LEN );
   \   000058   ........     CALLA   #?Subroutine23
   2708                  }
   2709                }
   2710              }
   2711            }
   2712          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   00005C   31502200     ADD.W   #0x22, SP
   \   000060   3A41         POP.W   R10
   \   000062   1001         RETA
   2713          
   2714          /******************************************************************************
   2715           * @fn          ZDSecMgrEstablishKeyInd
   2716           *
   2717           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2718           *
   2719           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2720           *
   2721           * @return      none
   2722           */

   \                                 In  segment CODE, align 2, keep-with-next
   2723          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2724          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31801200     SUB.W   #0x12, SP
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   2C52         ADD.W   #0x4, R12
   2725            ZDSecMgrDevice_t        device;
   2726            APSME_EstablishKeyRsp_t rsp;
   2727          
   2728          
   2729            // load Trust Center data if needed
   2730            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000A   ........     CALLA   #ZDSecMgrTCDataLoad
   2731          
   2732            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   00000E   0C4A         MOV.W   R10, R12
   \   000010   2C52         ADD.W   #0x4, R12
   \   000012   ........     CALLA   #ZDSecMgrTCExtAddrCheck
   \   000016   4C93         CMP.B   #0x0, R12
   \   000018   0624         JEQ     ??ZDSecMgrEstablishKeyInd_0
   2733            {
   2734              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2735              //OR
   2736              //!ZDSecMgrTCAuthenticated
   2737              //devtag.0604.critical
   2738                  //how is the parentAddr used here
   2739          
   2740              // initial SKKE from Trust Center via parent
   2741              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   00001A   81430800     MOV.W   #0x0, 0x8(SP)
   2742              device.parentAddr = ind->srcAddr;
   \   00001E   914A02000C00 MOV.W   0x2(R10), 0xc(SP)
   \   000024   063C         JMP     ??ZDSecMgrEstablishKeyInd_1
   2743            }
   2744            else
   2745            {
   2746              // Trust Center direct or E2E SKKE
   2747              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   000026   914A02000800 MOV.W   0x2(R10), 0x8(SP)
   2748              device.parentAddr = INVALID_NODE_ADDR;
   \   00002C   B140FEFF0C00 MOV.W   #0xfffe, 0xc(SP)
   2749            }
   2750          
   2751            device.extAddr = ind->initExtAddr;
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   000032   0F4A         MOV.W   R10, R15
   \   000034   2F52         ADD.W   #0x4, R15
   \   000036   814F0A00     MOV.W   R15, 0xa(SP)
   2752            //devtag.pro.security.0724.todo - verify usage
   2753            device.secure  = ind->nwkSecure;
   \   00003A   D14A0E000E00 MOV.B   0xe(R10), 0xe(SP)
   2754          
   2755            // validate device for SKKE
   2756            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   000040   0C41         MOV.W   SP, R12
   \   000042   3C52         ADD.W   #0x8, R12
   \   000044   ........     CALLA   #ZDSecMgrDeviceValidateSKKE
   \   000048   4C93         CMP.B   #0x0, R12
   \   00004A   0224         JEQ     ??ZDSecMgrEstablishKeyInd_2
   \   00004C   4E43         MOV.B   #0x0, R14
   \   00004E   013C         JMP     ??ZDSecMgrEstablishKeyInd_3
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   000050   5E43         MOV.B   #0x1, R14
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   000052   C14E0400     MOV.B   R14, 0x4(SP)
   2757            {
   2758              rsp.accept = TRUE;
   2759            }
   2760            else
   2761            {
   2762              rsp.accept = FALSE;
   2763            }
   2764          
   2765            rsp.dstAddr     = ind->srcAddr;
   \   000056   ........     CALLA   #?Subroutine37
   2766            rsp.initExtAddr = &ind->initExtAddr[0];
   2767            //devtag.0604.todo - remove obsolete
   2768            rsp.apsSecure   = ind->apsSecure;
   \                     ??CrossCallReturnLabel_37:
   \   00005A   D14A0D000500 MOV.B   0xd(R10), 0x5(SP)
   2769            rsp.nwkSecure   = ind->nwkSecure;
   \   000060   D14A0E000600 MOV.B   0xe(R10), 0x6(SP)
   2770          
   2771            APSME_EstablishKeyRsp( &rsp );
   \   000066   0C41         MOV.W   SP, R12
   \   000068   0C53         ADD.W   #0x0, R12
   \   00006A   ........     CALLA   #APSME_EstablishKeyRsp
   2772          }
   \   00006E   31501200     ADD.W   #0x12, SP
   \   000072   3A41         POP.W   R10
   \   000074   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine37:
   \   000000   914A02000400 MOV.W   0x2(R10), 0x4(SP)
   \   000006   0F4A         MOV.W   R10, R15
   \   000008   2F52         ADD.W   #0x4, R15
   \   00000A   814F0600     MOV.W   R15, 0x6(SP)
   \   00000E   1001         RETA
   2773          
   2774          //devtag.pro.security
   2775          #if 0
   2776          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2777          {
   2778            ZDSecMgrDevice_t        device;
   2779            APSME_EstablishKeyRsp_t rsp;
   2780          
   2781          
   2782            device.extAddr = ind->initExtAddr;
   2783            device.secure  = ind->secure;
   2784          
   2785            if ( ind->secure == FALSE )
   2786            {
   2787              // SKKE from Trust Center is not secured between child and parent
   2788              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2789              device.parentAddr = ind->srcAddr;
   2790            }
   2791            else
   2792            {
   2793              // SKKE from initiator should be secured
   2794              device.nwkAddr    = ind->srcAddr;
   2795              device.parentAddr = INVALID_NODE_ADDR;
   2796            }
   2797          
   2798            rsp.dstAddr     = ind->srcAddr;
   2799            rsp.initExtAddr = &ind->initExtAddr[0];
   2800            rsp.secure      = ind->secure;
   2801          
   2802            // validate device for SKKE
   2803            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2804            {
   2805              rsp.accept = TRUE;
   2806            }
   2807            else
   2808            {
   2809              rsp.accept = FALSE;
   2810            }
   2811          
   2812            APSME_EstablishKeyRsp( &rsp );
   2813          }
   2814          #endif
   2815          
   2816          /******************************************************************************
   2817           * @fn          ZDSecMgrTransportKeyInd
   2818           *
   2819           * @brief       Process the ZDO_TransportKeyInd_t message.
   2820           *
   2821           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2822           *
   2823           * @return      none
   2824           */

   \                                 In  segment CODE, align 2, keep-with-next
   2825          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2826          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31801000     SUB.W   #0x10, SP
   \   000006   0A4C         MOV.W   R12, R10
   2827            uint8 index;
   2828            uint8 zgPreConfigKey[SEC_KEY_LEN];
   2829          
   2830            // load Trust Center data if needed
   2831            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   000008   3C501600     ADD.W   #0x16, R12
   \   00000C   ........     CALLA   #ZDSecMgrTCDataLoad
   2832          
   2833            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000010   5E4A0400     MOV.B   0x4(R10), R14
   \   000014   4E93         CMP.B   #0x0, R14
   \   000016   3924         JEQ     ??ZDSecMgrTransportKeyInd_1
   2834            {
   2835              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2836              //ZDSecMgrTCMasterKey( ind );
   2837              {
   2838                if ( zgPreConfigKeys != TRUE )
   2839                {
   2840                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2841                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2842                }
   2843                else
   2844                {
   2845                  // error condition - reject key
   2846                }
   2847              }
   2848            }
   2849            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2850                      ( ind->keyType == 6                 ) ||
   2851                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000018   5E93         CMP.B   #0x1, R14
   \   00001A   0624         JEQ     ??ZDSecMgrTransportKeyInd_2
   \   00001C   7E900600     CMP.B   #0x6, R14
   \   000020   0324         JEQ     ??ZDSecMgrTransportKeyInd_2
   \   000022   7E900500     CMP.B   #0x5, R14
   \   000026   3120         JNE     ??ZDSecMgrTransportKeyInd_1
   2852            {
   2853              // check for dummy NWK key (all zeros)
   2854              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   000028   4F43         MOV.B   #0x0, R15
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   00002A   0E4A         MOV.W   R10, R14
   \   00002C   0E5F         ADD.W   R15, R14
   \   00002E   CE930600     CMP.B   #0x0, 0x6(R14)
   \   000032   0420         JNE     ??ZDSecMgrTransportKeyInd_3
   2855                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2856                    index++ );
   \   000034   5F53         ADD.B   #0x1, R15
   \   000036   7F901000     CMP.B   #0x10, R15
   \   00003A   F72B         JNC     ??ZDSecMgrTransportKeyInd_0
   2857          
   2858              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   00003C   7F901000     CMP.B   #0x10, R15
   \   000040   1420         JNE     ??ZDSecMgrTransportKeyInd_4
   2859              {
   2860                // load preconfigured key - once!!
   2861                if ( !_NIB.nwkKeyLoaded )
   \   000042   C293....     CMP.B   #0x0, &_NIB + 65
   \   000046   1F20         JNE     ??ZDSecMgrTransportKeyInd_5
   2862                {
   2863                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   \   000048   0A41         MOV.W   SP, R10
   \   00004A   0A53         ADD.W   #0x0, R10
   \   00004C   0D4A         MOV.W   R10, R13
   \   00004E   3C406200     MOV.W   #0x62, R12
   \   000052   ........     CALLA   #ZDSecMgrReadKeyFromNv
   2864                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   \   000056   4D43         MOV.B   #0x0, R13
   \   000058   0C4A         MOV.W   R10, R12
   \   00005A   ........     CALLA   #SSP_UpdateNwkKey
   2865                  SSP_SwitchNwkKey( 0 );
   \   00005E   4C43         MOV.B   #0x0, R12
   \   000060   ........     CALLA   #SSP_SwitchNwkKey
   2866          
   2867                  // clear local copy of key
   2868                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   \   000064   ........     CALLA   #?Subroutine23
   2869                }
   2870              }
   \                     ??CrossCallReturnLabel_68:
   \   000068   0E3C         JMP     ??ZDSecMgrTransportKeyInd_5
   2871              else
   2872              {
   2873                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   00006A   5D4A0500     MOV.B   0x5(R10), R13
   \   00006E   0C4A         MOV.W   R10, R12
   \   000070   3C500600     ADD.W   #0x6, R12
   \   000074   ........     CALLA   #SSP_UpdateNwkKey
   2874                if ( !_NIB.nwkKeyLoaded )
   \   000078   C293....     CMP.B   #0x0, &_NIB + 65
   \   00007C   0420         JNE     ??ZDSecMgrTransportKeyInd_5
   2875                {
   2876                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   00007E   5C4A0500     MOV.B   0x5(R10), R12
   \   000082   ........     CALLA   #SSP_SwitchNwkKey
   2877                }
   2878              }
   2879          
   2880              // handle next step in authentication process
   2881              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   000086   ........     CALLA   #ZDSecMgrAuthNwkKey
   2882            }
   2883            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2884            {
   2885              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2886              {
   2887                // This should not happen because TCLK should not be Tx
   2888              }
   2889            }
   2890            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2891            {
   2892              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2893              {
   2894                uint16           ami;
   2895                AddrMgrEntry_t   entry;
   2896                ZDSecMgrEntry_t* entryZD;
   2897          
   2898                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2899          
   2900                if ( ind->initiator == TRUE )
   2901                {
   2902                  // get the ami data
   2903                  entry.user  = ADDRMGR_USER_SECURITY;
   2904                  entry.index = ami;
   2905                  AddrMgrEntryGet( &entry );
   2906          
   2907                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2908                  {
   2909                    APSME_EstablishKeyReq_t req;
   2910                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2911          
   2912                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2913          
   2914                    if ( entryZD == NULL )
   2915                    {
   2916                      // get new entry
   2917                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2918                      {
   2919                        // finish setting up entry
   2920                        entryZD->ami = ami;
   2921                      }
   2922                    }
   2923          
   2924                    req.respExtAddr = ind->srcExtAddr;
   2925                    req.method      = APSME_SKKE_METHOD;
   2926                    req.dstAddr     = entry.nwkAddr;
   2927                    req.apsSecure   = FALSE;
   2928                    req.nwkSecure   = TRUE;
   2929                    APSME_EstablishKeyReq( &req );
   2930                  }
   2931                }
   2932                else
   2933                {
   2934                  if ( ami == INVALID_NODE_ADDR )
   2935                  {
   2936                    // store new EXT address
   2937                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2938                  }
   2939          
   2940                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2941                }
   2942              }
   2943            }
   2944            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2945            {
   2946              if ( ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH ) ||
   2947                   ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD ) )
   2948              {
   2949                uint16           ami;
   2950                ZDSecMgrEntry_t* entry;
   2951          
   2952                // get the address index
   2953                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2954                {
   2955                  // store new EXT address
   2956                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2957                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2958                }
   2959          
   2960                ZDSecMgrEntryLookupAMI( ami, &entry );
   2961          
   2962                if ( entry == NULL )
   2963                {
   2964                  // get new entry
   2965                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2966                  {
   2967                    // finish setting up entry
   2968                    entry->ami = ami;
   2969                  }
   2970                }
   2971          
   2972                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2973          
   2974          #if defined NV_RESTORE
   2975                ZDSecMgrWriteNV();  // Write the control record for the new established link key to NV.
   2976          #endif
   2977              }
   2978            }
   2979          }
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   00008A                REQUIRE ?Subroutine5
   \   00008A                // Fall through to label ?Subroutine5
   2980          
   2981          /******************************************************************************
   2982           * @fn          ZDSecMgrUpdateDeviceInd
   2983           *
   2984           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2985           *
   2986           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2987           *
   2988           * @return      none
   2989           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine13:
   \   000000   31500A00     ADD.W   #0xa, SP
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2990          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2991          {
   \   000000   31800A00     SUB.W   #0xa, SP
   2992            ZDSecMgrDevice_t device;
   2993          
   2994            device.nwkAddr    = ind->devAddr;
   \   000004   914C0C000000 MOV.W   0xc(R12), 0(SP)
   2995            device.extAddr    = ind->devExtAddr;
   \   00000A   0F4C         MOV.W   R12, R15
   \   00000C   2F52         ADD.W   #0x4, R15
   \   00000E   814F0200     MOV.W   R15, 0x2(SP)
   2996            device.parentAddr = ind->srcAddr;
   \   000012   914C02000400 MOV.W   0x2(R12), 0x4(SP)
   2997          
   2998            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2999            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   3000            //{
   3001            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   3002            //  {
   3003            //    device.secure = TRUE;
   3004            //  }
   3005            //  else
   3006            //  {
   3007            //    device.secure = FALSE;
   3008            //  }
   3009          
   3010              // try to join this device
   3011              ZDSecMgrDeviceJoin( &device );
   \   000018   0C41         MOV.W   SP, R12
   \   00001A   0C53         ADD.W   #0x0, R12
   \   00001C   ........     CALLA   #ZDSecMgrDeviceJoin
   3012            //}
   3013          }
   \   000020   ....         JMP     ?Subroutine13
   3014          
   3015          /******************************************************************************
   3016           * @fn          ZDSecMgrRemoveDeviceInd
   3017           *
   3018           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   3019           *
   3020           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   3021           *
   3022           * @return      none
   3023           */

   \                                 In  segment CODE, align 2, keep-with-next
   3024          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   3025          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31800A00     SUB.W   #0xa, SP
   \   000006   0A4C         MOV.W   R12, R10
   3026            ZDSecMgrDevice_t device;
   3027          
   3028            // only accept from Trust Center
   3029            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000008   8C930200     CMP.W   #0x0, 0x2(R12)
   \   00000C   1220         JNE     ??ZDSecMgrRemoveDeviceInd_0
   3030            {
   3031              // look up NWK address
   3032              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   00000E   0D41         MOV.W   SP, R13
   \   000010   0D53         ADD.W   #0x0, R13
   \   000012   2C52         ADD.W   #0x4, R12
   \   000014   ........     CALLA   #APSME_LookupNwkAddr
   \   000018   5C93         CMP.B   #0x1, R12
   \   00001A   0B20         JNE     ??ZDSecMgrRemoveDeviceInd_0
   3033              {
   3034                device.parentAddr = NLME_GetShortAddr();
   \   00001C   ........     CALLA   #NLME_GetShortAddr
   \   000020   814C0400     MOV.W   R12, 0x4(SP)
   3035                device.extAddr    = ind->childExtAddr;
   \   000024   2A52         ADD.W   #0x4, R10
   \   000026   814A0200     MOV.W   R10, 0x2(SP)
   3036          
   3037                // remove device
   3038                ZDSecMgrDeviceRemove( &device );
   \   00002A   0C41         MOV.W   SP, R12
   \   00002C   0C53         ADD.W   #0x0, R12
   \   00002E   ........     CALLA   #ZDSecMgrDeviceRemove
   3039              }
   3040            }
   3041          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000032                REQUIRE ?Subroutine4
   \   000032                // Fall through to label ?Subroutine4
   3042          
   3043          /******************************************************************************
   3044           * @fn          ZDSecMgrRequestKeyInd
   3045           *
   3046           * @brief       Process the ZDO_RequestKeyInd_t message.
   3047           *
   3048           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   3049           *
   3050           * @return      none
   3051           */

   \                                 In  segment CODE, align 2, keep-with-next
   3052          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   3053          {
   3054            if ( ind->keyType == KEY_TYPE_NWK )
   \   000000   5E4C0400     MOV.B   0x4(R12), R14
   \   000004   5E93         CMP.B   #0x1, R14
   \   000006   0424         JEQ     ??ZDSecMgrRequestKeyInd_0
   3055            {
   3056            }
   3057            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000008   6E93         CMP.B   #0x2, R14
   \   00000A   0220         JNE     ??ZDSecMgrRequestKeyInd_0
   3058            {
   3059              ZDSecMgrAppKeyReq( ind );
   \   00000C   ........     CALLA   #ZDSecMgrAppKeyReq
   3060            }
   3061            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   3062            {
   3063            }
   3064            //else ignore
   3065          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   000010   1001         RETA
   3066          
   3067          /******************************************************************************
   3068           * @fn          ZDSecMgrSwitchKeyInd
   3069           *
   3070           * @brief       Process the ZDO_SwitchKeyInd_t message.
   3071           *
   3072           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   3073           *
   3074           * @return      none
   3075           */

   \                                 In  segment CODE, align 2, keep-with-next
   3076          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   3077          {
   3078            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000000   5C4C0400     MOV.B   0x4(R12), R12
   \   000004   ........     CALLA   #SSP_SwitchNwkKey
   3079          
   3080            // Save if nv
   3081            ZDApp_NVUpdate();
   \   000008   ........     BRA     #ZDApp_NVUpdate
   3082          }
   3083          
   3084          /******************************************************************************
   3085           * @fn          ZDSecMgrAuthenticateInd
   3086           *
   3087           * @brief       Process the ZDO_AuthenticateInd_t message.
   3088           *
   3089           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   3090           *
   3091           * @return      none
   3092           */

   \                                 In  segment CODE, align 2, keep-with-next
   3093          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   3094          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31801600     SUB.W   #0x16, SP
   \   000006   0A4C         MOV.W   R12, R10
   3095            APSME_AuthenticateReq_t req;
   3096            AddrMgrEntry_t          entry;
   3097          
   3098            // update the address manager
   3099            //---------------------------------------------------------------------------
   3100            // note:
   3101            // required for EA processing, but ultimately EA logic could also use the
   3102            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3103            // table is supposed to have authentication states for neighbors
   3104            //---------------------------------------------------------------------------
   3105            entry.user    = ADDRMGR_USER_SECURITY;
   \   000008   E1430800     MOV.B   #0x2, 0x8(SP)
   3106            entry.nwkAddr = ind->aps.initNwkAddr;
   \   00000C   914C02000A00 MOV.W   0x2(R12), 0xa(SP)
   3107            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \   000012   0D4C         MOV.W   R12, R13
   \   000014   2D52         ADD.W   #0x4, R13
   \   000016   0C41         MOV.W   SP, R12
   \   000018   3C500C00     ADD.W   #0xc, R12
   \   00001C   ........     CALLA   #AddrMgrExtAddrSet
   3108          
   3109            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000020   0C41         MOV.W   SP, R12
   \   000022   3C52         ADD.W   #0x8, R12
   \   000024   ........     CALLA   #AddrMgrEntryUpdate
   \   000028   5C93         CMP.B   #0x1, R12
   \   00002A   0C20         JNE     ??ZDSecMgrAuthenticateInd_0
   3110            {
   3111              // set request fields
   3112              req.nwkAddr   = ind->aps.initNwkAddr;
   \   00002C   ........     CALLA   #?Subroutine37
   3113              req.extAddr   = ind->aps.initExtAddr;
   3114              req.action    = APSME_EA_ACCEPT;
   \                     ??CrossCallReturnLabel_36:
   \   000030   D1430600     MOV.B   #0x1, 0x6(SP)
   3115              req.challenge = ind->aps.challenge;
   \   000034   3A500C00     ADD.W   #0xc, R10
   \   000038   814A0400     MOV.W   R10, 0x4(SP)
   3116          
   3117              // start EA processing
   3118              APSME_AuthenticateReq( &req );
   \   00003C   0C41         MOV.W   SP, R12
   \   00003E   0C53         ADD.W   #0x0, R12
   \   000040   ........     CALLA   #APSME_AuthenticateReq
   3119            }
   3120          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   000044   31501600     ADD.W   #0x16, SP
   \   000048   3A41         POP.W   R10
   \   00004A   1001         RETA
   3121          
   3122          /******************************************************************************
   3123           * @fn          ZDSecMgrAuthenticateCfm
   3124           *
   3125           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3126           *
   3127           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3128           *
   3129           * @return      none
   3130           */

   \                                 In  segment CODE, align 2, keep-with-next
   3131          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3132          {
   3133            if ( cfm->aps.status == ZSuccess )
   \   000000   CC930B00     CMP.B   #0x0, 0xb(R12)
   \   000004   0520         JNE     ??ZDSecMgrAuthenticateCfm_0
   3134            {
   3135              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   000006   DC930200     CMP.B   #0x1, 0x2(R12)
   \   00000A   0220         JNE     ??ZDSecMgrAuthenticateCfm_0
   \   00000C   ........     CALLA   #?Subroutine16
   3136              {
   3137                // inform ZDO that device has been authenticated
   3138                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   3139              }
   3140            }
   3141          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   000010   1001         RETA
   3142          
   3143          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3144          /******************************************************************************
   3145           * @fn          ZDSecMgrUpdateNwkKey
   3146           *
   3147           * @brief       Load a new NWK key and trigger a network wide update.
   3148           *
   3149           * @param       key       - [in] new NWK key
   3150           * @param       keySeqNum - [in] new NWK key sequence number
   3151           *
   3152           * @return      ZStatus_t
   3153           */
   3154          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3155          {
   3156            ZStatus_t               status;
   3157            APSME_TransportKeyReq_t req;
   3158          
   3159            // initialize common elements of local variables
   3160            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3161            {
   3162              req.keyType   = KEY_TYPE_NWK_HIGH;
   3163            }
   3164            else
   3165            {
   3166              req.keyType   = KEY_TYPE_NWK;
   3167            }
   3168          
   3169            req.dstAddr   = dstAddr;
   3170            req.keySeqNum = keySeqNum;
   3171            req.key       = key;
   3172            req.extAddr   = NULL;
   3173            req.nwkSecure = TRUE;
   3174            req.apsSecure = TRUE;
   3175            req.tunnel    = NULL;
   3176          
   3177            if (( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH ) ||
   3178                ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD ))
   3179            {
   3180              ZDSecMgrEntry_t*        entry;
   3181              uint16                  index;
   3182              AddrMgrEntry_t          addrEntry;
   3183          
   3184              addrEntry.user = ADDRMGR_USER_SECURITY;
   3185          
   3186              status = ZFailure;
   3187          
   3188              // verify data is available
   3189              if ( ZDSecMgrEntries != NULL )
   3190              {
   3191                // find available entry
   3192                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3193                {
   3194                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3195                  {
   3196                    // return successful result
   3197                    entry = &ZDSecMgrEntries[index];
   3198          
   3199                    // get NWK address
   3200                    addrEntry.index = entry->ami;
   3201                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3202                    {
   3203                      req.dstAddr = addrEntry.nwkAddr;
   3204                      req.extAddr = addrEntry.extAddr;
   3205                      status = APSME_TransportKeyReq( &req );
   3206                    }
   3207                  }
   3208                }
   3209              }
   3210            }
   3211            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3212            {
   3213              status = APSME_TransportKeyReq( &req );
   3214            }
   3215          
   3216            SSP_UpdateNwkKey( key, keySeqNum );
   3217          
   3218            // Save if nv
   3219            ZDApp_NVUpdate();
   3220          
   3221            return status;
   3222          }
   3223          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3224          
   3225          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3226          /******************************************************************************
   3227           * @fn          ZDSecMgrSwitchNwkKey
   3228           *
   3229           * @brief       Causes the NWK key to switch via a network wide command.
   3230           *
   3231           * @param       keySeqNum - [in] new NWK key sequence number
   3232           *
   3233           * @return      ZStatus_t
   3234           */
   3235          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3236          {
   3237            ZStatus_t            status;
   3238            APSME_SwitchKeyReq_t req;
   3239          
   3240            // initialize common elements of local variables
   3241            req.dstAddr = dstAddr;
   3242            req.keySeqNum = keySeqNum;
   3243          
   3244            if (( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH ) ||
   3245                ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD ))
   3246            {
   3247              ZDSecMgrEntry_t*     entry;
   3248              uint16               index;
   3249              AddrMgrEntry_t       addrEntry;
   3250          
   3251              addrEntry.user = ADDRMGR_USER_SECURITY;
   3252          
   3253              status = ZFailure;
   3254          
   3255              // verify data is available
   3256              if ( ZDSecMgrEntries != NULL )
   3257              {
   3258                // find available entry
   3259                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3260                {
   3261                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3262                  {
   3263                    // return successful result
   3264                    entry = &ZDSecMgrEntries[index];
   3265          
   3266                    // get NWK address
   3267                    addrEntry.index = entry->ami;
   3268          
   3269                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3270                    {
   3271                      req.dstAddr = addrEntry.nwkAddr;
   3272                      status = APSME_SwitchKeyReq( &req );
   3273                    }
   3274                  }
   3275                }
   3276              }
   3277            }
   3278            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3279            {
   3280              status = APSME_SwitchKeyReq( &req );
   3281            }
   3282          
   3283            SSP_SwitchNwkKey( keySeqNum );
   3284          
   3285            // Save if nv
   3286            ZDApp_NVUpdate();
   3287          
   3288            return status;
   3289          }
   3290          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3291          
   3292          /******************************************************************************
   3293           * @fn          ZDSecMgrRequestAppKey
   3294           *
   3295           * @brief       Request an application key with partner.
   3296           *
   3297           * @param       partExtAddr - [in] partner extended address
   3298           *
   3299           * @return      ZStatus_t
   3300           */

   \                                 In  segment CODE, align 2, keep-with-next
   3301          ZStatus_t ZDSecMgrRequestAppKey( uint8 *partExtAddr )
   \                     ZDSecMgrRequestAppKey:
   3302          {
   \   000000   2182         SUB.W   #0x4, SP
   3303            ZStatus_t status;
   3304            APSME_RequestKeyReq_t req;
   3305          
   3306            req.dstAddr = 0;
   \   000002   C1430000     MOV.B   #0x0, 0(SP)
   3307            req.keyType = KEY_TYPE_APP_MASTER;
   \   000006   E1430100     MOV.B   #0x2, 0x1(SP)
   3308          
   3309            req.partExtAddr = partExtAddr;
   \   00000A   814C0200     MOV.W   R12, 0x2(SP)
   3310            status = APSME_RequestKeyReq( &req );
   3311          
   3312            return status;
   \   00000E   0C41         MOV.W   SP, R12
   \   000010   0C53         ADD.W   #0x0, R12
   \   000012   ........     CALLA   #APSME_RequestKeyReq
   \   000016   2152         ADD.W   #0x4, SP
   \   000018   1001         RETA
   3313          }
   3314          
   3315          #if ( ZG_BUILD_JOINING_TYPE )
   3316          /******************************************************************************
   3317           * @fn          ZDSecMgrSetupPartner
   3318           *
   3319           * @brief       Setup for application key partner.
   3320           *
   3321           * @param       partNwkAddr - [in] partner network address
   3322           *
   3323           * @return      ZStatus_t
   3324           */

   \                                 In  segment CODE, align 2, keep-with-next
   3325          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3326          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31800E00     SUB.W   #0xe, SP
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0B4D         MOV.W   R13, R11
   3327            AddrMgrEntry_t entry;
   3328            ZStatus_t      status;
   3329          
   3330            status = ZFailure;
   \   00000A   5843         MOV.B   #0x1, R8
   3331          
   3332            // update the address manager
   3333            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000C   ........     CALLA   #?Subroutine30
   3334            entry.nwkAddr = partNwkAddr;
   3335            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   3336          
   3337            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_16:
   \   000010   5C93         CMP.B   #0x1, R12
   \   000012   1720         JNE     ??ZDSecMgrSetupPartner_0
   3338            {
   3339              status = ZSuccess;
   \   000014   4843         MOV.B   #0x0, R8
   3340          
   3341              // check for address discovery
   3342              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000016   3A90FEFF     CMP.W   #0xfffe, R10
   \   00001A   0720         JNE     ??ZDSecMgrSetupPartner_1
   3343              {
   3344                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00001C   4F43         MOV.B   #0x0, R15
   \   00001E   4E43         MOV.B   #0x0, R14
   \   000020   4D43         MOV.B   #0x0, R13
   \   000022   0C4B         MOV.W   R11, R12
   \   000024   ........     CALLA   #ZDP_NwkAddrReq
   \   000028   0B3C         JMP     ??ZDSecMgrSetupPartner_2
   3345              }
   3346              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_1:
   \   00002A   0C4B         MOV.W   R11, R12
   \   00002C   ........     CALLA   #AddrMgrExtAddrValid
   \   000030   4C93         CMP.B   #0x0, R12
   \   000032   0720         JNE     ??ZDSecMgrSetupPartner_0
   3347              {
   3348                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000034   4F43         MOV.B   #0x0, R15
   \   000036   4E43         MOV.B   #0x0, R14
   \   000038   4D43         MOV.B   #0x0, R13
   \   00003A   0C4A         MOV.W   R10, R12
   \   00003C   ........     CALLA   #ZDP_IEEEAddrReq
   \                     ??ZDSecMgrSetupPartner_2:
   \   000040   484C         MOV.B   R12, R8
   3349              }
   3350            }
   3351          
   3352            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   000042   4C48         MOV.B   R8, R12
   \   000044   31500E00     ADD.W   #0xe, SP
   \   000048   3817         POPM.W  #0x4, R11
   \   00004A   1001         RETA
   3353          }
   3354          #endif // ( ZG_BUILD_JOINING_TYPE )
   3355          
   3356          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3357          /******************************************************************************
   3358           * @fn          ZDSecMgrAppKeyTypeSet
   3359           *
   3360           * @brief       Set application key type.
   3361           *
   3362           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3363           *                                                   KEY_TYPE_APP_LINK@3
   3364           *
   3365           * @return      ZStatus_t
   3366           */
   3367          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3368          {
   3369            if ( keyType == KEY_TYPE_APP_LINK )
   3370            {
   3371              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3372            }
   3373            else
   3374            {
   3375              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3376            }
   3377          
   3378            return ZSuccess;
   3379          }
   3380          #endif
   3381          
   3382          /******************************************************************************
   3383           * ZigBee Device Security Manager - Stub Implementations
   3384           */
   3385          /******************************************************************************
   3386           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3387           *
   3388           * @brief       Get MASTER key for specified EXT address.
   3389           *
   3390           * @param       extAddr - [in] EXT address
   3391           * @param       pKeyNvId - [out] MASTER key NV ID
   3392           *
   3393           * @return      ZStatus_t
   3394           */

   \                                 In  segment CODE, align 2, keep-with-next
   3395          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint16* pKeyNvId )
   \                     APSME_MasterKeyGet:
   3396          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   ........     CALLA   #?Subroutine31
   3397            ZStatus_t status;
   3398            uint16 ami;
   3399          
   3400            // lookup entry for specified EXT address
   3401            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   3402          
   3403            if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_17:
   \   000008   0520         JNE     ??APSME_MasterKeyGet_0
   3404            {
   3405              ZDSecMgrMasterKeyLookup( ami, pKeyNvId );
   \   00000A   0D4A         MOV.W   R10, R13
   \   00000C   2C41         MOV.W   @SP, R12
   \   00000E   ........     CALLA   #ZDSecMgrMasterKeyLookup
   \   000012   023C         JMP     ??APSME_MasterKeyGet_1
   3406            }
   3407            else
   3408            {
   3409              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_MasterKeyGet_0:
   \   000014   8A430000     MOV.W   #0x0, 0(R10)
   3410            }
   3411          
   3412            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   000018   ........     BRA     #?Subroutine2
   3413          }
   3414          
   3415          /******************************************************************************
   3416           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3417           *
   3418           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3419           *
   3420           * @param       extAddr - [in] EXT address
   3421           * @param       data    - [in] APSME_LinkKeyData_t
   3422           *
   3423           * @return      ZStatus_t
   3424           */

   \                                 In  segment CODE, align 2, keep-with-next
   3425          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3426          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2182         SUB.W   #0x4, SP
   \   000004   0B4D         MOV.W   R13, R11
   3427            ZStatus_t status;
   3428            ZDSecMgrEntry_t* entry;
   3429            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3430            uint16 Index;
   3431          
   3432            // lookup entry index for specified EXT address
   3433            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index );
   \   000006   0E41         MOV.W   SP, R14
   \   000008   2E53         ADD.W   #0x2, R14
   \   00000A   0D41         MOV.W   SP, R13
   \   00000C   0D53         ADD.W   #0x0, R13
   \   00000E   ........     CALLA   #ZDSecMgrEntryLookupExtGetIndex
   \   000012   4A4C         MOV.B   R12, R10
   3434          
   3435            if ( status == ZSuccess )
   \   000014   4C93         CMP.B   #0x0, R12
   \   000016   4120         JNE     ??APSME_LinkKeySet_0
   3436            {
   3437              // point to NV item
   3438              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   \   000018   1F410200     MOV.W   0x2(SP), R15
   \   00001C   3F500102     ADD.W   #0x201, R15
   \   000020   2E41         MOV.W   @SP, R14
   \   000022   8E4F0200     MOV.W   R15, 0x2(R14)
   3439          
   3440              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000026   ........     CALLA   #?Subroutine15
   \                     ??CrossCallReturnLabel_2:
   \   00002A   084C         MOV.W   R12, R8
   3441          
   3442              if (pApsLinkKey != NULL)
   \   00002C   0C93         CMP.W   #0x0, R12
   \   00002E   3524         JEQ     ??APSME_LinkKeySet_0
   3443              {
   3444                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3445                osal_nv_read( entry->keyNvId, 0,
   3446                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000030   0F4C         MOV.W   R12, R15
   \   000032   ........     CALLA   #??Subroutine28_0
   \                     ??CrossCallReturnLabel_58:
   \   000036   2C41         MOV.W   @SP, R12
   \   000038   1C4C0200     MOV.W   0x2(R12), R12
   \   00003C   ........     CALLA   #osal_nv_read
   3447          
   3448                // set new values of the key
   3449                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   \   000040   3E401000     MOV.W   #0x10, R14
   \   000044   0D4B         MOV.W   R11, R13
   \   000046   0C48         MOV.W   R8, R12
   \   000048   ........     CALLA   #osal_memcpy
   3450                pApsLinkKey->rxFrmCntr = 0;
   \   00004C   88431400     MOV.W   #0x0, 0x14(R8)
   \   000050   88431600     MOV.W   #0x0, 0x16(R8)
   3451                pApsLinkKey->txFrmCntr = 0;
   \   000054   88431000     MOV.W   #0x0, 0x10(R8)
   \   000058   88431200     MOV.W   #0x0, 0x12(R8)
   3452          
   3453                osal_nv_write( entry->keyNvId, 0,
   3454                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   00005C   0F48         MOV.W   R8, R15
   \   00005E   ........     CALLA   #??Subroutine28_0
   \                     ??CrossCallReturnLabel_59:
   \   000062   2B41         MOV.W   @SP, R11
   \   000064   1C4B0200     MOV.W   0x2(R11), R12
   \   000068   ........     CALLA   #osal_nv_write
   3455          
   3456                // clear copy of key in RAM
   3457                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   00006C   3E401800     MOV.W   #0x18, R14
   \   000070   4D43         MOV.B   #0x0, R13
   \   000072   0C48         MOV.W   R8, R12
   \   000074   ........     CALLA   #osal_memset
   3458          
   3459                osal_mem_free(pApsLinkKey);
   \   000078   0C48         MOV.W   R8, R12
   \   00007A   ........     CALLA   #osal_mem_free
   \   00007E   2F41         MOV.W   @SP, R15
   \   000080   1B4F0200     MOV.W   0x2(R15), R11
   \   000084   0F4B         MOV.W   R11, R15
   \   000086                RPT     #0x9
   \   000086   48180F5B     ADDX.W  R11, R15
   \   00008A   8F43....     MOV.W   #0x0, LWRD(ApsLinkKeyFrmCntr - 5130)(R15)
   \   00008E   8F43....     MOV.W   #0x0, LWRD(ApsLinkKeyFrmCntr - 5128)(R15)
   3460          
   3461                // set initial values for counters in RAM
   3462                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   3463                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   \   000092   8F43....     MOV.W   #0x0, LWRD(ApsLinkKeyFrmCntr - 5126)(R15)
   \   000096   8F43....     MOV.W   #0x0, LWRD(ApsLinkKeyFrmCntr - 5124)(R15)
   3464              }
   3465            }
   3466          
   3467            return status;
   \                     ??APSME_LinkKeySet_0:
   \   00009A   4C4A         MOV.B   R10, R12
   \   00009C   2152         ADD.W   #0x4, SP
   \   00009E   3817         POPM.W  #0x4, R11
   \   0000A0   1001         RETA
   3468          }
   3469          
   3470          /******************************************************************************
   3471           * @fn          ZDSecMgrAuthenticationSet
   3472           *
   3473           * @brief       Mark the specific device as authenticated or not
   3474           *
   3475           * @param       extAddr - [in] EXT address
   3476           * @param       option  - [in] authenticated or not
   3477           *
   3478           * @return      ZStatus_t
   3479           */

   \                                 In  segment CODE, align 2, keep-with-next
   3480          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3481          {
   \   000000   0A12         PUSH.W  R10
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   4A4D         MOV.B   R13, R10
   3482            ZStatus_t        status;
   3483            ZDSecMgrEntry_t* entry;
   3484          
   3485          
   3486            // lookup entry index for specified EXT address
   3487            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000006   ........     CALLA   #?Subroutine34
   3488          
   3489            if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_29:
   \   00000A   4C93         CMP.B   #0x0, R12
   \   00000C   0320         JNE     ??ZDSecMgrAuthenticationSet_0
   3490            {
   3491              entry->authenticateOption = option;
   \   00000E   2F41         MOV.W   @SP, R15
   \   000010   CF4A0400     MOV.B   R10, 0x4(R15)
   3492            }
   3493          
   3494            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000014   ....         JMP     ?Subroutine10
   3495          }
   3496          
   3497          /******************************************************************************
   3498           * @fn          ZDSecMgrAuthenticationCheck
   3499           *
   3500           * @brief       Check if the specific device has been authenticated or not
   3501           *              For non-trust center device, always return TRUE
   3502           *
   3503           * @param       shortAddr - [in] short address
   3504           *
   3505           * @return      TRUE @ authenticated with CBKE
   3506           *              FALSE @ not authenticated
   3507           */
   3508          

   \                                 In  segment CODE, align 2, keep-with-next
   3509          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3510          {
   3511          #if defined (TC_LINKKEY_JOIN)
   3512          
   3513            ZDSecMgrEntry_t* entry;
   3514            uint8 extAddr[Z_EXTADDR_LEN];
   3515          
   3516            // If the local device is not the trust center, always return TRUE
   3517            if ( NLME_GetShortAddr() != zgTrustCenterAddr )
   3518            {
   3519              return TRUE;
   3520            }
   3521            // Otherwise, check the authentication option
   3522            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3523            {
   3524              // lookup entry index for specified EXT address
   3525              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3526              {
   3527                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3528                {
   3529                  return TRUE;
   3530                }
   3531                else
   3532                {
   3533                  return FALSE;
   3534                }
   3535              }
   3536            }
   3537            return FALSE;
   3538          
   3539          #else
   3540            (void)shortAddr;  // Intentionally unreferenced parameter
   3541          
   3542            // For non AMI/SE Profile, perform no check and always return TRUE.
   3543            return TRUE;
   \   000000   5C43         MOV.B   #0x1, R12
   \   000002   1001         RETA
   3544          
   3545          #endif // TC_LINKKEY_JOIN
   3546          }
   3547          
   3548          /******************************************************************************
   3549           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   3550           *
   3551           * @brief       Get Key NV ID for specified NWK address.
   3552           *
   3553           * @param       extAddr - [in] EXT address
   3554           * @param       keyNvId - [out] NV ID
   3555           *
   3556           * @return      ZStatus_t
   3557           */

   \                                 In  segment CODE, align 2, keep-with-next
   3558          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   \                     APSME_LinkKeyNVIdGet:
   3559          {
   \   000000   0A12         PUSH.W  R10
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4D         MOV.W   R13, R10
   3560            ZStatus_t status;
   3561            ZDSecMgrEntry_t* entry;
   3562          
   3563            // lookup entry index for specified NWK address
   3564            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000006   ........     CALLA   #?Subroutine34
   3565          
   3566            if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_30:
   \   00000A   4C93         CMP.B   #0x0, R12
   \   00000C   0420         JNE     ??APSME_LinkKeyNVIdGet_0
   3567            {
   3568              // return the index to the NV table
   3569              *pKeyNvId = entry->keyNvId;
   \   00000E   2F41         MOV.W   @SP, R15
   \   000010   1F4F0200     MOV.W   0x2(R15), R15
   \   000014   013C         JMP     ??APSME_LinkKeyNVIdGet_1
   3570            }
   3571            else
   3572            {
   3573              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_LinkKeyNVIdGet_0:
   \   000016   0F43         MOV.W   #0x0, R15
   \                     ??APSME_LinkKeyNVIdGet_1:
   \   000018   8A4F0000     MOV.W   R15, 0(R10)
   3574            }
   3575          
   3576            return status;
   \   00001C                REQUIRE ?Subroutine10
   \   00001C                // Fall through to label ?Subroutine10
   3577          }
   3578          
   3579          /******************************************************************************
   3580           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   3581           *
   3582           * @brief       Verifies if Link Key in NV has been set.
   3583           *
   3584           * @param       extAddr - [in] EXT address
   3585           *
   3586           * @return      TRUE - Link Key has been established
   3587           *              FALSE - Link Key in NV has default value.
   3588           */

   \                                 In  segment CODE, align 2, keep-with-next
   3589          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   \                     APSME_IsLinkKeyValid:
   3590          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31801200     SUB.W   #0x12, SP
   \   000006   0A4C         MOV.W   R12, R10
   3591            APSME_LinkKeyData_t *pKeyData;
   3592            uint16 apsLinkKeyNvId;
   3593            uint8 nullKey[SEC_KEY_LEN];
   3594            uint8 status = FALSE;
   \   000008   4B43         MOV.B   #0x0, R11
   3595          
   3596            // initialize default vealue to compare to
   3597            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   \   00000A   3E401000     MOV.W   #0x10, R14
   \   00000E   ........     CALLA   #?Subroutine26
   3598          
   3599            // check for APS link NV ID
   3600            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   \                     ??CrossCallReturnLabel_12:
   \   000012   0D41         MOV.W   SP, R13
   \   000014   0D53         ADD.W   #0x0, R13
   \   000016   0C4A         MOV.W   R10, R12
   \   000018   ........     CALLA   #APSME_LinkKeyNVIdGet
   3601          
   3602            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   \   00001C   81930000     CMP.W   #0x0, 0(SP)
   \   000020   1724         JEQ     ??APSME_IsLinkKeyValid_0
   3603            {
   3604              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000022   ........     CALLA   #?Subroutine14
   3605          
   3606              if (pKeyData != NULL)
   \                     ??CrossCallReturnLabel_47:
   \   000026   1424         JEQ     ??APSME_IsLinkKeyValid_0
   3607              {
   3608                // retrieve key from NV
   3609                if ( osal_nv_read( apsLinkKeyNvId, 0,
   3610                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   \   000028   0F4C         MOV.W   R12, R15
   \   00002A   ........     CALLA   #??Subroutine28_0
   \                     ??CrossCallReturnLabel_57:
   \   00002E   2C41         MOV.W   @SP, R12
   \   000030   ........     CALLA   #osal_nv_read
   \   000034   4C93         CMP.B   #0x0, R12
   \   000036   0A20         JNE     ??APSME_IsLinkKeyValid_1
   3611                {
   3612                  // if stored key is different than default value, then a key has been established
   3613                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   \   000038   3E401000     MOV.W   #0x10, R14
   \   00003C   0D41         MOV.W   SP, R13
   \   00003E   2D53         ADD.W   #0x2, R13
   \   000040   0C4A         MOV.W   R10, R12
   \   000042   ........     CALLA   #osal_memcmp
   \   000046   4C93         CMP.B   #0x0, R12
   \   000048   0120         JNE     ??APSME_IsLinkKeyValid_1
   3614                  {
   3615                    status = TRUE;
   \   00004A   5B43         MOV.B   #0x1, R11
   3616                  }
   3617                }
   3618          
   3619                // clear copy of key in RAM
   3620                osal_memset(pKeyData, 0x00, sizeof(APSME_LinkKeyData_t));
   \                     ??APSME_IsLinkKeyValid_1:
   \   00004C   ........     CALLA   #?Subroutine22
   3621          
   3622                osal_mem_free(pKeyData);
   3623              }
   3624            }
   3625          
   3626            return status;
   \                     ??APSME_IsLinkKeyValid_0:
   \   000050   4C4B         MOV.B   R11, R12
   \   000052   31501200     ADD.W   #0x12, SP
   \   000056   1A17         POPM.W  #0x2, R11
   \   000058   1001         RETA
   3627          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine26:
   \   000000   4D43         MOV.B   #0x0, R13
   \   000002   0C41         MOV.W   SP, R12
   \   000004   3C500600     ADD.W   #0x6, R12
   \   000008   ........     BRA     #osal_memset

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine22:
   \   000000   3E401800     MOV.W   #0x18, R14
   \   000004   ........     CALLA   #?Subroutine41
   \                     ??CrossCallReturnLabel_71:
   \   000008   0C4A         MOV.W   R10, R12
   \   00000A   ........     BRA     #osal_mem_free

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine14:
   \   000000   3C401800     MOV.W   #0x18, R12
   \   000004                REQUIRE ??Subroutine42_0
   \   000004                // Fall through to label ??Subroutine42_0

   \                                 In  segment CODE, align 2
   \                     ??Subroutine42_0:
   \   000000   ........     CALLA   #osal_mem_alloc
   \   000004   0A4C         MOV.W   R12, R10
   \   000006   0C93         CMP.W   #0x0, R12
   \   000008   1001         RETA
   3628          
   3629          /******************************************************************************
   3630           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3631           *
   3632           * @brief       Verify and process key transportation to child.
   3633           *
   3634           * @param       ind - [in] APSME_TransportKeyInd_t
   3635           *
   3636           * @return      uint8 - success(TRUE:FALSE)
   3637           */

   \                                 In  segment CODE, align 2, keep-with-next
   3638          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3639          {
   3640            // verify from Trust Center
   3641            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000000   8C930000     CMP.W   #0x0, 0(R12)
   \   000004   1220         JNE     ??APSME_KeyFwdToChild_0
   3642            {
   3643              // check for initial NWK key
   3644              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3645                   ( ind->keyType == 6                 ) ||
   3646                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000006   5E4C0200     MOV.B   0x2(R12), R14
   \   00000A   5E93         CMP.B   #0x1, R14
   \   00000C   0624         JEQ     ??APSME_KeyFwdToChild_1
   \   00000E   7E900600     CMP.B   #0x6, R14
   \   000012   0324         JEQ     ??APSME_KeyFwdToChild_1
   \   000014   7E900500     CMP.B   #0x5, R14
   \   000018   0620         JNE     ??APSME_KeyFwdToChild_2
   3647              {
   3648                // set association status to authenticated
   3649                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   00001A   1C4C0600     MOV.W   0x6(R12), R12
   \   00001E   ........     CALLA   #AssocGetWithExt
   \   000022   ........     CALLA   #ZDSecMgrAssocDeviceAuth
   3650              }
   3651          
   3652              return TRUE;
   \                     ??APSME_KeyFwdToChild_2:
   \   000026   5C43         MOV.B   #0x1, R12
   \   000028   1001         RETA
   3653            }
   3654          
   3655            return FALSE;
   \                     ??APSME_KeyFwdToChild_0:
   \   00002A   4C43         MOV.B   #0x0, R12
   \   00002C   1001         RETA
   3656          }
   3657          
   3658          /******************************************************************************
   3659           * @fn          ZDSecMgrAddLinkKey
   3660           *
   3661           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3662           *              as authenticated in the authenticateOption. Note that this function
   3663           *              is hardwared to CBKE right now.
   3664           *
   3665           * @param       shortAddr - short address of the partner device
   3666           * @param       extAddr - extended address of the partner device
   3667           * @param       key - link key
   3668           *
   3669           * @return      ZStatus_t
   3670           */

   \                                 In  segment CODE, align 2, keep-with-next
   3671          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3672          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2182         SUB.W   #0x4, SP
   \   000004   0A4D         MOV.W   R13, R10
   \   000006   0B4E         MOV.W   R14, R11
   3673            uint16           ami;
   3674            ZDSecMgrEntry_t* entry;
   3675          
   3676            /* Store the device address in the addr manager */
   3677            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   000008   0E41         MOV.W   SP, R14
   \   00000A   2E53         ADD.W   #0x2, R14
   \   00000C   ........     CALLA   #ZDSecMgrAddrStore
   \   000010   4C93         CMP.B   #0x0, R12
   \   000012   0224         JEQ     ??ZDSecMgrAddLinkKey_1
   3678            {
   3679              /* Adding to Addr Manager fails */
   3680              return ZFailure;
   \   000014   5C43         MOV.B   #0x1, R12
   \   000016   183C         JMP     ??ZDSecMgrAddLinkKey_0
   3681            }
   3682          
   3683            /* Lookup entry using specified address index */
   3684            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_1:
   \   000018   0D41         MOV.W   SP, R13
   \   00001A   0D53         ADD.W   #0x0, R13
   \   00001C   1C410200     MOV.W   0x2(SP), R12
   \   000020   ........     CALLA   #ZDSecMgrEntryLookupAMI
   3685          
   3686            // If no existing entry, create one
   3687            if ( entry == NULL )
   \   000024   81930000     CMP.W   #0x0, 0(SP)
   \   000028   0A20         JNE     ??ZDSecMgrAddLinkKey_2
   3688            {
   3689              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   00002A   0C41         MOV.W   SP, R12
   \   00002C   0C53         ADD.W   #0x0, R12
   \   00002E   ........     CALLA   #ZDSecMgrEntryNew
   \   000032   4C93         CMP.B   #0x0, R12
   \   000034   0B20         JNE     ??ZDSecMgrAddLinkKey_3
   3690              {
   3691                entry->ami = ami;
   \   000036   2F41         MOV.W   @SP, R15
   \   000038   9F4102000000 MOV.W   0x2(SP), 0(R15)
   3692              }
   3693              else
   3694              {
   3695                /* Security Manager full */
   3696                return ZBufferFull;
   3697              }
   3698            }
   3699            // Write the link key
   3700            APSME_LinkKeySet( extAddr, key );
   \                     ??ZDSecMgrAddLinkKey_2:
   \   00003E   0D4B         MOV.W   R11, R13
   \   000040   0C4A         MOV.W   R10, R12
   \   000042   ........     CALLA   #APSME_LinkKeySet
   3701          
   3702          #if defined (TC_LINKKEY_JOIN)
   3703            // Mark the device as authenticated.
   3704            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3705          #endif
   3706          
   3707          #if defined NV_RESTORE
   3708            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   3709          #endif
   3710          
   3711            return ZSuccess;
   \   000046   4C43         MOV.B   #0x0, R12
   \                     ??ZDSecMgrAddLinkKey_0:
   \   000048   ........     BRA     #?Subroutine9
   \                     ??ZDSecMgrAddLinkKey_3:
   \   00004C   7C401100     MOV.B   #0x11, R12
   \   000050   FB3F         JMP     ??ZDSecMgrAddLinkKey_0
   3712          }
   3713          
   3714          #if defined ( NV_RESTORE )
   3715          /******************************************************************************
   3716           * @fn          ZDSecMgrInitNV
   3717           *
   3718           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   3719           *
   3720           * @param       none
   3721           *
   3722           * @return      uint8 - <osal_nv_item_init> return codes
   3723           */
   3724          uint8 ZDSecMgrInitNV(void)
   3725          {
   3726          
   3727            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE,
   3728                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   3729          
   3730            // If the item does not already exist, set all values to 0
   3731            if (rtrn != SUCCESS)
   3732            {
   3733              nvDeviceListHdr_t hdr;
   3734              hdr.numRecs = 0;
   3735              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   3736            }
   3737          
   3738            return rtrn;
   3739          }
   3740          #endif // NV_RESTORE
   3741          
   3742          #if defined ( NV_RESTORE )
   3743          /*********************************************************************
   3744           * @fn      ZDSecMgrWriteNV()
   3745           *
   3746           * @brief   Save off the APS link key list to NV
   3747           *
   3748           * @param   none
   3749           *
   3750           * @return  none
   3751           */
   3752          static void ZDSecMgrWriteNV( void )
   3753          {
   3754            uint16 i;
   3755            nvDeviceListHdr_t hdr;
   3756          
   3757            hdr.numRecs = 0;
   3758          
   3759            if (ZDSecMgrEntries != NULL)
   3760            {
   3761              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   3762              {
   3763                // Save off the record
   3764                osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3765                              (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   3766                              sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   3767          
   3768                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   3769                {
   3770                  hdr.numRecs++;
   3771                }
   3772              }
   3773            }
   3774          
   3775            // Save off the header
   3776            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3777          }
   3778          #endif // NV_RESTORE
   3779          
   3780          #if defined ( NV_RESTORE )
   3781          /******************************************************************************
   3782           * @fn          ZDSecMgrRestoreFromNV
   3783           *
   3784           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   3785           *              the key data itself as they remain in NV until they are used.
   3786           *              Only list data is restored.
   3787           *
   3788           * @param       none
   3789           *
   3790           * @return      None.
   3791           */
   3792          static void ZDSecMgrRestoreFromNV( void )
   3793          {
   3794            nvDeviceListHdr_t hdr;
   3795            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3796          
   3797            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   3798                ((hdr.numRecs > 0) && (hdr.numRecs <= ZDSECMGR_ENTRY_MAX)))
   3799            {
   3800              uint8 x;
   3801          
   3802              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   3803          
   3804              for (x = 0; x < ZDSECMGR_ENTRY_MAX; x++)
   3805              {
   3806                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3807                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3808                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   3809                {
   3810                  // update data only for valid entries
   3811                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   3812                  {
   3813                    if (pApsLinkKey != NULL)
   3814                    {
   3815                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   3816                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0,
   3817                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3818          
   3819                      // set new values for the counter
   3820                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3821          
   3822                      // restore values for counters in RAM
   3823                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr =
   3824                                                      pApsLinkKey->txFrmCntr;
   3825          
   3826                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr =
   3827                                                      pApsLinkKey->rxFrmCntr;
   3828          
   3829                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0,
   3830                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   3831          
   3832                      // clear copy of key in RAM
   3833                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   3834                    }
   3835                  }
   3836                }
   3837              }
   3838          
   3839              if (pApsLinkKey != NULL)
   3840              {
   3841                osal_mem_free(pApsLinkKey);
   3842              }
   3843            }
   3844          }
   3845          #endif // NV_RESTORE
   3846          
   3847          /*********************************************************************
   3848           * @fn          ZDSecMgrSetDefaultNV
   3849           *
   3850           * @brief       Write the defaults to NV for Entry table and for APS key data table
   3851           *
   3852           * @param       none
   3853           *
   3854           * @return      none
   3855           */

   \                                 In  segment CODE, align 2, keep-with-next
   3856          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   3857          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   3182         SUB.W   #0x8, SP
   3858            uint16 i;
   3859            nvDeviceListHdr_t hdr;
   3860            ZDSecMgrEntry_t secMgrEntry;
   3861            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   3862          
   3863            // Initialize the header
   3864            hdr.numRecs = 0;
   \   000004   81430000     MOV.W   #0x0, 0(SP)
   3865          
   3866            // clear the header
   3867            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \   000008   0F41         MOV.W   SP, R15
   \   00000A   0F53         ADD.W   #0x0, R15
   \   00000C   2E43         MOV.W   #0x2, R14
   \   00000E   0D43         MOV.W   #0x0, R13
   \   000010   3C404C00     MOV.W   #0x4c, R12
   \   000014   ........     CALLA   #osal_nv_write
   3868          
   3869            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   \   000018   3E400600     MOV.W   #0x6, R14
   \   00001C   ........     CALLA   #?Subroutine26
   3870          
   3871            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \                     ??CrossCallReturnLabel_13:
   \   000020   0A43         MOV.W   #0x0, R10
   3872            {
   3873              // Clear the record
   3874              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3875                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   3876                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   \                     ??ZDSecMgrSetDefaultNV_0:
   \   000022   0F41         MOV.W   SP, R15
   \   000024   2F53         ADD.W   #0x2, R15
   \   000026   3E400600     MOV.W   #0x6, R14
   \   00002A   2D43         MOV.W   #0x2, R13
   \   00002C                RPT     #0x6
   \   00002C   45180D5A     ADDX.W  R10, R13
   \   000030   3C404C00     MOV.W   #0x4c, R12
   \   000034   ........     CALLA   #osal_nv_write
   3877            }
   \   000038   1A53         ADD.W   #0x1, R10
   \   00003A   3A900300     CMP.W   #0x3, R10
   \   00003E   F12B         JNC     ??ZDSecMgrSetDefaultNV_0
   3878          
   3879            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000040   ........     CALLA   #?Subroutine15
   \                     ??CrossCallReturnLabel_3:
   \   000044   0B4C         MOV.W   R12, R11
   3880          
   3881            if (pApsLinkKey != NULL)
   \   000046   0C93         CMP.W   #0x0, R12
   \   000048   1124         JEQ     ??ZDSecMgrSetDefaultNV_2
   3882            {
   3883              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00004A   ........     CALLA   #?Subroutine27
   3884          
   3885              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \                     ??CrossCallReturnLabel_15:
   \   00004E   0A43         MOV.W   #0x0, R10
   3886              {
   3887                // Clear the record
   3888                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3889                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \                     ??ZDSecMgrSetDefaultNV_1:
   \   000050   ........     CALLA   #?Subroutine28
   3890              }
   \                     ??CrossCallReturnLabel_61:
   \   000054   0C4A         MOV.W   R10, R12
   \   000056   3C500102     ADD.W   #0x201, R12
   \   00005A   ........     CALLA   #osal_nv_write
   \   00005E   1A53         ADD.W   #0x1, R10
   \   000060   3A900300     CMP.W   #0x3, R10
   \   000064   F52B         JNC     ??ZDSecMgrSetDefaultNV_1
   3891          
   3892              osal_mem_free(pApsLinkKey);
   \   000066   0C4B         MOV.W   R11, R12
   \   000068   ........     CALLA   #osal_mem_free
   3893            }
   3894          }
   \                     ??ZDSecMgrSetDefaultNV_2:
   \   00006C                REQUIRE ?Subroutine8
   \   00006C                // Fall through to label ?Subroutine8
   3895          
   3896          #if defined ( NV_RESTORE )
   3897          /*********************************************************************
   3898           * @fn      ZDSecMgrUpdateNV()
   3899           *
   3900           * @brief   Updates one entry of the APS link key table to NV
   3901           *
   3902           * @param   index - to the entry in security manager table
   3903           *
   3904           * @return  none
   3905           */
   3906          static void ZDSecMgrUpdateNV( uint16 index )
   3907          {
   3908            nvDeviceListHdr_t hdr;
   3909          
   3910            if (ZDSecMgrEntries != NULL)
   3911            {
   3912              // Save off the record
   3913              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3914                             (uint16)((sizeof(nvDeviceListHdr_t)) + (index * sizeof(ZDSecMgrEntry_t))),
   3915                             sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[index] );
   3916            }
   3917          
   3918            if (osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS)
   3919            {
   3920              if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   3921              {
   3922                if (hdr.numRecs > 0)
   3923                {
   3924                  hdr.numRecs--;
   3925                }
   3926              }
   3927              else
   3928              {
   3929                hdr.numRecs++;
   3930              }
   3931          
   3932              // Save off the header
   3933              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   3934            }
   3935          }
   3936          #endif // NV_RESTORE
   3937          
   3938          /******************************************************************************
   3939           * @fn          ZDSecMgrAPSRemove
   3940           *
   3941           * @brief       Remove device from network.
   3942           *
   3943           * @param       nwkAddr - device's NWK address
   3944           * @param       extAddr - device's Extended address
   3945           * @param       parentAddr - parent's NWK address
   3946           *
   3947           * @return      ZStatus_t
   3948           */

   \                                 In  segment CODE, align 2, keep-with-next
   3949          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3950          {
   \   000000   31800A00     SUB.W   #0xa, SP
   3951            ZDSecMgrDevice_t device;
   3952          
   3953            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3954                 ( extAddr == NULL )              ||
   3955                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   000004   3C90FEFF     CMP.W   #0xfffe, R12
   \   000008   0524         JEQ     ??ZDSecMgrAPSRemove_0
   \   00000A   0D93         CMP.W   #0x0, R13
   \   00000C   0324         JEQ     ??ZDSecMgrAPSRemove_0
   \   00000E   3E90FEFF     CMP.W   #0xfffe, R14
   \   000012   0220         JNE     ??ZDSecMgrAPSRemove_1
   3956            {
   3957              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_0:
   \   000014   5C43         MOV.B   #0x1, R12
   \   000016   0B3C         JMP     ??ZDSecMgrAPSRemove_2
   3958            }
   3959          
   3960            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_1:
   \   000018   814C0000     MOV.W   R12, 0(SP)
   3961            device.extAddr = extAddr;
   \   00001C   814D0200     MOV.W   R13, 0x2(SP)
   3962            device.parentAddr = parentAddr;
   \   000020   814E0400     MOV.W   R14, 0x4(SP)
   3963          
   3964            // remove device
   3965            ZDSecMgrDeviceRemove( &device );
   \   000024   0C41         MOV.W   SP, R12
   \   000026   0C53         ADD.W   #0x0, R12
   \   000028   ........     CALLA   #ZDSecMgrDeviceRemove
   3966          
   3967            return ( ZSuccess );
   \   00002C   4C43         MOV.B   #0x0, R12
   \                     ??ZDSecMgrAPSRemove_2:
   \   00002E                REQUIRE ?Subroutine13
   \   00002E                // Fall through to label ?Subroutine13
   3968          }
   3969          
   3970          /******************************************************************************
   3971           * @fn          APSME_TCLinkKeyInit
   3972           *
   3973           * @brief       Initialize the NV table for preconfigured TC link key
   3974           *
   3975           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   3976           *              Trust Center Link Key is written to NV. A single tclk is used
   3977           *              by all devices joining the network.
   3978           *
   3979           * @param       setDefault - TRUE to set default values
   3980           *
   3981           * @return      none
   3982           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine18:
   \   000000   3E402000     MOV.W   #0x20, R14
   \   000004   ........     BRA     #?Subroutine41

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine17:
   \   000000   0F4A         MOV.W   R10, R15
   \   000002                REQUIRE ??Subroutine17_0
   \   000002                // Fall through to label ??Subroutine17_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine17_0:
   \   000000   3E402000     MOV.W   #0x20, R14
   \   000004   0D43         MOV.W   #0x0, R13
   \   000006   3C400101     MOV.W   #0x101, R12
   \   00000A   ........     BRA     #osal_nv_read

   \                                 In  segment CODE, align 2, keep-with-next
   3983          void APSME_TCLinkKeyInit(uint8 setDefault)
   \                     APSME_TCLinkKeyInit:
   3984          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31802000     SUB.W   #0x20, SP
   3985            uint8             i;
   3986            APSME_TCLinkKey_t tcLinkKey;
   3987            uint8             rtrn;
   3988          
   3989            // Initialize all NV items for preconfigured TCLK
   3990            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   000006   0A41         MOV.W   SP, R10
   \   000008   0A53         ADD.W   #0x0, R10
   3991            {
   3992              // Making sure data is cleared for every key all the time
   3993              osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   00000A   ........     CALLA   #?Subroutine18
   3994          
   3995              // Initialize first element of the table with the default TCLK
   3996              if((i == 0) && ( zgUseDefaultTCLK == TRUE ))
   \                     ??CrossCallReturnLabel_6:
   \   00000E   D293....     CMP.B   #0x1, &zgUseDefaultTCLK
   \   000012   0C20         JNE     ??APSME_TCLinkKeyInit_0
   3997              {
   3998                osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   000014   3E42         MOV.W   #0x8, R14
   \   000016   7D43         MOV.B   #0xff, R13
   \   000018   ........     CALLA   #??Subroutine46_0
   3999                osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \                     ??CrossCallReturnLabel_67:
   \   00001C   3E401000     MOV.W   #0x10, R14
   \   000020   3D40....     MOV.W   #defaultTCLinkKey, R13
   \   000024   0C4A         MOV.W   R10, R12
   \   000026   3C52         ADD.W   #0x8, R12
   \   000028   ........     CALLA   #osal_memcpy
   4000              }
   4001          
   4002              // If the item doesn't exist in NV memory, create and initialize
   4003              // it with the default value passed in, either defaultTCLK or 0
   4004              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i),
   4005                                         sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   4006          
   4007              if (rtrn == SUCCESS)
   \                     ??APSME_TCLinkKeyInit_0:
   \   00002C   0E4A         MOV.W   R10, R14
   \   00002E   3D402000     MOV.W   #0x20, R13
   \   000032   3C400101     MOV.W   #0x101, R12
   \   000036   ........     CALLA   #??Subroutine29_0
   \                     ??CrossCallReturnLabel_54:
   \   00003A   1820         JNE     ??APSME_TCLinkKeyInit_1
   4008              {
   4009                // set the Frame counters to 0 to existing keys in NV
   4010                osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   4011                               sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00003C   ........     CALLA   #?Subroutine17
   4012          
   4013          #if defined ( NV_RESTORE )
   4014                if (setDefault == TRUE)
   4015                {
   4016                  // clear the value stored in NV
   4017                  tcLinkKey.txFrmCntr = 0;
   4018                }
   4019                else
   4020                {
   4021                  // increase the value stored in NV
   4022                  tcLinkKey.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   4023                }
   4024          #else
   4025                // Clear the counters if NV_RESTORE is not enabled and this NV item
   4026                // already existed in the NV memory
   4027                tcLinkKey.txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_65:
   \   000040   81431800     MOV.W   #0x0, 0x18(SP)
   \   000044   81431A00     MOV.W   #0x0, 0x1a(SP)
   4028                tcLinkKey.rxFrmCntr = 0;
   \   000048   81431C00     MOV.W   #0x0, 0x1c(SP)
   \   00004C   81431E00     MOV.W   #0x0, 0x1e(SP)
   4029          #endif  // NV_RESTORE
   4030          
   4031                osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   4032                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000050   ........     CALLA   #?Subroutine19
   4033          
   4034                // set initial values for counters in RAM
   4035                TCLinkKeyFrmCntr[i].txFrmCntr = tcLinkKey.txFrmCntr;
   \                     ??CrossCallReturnLabel_8:
   \   000054   92411800.... MOV.W   0x18(SP), &TCLinkKeyFrmCntr
   \   00005A   92411A00.... MOV.W   0x1a(SP), &TCLinkKeyFrmCntr + 2
   4036                TCLinkKeyFrmCntr[i].rxFrmCntr = tcLinkKey.rxFrmCntr;
   \   000060   92411C00.... MOV.W   0x1c(SP), &TCLinkKeyFrmCntr + 4
   \   000066   92411E00.... MOV.W   0x1e(SP), &TCLinkKeyFrmCntr + 6
   4037              }
   4038            }
   4039          
   4040            // clear copy of key in RAM
   4041            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyInit_1:
   \   00006C   ........     CALLA   #?Subroutine18
   4042          
   4043          }
   \                     ??CrossCallReturnLabel_7:
   \   000070   31502000     ADD.W   #0x20, SP
   \   000074   3A41         POP.W   R10
   \   000076   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine19:
   \   000000   0F4A         MOV.W   R10, R15
   \   000002   3E402000     MOV.W   #0x20, R14
   \   000006   0D43         MOV.W   #0x0, R13
   \   000008   3C400101     MOV.W   #0x101, R12
   \   00000C   ........     BRA     #osal_nv_write
   4044          
   4045          /******************************************************************************
   4046           * @fn          APSME_TCLinkKeySync
   4047           *
   4048           * @brief       Sync Trust Center LINK key data.
   4049           *
   4050           * @param       srcAddr - [in] srcAddr
   4051           * @param       si      - [in, out] SSP_Info_t
   4052           *
   4053           * @return      ZStatus_t
   4054           */

   \                                 In  segment CODE, align 2, keep-with-next
   4055          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   4056          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31802000     SUB.W   #0x20, SP
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0B4D         MOV.W   R13, R11
   4057            uint8 i;
   4058            ZStatus_t status = ZSecNoKey;
   \   00000A   7840A100     MOV.B   #0xa1, R8
   4059            APSME_TCLinkKey_t tcLinkKey;
   4060            uint32 *tclkRxFrmCntr;
   4061          
   4062            // Look up the IEEE address of the trust center if it's available
   4063            if ( AddrMgrExtAddrValid( si->extAddr ) == FALSE )
   \   00000E   0C4D         MOV.W   R13, R12
   \   000010   3C500600     ADD.W   #0x6, R12
   \   000014   ........     CALLA   #AddrMgrExtAddrValid
   \   000018   4C93         CMP.B   #0x0, R12
   \   00001A   0620         JNE     ??APSME_TCLinkKeySync_0
   4064            {
   4065              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   00001C   0D4B         MOV.W   R11, R13
   \   00001E   3D500600     ADD.W   #0x6, R13
   \   000022   0C4A         MOV.W   R10, R12
   \   000024   ........     CALLA   #APSME_LookupExtAddr
   4066            }
   4067          
   4068            // Look up the TC link key associated with the device
   4069            // or the default TC link key (extAddr is all FFs), whichever is found
   4070            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \                     ??APSME_TCLinkKeySync_0:
   \   000028   0A41         MOV.W   SP, R10
   \   00002A   0A53         ADD.W   #0x0, R10
   4071            {
   4072              // Read entry i of the TC link key table from NV
   4073              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   4074                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00002C   ........     CALLA   #?Subroutine17
   4075          
   4076              if( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) ||
   4077                  APSME_IsDefaultTCLK(tcLinkKey.extAddr))
   \                     ??CrossCallReturnLabel_66:
   \   000030   0D4A         MOV.W   R10, R13
   \   000032   0C4B         MOV.W   R11, R12
   \   000034   3C500600     ADD.W   #0x6, R12
   \   000038   ........     CALLA   #AddrMgrExtAddrEqual
   \   00003C   4C93         CMP.B   #0x0, R12
   \   00003E   0520         JNE     ??APSME_TCLinkKeySync_1
   \   000040   0C4A         MOV.W   R10, R12
   \   000042   ........     CALLA   #APSME_IsDefaultTCLK
   \   000046   4C93         CMP.B   #0x0, R12
   \   000048   1824         JEQ     ??APSME_TCLinkKeySync_2
   4078              {
   4079                tclkRxFrmCntr = &TCLinkKeyFrmCntr[i].rxFrmCntr;
   4080          
   4081                // verify that the incoming frame counter is valid
   4082                if ( si->frmCntr >= *tclkRxFrmCntr )
   \                     ??APSME_TCLinkKeySync_1:
   \   00004A   1E4B1400     MOV.W   0x14(R11), R14
   \   00004E   1F4B1600     MOV.W   0x16(R11), R15
   \   000052   1F92....     CMP.W   &TCLinkKeyFrmCntr + 6, R15
   \   000056   0F28         JNC     ??APSME_TCLinkKeySync_3
   \   000058   0320         JNE     ??APSME_TCLinkKeySync_4
   \   00005A   1E92....     CMP.W   &TCLinkKeyFrmCntr + 4, R14
   \   00005E   0B28         JNC     ??APSME_TCLinkKeySync_3
   4083                {
   4084                  // set the keyNvId to use
   4085                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \                     ??APSME_TCLinkKeySync_4:
   \   000060   BB4001011000 MOV.W   #0x101, 0x10(R11)
   4086          
   4087                  // update the rx frame counter
   4088                  *tclkRxFrmCntr = si->frmCntr + 1;
   \   000066   1E53         ADD.W   #0x1, R14
   \   000068   0F63         ADDC.W  #0x0, R15
   \   00006A   824E....     MOV.W   R14, &TCLinkKeyFrmCntr + 4
   \   00006E   824F....     MOV.W   R15, &TCLinkKeyFrmCntr + 6
   4089          
   4090                  status = ZSuccess;
   \   000072   4843         MOV.B   #0x0, R8
   \   000074   023C         JMP     ??APSME_TCLinkKeySync_2
   4091                }
   4092                else
   4093                {
   4094                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_3:
   \   000076   7840A200     MOV.B   #0xa2, R8
   4095                }
   4096                // break from the loop
   4097                break;
   4098              }
   4099            }
   4100          
   4101            // clear copy of key in RAM
   4102            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeySync_2:
   \   00007A   ........     CALLA   #?Subroutine18
   4103          
   4104            return status;
   \                     ??CrossCallReturnLabel_5:
   \   00007E   4C48         MOV.B   R8, R12
   \   000080   31502000     ADD.W   #0x20, SP
   \   000084   3817         POPM.W  #0x4, R11
   \   000086   1001         RETA
   4105          }
   4106          
   4107          /******************************************************************************
   4108           * @fn          APSME_TCLinkKeyLoad
   4109           *
   4110           * @brief       Load Trust Center LINK key data.
   4111           *
   4112           * @param       dstAddr - [in] dstAddr
   4113           * @param       si      - [in, out] SSP_Info_t
   4114           *
   4115           * @return      ZStatus_t
   4116           */

   \                                 In  segment CODE, align 2, keep-with-next
   4117          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   4118          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31802E00     SUB.W   #0x2e, SP
   \   000006   0A4D         MOV.W   R13, R10
   4119            uint8 i;
   4120            ZStatus_t status = ZSecNoKey;
   \   000008   7B40A100     MOV.B   #0xa1, R11
   4121            APSME_TCLinkKey_t tcLinkKey;
   4122            AddrMgrEntry_t addrEntry;
   4123            uint32 *tclkTxFrmCntr;
   4124            uint8 extAddrFound;
   4125            uint8 defaultTCLKIdx = ZDSECMGR_TC_DEVICE_MAX;
   4126          
   4127            // Look up the ami of the srcAddr if available
   4128            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   00000C   C1430000     MOV.B   #0x0, 0(SP)
   4129            addrEntry.nwkAddr = dstAddr;
   \   000010   814C0200     MOV.W   R12, 0x2(SP)
   4130          
   4131            APSME_LookupExtAddr( dstAddr, si->extAddr );
   \   000014   3D500600     ADD.W   #0x6, R13
   \   000018   ........     CALLA   #APSME_LookupExtAddr
   4132          
   4133            extAddrFound = AddrMgrExtAddrValid( si->extAddr );
   \   00001C   0C4A         MOV.W   R10, R12
   \   00001E   3C500600     ADD.W   #0x6, R12
   \   000022   ........     CALLA   #AddrMgrExtAddrValid
   \   000026   484C         MOV.B   R12, R8
   4134          
   4135            // Look up the TC link key associated with the device
   4136            // or the master TC link key (ami = 0xFFFF), whichever is found
   4137            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   000028   0941         MOV.W   SP, R9
   \   00002A   39500E00     ADD.W   #0xe, R9
   4138            {
   4139              // Read entry i of the TC link key table from NV
   4140              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   4141                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00002E   0F49         MOV.W   R9, R15
   \   000030   ........     CALLA   #??Subroutine17_0
   4142          
   4143              if( extAddrFound && AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) )
   \                     ??CrossCallReturnLabel_63:
   \   000034   4893         CMP.B   #0x0, R8
   \   000036   0824         JEQ     ??APSME_TCLinkKeyLoad_1
   \   000038   0D49         MOV.W   R9, R13
   \   00003A   0C4A         MOV.W   R10, R12
   \   00003C   3C500600     ADD.W   #0x6, R12
   \   000040   ........     CALLA   #AddrMgrExtAddrEqual
   \   000044   4C93         CMP.B   #0x0, R12
   \   000046   0520         JNE     ??APSME_TCLinkKeyLoad_0
   4144              {
   4145                status = ZSuccess;
   4146          
   4147                break; // break from the loop
   4148              }
   4149          
   4150              if ( APSME_IsDefaultTCLK(tcLinkKey.extAddr) )
   \                     ??APSME_TCLinkKeyLoad_1:
   \   000048   0C49         MOV.W   R9, R12
   \   00004A   ........     CALLA   #APSME_IsDefaultTCLK
   \   00004E   4C93         CMP.B   #0x0, R12
   \   000050   1124         JEQ     ??APSME_TCLinkKeyLoad_2
   4151              {
   4152                if ( !extAddrFound )
   4153                {
   4154                  status = ZSuccess;
   \                     ??APSME_TCLinkKeyLoad_0:
   \   000052   4B43         MOV.B   #0x0, R11
   4155          
   4156                  break; // break from the loop
   4157                }
   4158          
   4159                // Remember the default TCLK index
   4160                defaultTCLKIdx = i;
   4161              }
   4162            }
   4163          
   4164            if ( (status != ZSuccess) && (defaultTCLKIdx < ZDSECMGR_TC_DEVICE_MAX) )
   4165            {
   4166              // Exact match was not found; use the default TC Link Key
   4167              i = defaultTCLKIdx;
   4168              status = ZSuccess;
   4169            }
   4170          
   4171            if ( status == ZSuccess )
   4172            {
   4173              tclkTxFrmCntr = &TCLinkKeyFrmCntr[i].txFrmCntr;
   4174          
   4175              // set the keyNvId to use
   4176              si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   000054   BA4001011000 MOV.W   #0x101, 0x10(R10)
   4177          
   4178              // update link key related fields
   4179              si->keyID   = SEC_KEYID_LINK;
   \   00005A   CA430E00     MOV.B   #0x0, 0xe(R10)
   4180              si->frmCntr = *tclkTxFrmCntr;
   \   00005E   9A42....1400 MOV.W   &TCLinkKeyFrmCntr, 0x14(R10)
   \   000064   9A42....1600 MOV.W   &TCLinkKeyFrmCntr + 2, 0x16(R10)
   4181          
   4182              // update outgoing frame counter
   4183              (*tclkTxFrmCntr)++;
   \   00006A   9253....     ADD.W   #0x1, &TCLinkKeyFrmCntr
   \   00006E   8263....     ADDC.W  #0x0, &TCLinkKeyFrmCntr + 2
   \   000072   0A3C         JMP     ??APSME_TCLinkKeyLoad_3
   4184          
   4185          #if defined ( NV_RESTORE )
   4186              // write periodically to NV
   4187              if ( !(*tclkTxFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   4188              {
   4189                // set the flag to write key to NV
   4190                TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   4191          
   4192                // Notify the ZDApp that the frame counter has changed.
   4193                osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   4194              }
   4195          #endif
   4196            }
   \                     ??APSME_TCLinkKeyLoad_2:
   \   000074   0C41         MOV.W   SP, R12
   \   000076   0C53         ADD.W   #0x0, R12
   \   000078   ........     CALLA   #AddrMgrEntryLookupNwk
   \   00007C   5C93         CMP.B   #0x1, R12
   \   00007E   0420         JNE     ??APSME_TCLinkKeyLoad_3
   4197          
   4198            // If no TC link key found, remove the device from the address manager
   4199            if ( (status != ZSuccess) && (AddrMgrEntryLookupNwk(&addrEntry) == TRUE) )
   4200            {
   4201              AddrMgrEntryRelease( &addrEntry );
   \   000080   0C41         MOV.W   SP, R12
   \   000082   0C53         ADD.W   #0x0, R12
   \   000084   ........     CALLA   #AddrMgrEntryRelease
   4202            }
   4203          
   4204              // clear copy of key in RAM
   4205            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyLoad_3:
   \   000088   3E402000     MOV.W   #0x20, R14
   \   00008C   ........     CALLA   #??Subroutine49_0
   4206          
   4207            return status;
   \                     ??CrossCallReturnLabel_75:
   \   000090   4C4B         MOV.B   R11, R12
   \   000092   31502E00     ADD.W   #0x2e, SP
   \   000096   3817         POPM.W  #0x4, R11
   \   000098   1001         RETA
   4208          }
   4209          
   4210          /******************************************************************************
   4211           * @fn          APSME_IsDefaultTCLK
   4212           *
   4213           * @brief       Return TRUE or FALSE based on the extended address.  If the
   4214           *              input ext address is all FFs, it means the trust center link
   4215           *              assoiciated with the address is the default trust center link key
   4216           *
   4217           * @param       extAddr - [in] extended address
   4218           *
   4219           * @return      uint8 TRUE/FALSE
   4220           */

   \                                 In  segment CODE, align 2, keep-with-next
   4221          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   4222          {
   4223            uint8 i = 0;
   \   000000   4F43         MOV.B   #0x0, R15
   4224          
   4225            if( extAddr == NULL )
   \   000002   0C93         CMP.W   #0x0, R12
   \   000004   0724         JEQ     ??APSME_IsDefaultTCLK_1
   4226            {
   4227              return FALSE;
   4228            }
   4229          
   4230            while( i++ < Z_EXTADDR_LEN )
   \                     ??APSME_IsDefaultTCLK_0:
   \   000006   4E4F         MOV.B   R15, R14
   \   000008   5F53         ADD.B   #0x1, R15
   \   00000A   7E92         CMP.B   #0x8, R14
   \   00000C   052C         JC      ??APSME_IsDefaultTCLK_2
   4231            {
   4232              if( *extAddr++ != 0xFF )
   \   00000E   7E4C         MOV.B   @R12+, R14
   \   000010   7E93         CMP.B   #0xff, R14
   \   000012   F927         JEQ     ??APSME_IsDefaultTCLK_0
   4233              {
   4234                return FALSE;
   \                     ??APSME_IsDefaultTCLK_1:
   \   000014   4C43         MOV.B   #0x0, R12
   \   000016   1001         RETA
   4235              }
   4236            }
   4237          
   4238            return TRUE;
   \                     ??APSME_IsDefaultTCLK_2:
   \   000018   5C43         MOV.B   #0x1, R12
   \   00001A   1001         RETA
   4239          }
   4240          
   4241          /******************************************************************************
   4242           * @fn          ZDSecMgrNwkKeyInit
   4243           *
   4244           * @brief       Initialize the NV items for
   4245           *                  ZCD_NV_NWKKEY,
   4246           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and
   4247           *                  ZCD_NV_NWK_ALTERN_KEY_INFO
   4248           *
   4249           * @param       setDefault
   4250           *
   4251           * @return      none
   4252           */

   \                                 In  segment CODE, align 2, keep-with-next
   4253          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   \                     ZDSecMgrNwkKeyInit:
   4254          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31802800     SUB.W   #0x28, SP
   4255            uint8 status;
   4256            nwkKeyDesc nwkKey;
   4257          
   4258            // Initialize NV items for NWK key, this structure contains the frame counter
   4259            // and is only used when NV_RESTORE is enabled
   4260            nwkActiveKeyItems keyItems;
   4261          
   4262            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \   000006   0A41         MOV.W   SP, R10
   \   000008   0A53         ADD.W   #0x0, R10
   \   00000A   3E401600     MOV.W   #0x16, R14
   \   00000E   ........     CALLA   #?Subroutine41
   4263          
   4264            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   4265          
   4266          #if defined ( NV_RESTORE )
   4267            // reset the values of NV items if NV_RESTORE is not enabled
   4268            if ((status == SUCCESS) && (setDefault == TRUE))
   4269            {
   4270              // clear NV data to default values
   4271              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   4272            }
   4273          #else
   4274            (void)setDefault;   // to eliminate compiler warning
   4275          
   4276            // reset the values of NV items if NV_RESTORE is not enabled
   4277            if (status == SUCCESS)
   \                     ??CrossCallReturnLabel_69:
   \   000012   0E4A         MOV.W   R10, R14
   \   000014   3D401600     MOV.W   #0x16, R13
   \   000018   3C408200     MOV.W   #0x82, R12
   \   00001C   ........     CALLA   #??Subroutine29_0
   \                     ??CrossCallReturnLabel_51:
   \   000020   0820         JNE     ??ZDSecMgrNwkKeyInit_0
   4278            {
   4279              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   \   000022   0F4A         MOV.W   R10, R15
   \   000024   3E401600     MOV.W   #0x16, R14
   \   000028   0D43         MOV.W   #0x0, R13
   \   00002A   3C408200     MOV.W   #0x82, R12
   \   00002E   ........     CALLA   #osal_nv_write
   4280            }
   4281          #endif // defined (NV_RESTORE)
   4282          
   4283            // Initialize NV items for NWK Active and Alternate keys. These items are used
   4284            // all the time, independently of NV_RESTORE being set or not
   4285            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   \                     ??ZDSecMgrNwkKeyInit_0:
   \   000032   3A501600     ADD.W   #0x16, R10
   \   000036   3E401100     MOV.W   #0x11, R14
   \   00003A   ........     CALLA   #?Subroutine41
   4286          
   4287            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   4288          
   4289          #if defined ( NV_RESTORE )
   4290            // reset the values of NV items if NV_RESTORE is not enabled
   4291            if ((status == SUCCESS) && (setDefault == TRUE))
   4292            {
   4293              // clear NV data to default values
   4294              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4295            }
   4296          #else
   4297            // reset the values of NV items if NV_RESTORE is not enabled
   4298            if (status == SUCCESS)
   \                     ??CrossCallReturnLabel_70:
   \   00003E   3B401100     MOV.W   #0x11, R11
   \   000042   0E4A         MOV.W   R10, R14
   \   000044   0D4B         MOV.W   R11, R13
   \   000046   3C403A00     MOV.W   #0x3a, R12
   \   00004A   ........     CALLA   #??Subroutine29_0
   \                     ??CrossCallReturnLabel_52:
   \   00004E   0720         JNE     ??ZDSecMgrNwkKeyInit_1
   4299            {
   4300              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   000050   0F4A         MOV.W   R10, R15
   \   000052   0E4B         MOV.W   R11, R14
   \   000054   0D43         MOV.W   #0x0, R13
   \   000056   3C403A00     MOV.W   #0x3a, R12
   \   00005A   ........     CALLA   #osal_nv_write
   4301            }
   4302          #endif // defined (NV_RESTORE)
   4303          
   4304            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   4305          
   4306          #if defined ( NV_RESTORE )
   4307            // reset the values of NV items if NV_RESTORE is not enabled
   4308            if ((status == SUCCESS) && (setDefault == TRUE))
   4309            {
   4310              // clear NV data to default values
   4311              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   4312            }
   4313          #else
   4314            // reset the values of NV items if NV_RESTORE is not enabled
   4315            if (status == SUCCESS)
   \                     ??ZDSecMgrNwkKeyInit_1:
   \   00005E   0E4A         MOV.W   R10, R14
   \   000060   0D4B         MOV.W   R11, R13
   \   000062   3C403B00     MOV.W   #0x3b, R12
   \   000066   ........     CALLA   #??Subroutine29_0
   \                     ??CrossCallReturnLabel_53:
   \   00006A   0720         JNE     ??ZDSecMgrNwkKeyInit_2
   4316            {
   4317              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   00006C   0F4A         MOV.W   R10, R15
   \   00006E   0E4B         MOV.W   R11, R14
   \   000070   0D43         MOV.W   #0x0, R13
   \   000072   3C403B00     MOV.W   #0x3b, R12
   \   000076   ........     CALLA   #osal_nv_write
   4318            }
   4319          #endif // defined (NV_RESTORE)
   4320          
   4321          }
   \                     ??ZDSecMgrNwkKeyInit_2:
   \   00007A   31502800     ADD.W   #0x28, SP
   \   00007E   1A17         POPM.W  #0x2, R11
   \   000080   1001         RETA
   4322          
   4323          /*********************************************************************
   4324           * @fn          ZDSecMgrReadKeyFromNv
   4325           *
   4326           * @brief       Looks for a specific key in NV based on Index value
   4327           *
   4328           * @param   keyNvId - Index of key to look in NV
   4329           *                    valid values are:
   4330           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO
   4331           *                    ZCD_NV_NWK_ALTERN_KEY_INFO
   4332           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4333           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4334           *                    ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4335           *                    ZCD_NV_PRECFGKEY
   4336           *
   4337           * @param  *keyinfo - Data is read into this buffer.
   4338           *
   4339           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   4340           *          Otherwise, NV_OPER_FAILED for failure.
   4341           */

   \                                 In  segment CODE, align 2, keep-with-next
   4342          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   \                     ZDSecMgrReadKeyFromNv:
   4343          {
   4344            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   4345                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   \   000000   3E401000     MOV.W   #0x10, R14
   \   000004   3C903A00     CMP.W   #0x3a, R12
   \   000008   0324         JEQ     ??ZDSecMgrReadKeyFromNv_0
   \   00000A   3C903B00     CMP.W   #0x3b, R12
   \   00000E   0420         JNE     ??ZDSecMgrReadKeyFromNv_1
   4346            {
   4347              // get NWK active or alternate key from NV
   4348              return (osal_nv_read(keyNvId,
   4349                                   osal_offsetof(nwkKeyDesc, key),
   4350                                   SEC_KEY_LEN,
   4351                                   keyinfo));
   \                     ??ZDSecMgrReadKeyFromNv_0:
   \   000010   0F4D         MOV.W   R13, R15
   \   000012   1D43         MOV.W   #0x1, R13
   \   000014   ........     BRA     #osal_nv_read
   4352            }
   4353            else if ((keyNvId >= ZCD_NV_TCLK_TABLE_START) &&
   4354                     (keyNvId < (ZCD_NV_TCLK_TABLE_START + ZDSECMGR_TC_DEVICE_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_1:
   \   000018   0F4C         MOV.W   R12, R15
   \   00001A   3F50FFFE     ADD.W   #0xfeff, R15
   \   00001E   0420         JNE     ??ZDSecMgrReadKeyFromNv_2
   4355            {
   4356              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   4357              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   4358              return (osal_nv_read(keyNvId,
   4359                                   osal_offsetof(APSME_TCLinkKey_t, key),
   4360                                   SEC_KEY_LEN,
   4361                                   keyinfo));
   \   000020   0F4D         MOV.W   R13, R15
   \   000022   3D42         MOV.W   #0x8, R13
   \   000024   ........     BRA     #osal_nv_read
   4362            }
   4363            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   4364                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_2:
   \   000028   0F4C         MOV.W   R12, R15
   \   00002A   3F50FFFD     ADD.W   #0xfdff, R15
   \   00002E   3F900300     CMP.W   #0x3, R15
   \   000032   042C         JC      ??ZDSecMgrReadKeyFromNv_3
   4365            {
   4366              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   4367              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   4368              return (osal_nv_read(keyNvId,
   4369                                   osal_offsetof(APSME_LinkKeyData_t, key),
   4370                                   SEC_KEY_LEN,
   4371                                   keyinfo));
   \   000034   0F4D         MOV.W   R13, R15
   \   000036   0D43         MOV.W   #0x0, R13
   \   000038   ........     BRA     #osal_nv_read
   4372            }
   4373            else if ((keyNvId >= ZCD_NV_MASTER_KEY_DATA_START) &&
   4374                     (keyNvId < (ZCD_NV_MASTER_KEY_DATA_START + ZDSECMGR_MASTERKEY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_3:
   \   00003C   0F4C         MOV.W   R12, R15
   \   00003E   3F50FFFC     ADD.W   #0xfcff, R15
   \   000042   3F900300     CMP.W   #0x3, R15
   \   000046   042C         JC      ??ZDSecMgrReadKeyFromNv_4
   4375            {
   4376              // Read entry keyNvId of the MASTER key table from NV. keyNvId should be
   4377              // ZCD_NV_MASTER_KEY_DATA_START + <offset_in_table>
   4378              return (osal_nv_read(keyNvId,
   4379                                   osal_offsetof(ZDSecMgrMasterKeyData_t, key),
   4380                                   SEC_KEY_LEN,
   4381                                   keyinfo));
   \   000048   0F4D         MOV.W   R13, R15
   \   00004A   2D43         MOV.W   #0x2, R13
   \   00004C   ........     BRA     #osal_nv_read
   4382            }
   4383            else if (keyNvId == ZCD_NV_PRECFGKEY)
   \                     ??ZDSecMgrReadKeyFromNv_4:
   \   000050   3C906200     CMP.W   #0x62, R12
   \   000054   0620         JNE     ??ZDSecMgrReadKeyFromNv_5
   4384            {
   4385              // Read entry keyNvId of the Preconfig key from NV.
   4386              return (osal_nv_read(keyNvId,
   4387                                   0,
   4388                                   SEC_KEY_LEN,
   4389                                   keyinfo));
   \   000056   0F4D         MOV.W   R13, R15
   \   000058   0D43         MOV.W   #0x0, R13
   \   00005A   3C406200     MOV.W   #0x62, R12
   \   00005E   ........     BRA     #osal_nv_read
   4390            }
   4391          
   4392            return NV_OPER_FAILED;
   \                     ??ZDSecMgrReadKeyFromNv_5:
   \   000062   7C400A00     MOV.B   #0xa, R12
   \   000066   1001         RETA
   4393          }
   4394          
   4395          /******************************************************************************
   4396           * @fn          ZDSecMgrApsLinkKeyInit
   4397           *
   4398           * @brief       Initialize the NV table for Application link keys
   4399           *
   4400           * @param       none
   4401           *
   4402           * @return      none
   4403           */

   \                                 In  segment CODE, align 2, keep-with-next
   4404          void ZDSecMgrApsLinkKeyInit(void)
   \                     ZDSecMgrApsLinkKeyInit:
   4405          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801800     SUB.W   #0x18, SP
   4406            APSME_LinkKeyData_t pApsLinkKey;
   4407            uint8 i;
   4408            uint8 status;
   4409          
   4410            // Initialize all NV items for APS link key, if not exist already.
   4411            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000006   0B41         MOV.W   SP, R11
   \   000008   0B53         ADD.W   #0x0, R11
   \   00000A   3E401800     MOV.W   #0x18, R14
   \   00000E   ........     CALLA   #??Subroutine21_0
   4412          
   4413            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \                     ??CrossCallReturnLabel_73:
   \   000012   4A43         MOV.B   #0x0, R10
   4414            {
   4415              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i),
   4416                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   4417          
   4418          #if defined ( NV_RESTORE )
   4419              (void)status;   // to eliminate compiler warning
   4420          #else
   4421              // reset the values of NV items if NV_RESTORE is not enabled
   4422              if (status == SUCCESS)
   \                     ??ZDSecMgrApsLinkKeyInit_0:
   \   000014   484A         MOV.B   R10, R8
   \   000016   38500102     ADD.W   #0x201, R8
   \   00001A   0E4B         MOV.W   R11, R14
   \   00001C   3D401800     MOV.W   #0x18, R13
   \   000020   ........     CALLA   #?Subroutine29
   \                     ??CrossCallReturnLabel_49:
   \   000024   0520         JNE     ??ZDSecMgrApsLinkKeyInit_1
   4423              {
   4424                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   4425                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   000026   ........     CALLA   #?Subroutine28
   4426          
   4427              }
   4428          #endif // defined (NV_RESTORE)
   4429            }
   \                     ??CrossCallReturnLabel_60:
   \   00002A   0C48         MOV.W   R8, R12
   \   00002C   ........     CALLA   #osal_nv_write
   \                     ??ZDSecMgrApsLinkKeyInit_1:
   \   000030   5A53         ADD.B   #0x1, R10
   \   000032   7A900300     CMP.B   #0x3, R10
   \   000036   EE2B         JNC     ??ZDSecMgrApsLinkKeyInit_0
   4430          }
   \   000038                REQUIRE ?Subroutine3
   \   000038                // Fall through to label ?Subroutine3
   4431          
   4432          /******************************************************************************
   4433           * @fn          ZDSecMgrInitNVKeyTables
   4434           *
   4435           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   4436           *
   4437           * @param       setDefault - TRUE to set default values
   4438           *
   4439           * @return      none
   4440           */

   \                                 In  segment CODE, align 2
   4441          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   \                     ZDSecMgrInitNVKeyTables:
   4442          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
   4443            ZDSecMgrNwkKeyInit(setDefault);
   \   000004   ........     CALLA   #ZDSecMgrNwkKeyInit
   4444            ZDSecMgrMasterKeyInit();
   \   000008   ........     CALLA   #ZDSecMgrMasterKeyInit
   4445            ZDSecMgrApsLinkKeyInit();
   \   00000C   ........     CALLA   #ZDSecMgrApsLinkKeyInit
   4446            APSME_TCLinkKeyInit(setDefault);
   \   000010   4C4A         MOV.B   R10, R12
   \   000012   ........     CALLA   #APSME_TCLinkKeyInit
   4447          }
   \   000016   3A41         POP.W   R10
   \   000018   1001         RETA
   4448          
   4449          /******************************************************************************
   4450           * @fn          ZDSecMgrSaveApsLinkKey
   4451           *
   4452           * @brief       Save APS Link Key to NV. It will loop through all the keys
   4453           *              to see which one to save.
   4454           *
   4455           * @param       none
   4456           *
   4457           * @return      none
   4458           */

   \                                 In  segment CODE, align 2
   4459          void ZDSecMgrSaveApsLinkKey(void)
   \                     ZDSecMgrSaveApsLinkKey:
   4460          {
   \   000000   3B15         PUSHM.W #0x4, R11
   4461            APSME_LinkKeyData_t *pKeyData = NULL;
   4462            int i;
   4463          
   4464            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000002   ........     CALLA   #?Subroutine14
   4465          
   4466            if (pKeyData != NULL)
   \                     ??CrossCallReturnLabel_46:
   \   000006   2C24         JEQ     ??ZDSecMgrSaveApsLinkKey_1
   4467            {
   4468              // checks all pending flags to know which one to save
   4469              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   \   000008   0B43         MOV.W   #0x0, R11
   4470              {
   4471                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveApsLinkKey_0:
   \   00000A   084B         MOV.W   R11, R8
   \   00000C                RPT     #0x9
   \   00000C   4818085B     ADDX.W  R11, R8
   \   000010   D893....     CMP.B   #0x1, ApsLinkKeyFrmCntr + 8(R8)
   \   000014   1F20         JNE     ??ZDSecMgrSaveApsLinkKey_2
   \   000016   094B         MOV.W   R11, R9
   \   000018   39500102     ADD.W   #0x201, R9
   \   00001C   0F4A         MOV.W   R10, R15
   \   00001E   ........     CALLA   #??Subroutine28_0
   \                     ??CrossCallReturnLabel_55:
   \   000022   0C49         MOV.W   R9, R12
   4472                {
   4473                  // retrieve key from NV
   4474                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   4475                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   \   000024   ........     CALLA   #osal_nv_read
   \   000028   4C93         CMP.B   #0x0, R12
   \   00002A   1420         JNE     ??ZDSecMgrSaveApsLinkKey_2
   4476                  {
   4477                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   \   00002C   9A48....1000 MOV.W   ApsLinkKeyFrmCntr(R8), 0x10(R10)
   \   000032   9A48....1200 MOV.W   ApsLinkKeyFrmCntr + 2(R8), 0x12(R10)
   4478                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   \   000038   9A48....1400 MOV.W   ApsLinkKeyFrmCntr + 4(R8), 0x14(R10)
   \   00003E   9A48....1600 MOV.W   ApsLinkKeyFrmCntr + 6(R8), 0x16(R10)
   4479          
   4480                    // Write the APS link key back to the NV
   4481                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   4482                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   \   000044   0F4A         MOV.W   R10, R15
   \   000046   ........     CALLA   #??Subroutine28_0
   \                     ??CrossCallReturnLabel_56:
   \   00004A   0C49         MOV.W   R9, R12
   \   00004C   ........     CALLA   #osal_nv_write
   4483          
   4484                    // clear the pending write flag
   4485                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   000050   C843....     MOV.B   #0x0, ApsLinkKeyFrmCntr + 8(R8)
   4486                  }
   4487                }
   4488              }
   \                     ??ZDSecMgrSaveApsLinkKey_2:
   \   000054   1B53         ADD.W   #0x1, R11
   \   000056   3B900300     CMP.W   #0x3, R11
   \   00005A   D73B         JL      ??ZDSecMgrSaveApsLinkKey_0
   4489          
   4490              // clear copy of key in RAM
   4491              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00005C   ........     CALLA   #?Subroutine22
   4492          
   4493              osal_mem_free(pKeyData);
   4494            }
   4495          }
   \                     ??ZDSecMgrSaveApsLinkKey_1:
   \   000060   3817         POPM.W  #0x4, R11
   \   000062   1001         RETA
   4496          
   4497          /******************************************************************************
   4498           * @fn          ZDSecMgrSaveTCLinkKey
   4499           *
   4500           * @brief       Save TC Link Key to NV. It will loop through all the keys
   4501           *              to see which one to save.
   4502           *
   4503           * @param       none
   4504           *
   4505           * @return      none
   4506           */

   \                                 In  segment CODE, align 2
   4507          void ZDSecMgrSaveTCLinkKey(void)
   \                     ZDSecMgrSaveTCLinkKey:
   4508          {
   \   000000   0A12         PUSH.W  R10
   4509            APSME_TCLinkKey_t *pKeyData = NULL;
   4510            uint16 i;
   4511          
   4512            pKeyData = (APSME_TCLinkKey_t *)osal_mem_alloc(sizeof(APSME_TCLinkKey_t));
   \   000002   3C402000     MOV.W   #0x20, R12
   \   000006   ........     CALLA   #??Subroutine42_0
   4513          
   4514            if (pKeyData != NULL)
   \                     ??CrossCallReturnLabel_48:
   \   00000A   1D24         JEQ     ??ZDSecMgrSaveTCLinkKey_0
   4515            {
   4516              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   4517              {
   4518                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \   00000C   D293....     CMP.B   #0x1, &TCLinkKeyFrmCntr + 8
   \   000010   1520         JNE     ??ZDSecMgrSaveTCLinkKey_1
   4519                {
   4520                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0,
   4521                                   sizeof(APSME_TCLinkKey_t), pKeyData) == SUCCESS)
   \   000012   0F4C         MOV.W   R12, R15
   \   000014   ........     CALLA   #??Subroutine17_0
   \                     ??CrossCallReturnLabel_64:
   \   000018   4C93         CMP.B   #0x0, R12
   \   00001A   1020         JNE     ??ZDSecMgrSaveTCLinkKey_1
   4522                  {
   4523                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   00001C   9A42....1800 MOV.W   &TCLinkKeyFrmCntr, 0x18(R10)
   \   000022   9A42....1A00 MOV.W   &TCLinkKeyFrmCntr + 2, 0x1a(R10)
   4524                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   \   000028   9A42....1C00 MOV.W   &TCLinkKeyFrmCntr + 4, 0x1c(R10)
   \   00002E   9A42....1E00 MOV.W   &TCLinkKeyFrmCntr + 6, 0x1e(R10)
   4525          
   4526                    // Write the TC link key back to the NV
   4527                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0,
   4528                                  sizeof(APSME_TCLinkKey_t), pKeyData);
   \   000034   ........     CALLA   #?Subroutine19
   4529          
   4530                    // clear the pending write flag
   4531                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \                     ??CrossCallReturnLabel_9:
   \   000038   C243....     MOV.B   #0x0, &TCLinkKeyFrmCntr + 8
   4532                  }
   4533                }
   4534              }
   4535                // clear copy of key in RAM
   4536              osal_memset( pKeyData, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??ZDSecMgrSaveTCLinkKey_1:
   \   00003C   ........     CALLA   #?Subroutine18
   4537          
   4538              osal_mem_free(pKeyData);
   \                     ??CrossCallReturnLabel_4:
   \   000040   0C4A         MOV.W   R10, R12
   \   000042   ........     CALLA   #osal_mem_free
   4539            }
   4540          }
   \                     ??ZDSecMgrSaveTCLinkKey_0:
   \   000046   3A41         POP.W   R10
   \   000048   1001         RETA

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DC8 3
   4541          
   4542          #if defined ( ZBA_FALLBACK_NWKKEY )
   4543          /******************************************************************************
   4544           * @fn          ZDSecMgrFallbackNwkKey
   4545           *
   4546           * @brief       Use the ZBA fallback network key.
   4547           *
   4548           * @param       none
   4549           *
   4550           * @return      none
   4551           */
   4552          void ZDSecMgrFallbackNwkKey( void )
   4553          {
   4554            if ( !_NIB.nwkKeyLoaded )
   4555            {
   4556              uint8 fallbackKey[SEC_KEY_LEN];
   4557          
   4558              ZDSecMgrReadKeyFromNv( ZCD_NV_PRECFGKEY, fallbackKey );
   4559              SSP_UpdateNwkKey( fallbackKey, 0);
   4560              SSP_SwitchNwkKey( 0 );
   4561          
   4562              // clear local copy of key
   4563              osal_memset( fallbackKey, 0x00, SEC_KEY_LEN );
   4564          
   4565              // handle next step in authentication process
   4566              ZDSecMgrAuthNwkKey();
   4567            }
   4568          }
   4569          #endif // defined ( ZBA_FALLBACK_NWKKEY )
   4570          
   4571          #if defined ( NV_RESTORE )
   4572          /******************************************************************************
   4573           * @fn          ZDSecMgrClearNVKeyValues
   4574           *
   4575           * @brief       If NV_RESTORE is enabled and the status of the network needs
   4576           *              default values this fuction clears ZCD_NV_NWKKEY,
   4577           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link
   4578           *
   4579           * @param       none
   4580           *
   4581           * @return      none
   4582           */
   4583          void ZDSecMgrClearNVKeyValues(void)
   4584          {
   4585            nwkActiveKeyItems keyItems;
   4586            nwkKeyDesc nwkKey;
   4587          
   4588            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   4589          
   4590            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   4591          
   4592            // Initialize NV items for NWK Active and Alternate keys.
   4593            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   4594          
   4595            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4596          
   4597            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   4598          }
   4599          #endif // defined ( NV_RESTORE )
   4600          
   4601          /******************************************************************************
   4602          ******************************************************************************/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   APSME_IsDefaultTCLK
     26   APSME_IsLinkKeyValid
       26   -> APSME_LinkKeyNVIdGet
       26   -> osal_mem_alloc
       26   -> osal_mem_free
       26   -> osal_memcmp
       26   -> osal_memset
       26   -> osal_nv_read
      4   APSME_KeyFwdToChild
        4   -> AssocGetWithExt
        4   -> ZDSecMgrAssocDeviceAuth
      8   APSME_LinkKeyNVIdGet
        8   -> ZDSecMgrEntryLookupExt
     16   APSME_LinkKeySet
       16   -> ZDSecMgrEntryLookupExtGetIndex
       16   -> osal_mem_alloc
       16   -> osal_mem_free
       16   -> osal_memcpy
       16   -> osal_memset
       16   -> osal_nv_read
       16   -> osal_nv_write
     10   APSME_MasterKeyGet
       10   -> ZDSecMgrExtAddrLookup
       10   -> ZDSecMgrMasterKeyLookup
      4   APSME_SKA_TimerExpired
     38   APSME_TCLinkKeyInit
       38   -> osal_memcpy
       38   -> osal_memset
       38   -> osal_nv_item_init
       38   -> osal_nv_read
       38   -> osal_nv_write
     58   APSME_TCLinkKeyLoad
       58   -> APSME_IsDefaultTCLK
       58   -> APSME_LookupExtAddr
       58   -> AddrMgrEntryLookupNwk
       58   -> AddrMgrEntryRelease
       58   -> AddrMgrExtAddrEqual
       58   -> AddrMgrExtAddrValid
       58   -> osal_memset
       58   -> osal_nv_read
     44   APSME_TCLinkKeySync
       44   -> APSME_IsDefaultTCLK
       44   -> APSME_LookupExtAddr
       44   -> AddrMgrExtAddrEqual
       44   -> AddrMgrExtAddrValid
       44   -> osal_memset
       44   -> osal_nv_read
     14   ZDSecMgrAPSRemove
       14   -> ZDSecMgrDeviceRemove
     12   ZDSecMgrAddLinkKey
       12   -> APSME_LinkKeySet
       12   -> ZDSecMgrAddrStore
       12   -> ZDSecMgrEntryLookupAMI
       12   -> ZDSecMgrEntryNew
     22   ZDSecMgrAddrClear
       22   -> AddrMgrEntryRelease
       22   -> ZDSecMgrExtAddrLookup
     20   ZDSecMgrAddrMgrUpdate
       20   -> AddrMgrEntryGet
       20   -> AddrMgrEntryUpdate
     20   ZDSecMgrAddrStore
       20   -> AddrMgrEntryUpdate
       20   -> AddrMgrExtAddrSet
      6   ZDSecMgrAppKeyGet
        6   -> SSP_GetTrueRand
     56   ZDSecMgrAppKeyReq
       52   -> APSME_LookupExtAddr
       52   -> APSME_LookupNwkAddr
       52   -> APSME_TransportKeyReq
       56   -> ZDSecMgrAppKeyGet
       52   -> osal_memset
     36   ZDSecMgrApsLinkKeyInit
       36   -> osal_memset
       36   -> osal_nv_item_init
       36   -> osal_nv_write
      4   ZDSecMgrAssocDeviceAuth
     14   ZDSecMgrAuthInitiate
       14   -> APSME_AuthenticateReq
       14   -> APSME_LookupNwkAddr
      4   ZDSecMgrAuthNwkKey
        4   -> osal_set_event
      4   ZDSecMgrAuthenticateCfm
        4   -> osal_set_event
     28   ZDSecMgrAuthenticateInd
       28   -> APSME_AuthenticateReq
       28   -> AddrMgrEntryUpdate
       28   -> AddrMgrExtAddrSet
      4   ZDSecMgrAuthenticationCheck
      8   ZDSecMgrAuthenticationSet
        8   -> ZDSecMgrEntryLookupExt
      4   ZDSecMgrConfig
        4   -> APSME_SecurityNM
      8   ZDSecMgrCtrlAdd
        8   -> ZDSecMgrCtrlSet
      4   ZDSecMgrCtrlInit
        4   -> osal_mem_alloc
      8   ZDSecMgrCtrlLookup
      4   ZDSecMgrCtrlRelease
     10   ZDSecMgrCtrlReset
       10   -> ZDSecMgrCtrlAdd
       10   -> ZDSecMgrCtrlLookup
       10   -> ZDSecMgrCtrlSet
      4   ZDSecMgrCtrlSet
      6   ZDSecMgrCtrlTerm
        6   -> ZDSecMgrCtrlLookup
      8   ZDSecMgrDeviceCtrlHandler
        8   -> ZDSecMgrEstablishKey
        8   -> ZDSecMgrSendMasterKey
        8   -> ZDSecMgrSendNwkKey
        8   -> osal_start_timerEx
      4   ZDSecMgrDeviceCtrlSetup
        4   -> ZDSecMgrDeviceCtrlHandler
     10   ZDSecMgrDeviceCtrlUpdate
       10   -> ZDSecMgrCtrlLookup
       10   -> ZDSecMgrEntryLookupExt
     14   ZDSecMgrDeviceEntryAdd
       14   -> ZDSecMgrAddrMgrUpdate
       14   -> ZDSecMgrEntryFree
       14   -> ZDSecMgrEntryLookup
       14   -> ZDSecMgrEntryLookupAMI
       14   -> ZDSecMgrEntryNew
      4   ZDSecMgrDeviceEntryRemove
        4   -> ZDSecMgrEntryFree
     10   ZDSecMgrDeviceJoin
       10   -> ZDSecMgrAddrStore
       10   -> ZDSecMgrDeviceRemove
       10   -> ZDSecMgrDeviceValidate
       10   -> ZDSecMgrSendNwkKey
      8   ZDSecMgrDeviceJoinDirect
        8   -> AssocGetWithShort
        8   -> ZDSecMgrAssocDeviceAuth
        8   -> ZDSecMgrDeviceJoin
     12   ZDSecMgrDeviceJoinFwd
       12   -> APSME_UpdateDeviceReq
      4   ZDSecMgrDeviceNew
        4   -> ZDSecMgrDeviceJoinFwd
     16   ZDSecMgrDeviceRemove
       16   -> APSME_RemoveDeviceReq
       16   -> AssocGetWithExt
       16   -> NLME_GetShortAddr
       16   -> NLME_LeaveReq
      8   ZDSecMgrDeviceRemoveByExtAddr
        8   -> ZDSecMgrEntryFree
        8   -> ZDSecMgrEntryLookupExt
      4   ZDSecMgrDeviceValidate
        4   -> ZDSecMgrDeviceValidateRM
     30   ZDSecMgrDeviceValidateCM
       30   -> ZDSecMgrAddrStore
       30   -> ZDSecMgrDeviceEntryAdd
       30   -> ZDSecMgrMasterKeyLoad
       30   -> osal_memcpy
       30   -> osal_memset
      4   ZDSecMgrDeviceValidateRM
     10   ZDSecMgrDeviceValidateSKKE
       10   -> ZDSecMgrDeviceEntryAdd
       10   -> ZDSecMgrExtAddrLookup
       10   -> ZDSecMgrMasterKeyLookup
      8   ZDSecMgrEntryFree
        8   -> osal_mem_alloc
        8   -> osal_mem_free
        8   -> osal_memset
        8   -> osal_nv_write
      4   ZDSecMgrEntryInit
        4   -> osal_mem_alloc
     20   ZDSecMgrEntryLookup
       20   -> AddrMgrEntryLookupNwk
      8   ZDSecMgrEntryLookupAMI
      8   ZDSecMgrEntryLookupAMIGetIndex
     10   ZDSecMgrEntryLookupExt
       10   -> ZDSecMgrEntryLookupAMI
       10   -> ZDSecMgrExtAddrLookup
     10   ZDSecMgrEntryLookupExtGetIndex
       10   -> ZDSecMgrExtAddrLookup
      6   ZDSecMgrEntryNew
     14   ZDSecMgrEstablishKey
       14   -> APSME_EstablishKeyReq
       14   -> NLME_GetShortAddr
      4   ZDSecMgrEstablishKeyCfm
     24   ZDSecMgrEstablishKeyInd
       24   -> APSME_EstablishKeyRsp
       24   -> ZDSecMgrDeviceValidateSKKE
       24   -> ZDSecMgrTCDataLoad
       24   -> ZDSecMgrTCExtAddrCheck
     36   ZDSecMgrEvent
       36   -> AddrMgrEntryGet
       36   -> ZDSecMgrDeviceCtrlHandler
       36   -> osal_start_timerEx
     20   ZDSecMgrExtAddrLookup
       20   -> AddrMgrEntryLookupExt
       20   -> AddrMgrExtAddrSet
     20   ZDSecMgrExtAddrStore
       20   -> AddrMgrEntryUpdate
       20   -> AddrMgrExtAddrSet
      4   ZDSecMgrInit
        4   -> APSME_SecurityNM
      6   ZDSecMgrInitNVKeyTables
        6   -> APSME_TCLinkKeyInit
        6   -> ZDSecMgrApsLinkKeyInit
        6   -> ZDSecMgrMasterKeyInit
        6   -> ZDSecMgrNwkKeyInit
     30   ZDSecMgrMasterKeyInit
       30   -> osal_memset
       30   -> osal_nv_item_init
       30   -> osal_nv_write
     12   ZDSecMgrMasterKeyLoad
       12   -> ZDSecMgrExtAddrLookup
       12   -> ZDSecMgrMasterKeyLookup
       12   -> ZDSecMgrMasterKeyStore
       12   -> osal_nv_write
     34   ZDSecMgrMasterKeyLookup
       34   -> osal_memset
       34   -> osal_nv_read
     34   ZDSecMgrMasterKeyStore
       34   -> osal_memcpy
       34   -> osal_memset
       34   -> osal_nv_read
       34   -> osal_nv_write
     36   ZDSecMgrNewDeviceEvent
       36   -> AddrMgrEntryGet
       36   -> AssocMatchDeviceStatus
       36   -> AssocRemove
       36   -> NLME_GetShortAddr
       36   -> ZDSecMgrAssocDeviceAuth
       36   -> ZDSecMgrDeviceNew
     48   ZDSecMgrNwkKeyInit
       48   -> osal_memset
       48   -> osal_nv_item_init
       48   -> osal_nv_write
      4   ZDSecMgrPermitJoining
      4   ZDSecMgrPermitJoiningTimeout
      4   ZDSecMgrReadKeyFromNv
        4   -> osal_nv_read
     16   ZDSecMgrRemoveDeviceInd
       16   -> APSME_LookupNwkAddr
       16   -> NLME_GetShortAddr
       16   -> ZDSecMgrDeviceRemove
      8   ZDSecMgrRequestAppKey
        8   -> APSME_RequestKeyReq
      4   ZDSecMgrRequestKeyInd
        4   -> ZDSecMgrAppKeyReq
     12   ZDSecMgrSaveApsLinkKey
       12   -> osal_mem_alloc
       12   -> osal_mem_free
       12   -> osal_memset
       12   -> osal_nv_read
       12   -> osal_nv_write
      6   ZDSecMgrSaveTCLinkKey
        6   -> osal_mem_alloc
        6   -> osal_mem_free
        6   -> osal_memset
        6   -> osal_nv_read
        6   -> osal_nv_write
     40   ZDSecMgrSendMasterKey
       40   -> APSME_TransportKeyReq
       40   -> NLME_GetShortAddr
       40   -> ZDSecMgrMasterKeyLookup
       40   -> osal_memset
       40   -> osal_nv_read
     40   ZDSecMgrSendNwkKey
       40   -> APSME_TransportKeyReq
       40   -> NLME_GetShortAddr
       40   -> NLME_ReadNwkKeyInfo
       40   -> osal_memset
     16   ZDSecMgrSetDefaultNV
       16   -> osal_mem_alloc
       16   -> osal_mem_free
       16   -> osal_memset
       16   -> osal_nv_write
     26   ZDSecMgrSetupPartner
       26   -> AddrMgrEntryUpdate
       26   -> AddrMgrExtAddrSet
       26   -> AddrMgrExtAddrValid
       26   -> ZDP_IEEEAddrReq
       26   -> ZDP_NwkAddrReq
      4   ZDSecMgrSwitchKeyInd
        4   -> SSP_SwitchNwkKey
        4   -> ZDApp_NVUpdate
     40   ZDSecMgrTCDataLoad
       40   -> AddrMgrEntryLookupNwk
       40   -> ZDSecMgrAddrStore
       40   -> ZDSecMgrMasterKeyLookup
       40   -> ZDSecMgrMasterKeyStore
       40   -> osal_memcpy
       40   -> osal_memset
     16   ZDSecMgrTCExtAddrCheck
       16   -> AddrMgrExtAddrEqual
       16   -> AddrMgrExtAddrLookup
     22   ZDSecMgrTransportKeyInd
       22   -> SSP_SwitchNwkKey
       22   -> SSP_UpdateNwkKey
       22   -> ZDSecMgrAuthNwkKey
       22   -> ZDSecMgrReadKeyFromNv
       22   -> ZDSecMgrTCDataLoad
       22   -> osal_memset
     14   ZDSecMgrUpdateDeviceInd
       14   -> ZDSecMgrDeviceJoin


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for ZDSecMgrAppKeyType>
       8  ??Subroutine0_0
      14  ??Subroutine17_0
       8  ??Subroutine21_0
       8  ??Subroutine28_0
       8  ??Subroutine29_0
       6  ??Subroutine2_0
      10  ??Subroutine42_0
       6  ??Subroutine46_0
       8  ??Subroutine49_0
      32  ?Subroutine0
      14  ?Subroutine1
       6  ?Subroutine10
       6  ?Subroutine11
       6  ?Subroutine12
       6  ?Subroutine13
       4  ?Subroutine14
       8  ?Subroutine15
      22  ?Subroutine16
       2  ?Subroutine17
       8  ?Subroutine18
      16  ?Subroutine19
       2  ?Subroutine2
      20  ?Subroutine20
       4  ?Subroutine21
      14  ?Subroutine22
       4  ?Subroutine23
      18  ?Subroutine24
       4  ?Subroutine25
      12  ?Subroutine26
      10  ?Subroutine27
       2  ?Subroutine28
       2  ?Subroutine29
       8  ?Subroutine3
      24  ?Subroutine30
      16  ?Subroutine31
       8  ?Subroutine32
      18  ?Subroutine33
       8  ?Subroutine34
       8  ?Subroutine35
      14  ?Subroutine36
      16  ?Subroutine37
      12  ?Subroutine38
      16  ?Subroutine39
       8  ?Subroutine4
      10  ?Subroutine40
       2  ?Subroutine41
       8  ?Subroutine5
       8  ?Subroutine6
       8  ?Subroutine7
       6  ?Subroutine8
       6  ?Subroutine9
      28  APSME_IsDefaultTCLK
      90  APSME_IsLinkKeyValid
      46  APSME_KeyFwdToChild
      28  APSME_LinkKeyNVIdGet
     162  APSME_LinkKeySet
      28  APSME_MasterKeyGet
       2  APSME_SKA_TimerExpired
     120  APSME_TCLinkKeyInit
     154  APSME_TCLinkKeyLoad
     136  APSME_TCLinkKeySync
      30  ApsLinkKeyFrmCntr
      10  TCLinkKeyFrmCntr
      32  TrustCenterLinkKey
      46  ZDSecMgrAPSRemove
      82  ZDSecMgrAddLinkKey
      44  ZDSecMgrAddrClear
      46  ZDSecMgrAddrMgrUpdate
       2  ZDSecMgrAddrStore
      32  ZDSecMgrAppKeyGet
     174  ZDSecMgrAppKeyReq
       1  ZDSecMgrAppKeyType
      56  ZDSecMgrApsLinkKeyInit
      10  ZDSecMgrAssocDeviceAuth
      38  ZDSecMgrAuthInitiate
       0  ZDSecMgrAuthNwkKey
      18  ZDSecMgrAuthenticateCfm
      76  ZDSecMgrAuthenticateInd
       4  ZDSecMgrAuthenticationCheck
      22  ZDSecMgrAuthenticationSet
       4  ZDSecMgrConfig
      50  ZDSecMgrCtrlAdd
       2  ZDSecMgrCtrlData
      36  ZDSecMgrCtrlInit
      54  ZDSecMgrCtrlLookup
       6  ZDSecMgrCtrlRelease
      46  ZDSecMgrCtrlReset
      30  ZDSecMgrCtrlSet
      22  ZDSecMgrCtrlTerm
      96  ZDSecMgrDeviceCtrlHandler
      32  ZDSecMgrDeviceCtrlSetup
      76  ZDSecMgrDeviceCtrlUpdate
     106  ZDSecMgrDeviceEntryAdd
       4  ZDSecMgrDeviceEntryRemove
      50  ZDSecMgrDeviceJoin
      30  ZDSecMgrDeviceJoinDirect
     102  ZDSecMgrDeviceJoinFwd
       4  ZDSecMgrDeviceNew
     100  ZDSecMgrDeviceRemove
      26  ZDSecMgrDeviceRemoveByExtAddr
      32  ZDSecMgrDeviceValidate
      72  ZDSecMgrDeviceValidateCM
      14  ZDSecMgrDeviceValidateRM
      36  ZDSecMgrDeviceValidateSKKE
       2  ZDSecMgrEntries
      54  ZDSecMgrEntryFree
      54  ZDSecMgrEntryInit
      80  ZDSecMgrEntryLookup
      54  ZDSecMgrEntryLookupAMI
      50  ZDSecMgrEntryLookupAMIGetIndex
      36  ZDSecMgrEntryLookupExt
      68  ZDSecMgrEntryLookupExtGetIndex
      66  ZDSecMgrEntryNew
      60  ZDSecMgrEstablishKey
       2  ZDSecMgrEstablishKeyCfm
     118  ZDSecMgrEstablishKeyInd
     146  ZDSecMgrEvent
      32  ZDSecMgrExtAddrLookup
       2  ZDSecMgrExtAddrStore
       4  ZDSecMgrInit
      26  ZDSecMgrInitNVKeyTables
      76  ZDSecMgrMasterKeyInit
      46  ZDSecMgrMasterKeyLoad
      56  ZDSecMgrMasterKeyLookup
      96  ZDSecMgrMasterKeyStore
     122  ZDSecMgrNewDeviceEvent
     130  ZDSecMgrNwkKeyInit
      30  ZDSecMgrPermitJoining
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      16  ZDSecMgrPermitJoiningTimeout
     104  ZDSecMgrReadKeyFromNv
      50  ZDSecMgrRemoveDeviceInd
      26  ZDSecMgrRequestAppKey
      18  ZDSecMgrRequestKeyInd
     100  ZDSecMgrSaveApsLinkKey
      74  ZDSecMgrSaveTCLinkKey
     120  ZDSecMgrSendMasterKey
     136  ZDSecMgrSendNwkKey
     108  ZDSecMgrSetDefaultNV
      76  ZDSecMgrSetupPartner
      12  ZDSecMgrSwitchKeyInd
       1  ZDSecMgrTCAuthenticated
     100  ZDSecMgrTCDataLoad
       8  ZDSecMgrTCExtAddr
      40  ZDSecMgrTCExtAddrCheck
      16  ZDSecMgrTCMasterKey
     138  ZDSecMgrTransportKeyInd
      34  ZDSecMgrUpdateDeviceInd

 
 5 534 bytes in segment CODE
    16 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
    87 bytes in segment DATA16_Z
 
 5 534 bytes of CODE  memory
    17 bytes of CONST memory
    88 bytes of DATA  memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       10/Jun/2013  17:10:33 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\st #
#                     ack\af\AF.c                                             #
#    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\..\To #
#                     ols\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0      #
#                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                       #
#                     -DDEFAULT_CHANLIST=0x00000800                           #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100      #
#                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                   #
#                     -DBEACON_REQUEST_DELAY=100                              #
#                     -DBEACON_REQ_DELAY_MASK=0x00FF                          #
#                     -DLINK_STATUS_JITTER_MASK=0x007F                        #
#                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED= #
#                     3000 -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8  #
#                     -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2     #
#                     -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9              #
#                     -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40                #
#                     -DNWK_MAX_BINDING_ENTRIES=4                             #
#                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,       #
#                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,   #
#                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                    #
#                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=2 #
#                     0 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000           #
#                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100         #
#                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wEndev.cfg" (-DCPU6MHZ -DMAC_CFG_TX_DATA_MAX=3         #
#                     -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "C:\Texas     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC          #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)                #
#                     -DZCL_DEVICE_MGMT "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Components\stack\af\AF #
#                     .c" -D MSP430F2618 -D NWK_AUTO_POLL -D ZTOOL_P1 -D      #
#                     MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED  #
#                     -lC "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects #
#                     \zstack\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\ #
#                     List\" -lA "C:\Texas Instruments\ZStack-MSP2618-2.5.1\P #
#                     rojects\zstack\HomeAutomation\SampleSwitch\CC2520DB\End #
#                     Device\List\" --remarks --diag_suppress                 #
#                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\EndDevice\Obj\" --debug  #
#                     -D__MSP430F2618__ -e --double=32 --clib -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\" -I "C:\Texas           #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\Source\" -I           #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\..\..\Source\" #
#                      -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects #
#                     \zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\..\Z #
#                     Main\MSP2618\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\target\MSP2618CC2520\" -I "C:\Texas               #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\high_level\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\" -I "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\dual_chip\" -I "C:\Texas          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pr #
#                     ojects\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\. #
#                     .\..\..\..\Components\osal\include\" -I "C:\Texas       #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\osal\mcu\msp430\" -I "C:\Texas                        #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\saddr\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\sdata\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\af\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2520D #
#                     B\..\..\..\..\..\Components\stack\nwk\" -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sec\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sapi\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sys\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zcl\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zdo\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ #
#                     Projects\zstack\HomeAutomation\SampleSwitch\CC2520DB\.. #
#                     \..\..\..\..\Components\zmac\f8w\" --core=430X          #
#                     --data_model=small -Ohz --multiplier=16s                #
#                     --require_prototypes                                    #
#    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\List\ #
#                     AF.lst                                                  #
#    Object file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\Obj\A #
#                     F.r43                                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\stack\af\AF.c
      1          /**************************************************************************************************
      2            Filename:       AF.c
      3            Revised:        $Date: 2011-11-18 16:03:29 -0800 (Fri, 18 Nov 2011) $
      4            Revision:       $Revision: 28423 $
      5          
      6            Description:    Application Framework - Device Description helper functions
      7          
      8          
      9            Copyright 2004-2011 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "OSAL.h"
     45          #include "AF.h"
     46          #include "nwk_globals.h"
     47          #include "nwk_util.h"
     48          #include "aps_groups.h"
     49          #include "ZDProfile.h"
     50          #include "aps_frag.h"
     51          #include "rtg.h"
     52          
     53          #if defined ( MT_AF_CB_FUNC )
     54            #include "MT_AF.h"
     55          #endif
     56          
     57          #if defined ( INTER_PAN )
     58            #include "stub_aps.h"
     59          #endif
     60          
     61          /*********************************************************************
     62           * MACROS
     63           */
     64          
     65          /*********************************************************************
     66           * @fn      afSend
     67           *
     68           * @brief   Helper macro for V1 API to invoke V2 API.
     69           *
     70           * input parameters
     71           *
     72           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
     73           * @param   srcEP - Origination (i.e. respond to or ack to) End Point.
     74           * @param   cID - A valid cluster ID as specified by the Profile.
     75           * @param   len - Number of bytes of data pointed to by next param.
     76           * @param  *buf - A pointer to the data bytes to send.
     77           * @param   options - Valid bit mask of AF Tx Options as defined in AF.h.
     78           * @param  *transID - A pointer to a byte which can be modified and which will
     79           *                    be used as the transaction sequence number of the msg.
     80           *
     81           * output parameters
     82           *
     83           * @param  *transID - Incremented by one if the return value is success.
     84           *
     85           * @return  afStatus_t - See previous definition of afStatus_... types.
     86           */
     87          #define afSend( dstAddr, srcEP, cID, len, buf, transID, options, radius ) \
     88                  AF_DataRequest( (dstAddr), afFindEndPointDesc( (srcEP) ), \
     89                                    (cID), (len), (buf), (transID), (options), (radius) )
     90          
     91          /*********************************************************************
     92           * GLOBAL VARIABLES
     93           */
     94          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     95          epList_t *epList;
   \                     epList:
   \   000000                DS8 2
     96          
     97          /*********************************************************************
     98           * LOCAL FUNCTIONS
     99           */
    100          
    101          static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
    102                          zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig,
    103                          uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp );
    104          
    105          static epList_t *afFindEndPointDescList( uint8 EndPoint );
    106          
    107          static pDescCB afGetDescCB( endPointDesc_t *epDesc );
    108          
    109          /*********************************************************************
    110           * PUBLIC FUNCTIONS
    111           */
    112          
    113          /*********************************************************************
    114           * @fn      afInit
    115           *
    116           * @brief   Initialization function for the AF.
    117           *
    118           * @param   none
    119           *
    120           * @return  none
    121          void afInit( void )
    122          {
    123          }
    124           */
    125          
    126          /*********************************************************************
    127           * @fn      afRegisterExtended
    128           *
    129           * @brief   Register an Application's EndPoint description.
    130           *
    131           * @param   epDesc - pointer to the Application's endpoint descriptor.
    132           * @param   descFn - pointer to descriptor callback function
    133           *
    134           * NOTE:  The memory that epDesc is pointing to must exist after this call.
    135           *
    136           * @return  Pointer to epList_t on success, NULL otherwise.
    137           */

   \                                 In  segment CODE, align 2
    138          epList_t *afRegisterExtended( endPointDesc_t *epDesc, pDescCB descFn )
   \                     afRegisterExtended:
    139          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   084C         MOV.W   R12, R8
   \   000004   0A4E         MOV.W   R14, R10
   \   000006   0B4F         MOV.W   R15, R11
    140            epList_t *ep = osal_mem_alloc(sizeof(epList_t));
   \   000008   3C400C00     MOV.W   #0xc, R12
   \   00000C   ........     CALLA   #osal_mem_alloc
    141          
    142            if (ep != NULL)
   \   000010   0C93         CMP.W   #0x0, R12
   \   000012   1224         JEQ     ??afRegisterExtended_0
    143            {
    144              ep->nextDesc = epList;
   \   000014   9C42....0000 MOV.W   &epList, 0(R12)
    145              epList = ep;
   \   00001A   824C....     MOV.W   R12, &epList
    146              ep->epDesc = epDesc;
   \   00001E   8C480200     MOV.W   R8, 0x2(R12)
    147              ep->pfnDescCB = descFn;
   \   000022   8C4A0400     MOV.W   R10, 0x4(R12)
   \   000026   8C4B0600     MOV.W   R11, 0x6(R12)
    148              ep->apsfCfg.frameDelay = APSF_DEFAULT_INTERFRAME_DELAY;
   \   00002A   FC4032000800 MOV.B   #0x32, 0x8(R12)
    149              ep->apsfCfg.windowSize = APSF_DEFAULT_WINDOW_SIZE;
   \   000030   DC430900     MOV.B   #0x1, 0x9(R12)
    150              ep->flags = eEP_AllowMatch;  // Default to allow Match Descriptor.
   \   000034   DC430A00     MOV.B   #0x1, 0xa(R12)
    151            }
    152          
    153            return ep;
   \                     ??afRegisterExtended_0:
   \   000038   3817         POPM.W  #0x4, R11
   \   00003A   1001         RETA
    154          }
    155          
    156          /*********************************************************************
    157           * @fn      afRegister
    158           *
    159           * @brief   Register an Application's EndPoint description.
    160           *
    161           * @param   epDesc - pointer to the Application's endpoint descriptor.
    162           *
    163           * NOTE:  The memory that epDesc is pointing to must exist after this call.
    164           *
    165           * @return  afStatus_SUCCESS - Registered
    166           *          afStatus_MEM_FAIL - not enough memory to add descriptor
    167           *          afStatus_INVALID_PARAMETER - duplicate endpoint
    168           */

   \                                 In  segment CODE, align 2
    169          afStatus_t afRegister( endPointDesc_t *epDesc )
   \                     afRegister:
    170          {
   \   000000   0D4C         MOV.W   R12, R13
    171            if (afFindEndPointDescList(epDesc->endPoint))  // Look for duplicate endpoint.
   \   000002   6C4D         MOV.B   @R13, R12
   \   000004   ........     CALLA   #afFindEndPointDescList
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0224         JEQ     ??afRegister_1
    172            {
    173              return afStatus_INVALID_PARAMETER;
   \   00000C   6C43         MOV.B   #0x2, R12
   \   00000E   1001         RETA
    174            }
    175          
    176            return ((NULL == afRegisterExtended(epDesc, NULL)) ? afStatus_MEM_FAIL : afStatus_SUCCESS);
   \                     ??afRegister_1:
   \   000010   0E43         MOV.W   #0x0, R14
   \   000012   0F43         MOV.W   #0x0, R15
   \   000014   0C4D         MOV.W   R13, R12
   \   000016   ........     CALLA   #afRegisterExtended
   \   00001A   0C93         CMP.W   #0x0, R12
   \   00001C   0224         JEQ     ??afRegister_2
   \   00001E   4C43         MOV.B   #0x0, R12
   \   000020   1001         RETA
   \                     ??afRegister_2:
   \   000022   7C401000     MOV.B   #0x10, R12
   \   000026   1001         RETA
    177          }
    178          
    179          /*********************************************************************
    180           * @fn      afDelete
    181           *
    182           * @brief   Delete an Application's EndPoint descriptor and frees the memory
    183           *
    184           * @param   EndPoint - Application Endpoint to delete
    185           *
    186           * @return  afStatus_SUCCESS - endpoint deleted
    187           *          afStatus_INVALID_PARAMETER - endpoint not found
    188           *          afStatus_FAILED - endpoint list empty
    189           */

   \                                 In  segment CODE, align 2
    190          afStatus_t afDelete( uint8 EndPoint )
   \                     afDelete:
    191          {
   \   000000   0A12         PUSH.W  R10
    192            epList_t *epCurrent;
    193            epList_t *epPrevious;
    194          
    195            if (epList != NULL)
   \   000002   1F42....     MOV.W   &epList, R15
   \   000006   0F93         CMP.W   #0x0, R15
   \   000008   1C24         JEQ     ??afDelete_1
    196            {
    197              epPrevious = epCurrent = epList;
   \   00000A   0E4F         MOV.W   R15, R14
    198          
    199              // first element of the list matches
    200              if (epCurrent->epDesc->endPoint == EndPoint)
   \   00000C   2D4F         MOV.W   @R15, R13
   \   00000E   1A4F0200     MOV.W   0x2(R15), R10
   \   000012   CA9C0000     CMP.B   R12, 0(R10)
   \   000016   0320         JNE     ??afDelete_2
    201              {
    202                epList = epCurrent->nextDesc;
   \   000018   824D....     MOV.W   R13, &epList
    203                osal_mem_free(epCurrent);
   \   00001C   0D3C         JMP     ??afDelete_3
    204          
    205                return (afStatus_SUCCESS);
    206              }
    207              else
    208              {
    209                // search the list
    210                for (epCurrent = epPrevious->nextDesc; epCurrent != NULL; epPrevious = epCurrent)
   \                     ??afDelete_2:
   \   00001E   0F4D         MOV.W   R13, R15
   \   000020   0D93         CMP.W   #0x0, R13
   \   000022   0320         JNE     ??afDelete_4
    211                {
    212                  if (epCurrent->epDesc->endPoint == EndPoint)
    213                  {
    214                    epPrevious->nextDesc = epCurrent->nextDesc;
    215                    osal_mem_free(epCurrent);
    216          
    217                    // delete the entry and free the memory
    218                    return (afStatus_SUCCESS);
    219                  }
    220                }
    221              }
    222          
    223              // no endpoint found
    224              return (afStatus_INVALID_PARAMETER);
   \   000024   6C43         MOV.B   #0x2, R12
   \   000026   0E3C         JMP     ??afDelete_5
   \                     ??afDelete_0:
   \   000028   0E4F         MOV.W   R15, R14
   \                     ??afDelete_4:
   \   00002A   1D4F0200     MOV.W   0x2(R15), R13
   \   00002E   CD9C0000     CMP.B   R12, 0(R13)
   \   000032   FA23         JNE     ??afDelete_0
   \   000034   AE4F0000     MOV.W   @R15, 0(R14)
   \                     ??afDelete_3:
   \   000038   0C4F         MOV.W   R15, R12
   \   00003A   ........     CALLA   #osal_mem_free
   \   00003E   4C43         MOV.B   #0x0, R12
   \   000040   013C         JMP     ??afDelete_5
    225            }
    226            else
    227            {
    228              // epList is empty
    229              return (afStatus_FAILED);
   \                     ??afDelete_1:
   \   000042   5C43         MOV.B   #0x1, R12
   \                     ??afDelete_5:
   \   000044   3A41         POP.W   R10
   \   000046   1001         RETA
    230            }
    231          }
    232          
    233          /*********************************************************************
    234           * @fn          afDataConfirm
    235           *
    236           * @brief       This function will generate the Data Confirm back to
    237           *              the application.
    238           *
    239           * @param       endPoint - confirm end point
    240           * @param       transID - transaction ID from APSDE_DATA_REQUEST
    241           * @param       status - status of APSDE_DATA_REQUEST
    242           *
    243           * @return      none
    244           */

   \                                 In  segment CODE, align 2
    245          void afDataConfirm( uint8 endPoint, uint8 transID, ZStatus_t status )
   \                     afDataConfirm:
    246          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   484C         MOV.B   R12, R8
   \   000004   4A4D         MOV.B   R13, R10
   \   000006   4B4E         MOV.B   R14, R11
    247            endPointDesc_t *epDesc;
    248            afDataConfirm_t *msgPtr;
    249          
    250            // Find the endpoint description
    251            epDesc = afFindEndPointDesc( endPoint );
   \   000008   ........     CALLA   #afFindEndPointDesc
   \   00000C   094C         MOV.W   R12, R9
    252            if ( epDesc == NULL )
   \   00000E   0C93         CMP.W   #0x0, R12
   \   000010   1124         JEQ     ??afDataConfirm_0
    253              return;
    254          
    255            // Determine the incoming command type
    256            msgPtr = (afDataConfirm_t *)osal_msg_allocate( sizeof(afDataConfirm_t) );
   \   000012   2C42         MOV.W   #0x4, R12
   \   000014   ........     CALLA   #osal_msg_allocate
    257            if ( msgPtr )
   \   000018   0C93         CMP.W   #0x0, R12
   \   00001A   0C24         JEQ     ??afDataConfirm_0
    258            {
    259              // Build the Data Confirm message
    260              msgPtr->hdr.event = AF_DATA_CONFIRM_CMD;
   \   00001C   FC40FD000000 MOV.B   #0xfd, 0(R12)
    261              msgPtr->hdr.status = status;
   \   000022   CC4B0100     MOV.B   R11, 0x1(R12)
    262              msgPtr->endpoint = endPoint;
   \   000026   CC480200     MOV.B   R8, 0x2(R12)
    263              msgPtr->transID = transID;
   \   00002A   CC4A0300     MOV.B   R10, 0x3(R12)
    264          
    265          #if defined ( MT_AF_CB_FUNC )
    266              /* If MT has subscribed for this callback, don't send as a message. */
    267              if ( AFCB_CHECK(CB_ID_AF_DATA_CNF,*(epDesc->task_id)) )
    268              {
    269                /* Send callback if it's subscribed */
    270                MT_AfDataConfirm ((void *)msgPtr);
    271                /* Release the memory. */
    272                osal_msg_deallocate( (void *)msgPtr );
    273              }
    274              else
    275          #endif
    276              {
    277                /* send message through task message */
    278                osal_msg_send( *(epDesc->task_id), (uint8 *)msgPtr );
   \   00002E   0D4C         MOV.W   R12, R13
   \   000030   ........     CALLA   #?Subroutine0
    279              }
    280            }
    281          }
   \                     ??afDataConfirm_0:
   \   000034   3817         POPM.W  #0x4, R11
   \   000036   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   1F490200     MOV.W   0x2(R9), R15
   \   000004   6C4F         MOV.B   @R15, R12
   \   000006   ........     BRA     #osal_msg_send
    282          
    283          /*********************************************************************
    284           * @fn          afIncomingData
    285           *
    286           * @brief       Transfer a data PDU (ASDU) from the APS sub-layer to the AF.
    287           *
    288           * @param       aff  - pointer to APS frame format
    289           * @param       SrcAddress  - Source address
    290           * @param       SrcPanId  - Source PAN ID
    291           * @param       sig - incoming message's link quality
    292           * @param       nwkSeqNum - incoming network sequence number (from nwk header frame)
    293           * @param       SecurityUse - Security enable/disable
    294           * @param       timestamp - the MAC Timer2 timestamp at Rx.
    295           *
    296           * @return      none
    297           */

   \                                 In  segment CODE, align 2
    298          void afIncomingData( aps_FrameFormat_t *aff, zAddrType_t *SrcAddress, uint16 SrcPanId,
   \                     afIncomingData:
    299                               NLDE_Signal_t *sig, uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp )
    300          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   0D12         PUSH.W  R13
   \   000004   0E12         PUSH.W  R14
   \   000006   0F12         PUSH.W  R15
   \   000008   0B4C         MOV.W   R12, R11
    301            endPointDesc_t *epDesc = NULL;
    302            epList_t *pList = epList;
   \   00000A   1842....     MOV.W   &epList, R8
    303          #if !defined ( APS_NO_GROUPS )
    304            uint8 grpEp = APS_GROUPS_EP_NOT_FOUND;
   \   00000E   7740FE00     MOV.B   #0xfe, R7
   \   000012   4947         MOV.B   R7, R9
    305          #endif
    306          
    307            if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
   \   000014   76400C00     MOV.B   #0xc, R6
   \   000018   4E46         MOV.B   R6, R14
   \   00001A   6EFC         AND.B   @R12, R14
   \   00001C   4E96         CMP.B   R6, R14
   \   00001E   0820         JNE     ??afIncomingData_7
    308            {
    309          #if !defined ( APS_NO_GROUPS )
    310              // Find the first endpoint for this group
    311              grpEp = aps_FindGroupForEndpoint( aff->GroupID, APS_GROUPS_FIND_FIRST );
   \   000020   4D47         MOV.B   R7, R13
   \   000022   ........     CALLA   #?Subroutine1
    312              if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
   \                     ??CrossCallReturnLabel_0:
   \   000026   7624         JEQ     ??afIncomingData_6
    313                return;   // No endpoint found
    314          
    315              epDesc = afFindEndPointDesc( grpEp );
   \   000028   ........     CALLA   #?Subroutine2
    316              if ( epDesc == NULL )
   \                     ??CrossCallReturnLabel_2:
   \   00002C   1820         JNE     ??afIncomingData_8
    317                return;   // Endpoint descriptor not found
   \   00002E   723C         JMP     ??afIncomingData_6
    318          
    319              pList = afFindEndPointDescList( epDesc->endPoint );
    320          #else
    321              return; // Not supported
    322          #endif
    323            }
    324            else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
   \                     ??afIncomingData_7:
   \   000030   5C4B0200     MOV.B   0x2(R11), R12
   \   000034   7C93         CMP.B   #0xff, R12
   \   000036   1020         JNE     ??afIncomingData_9
    325            {
    326              // Set the list
    327              if ( pList != NULL )
   \   000038   0893         CMP.W   #0x0, R8
   \   00003A   6C24         JEQ     ??afIncomingData_6
    328              {
    329                epDesc = pList->epDesc;
   \   00003C   1A480200     MOV.W   0x2(R8), R10
   \                     ??afIncomingData_0:
   \   000040   D1411A001A00 MOV.B   0x1a(SP), 0x1a(SP)
   \   000046   55411C00     MOV.B   0x1c(SP), R5
   \   00004A   91411E001E00 MOV.W   0x1e(SP), 0x1e(SP)
   \   000050   914120002000 MOV.W   0x20(SP), 0x20(SP)
   \   000056   0A3C         JMP     ??afIncomingData_10
    330              }
    331            }
    332            else if ( (epDesc = afFindEndPointDesc( aff->DstEndPoint )) )
   \                     ??afIncomingData_9:
   \   000058   ........     CALLA   #?Subroutine2
   \                     ??CrossCallReturnLabel_3:
   \   00005C   F127         JEQ     ??afIncomingData_0
    333            {
    334              pList = afFindEndPointDescList( epDesc->endPoint );
   \                     ??afIncomingData_8:
   \   00005E   6C4A         MOV.B   @R10, R12
   \   000060   ........     CALLA   #afFindEndPointDescList
   \   000064   084C         MOV.W   R12, R8
   \   000066   EC3F         JMP     ??afIncomingData_0
    335            }
    336          
    337            while ( epDesc )
    338            {
    339              uint16 epProfileID = 0xFFFF;  // Invalid Profile ID
    340          
    341              if ( pList->pfnDescCB )
    342              {
    343                uint16 *pID = (uint16 *)(pList->pfnDescCB(
    344                                           AF_DESCRIPTOR_PROFILE_ID, epDesc->endPoint ));
    345                if ( pID )
    346                {
    347                  epProfileID = *pID;
    348                  osal_mem_free( pID );
    349                }
    350              }
    351              else if ( epDesc->simpleDesc )
    352              {
    353                epProfileID = epDesc->simpleDesc->AppProfId;
    354              }
    355          
    356              if ( (aff->ProfileID == epProfileID) ||
    357                   ((epDesc->endPoint == ZDO_EP) && (aff->ProfileID == ZDO_PROFILE_ID)) )
    358              {
    359                {
    360                  // Save original endpoint
    361                  uint8 endpoint = aff->DstEndPoint;
    362          
    363                  // overwrite with descriptor's endpoint
    364                  aff->DstEndPoint = epDesc->endPoint;
    365          
    366                  afBuildMSGIncoming( aff, epDesc, SrcAddress, SrcPanId, sig,
    367                                     nwkSeqNum, SecurityUse, timestamp );
    368          
    369                  // Restore with original endpoint
    370                  aff->DstEndPoint = endpoint;
    371                }
    372              }
    373          
    374              if ( ((aff->FrmCtrl & APS_DELIVERYMODE_MASK) == APS_FC_DM_GROUP) )
    375              {
    376          #if !defined ( APS_NO_GROUPS )
    377                // Find the next endpoint for this group
    378                grpEp = aps_FindGroupForEndpoint( aff->GroupID, grpEp );
    379                if ( grpEp == APS_GROUPS_EP_NOT_FOUND )
    380                  return;   // No endpoint found
    381          
    382                epDesc = afFindEndPointDesc( grpEp );
    383                if ( epDesc == NULL )
    384                  return;   // Endpoint descriptor not found
    385          
    386                pList = afFindEndPointDescList( epDesc->endPoint );
    387          #else
    388                return;
    389          #endif
    390              }
    391              else if ( aff->DstEndPoint == AF_BROADCAST_ENDPOINT )
    392              {
    393                pList = pList->nextDesc;
    394                if ( pList )
    395                  epDesc = pList->epDesc;
   \                     ??afIncomingData_2:
   \   000068   1A480200     MOV.W   0x2(R8), R10
   \                     ??afIncomingData_10:
   \   00006C   0A93         CMP.W   #0x0, R10
   \   00006E   5224         JEQ     ??afIncomingData_6
   \   000070   043C         JMP     ??afIncomingData_11
   \                     ??afIncomingData_1:
   \   000072   6C4A         MOV.B   @R10, R12
   \   000074   ........     CALLA   #afFindEndPointDescList
   \   000078   084C         MOV.W   R12, R8
   \                     ??afIncomingData_11:
   \   00007A   3443         MOV.W   #0xffff, R4
   \   00007C   1E480400     MOV.W   0x4(R8), R14
   \   000080   1F480600     MOV.W   0x6(R8), R15
   \   000084   0D4E         MOV.W   R14, R13
   \   000086   0DDF         BIS.W   R15, R13
   \   000088   0D93         CMP.W   #0x0, R13
   \   00008A   0A24         JEQ     ??afIncomingData_12
   \   00008C   6D4A         MOV.B   @R10, R13
   \   00008E   6C43         MOV.B   #0x2, R12
   \   000090   ........     CALLA   #?IndCallR15
   \   000094   0C93         CMP.W   #0x0, R12
   \   000096   0A24         JEQ     ??afIncomingData_13
   \   000098   244C         MOV.W   @R12, R4
   \   00009A   ........     CALLA   #osal_mem_free
   \   00009E   063C         JMP     ??afIncomingData_13
   \                     ??afIncomingData_12:
   \   0000A0   1F4A0400     MOV.W   0x4(R10), R15
   \   0000A4   0F93         CMP.W   #0x0, R15
   \   0000A6   0224         JEQ     ??afIncomingData_13
   \   0000A8   144F0200     MOV.W   0x2(R15), R4
   \                     ??afIncomingData_13:
   \   0000AC   1F4B0800     MOV.W   0x8(R11), R15
   \   0000B0   6E4A         MOV.B   @R10, R14
   \   0000B2   0F94         CMP.W   R4, R15
   \   0000B4   0424         JEQ     ??afIncomingData_14
   \   0000B6   4E93         CMP.B   #0x0, R14
   \   0000B8   1B20         JNE     ??afIncomingData_15
   \   0000BA   0F93         CMP.W   #0x0, R15
   \   0000BC   1920         JNE     ??afIncomingData_15
   \                     ??afIncomingData_14:
   \   0000BE   544B0200     MOV.B   0x2(R11), R4
   \   0000C2   CB4E0200     MOV.B   R14, 0x2(R11)
   \   0000C6   11122200     PUSH.W  0x22(SP)
   \   0000CA   11122200     PUSH.W  0x22(SP)
   \   0000CE   4512         PUSH.B  R5
   \   0000D0   51122200     PUSH.B  0x22(SP)
   \   0000D4   11120A00     PUSH.W  0xa(SP)
   \   0000D8   1F410C00     MOV.W   0xc(SP), R15
   \   0000DC   1E410E00     MOV.W   0xe(SP), R14
   \   0000E0   0D4A         MOV.W   R10, R13
   \   0000E2   0C4B         MOV.W   R11, R12
   \   0000E4   ........     CALLA   #afBuildMSGIncoming
   \   0000E8   CB440200     MOV.B   R4, 0x2(R11)
   \   0000EC   31500A00     ADD.W   #0xa, SP
   \                     ??afIncomingData_15:
   \   0000F0   4E46         MOV.B   R6, R14
   \   0000F2   6EFB         AND.B   @R11, R14
   \   0000F4   4E96         CMP.B   R6, R14
   \   0000F6   0820         JNE     ??afIncomingData_16
   \   0000F8   4D49         MOV.B   R9, R13
   \   0000FA   ........     CALLA   #?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   0000FE   0A24         JEQ     ??afIncomingData_6
   \   000100   ........     CALLA   #?Subroutine2
   \                     ??CrossCallReturnLabel_4:
   \   000104   B623         JNE     ??afIncomingData_1
   \   000106   063C         JMP     ??afIncomingData_6
   \                     ??afIncomingData_16:
   \   000108   FB930200     CMP.B   #0xff, 0x2(R11)
   \   00010C   0320         JNE     ??afIncomingData_6
   \   00010E   2848         MOV.W   @R8, R8
   \   000110   0893         CMP.W   #0x0, R8
   \   000112   AA23         JNE     ??afIncomingData_2
    396                else
    397                  epDesc = NULL;
    398              }
    399              else
    400                epDesc = NULL;
    401            }
    402          }
   \                     ??afIncomingData_6:
   \   000114   31500600     ADD.W   #0x6, SP
   \   000118   7417         POPM.W  #0x8, R11
   \   00011A   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   ........     CALLA   #afFindEndPointDesc
   \   000004   0A4C         MOV.W   R12, R10
   \   000006   0C93         CMP.W   #0x0, R12
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   1C4B0400     MOV.W   0x4(R11), R12
   \   000004   ........     CALLA   #aps_FindGroupForEndpoint
   \   000008   494C         MOV.B   R12, R9
   \   00000A   4C97         CMP.B   R7, R12
   \   00000C   1001         RETA
    403          
    404          /*********************************************************************
    405           * @fn          afBuildMSGIncoming
    406           *
    407           * @brief       Build the message for the app
    408           *
    409           * @param
    410           *
    411           * @return      pointer to next in data buffer
    412           */

   \                                 In  segment CODE, align 2
    413          static void afBuildMSGIncoming( aps_FrameFormat_t *aff, endPointDesc_t *epDesc,
   \                     afBuildMSGIncoming:
    414                           zAddrType_t *SrcAddress, uint16 SrcPanId, NLDE_Signal_t *sig,
    415                           uint8 nwkSeqNum, uint8 SecurityUse, uint32 timestamp )
    416          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   0E12         PUSH.W  R14
   \   000004   0F12         PUSH.W  R15
   \   000006   084C         MOV.W   R12, R8
   \   000008   094D         MOV.W   R13, R9
   \   00000A   56411A00     MOV.B   0x1a(SP), R6
   \   00000E   57411C00     MOV.B   0x1c(SP), R7
   \   000012   1A411E00     MOV.W   0x1e(SP), R10
   \   000016   1B412000     MOV.W   0x20(SP), R11
    417            afIncomingMSGPacket_t *MSGpkt;
    418            const uint8 len = sizeof( afIncomingMSGPacket_t ) + aff->asduLength;
    419            uint8 *asdu = aff->asdu;
   \   00001A   144C0E00     MOV.W   0xe(R12), R4
    420            MSGpkt = (afIncomingMSGPacket_t *)osal_msg_allocate( len );
   \   00001E   5C481000     MOV.B   0x10(R8), R12
   \   000022   7C502600     ADD.B   #0x26, R12
   \   000026   ........     CALLA   #osal_msg_allocate
   \   00002A   054C         MOV.W   R12, R5
    421          
    422            if ( MSGpkt == NULL )
   \   00002C   0C93         CMP.W   #0x0, R12
   \   00002E   4624         JEQ     ??afBuildMSGIncoming_1
    423            {
    424              return;
    425            }
    426          
    427            MSGpkt->hdr.event = AF_INCOMING_MSG_CMD;
   \   000030   FC401A000000 MOV.B   #0x1a, 0(R12)
    428            MSGpkt->groupId = aff->GroupID;
   \   000036   9C4804000200 MOV.W   0x4(R8), 0x2(R12)
    429            MSGpkt->clusterId = aff->ClusterID;
   \   00003C   9C4806000400 MOV.W   0x6(R8), 0x4(R12)
    430            afCopyAddress( &MSGpkt->srcAddr, SrcAddress );
   \   000042   1D410200     MOV.W   0x2(SP), R13
   \   000046   3C500600     ADD.W   #0x6, R12
   \   00004A   ........     CALLA   #afCopyAddress
    431            MSGpkt->srcAddr.endPoint = aff->SrcEndPoint;
   \   00004E   D54803000F00 MOV.B   0x3(R8), 0xf(R5)
    432            MSGpkt->endPoint = epDesc->endPoint;
   \   000054   E5491400     MOV.B   @R9, 0x14(R5)
    433            MSGpkt->wasBroadcast = aff->wasBroadcast;
   \   000058   D5480C001500 MOV.B   0xc(R8), 0x15(R5)
   \   00005E   1F411800     MOV.W   0x18(SP), R15
    434            MSGpkt->LinkQuality = sig->LinkQuality;
   \   000062   E54F1600     MOV.B   @R15, 0x16(R5)
    435            MSGpkt->correlation = sig->correlation;
   \   000066   D54F01001700 MOV.B   0x1(R15), 0x17(R5)
    436            MSGpkt->rssi = sig->rssi;
   \   00006C   D54F02001800 MOV.B   0x2(R15), 0x18(R5)
    437            MSGpkt->SecurityUse = SecurityUse;
   \   000072   C5471900     MOV.B   R7, 0x19(R5)
    438            MSGpkt->timestamp = timestamp;
   \   000076   854A1A00     MOV.W   R10, 0x1a(R5)
   \   00007A   854B1C00     MOV.W   R11, 0x1c(R5)
    439            MSGpkt->nwkSeqNum = nwkSeqNum;
   \   00007E   C5461E00     MOV.B   R6, 0x1e(R5)
    440            MSGpkt->macDestAddr = aff->macDestAddr;
   \   000082   95480A001200 MOV.W   0xa(R8), 0x12(R5)
    441            MSGpkt->srcAddr.panId = SrcPanId;
   \   000088   A5411000     MOV.W   @SP, 0x10(R5)
    442            MSGpkt->cmd.TransSeqNumber = 0;
   \   00008C   C5432000     MOV.B   #0x0, 0x20(R5)
    443            MSGpkt->cmd.DataLength = aff->asduLength;
   \   000090   5E481000     MOV.B   0x10(R8), R14
   \   000094   854E2200     MOV.W   R14, 0x22(R5)
    444          
    445            if ( MSGpkt->cmd.DataLength )
   \   000098   4E93         CMP.B   #0x0, R14
   \   00009A   0B24         JEQ     ??afBuildMSGIncoming_2
    446            {
    447              MSGpkt->cmd.Data = (uint8 *)(MSGpkt + 1);
   \   00009C   0C45         MOV.W   R5, R12
   \   00009E   3C502600     ADD.W   #0x26, R12
   \   0000A2   854C2400     MOV.W   R12, 0x24(R5)
    448              osal_memcpy( MSGpkt->cmd.Data, asdu, MSGpkt->cmd.DataLength );
   \   0000A6   1E452200     MOV.W   0x22(R5), R14
   \   0000AA   0D44         MOV.W   R4, R13
   \   0000AC   ........     CALLA   #osal_memcpy
   \   0000B0   023C         JMP     ??afBuildMSGIncoming_3
    449            }
    450            else
    451            {
    452              MSGpkt->cmd.Data = NULL;
   \                     ??afBuildMSGIncoming_2:
   \   0000B2   85432400     MOV.W   #0x0, 0x24(R5)
    453            }
    454          
    455          #if defined ( MT_AF_CB_FUNC )
    456            // If ZDO or SAPI have registered for this endpoint, dont intercept it here
    457            if (AFCB_CHECK(CB_ID_AF_DATA_IND, *(epDesc->task_id)))
    458            {
    459              MT_AfIncomingMsg( (void *)MSGpkt );
    460              // Release the memory.
    461              osal_msg_deallocate( (void *)MSGpkt );
    462            }
    463            else
    464          #endif
    465            {
    466              // Send message through task message.
    467              osal_msg_send( *(epDesc->task_id), (uint8 *)MSGpkt );
   \                     ??afBuildMSGIncoming_3:
   \   0000B6   0D45         MOV.W   R5, R13
   \   0000B8   ........     CALLA   #?Subroutine0
    468            }
    469          }
   \                     ??afBuildMSGIncoming_1:
   \   0000BC   2152         ADD.W   #0x4, SP
   \   0000BE   7417         POPM.W  #0x8, R11
   \   0000C0   1001         RETA
    470          
    471          /*********************************************************************
    472           * @fn      AF_DataRequest
    473           *
    474           * @brief   Common functionality for invoking APSDE_DataReq() for both
    475           *          SendMulti and MSG-Send.
    476           *
    477           * input parameters
    478           *
    479           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
    480           * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
    481           * @param   cID - A valid cluster ID as specified by the Profile.
    482           * @param   len - Number of bytes of data pointed to by next param.
    483           * @param  *buf - A pointer to the data bytes to send.
    484           * @param  *transID - A pointer to a byte which can be modified and which will
    485           *                    be used as the transaction sequence number of the msg.
    486           * @param   options - Valid bit mask of Tx options.
    487           * @param   radius - Normally set to AF_DEFAULT_RADIUS.
    488           *
    489           * output parameters
    490           *
    491           * @param  *transID - Incremented by one if the return value is success.
    492           *
    493           * @return  afStatus_t - See previous definition of afStatus_... types.
    494           */

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    495          uint8 AF_DataRequestDiscoverRoute = TRUE;
   \                     AF_DataRequestDiscoverRoute:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for AF_DataRequestDiscoverRoute>`

   \                                 In  segment CODE, align 2
    496          afStatus_t AF_DataRequest( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
   \                     AF_DataRequest:
    497                                     uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
    498                                     uint8 options, uint8 radius )
    499          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   0E12         PUSH.W  R14
   \   000004   31802000     SUB.W   #0x20, SP
   \   000008   0A4C         MOV.W   R12, R10
   \   00000A   0B4D         MOV.W   R13, R11
   \   00000C   074F         MOV.W   R15, R7
   \   00000E   15413600     MOV.W   0x36(SP), R5
   \   000012   54413C00     MOV.B   0x3c(SP), R4
    500            pDescCB pfnDescCB;
    501            ZStatus_t stat;
    502            APSDE_DataReq_t req;
    503            afDataReqMTU_t mtu;
    504          
    505            // Verify source end point
    506            if ( srcEP == NULL )
   \   000016   0D93         CMP.W   #0x0, R13
   \   000018   3F24         JEQ     ??AF_DataRequest_2
   \   00001A   58413A00     MOV.B   0x3a(SP), R8
    507            {
    508              return afStatus_INVALID_PARAMETER;
    509            }
    510          
    511          #if !defined( REFLECTOR )
    512            if ( dstAddr->addrMode == afAddrNotPresent )
    513            {
    514              return afStatus_INVALID_PARAMETER;
    515            }
    516          #endif
    517          
    518            // Check if route is available before sending data
    519            if ( options & AF_LIMIT_CONCENTRATOR  )
   \   00001E   78B2         BIT.B   #0x8, R8
   \   000020   1328         JNC     ??AF_DataRequest_3
    520            {
    521              if ( dstAddr->addrMode != afAddr16Bit )
   \   000022   EC930800     CMP.B   #0x2, 0x8(R12)
   \   000026   3820         JNE     ??AF_DataRequest_2
    522              {
    523                return ( afStatus_INVALID_PARAMETER );
    524              }
    525          
    526              // First, make sure the destination is not its self, then check for an existing route.
    527              if ( (dstAddr->addr.shortAddr != NLME_GetShortAddr())
    528                  && (RTG_CheckRtStatus( dstAddr->addr.shortAddr, RT_ACTIVE, (MTO_ROUTE | NO_ROUTE_CACHE) ) != RTG_SUCCESS) )
   \   000028   ........     CALLA   #NLME_GetShortAddr
   \   00002C   0F4C         MOV.W   R12, R15
   \   00002E   2C4A         MOV.W   @R10, R12
   \   000030   0C9F         CMP.W   R15, R12
   \   000032   0A24         JEQ     ??AF_DataRequest_3
   \   000034   7E400300     MOV.B   #0x3, R14
   \   000038   5D43         MOV.B   #0x1, R13
   \   00003A   ........     CALLA   #RTG_CheckRtStatus
   \   00003E   4C93         CMP.B   #0x0, R12
   \   000040   0324         JEQ     ??AF_DataRequest_3
    529              {
    530                // A valid route to a concentrator wasn't found
    531                return ( afStatus_NO_ROUTE );
   \   000042   7C40CD00     MOV.B   #0xcd, R12
   \   000046   B23C         JMP     ??AF_DataRequest_4
    532              }
    533            }
    534          
    535            // Validate broadcasting
    536            if ( ( dstAddr->addrMode == afAddr16Bit     ) ||
    537                 ( dstAddr->addrMode == afAddrBroadcast )    )
   \                     ??AF_DataRequest_3:
   \   000048   5E4A0800     MOV.B   0x8(R10), R14
   \   00004C   79400F00     MOV.B   #0xf, R9
   \   000050   6E93         CMP.B   #0x2, R14
   \   000052   0224         JEQ     ??AF_DataRequest_5
   \   000054   4E99         CMP.B   R9, R14
   \   000056   1920         JNE     ??AF_DataRequest_6
    538            {
    539              // Check for valid broadcast values
    540              if( ADDR_NOT_BCAST != NLME_IsAddressBroadcast( dstAddr->addr.shortAddr )  )
   \                     ??AF_DataRequest_5:
   \   000058   2C4A         MOV.W   @R10, R12
   \   00005A   ........     CALLA   #NLME_IsAddressBroadcast
   \   00005E   4C93         CMP.B   #0x0, R12
   \   000060   1024         JEQ     ??AF_DataRequest_7
    541              {
    542                // Force mode to broadcast
    543                dstAddr->addrMode = afAddrBroadcast;
   \   000062   CA490800     MOV.B   R9, 0x8(R10)
    544              }
    545              else
    546              {
    547                // Address is not a valid broadcast type
    548                if ( dstAddr->addrMode == afAddrBroadcast )
    549                {
    550                  return afStatus_INVALID_PARAMETER;
    551                }
    552              }
    553            }
    554            else if ( dstAddr->addrMode != afAddr64Bit &&
    555                      dstAddr->addrMode != afAddrGroup &&
    556                      dstAddr->addrMode != afAddrNotPresent )
    557            {
    558              return afStatus_INVALID_PARAMETER;
    559            }
    560          
    561            // Set destination address
    562            req.dstAddr.addrMode = dstAddr->addrMode;
   \                     ??AF_DataRequest_0:
   \   000066   D14A08000A00 MOV.B   0x8(R10), 0xa(SP)
    563            if ( dstAddr->addrMode == afAddr64Bit )
   \   00006C   0641         MOV.W   SP, R6
   \   00006E   2653         ADD.W   #0x2, R6
   \   000070   FA9003000800 CMP.B   #0x3, 0x8(R10)
   \   000076   1220         JNE     ??AF_DataRequest_8
    564              osal_cpyExtAddr( req.dstAddr.addr.extAddr, dstAddr->addr.extAddr );
   \   000078   0D4A         MOV.W   R10, R13
   \   00007A   0C46         MOV.W   R6, R12
   \   00007C   ........     CALLA   #sAddrExtCpy
   \   000080   0F3C         JMP     ??AF_DataRequest_9
   \                     ??AF_DataRequest_7:
   \   000082   CA990800     CMP.B   R9, 0x8(R10)
   \   000086   EF23         JNE     ??AF_DataRequest_0
   \   000088   073C         JMP     ??AF_DataRequest_2
   \                     ??AF_DataRequest_6:
   \   00008A   7E900300     CMP.B   #0x3, R14
   \   00008E   EB27         JEQ     ??AF_DataRequest_0
   \   000090   5E93         CMP.B   #0x1, R14
   \   000092   E927         JEQ     ??AF_DataRequest_0
   \   000094   4E93         CMP.B   #0x0, R14
   \   000096   E727         JEQ     ??AF_DataRequest_0
   \                     ??AF_DataRequest_2:
   \   000098   6C43         MOV.B   #0x2, R12
   \   00009A   883C         JMP     ??AF_DataRequest_4
    565            else
    566              req.dstAddr.addr.shortAddr = dstAddr->addr.shortAddr;
   \                     ??AF_DataRequest_8:
   \   00009C   A14A0200     MOV.W   @R10, 0x2(SP)
    567          
    568            req.profileID = ZDO_PROFILE_ID;
   \                     ??AF_DataRequest_9:
   \   0000A0   81431200     MOV.W   #0x0, 0x12(SP)
    569          
    570            if ( (pfnDescCB = afGetDescCB( srcEP )) )
   \   0000A4   1F42....     MOV.W   &epList, R15
   \   0000A8   013C         JMP     ??AF_DataRequest_10
   \                     ??AF_DataRequest_1:
   \   0000AA   2F4F         MOV.W   @R15, R15
   \                     ??AF_DataRequest_10:
   \   0000AC   0F93         CMP.W   #0x0, R15
   \   0000AE   1624         JEQ     ??AF_DataRequest_11
   \   0000B0   8F9B0200     CMP.W   R11, 0x2(R15)
   \   0000B4   FA23         JNE     ??AF_DataRequest_1
   \   0000B6   1E4F0400     MOV.W   0x4(R15), R14
   \   0000BA   1F4F0600     MOV.W   0x6(R15), R15
   \   0000BE   0D4E         MOV.W   R14, R13
   \   0000C0   0DDF         BIS.W   R15, R13
   \   0000C2   0D93         CMP.W   #0x0, R13
   \   0000C4   0B24         JEQ     ??AF_DataRequest_11
    571            {
    572              uint16 *pID = (uint16 *)(pfnDescCB(
    573                                           AF_DESCRIPTOR_PROFILE_ID, srcEP->endPoint ));
   \   0000C6   6D4B         MOV.B   @R11, R13
   \   0000C8   6C43         MOV.B   #0x2, R12
   \   0000CA   ........     CALLA   #?IndCallR15
    574              if ( pID )
   \   0000CE   0C93         CMP.W   #0x0, R12
   \   0000D0   0C24         JEQ     ??AF_DataRequest_12
    575              {
    576                req.profileID = *pID;
   \   0000D2   A14C1200     MOV.W   @R12, 0x12(SP)
    577                osal_mem_free( pID );
   \   0000D6   ........     CALLA   #osal_mem_free
   \   0000DA   073C         JMP     ??AF_DataRequest_12
    578              }
    579            }
    580            else if ( srcEP->simpleDesc )
   \                     ??AF_DataRequest_11:
   \   0000DC   1F4B0400     MOV.W   0x4(R11), R15
   \   0000E0   0F93         CMP.W   #0x0, R15
   \   0000E2   0324         JEQ     ??AF_DataRequest_12
    581            {
    582              req.profileID = srcEP->simpleDesc->AppProfId;
   \   0000E4   914F02001200 MOV.W   0x2(R15), 0x12(SP)
    583            }
    584          
    585            req.txOptions = 0;
   \                     ??AF_DataRequest_12:
   \   0000EA   81431800     MOV.W   #0x0, 0x18(SP)
    586          
    587            if ( ( options & AF_ACK_REQUEST              ) &&
    588                 ( req.dstAddr.addrMode != AddrBroadcast ) &&
    589                 ( req.dstAddr.addrMode != AddrGroup     )    )
   \   0000EE   78B01000     BIT.B   #0x10, R8
   \   0000F2   0828         JNC     ??AF_DataRequest_13
   \   0000F4   5E410A00     MOV.B   0xa(SP), R14
   \   0000F8   4E99         CMP.B   R9, R14
   \   0000FA   0424         JEQ     ??AF_DataRequest_13
   \   0000FC   5E93         CMP.B   #0x1, R14
   \   0000FE   0224         JEQ     ??AF_DataRequest_13
    590            {
    591              req.txOptions |=  APS_TX_OPTIONS_ACK;
   \   000100   A1421800     MOV.W   #0x4, 0x18(SP)
    592            }
    593          
    594            if ( options & AF_SKIP_ROUTING )
   \                     ??AF_DataRequest_13:
   \   000104   4893         CMP.B   #0x0, R8
   \   000106   0334         JGE     ??AF_DataRequest_14
    595            {
    596              req.txOptions |=  APS_TX_OPTIONS_SKIP_ROUTING;
   \   000108   B1D010001800 BIS.W   #0x10, 0x18(SP)
    597            }
    598          
    599            if ( options & AF_EN_SECURITY )
   \                     ??AF_DataRequest_14:
   \   00010E   78B04000     BIT.B   #0x40, R8
   \   000112   0528         JNC     ??AF_DataRequest_15
    600            {
    601              req.txOptions |= APS_TX_OPTIONS_SECURITY_ENABLE;
   \   000114   91D31800     BIS.W   #0x1, 0x18(SP)
    602              mtu.aps.secure = TRUE;
   \   000118   D1430100     MOV.B   #0x1, 0x1(SP)
   \   00011C   023C         JMP     ??AF_DataRequest_16
    603            }
    604            else
    605            {
    606              mtu.aps.secure = FALSE;
   \                     ??AF_DataRequest_15:
   \   00011E   C1430100     MOV.B   #0x0, 0x1(SP)
    607            }
    608          
    609            if ( options & AF_PREPROCESS )
   \                     ??AF_DataRequest_16:
   \   000122   68B2         BIT.B   #0x4, R8
   \   000124   0328         JNC     ??AF_DataRequest_17
    610            {
    611              req.txOptions |=  APS_TX_OPTIONS_PREPROCESS;
   \   000126   B1D040001800 BIS.W   #0x40, 0x18(SP)
    612            }
    613          
    614            mtu.kvp = FALSE;
   \                     ??AF_DataRequest_17:
   \   00012C   C1430000     MOV.B   #0x0, 0(SP)
   \   000130   18413800     MOV.W   0x38(SP), R8
    615          
    616            req.transID       = *transID;
   \   000134   E1481A00     MOV.B   @R8, 0x1a(SP)
    617            req.srcEP         = srcEP->endPoint;
   \   000138   E14B0C00     MOV.B   @R11, 0xc(SP)
    618            req.dstEP         = dstAddr->endPoint;
   \   00013C   D14A09000D00 MOV.B   0x9(R10), 0xd(SP)
    619            req.clusterID     = cID;
   \   000142   914120001000 MOV.W   0x20(SP), 0x10(SP)
    620            req.asduLen       = len;
   \   000148   81471400     MOV.W   R7, 0x14(SP)
    621            req.asdu          = buf;
   \   00014C   81451600     MOV.W   R5, 0x16(SP)
    622            req.discoverRoute = AF_DataRequestDiscoverRoute;//(uint8)((options & AF_DISCV_ROUTE) ? 1 : 0);
   \   000150   D142....1B00 MOV.B   &AF_DataRequestDiscoverRoute, 0x1b(SP)
    623            req.radiusCounter = radius;
   \   000156   C1441C00     MOV.B   R4, 0x1c(SP)
    624          #if defined ( INTER_PAN )
    625            req.dstPanId      = dstAddr->panId;
    626          
    627            if ( StubAPS_InterPan( dstAddr->panId, dstAddr->endPoint ) )
    628            {
    629              if ( len > INTERP_DataReqMTU() )
    630              {
    631                stat = afStatus_INVALID_PARAMETER;
    632              }
    633              else
    634              {
    635                stat = INTERP_DataReq( &req );
    636              }
    637            }
    638            else
    639          #endif // INTER_PAN
    640            {
    641              if (len > afDataReqMTU( &mtu ) )
   \   00015A   0C41         MOV.W   SP, R12
   \   00015C   0C53         ADD.W   #0x0, R12
   \   00015E   ........     CALLA   #afDataReqMTU
   \   000162   4C4C         MOV.B   R12, R12
   \   000164   0C97         CMP.W   R7, R12
   \   000166   0C2C         JC      ??AF_DataRequest_18
    642              {
    643                if (apsfSendFragmented)
   \   000168   1F42....     MOV.W   &apsfSendFragmented, R15
   \   00016C   1FD2....     BIS.W   &apsfSendFragmented + 2, R15
   \   000170   0F93         CMP.W   #0x0, R15
   \   000172   0424         JEQ     ??AF_DataRequest_19
    644                {
    645                  stat = (*apsfSendFragmented)( &req );
   \   000174   0C46         MOV.W   R6, R12
   \   000176   ........     CALLA   &apsfSendFragmented
   \   00017A   053C         JMP     ??AF_DataRequest_20
    646                }
    647                else
    648                {
    649                  stat = afStatus_INVALID_PARAMETER;
   \                     ??AF_DataRequest_19:
   \   00017C   6A43         MOV.B   #0x2, R10
   \   00017E   043C         JMP     ??AF_DataRequest_21
    650                }
    651              }
    652              else
    653              {
    654                stat = APSDE_DataReq( &req );
   \                     ??AF_DataRequest_18:
   \   000180   0C46         MOV.W   R6, R12
   \   000182   ........     CALLA   #APSDE_DataReq
   \                     ??AF_DataRequest_20:
   \   000186   4A4C         MOV.B   R12, R10
    655              }
    656            }
    657          
    658            /*
    659             * If this is an EndPoint-to-EndPoint message on the same device, it will not
    660             * get added to the NWK databufs. So it will not go OTA and it will not get
    661             * a MACCB_DATA_CONFIRM_CMD callback. Thus it is necessary to generate the
    662             * AF_DATA_CONFIRM_CMD here. Note that APSDE_DataConfirm() only generates one
    663             * message with the first in line TransSeqNumber, even on a multi message.
    664             * Also note that a reflected msg will not have its confirmation generated
    665             * here.
    666             */
    667            if ( (req.dstAddr.addrMode == Addr16Bit) &&
    668                 (req.dstAddr.addr.shortAddr == NLME_GetShortAddr()) )
   \                     ??AF_DataRequest_21:
   \   000188   E1930A00     CMP.B   #0x2, 0xa(SP)
   \   00018C   0A20         JNE     ??AF_DataRequest_22
   \   00018E   ........     CALLA   #NLME_GetShortAddr
   \   000192   819C0200     CMP.W   R12, 0x2(SP)
   \   000196   0520         JNE     ??AF_DataRequest_22
    669            {
    670              afDataConfirm( srcEP->endPoint, *transID, stat );
   \   000198   4E4A         MOV.B   R10, R14
   \   00019A   6D48         MOV.B   @R8, R13
   \   00019C   6C4B         MOV.B   @R11, R12
   \   00019E   ........     CALLA   #afDataConfirm
    671            }
    672          
    673            if ( stat == afStatus_SUCCESS )
   \                     ??AF_DataRequest_22:
   \   0001A2   4A93         CMP.B   #0x0, R10
   \   0001A4   0220         JNE     ??AF_DataRequest_23
    674            {
    675              (*transID)++;
   \   0001A6   D8530000     ADD.B   #0x1, 0(R8)
    676            }
    677          
    678            return (afStatus_t)stat;
   \                     ??AF_DataRequest_23:
   \   0001AA   4C4A         MOV.B   R10, R12
   \                     ??AF_DataRequest_4:
   \   0001AC   31502200     ADD.W   #0x22, SP
   \   0001B0   7417         POPM.W  #0x8, R11
   \   0001B2   1001         RETA
    679          }
    680          
    681          #if defined ( ZIGBEE_SOURCE_ROUTING )
    682          /*********************************************************************
    683           * @fn      AF_DataRequestSrcRtg
    684           *
    685           * @brief   Common functionality for invoking APSDE_DataReq() for both
    686           *          SendMulti and MSG-Send.
    687           *
    688           * input parameters
    689           *
    690           * @param  *dstAddr - Full ZB destination address: Nwk Addr + End Point.
    691           * @param  *srcEP - Origination (i.e. respond to or ack to) End Point Descr.
    692           * @param   cID - A valid cluster ID as specified by the Profile.
    693           * @param   len - Number of bytes of data pointed to by next param.
    694           * @param  *buf - A pointer to the data bytes to send.
    695           * @param  *transID - A pointer to a byte which can be modified and which will
    696           *                    be used as the transaction sequence number of the msg.
    697           * @param   options - Valid bit mask of Tx options.
    698           * @param   radius - Normally set to AF_DEFAULT_RADIUS.
    699           * @param   relayCnt - Number of devices in the relay list
    700           * @param   pRelayList - Pointer to the relay list
    701           *
    702           * output parameters
    703           *
    704           * @param  *transID - Incremented by one if the return value is success.
    705           *
    706           * @return  afStatus_t - See previous definition of afStatus_... types.
    707           */
    708          

   \                                 In  segment CODE, align 2
    709          afStatus_t AF_DataRequestSrcRtg( afAddrType_t *dstAddr, endPointDesc_t *srcEP,
   \                     AF_DataRequestSrcRtg:
    710                                     uint16 cID, uint16 len, uint8 *buf, uint8 *transID,
    711                                     uint8 options, uint8 radius, uint8 relayCnt, uint16* pRelayList )
    712          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   054D         MOV.W   R13, R5
   \   000006   044E         MOV.W   R14, R4
   \   000008   0B4F         MOV.W   R15, R11
   \   00000A   18411400     MOV.W   0x14(SP), R8
   \   00000E   19411600     MOV.W   0x16(SP), R9
   \   000012   56411800     MOV.B   0x18(SP), R6
   \   000016   57411A00     MOV.B   0x1a(SP), R7
   \   00001A   5D411C00     MOV.B   0x1c(SP), R13
   \   00001E   1E411E00     MOV.W   0x1e(SP), R14
    713            uint8 status;
    714          
    715            /* Add the source route to the source routing table */
    716            status = RTG_AddSrcRtgEntry_Guaranteed( dstAddr->addr.shortAddr, relayCnt,
    717                                                   pRelayList );
   \   000022   2C4A         MOV.W   @R10, R12
   \   000024   ........     CALLA   #RTG_AddSrcRtgEntry_Guaranteed
    718          
    719            if( status == RTG_SUCCESS)
   \   000028   4C93         CMP.B   #0x0, R12
   \   00002A   0C20         JNE     ??AF_DataRequestSrcRtg_1
    720            {
    721              /* Call AF_DataRequest to send the data */
    722              status = AF_DataRequest( dstAddr, srcEP, cID, len, buf, transID, options, radius );
   \   00002C   4712         PUSH.B  R7
   \   00002E   4612         PUSH.B  R6
   \   000030   0912         PUSH.W  R9
   \   000032   0812         PUSH.W  R8
   \   000034   0F4B         MOV.W   R11, R15
   \   000036   0E44         MOV.W   R4, R14
   \   000038   0D45         MOV.W   R5, R13
   \   00003A   0C4A         MOV.W   R10, R12
   \   00003C   ........     CALLA   #AF_DataRequest
   \   000040   3152         ADD.W   #0x8, SP
   \   000042   073C         JMP     ??AF_DataRequestSrcRtg_0
    723            }
    724            else if( status == RTG_INVALID_PATH )
   \                     ??AF_DataRequestSrcRtg_1:
   \   000044   7C900500     CMP.B   #0x5, R12
   \   000048   0324         JEQ     ??AF_DataRequestSrcRtg_2
   \   00004A   7C401000     MOV.B   #0x10, R12
   \   00004E   013C         JMP     ??AF_DataRequestSrcRtg_0
   \                     ??AF_DataRequestSrcRtg_2:
   \   000050   6C43         MOV.B   #0x2, R12
    725            {
    726              /* The source route relay count is exceeding the network limit */
    727              status = afStatus_INVALID_PARAMETER;
    728            }
    729            else
    730            {
    731              /* The guaranteed adding entry fails due to memory failure */
    732              status = afStatus_MEM_FAIL;
    733            }
    734            return status;
   \                     ??AF_DataRequestSrcRtg_0:
   \   000052   7417         POPM.W  #0x8, R11
   \   000054   1001         RETA
    735          }
    736          
    737          #endif
    738          
    739          /*********************************************************************
    740           * @fn      afFindEndPointDescList
    741           *
    742           * @brief   Find the endpoint description entry from the endpoint
    743           *          number.
    744           *
    745           * @param   EndPoint - Application Endpoint to look for
    746           *
    747           * @return  the address to the endpoint/interface description entry
    748           */

   \                                 In  segment CODE, align 2
    749          static epList_t *afFindEndPointDescList( uint8 EndPoint )
   \                     afFindEndPointDescList:
    750          {
    751            epList_t *epSearch;
    752          
    753            for (epSearch = epList; epSearch != NULL; epSearch = epSearch->nextDesc)
   \   000000   1F42....     MOV.W   &epList, R15
   \   000004   013C         JMP     ??afFindEndPointDescList_1
   \                     ??afFindEndPointDescList_0:
   \   000006   2F4F         MOV.W   @R15, R15
   \                     ??afFindEndPointDescList_1:
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   0524         JEQ     ??afFindEndPointDescList_2
    754            {
    755              if (epSearch->epDesc->endPoint == EndPoint)
   \   00000C   1E4F0200     MOV.W   0x2(R15), R14
   \   000010   CE9C0000     CMP.B   R12, 0(R14)
   \   000014   F823         JNE     ??afFindEndPointDescList_0
    756              {
    757                break;
    758              }
    759            }
    760          
    761            return epSearch;
   \                     ??afFindEndPointDescList_2:
   \   000016   0C4F         MOV.W   R15, R12
   \   000018   1001         RETA
    762          }
    763          
    764          /*********************************************************************
    765           * @fn      afFindEndPointDesc
    766           *
    767           * @brief   Find the endpoint description entry from the endpoint
    768           *          number.
    769           *
    770           * @param   EndPoint - Application Endpoint to look for
    771           *
    772           * @return  the address to the endpoint/interface description entry
    773           */

   \                                 In  segment CODE, align 2
    774          endPointDesc_t *afFindEndPointDesc( uint8 EndPoint )
   \                     afFindEndPointDesc:
    775          {
    776            epList_t *epSearch;
    777          
    778            // Look for the endpoint
    779            epSearch = afFindEndPointDescList( EndPoint );
   \   000000   ........     CALLA   #afFindEndPointDescList
    780          
    781            if ( epSearch )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0324         JEQ     ??afFindEndPointDesc_0
    782              return ( epSearch->epDesc );
   \   000008   1C4C0200     MOV.W   0x2(R12), R12
   \   00000C   1001         RETA
    783            else
    784              return ( (endPointDesc_t *)NULL );
   \                     ??afFindEndPointDesc_0:
   \   00000E   0C43         MOV.W   #0x0, R12
   \   000010   1001         RETA
    785          }
    786          
    787          /*********************************************************************
    788           * @fn      afFindSimpleDesc
    789           *
    790           * @brief   Find the Simple Descriptor from the endpoint number.
    791           *
    792           * @param   EP - Application Endpoint to look for.
    793           *
    794           * @return  Non-zero to indicate that the descriptor memory must be freed.
    795           */

   \                                 In  segment CODE, align 2
    796          uint8 afFindSimpleDesc( SimpleDescriptionFormat_t **ppDesc, uint8 EP )
   \                     afFindSimpleDesc:
    797          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0B4C         MOV.W   R12, R11
   \   000004   4A4D         MOV.B   R13, R10
    798            epList_t *epItem = afFindEndPointDescList( EP );
   \   000006   4C4D         MOV.B   R13, R12
   \   000008   ........     CALLA   #afFindEndPointDescList
   \   00000C   0F4C         MOV.W   R12, R15
    799            uint8 rtrn = FALSE;
   \   00000E   4C43         MOV.B   #0x0, R12
    800          
    801            if ( epItem )
   \   000010   0F93         CMP.W   #0x0, R15
   \   000012   1624         JEQ     ??afFindSimpleDesc_0
    802            {
    803              if ( epItem->pfnDescCB )
   \   000014   184F0400     MOV.W   0x4(R15), R8
   \   000018   194F0600     MOV.W   0x6(R15), R9
   \   00001C   0E48         MOV.W   R8, R14
   \   00001E   0ED9         BIS.W   R9, R14
   \   000020   0E93         CMP.W   #0x0, R14
   \   000022   0824         JEQ     ??afFindSimpleDesc_1
    804              {
    805                *ppDesc = epItem->pfnDescCB( AF_DESCRIPTOR_SIMPLE, EP );
   \   000024   4D4A         MOV.B   R10, R13
   \   000026   5C43         MOV.B   #0x1, R12
   \   000028   ........     CALLA   #?IndCallR9
   \   00002C   8B4C0000     MOV.W   R12, 0(R11)
    806                rtrn = TRUE;
   \   000030   5C43         MOV.B   #0x1, R12
   \   000032   083C         JMP     ??afFindSimpleDesc_2
    807              }
    808              else
    809              {
    810                *ppDesc = epItem->epDesc->simpleDesc;
   \                     ??afFindSimpleDesc_1:
   \   000034   1F4F0200     MOV.W   0x2(R15), R15
   \   000038   9B4F04000000 MOV.W   0x4(R15), 0(R11)
   \   00003E   023C         JMP     ??afFindSimpleDesc_2
    811              }
    812            }
    813            else
    814            {
    815              *ppDesc = NULL;
   \                     ??afFindSimpleDesc_0:
   \   000040   8B430000     MOV.W   #0x0, 0(R11)
    816            }
    817          
    818            return rtrn;
   \                     ??afFindSimpleDesc_2:
   \   000044   3817         POPM.W  #0x4, R11
   \   000046   1001         RETA
    819          }
    820          
    821          /*********************************************************************
    822           * @fn      afGetDescCB
    823           *
    824           * @brief   Get the Descriptor callback function.
    825           *
    826           * @param   epDesc - pointer to the endpoint descriptor
    827           *
    828           * @return  function pointer or NULL
    829           */
    830          static pDescCB afGetDescCB( endPointDesc_t *epDesc )
    831          {
    832            epList_t *epSearch;
    833          
    834            // Start at the beginning
    835            epSearch = epList;
    836          
    837            // Look through the list until the end
    838            while ( epSearch )
    839            {
    840              // Is there a match?
    841              if ( epSearch->epDesc == epDesc )
    842              {
    843                return ( epSearch->pfnDescCB );
    844              }
    845              else
    846                epSearch = epSearch->nextDesc;  // Next entry
    847            }
    848          
    849            return ( (pDescCB)NULL );
    850          }
    851          
    852          /*********************************************************************
    853           * @fn      afDataReqMTU
    854           *
    855           * @brief   Get the Data Request MTU(Max Transport Unit).
    856           *
    857           * @param   fields - afDataReqMTU_t
    858           *
    859           * @return  uint8(MTU)
    860           */

   \                                 In  segment CODE, align 2
    861          uint8 afDataReqMTU( afDataReqMTU_t* fields )
   \                     afDataReqMTU:
    862          {
   \   000000   0A12         PUSH.W  R10
    863            uint8 len;
    864            uint8 hdr;
    865          
    866            if ( fields->kvp == TRUE )
   \   000002   DC930000     CMP.B   #0x1, 0(R12)
   \   000006   0224         JEQ     ??afDataReqMTU_0
   \   000008   4A43         MOV.B   #0x0, R10
   \   00000A   013C         JMP     ??afDataReqMTU_1
   \                     ??afDataReqMTU_0:
   \   00000C   7A42         MOV.B   #0x8, R10
    867            {
    868              hdr = AF_HDR_KVP_MAX_LEN;
    869            }
    870            else
    871            {
    872              hdr = AF_HDR_V1_1_MAX_LEN;
    873            }
    874          
    875            len = (uint8)(APSDE_DataReqMTU(&fields->aps) - hdr);
    876          
    877            return len;
   \                     ??afDataReqMTU_1:
   \   00000E   1C53         ADD.W   #0x1, R12
   \   000010   ........     CALLA   #APSDE_DataReqMTU
   \   000014   4C8A         SUB.B   R10, R12
   \   000016   3A41         POP.W   R10
   \   000018   1001         RETA
    878          }
    879          
    880          /*********************************************************************
    881           * @fn      afGetMatch
    882           *
    883           * @brief   Set the allow response flag.
    884           *
    885           * @param   ep - Application Endpoint to look for
    886           * @param   action - true - allow response, false - no response
    887           *
    888           * @return  TRUE allow responses, FALSE no response
    889           */

   \                                 In  segment CODE, align 2
    890          uint8 afGetMatch( uint8 ep )
   \                     afGetMatch:
    891          {
    892            epList_t *epSearch;
    893          
    894            // Look for the endpoint
    895            epSearch = afFindEndPointDescList( ep );
   \   000000   ........     CALLA   #afFindEndPointDescList
    896          
    897            if ( epSearch )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0524         JEQ     ??afGetMatch_0
    898            {
    899              if ( epSearch->flags & eEP_AllowMatch )
   \   000008   DCB30A00     BIT.B   #0x1, 0xa(R12)
   \   00000C   0228         JNC     ??afGetMatch_0
    900                return ( TRUE );
   \   00000E   5C43         MOV.B   #0x1, R12
   \   000010   1001         RETA
    901              else
    902                return ( FALSE );
    903            }
    904            else
    905              return ( FALSE );
   \                     ??afGetMatch_0:
   \   000012   4C43         MOV.B   #0x0, R12
   \   000014   1001         RETA
    906          }
    907          
    908          /*********************************************************************
    909           * @fn      afSetMatch
    910           *
    911           * @brief   Set the allow response flag.
    912           *
    913           * @param   ep - Application Endpoint to look for
    914           * @param   action - true - allow response, false - no response
    915           *
    916           * @return  TRUE if success, FALSE if endpoint not found
    917           */

   \                                 In  segment CODE, align 2
    918          uint8 afSetMatch( uint8 ep, uint8 action )
   \                     afSetMatch:
    919          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4D         MOV.B   R13, R10
    920            epList_t *epSearch;
    921          
    922            // Look for the endpoint
    923            epSearch = afFindEndPointDescList( ep );
   \   000004   ........     CALLA   #afFindEndPointDescList
    924          
    925            if ( epSearch )
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0B24         JEQ     ??afSetMatch_0
    926            {
    927              if ( action )
   \   00000C   5E4C0A00     MOV.B   0xa(R12), R14
   \   000010   4A93         CMP.B   #0x0, R10
   \   000012   0224         JEQ     ??afSetMatch_1
    928              {
    929                epSearch->flags |= eEP_AllowMatch;
   \   000014   5ED3         BIS.B   #0x1, R14
   \   000016   013C         JMP     ??afSetMatch_2
    930              }
    931              else
    932              {
    933                epSearch->flags &= (eEP_AllowMatch ^ 0xFFFF);
   \                     ??afSetMatch_1:
   \   000018   5EC3         BIC.B   #0x1, R14
   \                     ??afSetMatch_2:
   \   00001A   CC4E0A00     MOV.B   R14, 0xa(R12)
    934              }
    935              return ( TRUE );
   \   00001E   5C43         MOV.B   #0x1, R12
   \   000020   013C         JMP     ??afSetMatch_3
    936            }
    937            else
    938              return ( FALSE );
   \                     ??afSetMatch_0:
   \   000022   4C43         MOV.B   #0x0, R12
   \                     ??afSetMatch_3:
   \   000024   3A41         POP.W   R10
   \   000026   1001         RETA
    939          }
    940          
    941          /*********************************************************************
    942           * @fn      afNumEndPoints
    943           *
    944           * @brief   Returns the number of endpoints defined (including 0)
    945           *
    946           * @param   none
    947           *
    948           * @return  number of endpoints
    949           */

   \                                 In  segment CODE, align 2
    950          uint8 afNumEndPoints( void )
   \                     afNumEndPoints:
    951          {
    952            epList_t *epSearch;
    953            uint8 endpoints;
    954          
    955            // Start at the beginning
    956            epSearch = epList;
   \   000000   1F42....     MOV.W   &epList, R15
    957            endpoints = 0;
   \   000004   4C43         MOV.B   #0x0, R12
   \   000006   023C         JMP     ??afNumEndPoints_1
    958          
    959            while ( epSearch )
    960            {
    961              endpoints++;
   \                     ??afNumEndPoints_0:
   \   000008   5C53         ADD.B   #0x1, R12
    962              epSearch = epSearch->nextDesc;
   \   00000A   2F4F         MOV.W   @R15, R15
    963            }
   \                     ??afNumEndPoints_1:
   \   00000C   0F93         CMP.W   #0x0, R15
   \   00000E   FC23         JNE     ??afNumEndPoints_0
    964          
    965            return ( endpoints );
   \   000010   1001         RETA
    966          }
    967          
    968          /*********************************************************************
    969           * @fn      afEndPoints
    970           *
    971           * @brief   Fills in the passed in buffer with the endpoint (numbers).
    972           *          Use afNumEndPoints to find out how big a buffer to supply.
    973           *
    974           * @param   epBuf - pointer to mem used
    975           *
    976           * @return  void
    977           */

   \                                 In  segment CODE, align 2
    978          void afEndPoints( uint8 *epBuf, uint8 skipZDO )
   \                     afEndPoints:
    979          {
    980            epList_t *epSearch;
    981            uint8 endPoint;
    982          
    983            // Start at the beginning
    984            epSearch = epList;
   \   000000   1F42....     MOV.W   &epList, R15
   \   000004   0B3C         JMP     ??afEndPoints_1
    985          
    986            while ( epSearch )
    987            {
    988              endPoint = epSearch->epDesc->endPoint;
   \                     ??afEndPoints_0:
   \   000006   1E4F0200     MOV.W   0x2(R15), R14
   \   00000A   6E4E         MOV.B   @R14, R14
    989          
    990              if ( !skipZDO || endPoint != 0 )
   \   00000C   4D93         CMP.B   #0x0, R13
   \   00000E   0224         JEQ     ??afEndPoints_2
   \   000010   4E93         CMP.B   #0x0, R14
   \   000012   0324         JEQ     ??afEndPoints_3
    991                *epBuf++ = endPoint;
   \                     ??afEndPoints_2:
   \   000014   CC4E0000     MOV.B   R14, 0(R12)
   \   000018   1C53         ADD.W   #0x1, R12
    992          
    993              epSearch = epSearch->nextDesc;
   \                     ??afEndPoints_3:
   \   00001A   2F4F         MOV.W   @R15, R15
    994            }
   \                     ??afEndPoints_1:
   \   00001C   0F93         CMP.W   #0x0, R15
   \   00001E   F323         JNE     ??afEndPoints_0
    995          }
   \   000020   1001         RETA
    996          
    997          /*********************************************************************
    998           * @fn      afCopyAddress
    999           *
   1000           * @brief   Fills in the passed in afAddrType_t parameter with the corresponding information
   1001           *          from the zAddrType_t parameter.
   1002           *
   1003           * @param   epBuf - pointer to mem used
   1004           *
   1005           * @return  void
   1006           */

   \                                 In  segment CODE, align 2
   1007          void afCopyAddress( afAddrType_t *afAddr, zAddrType_t *zAddr )
   \                     afCopyAddress:
   1008          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
   1009            afAddr->addrMode = (afAddrMode_t)zAddr->addrMode;
   \   000004   DC4D08000800 MOV.B   0x8(R13), 0x8(R12)
   1010            if ( zAddr->addrMode == Addr64Bit )
   \   00000A   FD9003000800 CMP.B   #0x3, 0x8(R13)
   \   000010   0320         JNE     ??afCopyAddress_0
   1011            {
   1012              (void)osal_cpyExtAddr( afAddr->addr.extAddr, zAddr->addr.extAddr );
   \   000012   ........     CALLA   #sAddrExtCpy
   \   000016   023C         JMP     ??afCopyAddress_1
   1013            }
   1014            else
   1015            {
   1016              afAddr->addr.shortAddr = zAddr->addr.shortAddr;
   \                     ??afCopyAddress_0:
   \   000018   AC4D0000     MOV.W   @R13, 0(R12)
   1017            }
   1018          
   1019            // Since zAddrType_t has no INTER-PAN information, set the panId member to zero.
   1020            afAddr->panId = 0;
   \                     ??afCopyAddress_1:
   \   00001C   8A430A00     MOV.W   #0x0, 0xa(R10)
   1021          }
   \   000020   3A41         POP.W   R10
   \   000022   1001         RETA
   1022          
   1023          /**************************************************************************************************
   1024           * @fn          afAPSF_ConfigGet
   1025           *
   1026           * @brief       This function ascertains the fragmentation configuration that corresponds to
   1027           *              the specified EndPoint.
   1028           *
   1029           * input parameters
   1030           *
   1031           * @param       endPoint - The source EP of a Tx or destination EP of a Rx fragmented message.
   1032           *
   1033           * output parameters
   1034           *
   1035           * @param       pCfg - A pointer to an APSF configuration structure to fill with values.
   1036           *
   1037           * @return      None.
   1038           */

   \                                 In  segment CODE, align 2
   1039          void afAPSF_ConfigGet(uint8 endPoint, afAPSF_Config_t *pCfg)
   \                     afAPSF_ConfigGet:
   1040          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4D         MOV.W   R13, R10
   1041            epList_t *pList = afFindEndPointDescList(endPoint);
   \   000004   ........     CALLA   #afFindEndPointDescList
   \   000008   0D4C         MOV.W   R12, R13
   1042          
   1043            if (pList == NULL)
   \   00000A   0C93         CMP.W   #0x0, R12
   \   00000C   0620         JNE     ??afAPSF_ConfigGet_0
   1044            {
   1045              pCfg->frameDelay = APSF_DEFAULT_INTERFRAME_DELAY;
   \   00000E   FA4032000000 MOV.B   #0x32, 0(R10)
   1046              pCfg->windowSize = APSF_DEFAULT_WINDOW_SIZE;
   \   000014   DA430100     MOV.B   #0x1, 0x1(R10)
   \   000018   053C         JMP     ??afAPSF_ConfigGet_1
   1047            }
   1048            else
   1049            {
   1050              (void)osal_memcpy(pCfg, &pList->apsfCfg, sizeof(afAPSF_Config_t));
   \                     ??afAPSF_ConfigGet_0:
   \   00001A   2E43         MOV.W   #0x2, R14
   \   00001C   3D52         ADD.W   #0x8, R13
   \   00001E   0C4A         MOV.W   R10, R12
   \   000020   ........     CALLA   #osal_memcpy
   1051            }
   1052          }
   \                     ??afAPSF_ConfigGet_1:
   \   000024   3A41         POP.W   R10
   \   000026   1001         RETA
   1053          
   1054          /**************************************************************************************************
   1055           * @fn          afAPSF_ConfigSet
   1056           *
   1057           * @brief       This function attempts to set the fragmentation configuration that corresponds to
   1058           *              the specified EndPoint.
   1059           *
   1060           * input parameters
   1061           *
   1062           * @param       endPoint - The specific EndPoint for which to set the fragmentation configuration.
   1063           * @param       pCfg - A pointer to an APSF configuration structure to fill with values.
   1064           *
   1065           * output parameters
   1066           *
   1067           * None.
   1068           *
   1069           * @return      afStatus_SUCCESS for success.
   1070           *              afStatus_INVALID_PARAMETER if the specified EndPoint is not registered.
   1071           */

   \                                 In  segment CODE, align 2
   1072          afStatus_t afAPSF_ConfigSet(uint8 endPoint, afAPSF_Config_t *pCfg)
   \                     afAPSF_ConfigSet:
   1073          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4D         MOV.W   R13, R10
   1074            epList_t *pList = afFindEndPointDescList(endPoint);
   \   000004   ........     CALLA   #afFindEndPointDescList
   1075          
   1076            if (pList == NULL)
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0220         JNE     ??afAPSF_ConfigSet_0
   1077            {
   1078              return afStatus_INVALID_PARAMETER;
   \   00000C   6C43         MOV.B   #0x2, R12
   \   00000E   063C         JMP     ??afAPSF_ConfigSet_1
   1079            }
   1080          
   1081            (void)osal_memcpy(&pList->apsfCfg, pCfg, sizeof(afAPSF_Config_t));
   \                     ??afAPSF_ConfigSet_0:
   \   000010   2E43         MOV.W   #0x2, R14
   \   000012   0D4A         MOV.W   R10, R13
   \   000014   3C52         ADD.W   #0x8, R12
   \   000016   ........     CALLA   #osal_memcpy
   1082            return afStatus_SUCCESS;
   \   00001A   4C43         MOV.B   #0x0, R12
   \                     ??afAPSF_ConfigSet_1:
   \   00001C   3A41         POP.W   R10
   \   00001E   1001         RETA
   1083          }

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for AF_DataRequestDiscoverRoute>`:
   \   000000   01           DC8 1
   1084          
   1085          /**************************************************************************************************
   1086          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     54   AF_DataRequest
       54   -- Indirect call
       54   -> APSDE_DataReq
       54   -> NLME_GetShortAddr
       54   -> NLME_IsAddressBroadcast
       54   -> RTG_CheckRtStatus
       54   -> afDataConfirm
       54   -> afDataReqMTU
       54   -> osal_mem_free
       54   -> sAddrExtCpy
     28   AF_DataRequestSrcRtg
       28   -> AF_DataRequest
       20   -> RTG_AddSrcRtgEntry_Guaranteed
      6   afAPSF_ConfigGet
        6   -> afFindEndPointDescList
        6   -> osal_memcpy
      6   afAPSF_ConfigSet
        6   -> afFindEndPointDescList
        6   -> osal_memcpy
     24   afBuildMSGIncoming
       24   -> afCopyAddress
       24   -> osal_memcpy
       24   -> osal_msg_allocate
       24   -> osal_msg_send
      6   afCopyAddress
        6   -> sAddrExtCpy
     12   afDataConfirm
       12   -> afFindEndPointDesc
       12   -> osal_msg_allocate
       12   -> osal_msg_send
      6   afDataReqMTU
        6   -> APSDE_DataReqMTU
      6   afDelete
        6   -> osal_mem_free
      4   afEndPoints
      4   afFindEndPointDesc
        4   -> afFindEndPointDescList
      4   afFindEndPointDescList
     12   afFindSimpleDesc
       12   -- Indirect call
       12   -> afFindEndPointDescList
      4   afGetMatch
        4   -> afFindEndPointDescList
     36   afIncomingData
       26   -- Indirect call
       36   -> afBuildMSGIncoming
       26   -> afFindEndPointDesc
       26   -> afFindEndPointDescList
       26   -> aps_FindGroupForEndpoint
       26   -> osal_mem_free
      4   afNumEndPoints
      4   afRegister
        4   -> afFindEndPointDescList
        4   -> afRegisterExtended
     12   afRegisterExtended
       12   -> osal_mem_alloc
      6   afSetMatch
        6   -> afFindEndPointDescList


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for AF_DataRequestDiscoverRoute>
      10  ?Subroutine0
      14  ?Subroutine1
      10  ?Subroutine2
     436  AF_DataRequest
       1  AF_DataRequestDiscoverRoute
      86  AF_DataRequestSrcRtg
      40  afAPSF_ConfigGet
      32  afAPSF_ConfigSet
     194  afBuildMSGIncoming
      36  afCopyAddress
      56  afDataConfirm
      26  afDataReqMTU
      72  afDelete
      34  afEndPoints
      18  afFindEndPointDesc
      26  afFindEndPointDescList
      72  afFindSimpleDesc
      22  afGetMatch
     284  afIncomingData
      18  afNumEndPoints
      40  afRegister
      60  afRegisterExtended
      40  afSetMatch
       2  epList

 
 1 626 bytes in segment CODE
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
     2 bytes in segment DATA16_Z
 
 1 626 bytes of CODE  memory
     1 byte  of CONST memory
     3 bytes of DATA  memory

Errors: none
Warnings: none

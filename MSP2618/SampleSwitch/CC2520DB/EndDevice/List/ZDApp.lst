###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       10/Jun/2013  17:10:38 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\st #
#                     ack\zdo\ZDApp.c                                         #
#    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\..\To #
#                     ols\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0      #
#                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                       #
#                     -DDEFAULT_CHANLIST=0x00000800                           #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100      #
#                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                   #
#                     -DBEACON_REQUEST_DELAY=100                              #
#                     -DBEACON_REQ_DELAY_MASK=0x00FF                          #
#                     -DLINK_STATUS_JITTER_MASK=0x007F                        #
#                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED= #
#                     3000 -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8  #
#                     -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2     #
#                     -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9              #
#                     -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40                #
#                     -DNWK_MAX_BINDING_ENTRIES=4                             #
#                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,       #
#                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,   #
#                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                    #
#                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=2 #
#                     0 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000           #
#                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100         #
#                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wEndev.cfg" (-DCPU6MHZ -DMAC_CFG_TX_DATA_MAX=3         #
#                     -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "C:\Texas     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC          #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)                #
#                     -DZCL_DEVICE_MGMT "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Components\stack\zdo\Z #
#                     DApp.c" -D MSP430F2618 -D NWK_AUTO_POLL -D ZTOOL_P1 -D  #
#                     MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED  #
#                     -lC "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects #
#                     \zstack\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\ #
#                     List\" -lA "C:\Texas Instruments\ZStack-MSP2618-2.5.1\P #
#                     rojects\zstack\HomeAutomation\SampleSwitch\CC2520DB\End #
#                     Device\List\" --remarks --diag_suppress                 #
#                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\EndDevice\Obj\" --debug  #
#                     -D__MSP430F2618__ -e --double=32 --clib -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\" -I "C:\Texas           #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\Source\" -I           #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\..\..\Source\" #
#                      -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects #
#                     \zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\..\Z #
#                     Main\MSP2618\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\target\MSP2618CC2520\" -I "C:\Texas               #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\high_level\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\" -I "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\dual_chip\" -I "C:\Texas          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pr #
#                     ojects\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\. #
#                     .\..\..\..\Components\osal\include\" -I "C:\Texas       #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\osal\mcu\msp430\" -I "C:\Texas                        #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\saddr\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\sdata\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\af\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2520D #
#                     B\..\..\..\..\..\Components\stack\nwk\" -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sec\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sapi\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sys\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zcl\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zdo\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ #
#                     Projects\zstack\HomeAutomation\SampleSwitch\CC2520DB\.. #
#                     \..\..\..\..\Components\zmac\f8w\" --core=430X          #
#                     --data_model=small -Ohz --multiplier=16s                #
#                     --require_prototypes                                    #
#    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\List\ #
#                     ZDApp.lst                                               #
#    Object file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\Obj\Z #
#                     DApp.r43                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\stack\zdo\ZDApp.c
      1          /**************************************************************************************************
      2            Filename:       ZDApp.c
      3            Revised:        $Date: 2012-02-16 16:04:32 -0800 (Thu, 16 Feb 2012) $
      4            Revision:       $Revision: 29348 $
      5          
      6            Description:    This file contains the interface to the Zigbee Device Application. This is the
      7                            Application part that the user can change. This also contains the Task functions.
      8          
      9          
     10            Copyright 2004-2012 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          
     45          #include "ZComDef.h"
     46          #include "ZMac.h"
     47          #include "OSAL.h"
     48          #include "OSAL_Tasks.h"
     49          #include "OSAL_PwrMgr.h"
     50          #include "OSAL_Nv.h"
     51          #include "AF.h"
     52          #include "APSMEDE.h"
     53          #include "NLMEDE.h"
     54          #include "AddrMgr.h"
     55          #include "ZDProfile.h"
     56          #include "ZDObject.h"
     57          #include "ZDConfig.h"
     58          #include "ZDSecMgr.h"
     59          #include "ZDApp.h"
     60          #include "DebugTrace.h"
     61          #include "nwk_util.h"
     62          #include "OnBoard.h"
     63          #include "ZGlobals.h"
     64          #include "ZDNwkMgr.h"
     65          #include "rtg.h"
     66          
     67          #include "ssp.h"
     68          
     69          /* HAL */
     70          #include "hal_led.h"
     71          #include "hal_lcd.h"
     72          #include "hal_key.h"
     73          
     74          #if defined( MT_MAC_FUNC ) || defined( MT_MAC_CB_FUNC )
     75            #error "ERROR! MT_MAC functionalities should be disabled on ZDO devices"
     76          #endif
     77          
     78          /*********************************************************************
     79           * CONSTANTS
     80           */
     81          
     82          #if !defined( NWK_START_DELAY )
     83            #define NWK_START_DELAY             100   // in milliseconds
     84          #endif
     85          
     86          #if !defined( LEAVE_RESET_DELAY )
     87            #define LEAVE_RESET_DELAY           5000  // in milliseconds
     88          #endif
     89          
     90          // Init ZDO, but hold and wait for application to start the joining or
     91          // forming network
     92          #define ZDO_INIT_HOLD_NWK_START       0xFFFF
     93          
     94          #if !defined( EXTENDED_JOINING_RANDOM_MASK )
     95            #define EXTENDED_JOINING_RANDOM_MASK 0x007F
     96          #endif
     97          
     98          #if !defined( BEACON_REQUEST_DELAY )
     99            #define BEACON_REQUEST_DELAY        100   // in milliseconds
    100          #endif
    101          
    102          #if !defined( BEACON_REQ_DELAY_MASK )
    103            #define BEACON_REQ_DELAY_MASK       0x007F
    104          #endif
    105          
    106          #define MAX_RESUME_RETRY            3
    107          
    108          #define MAX_DEVICE_UNAUTH_TIMEOUT   5000  // 5 seconds
    109          
    110          // Beacon Order Settings (see NLMEDE.h)
    111          #define DEFAULT_BEACON_ORDER        BEACON_ORDER_NO_BEACONS
    112          #define DEFAULT_SUPERFRAME_ORDER    DEFAULT_BEACON_ORDER
    113          
    114          #if !defined( MAX_NWK_FRAMECOUNTER_CHANGES )
    115            // The number of times the frame counter can change before
    116            // saving to NV
    117            #define MAX_NWK_FRAMECOUNTER_CHANGES    1000
    118          #endif
    119          
    120          // Leave control bits
    121          #define ZDAPP_LEAVE_CTRL_INIT 0
    122          #define ZDAPP_LEAVE_CTRL_SET  1
    123          #define ZDAPP_LEAVE_CTRL_RA   2
    124          
    125          // Address Manager Stub Implementation
    126          #define ZDApp_NwkWriteNVRequest AddrMgrWriteNVRequest
    127          
    128          
    129          #if !defined ZDO_NV_SAVE_RFDs
    130          #define ZDO_NV_SAVE_RFDs  TRUE
    131          #endif
    132          
    133          // Delay time before updating NWK NV data to force fewer writes during high activity.
    134          #if ZDO_NV_SAVE_RFDs
    135          #define ZDAPP_UPDATE_NWK_NV_TIME 700
    136          #else
    137          #define ZDAPP_UPDATE_NWK_NV_TIME 65000
    138          #endif
    139          
    140          /*********************************************************************
    141           * GLOBAL VARIABLES
    142           */
    143          
    144          #if defined( LCD_SUPPORTED )

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    145            uint8 MatchRsps = 0;
   \                     MatchRsps:
   \   000000                DS8 1
    146          #endif
    147          

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    148          uint8 zdoDiscCounter = 1;
   \                     zdoDiscCounter:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for zdoDiscCounter>`
    149          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    150          zAddrType_t ZDAppNwkAddr;
   \                     ZDAppNwkAddr:
   \   000000                DS8 10
    151          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    152          uint8 zdappMgmtNwkDiscRspTransSeq;
   \                     zdappMgmtNwkDiscRspTransSeq:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    153          uint8 zdappMgmtNwkDiscReqInProgress = FALSE;
   \                     zdappMgmtNwkDiscReqInProgress:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    154          zAddrType_t zdappMgmtNwkDiscRspAddr;
   \                     zdappMgmtNwkDiscRspAddr:
   \   000000                DS8 10

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    155          uint8 zdappMgmtNwkDiscStartIndex;
   \                     zdappMgmtNwkDiscStartIndex:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    156          uint8 zdappMgmtSavedNwkState;
   \                     zdappMgmtSavedNwkState:
   \   000000                DS8 1
    157          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    158          uint16 nwkFrameCounterChanges = 0;
   \                     nwkFrameCounterChanges:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    159          uint8 continueJoining = TRUE;
   \                     continueJoining:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for continueJoining>`
    160          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    161          uint8  _tmpRejoinState;
   \                     _tmpRejoinState:
   \   000000                DS8 1
    162          
    163          // The extended PanID used in ZDO layer for rejoin.

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    164          uint8 ZDO_UseExtendedPANID[Z_EXTADDR_LEN];
   \                     ZDO_UseExtendedPANID:
   \   000000                DS8 8
    165          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    166          pfnZdoCb zdoCBFunc[MAX_ZDO_CB_FUNC];
   \                     zdoCBFunc:
   \   000000                DS8 28
    167          
    168          /*********************************************************************
    169           * EXTERNAL VARIABLES
    170           */
    171          
    172          /*********************************************************************
    173           * EXTERNAL FUNCTIONS
    174           */
    175          
    176          /*********************************************************************
    177           * LOCAL FUNCTIONS
    178           */
    179          
    180          void ZDApp_NetworkStartEvt( void );
    181          void ZDApp_DeviceAuthEvt( void );
    182          void ZDApp_SaveNetworkStateEvt( void );
    183          
    184          uint8 ZDApp_ReadNetworkRestoreState( void );
    185          uint8 ZDApp_RestoreNetworkState( void );
    186          void ZDAppDetermineDeviceType( void );
    187          void ZDApp_InitUserDesc( void );
    188          void ZDAppCheckForHoldKey( void );
    189          void ZDApp_ProcessOSALMsg( osal_event_hdr_t *msgPtr );
    190          void ZDApp_ProcessNetworkJoin( void );
    191          void ZDApp_SetCoordAddress( uint8 endPoint, uint8 dstEP );
    192          uint8 ZDApp_RestoreNwkKey( void );
    193          networkDesc_t* ZDApp_NwkDescListProcessing(void);
    194          
    195          void ZDApp_SecInit( uint8 state );
    196          UINT16 ZDApp_ProcessSecEvent( uint8 task_id, UINT16 events );
    197          void ZDApp_ProcessSecMsg( osal_event_hdr_t *msgPtr );
    198          
    199          void ZDApp_SendMsg( uint8 taskID, uint8 cmd, uint8 len, uint8 *buf );
    200          
    201          void ZDApp_ResetTimerStart( uint16 delay );
    202          void ZDApp_ResetTimerCancel( void );
    203          void ZDApp_LeaveCtrlInit( void );
    204          void ZDApp_LeaveCtrlSet( uint8 ra );
    205          uint8 ZDApp_LeaveCtrlBypass( void );
    206          void ZDApp_LeaveCtrlStartup( devStates_t* state, uint16* startDelay );
    207          void ZDApp_LeaveUpdate( uint16 nwkAddr, uint8* extAddr,
    208                                  uint8 removeChildren );
    209          void ZDApp_NodeProfileSync( uint8 stackProfile );
    210          void ZDApp_ProcessMsgCBs( zdoIncomingMsg_t *inMsg );
    211          void ZDApp_RegisterCBs( void );
    212          void ZDApp_InitZdoCBFunc(void);
    213          
    214          /*********************************************************************
    215           * LOCAL VARIABLES
    216           */
    217          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    218          uint8 ZDAppTaskID;
   \                     ZDAppTaskID:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    219          uint8 nwkStatus;
   \                     nwkStatus:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    220          endPointDesc_t *ZDApp_AutoFindMode_epDesc = (endPointDesc_t *)NULL;
   \                     ZDApp_AutoFindMode_epDesc:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    221          uint8 ZDApp_LeaveCtrl;
   \                     ZDApp_LeaveCtrl:
   \   000000                DS8 1
    222          
    223          #if defined( HOLD_AUTO_START )
    224            devStates_t devState = DEV_HOLD;
    225          #else

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    226            devStates_t devState = DEV_INIT;
   \                     devState:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for devState>`
    227          #endif
    228          
    229          #if ( ZG_BUILD_RTRONLY_TYPE ) || ( ZG_BUILD_ENDDEVICE_TYPE )

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    230            devStartModes_t devStartMode = MODE_JOIN;     // Assume joining
   \                     devStartMode:
   \   000000                DS8 1
    231            //devStartModes_t devStartMode = MODE_RESUME; // if already "directly joined"
    232                                  // to parent. Set to make the device do an Orphan scan.
    233          #else
    234            // Set the default to coodinator
    235            devStartModes_t devStartMode = MODE_HARD;
    236          #endif
    237          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    238          uint8 retryCnt;
   \                     retryCnt:
   \   000000                DS8 1
    239          

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    240          endPointDesc_t ZDApp_epDesc =
   \                     ZDApp_epDesc:
   \   000000                DS8 8
   \   000008                REQUIRE `?<Initializer for ZDApp_epDesc>`
    241          {
    242            ZDO_EP,
    243            &ZDAppTaskID,
    244            (SimpleDescriptionFormat_t *)NULL,  // No Simple description for ZDO
    245            (afNetworkLatencyReq_t)0            // No Network Latency req
    246          };
    247          

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    248          uint16 ZDApp_SavedPollRate = POLL_RATE;
   \                     ZDApp_SavedPollRate:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for ZDApp_SavedPollRate>`
    249          
    250          /*********************************************************************
    251           * @fn      ZDApp_Init
    252           *
    253           * @brief   ZDApp Initialization function.
    254           *
    255           * @param   task_id - ZDApp Task ID
    256           *
    257           * @return  None
    258           */

   \                                 In  segment CODE, align 2
    259          void ZDApp_Init( uint8 task_id )
   \                     ZDApp_Init:
    260          {
    261            // Save the task ID
    262            ZDAppTaskID = task_id;
   \   000000   C24C....     MOV.B   R12, &ZDAppTaskID
    263          
    264            // Initialize the ZDO global device short address storage
    265            ZDAppNwkAddr.addrMode = Addr16Bit;
   \   000004   E243....     MOV.B   #0x2, &ZDAppNwkAddr + 8
    266            ZDAppNwkAddr.addr.shortAddr = INVALID_NODE_ADDR;
   \   000008   B240FEFF.... MOV.W   #0xfffe, &ZDAppNwkAddr
    267            (void)NLME_GetExtAddr();  // Load the saveExtAddr pointer.
   \   00000E   ........     CALLA   #NLME_GetExtAddr
    268          
    269            // Check for manual "Hold Auto Start"
    270            ZDAppCheckForHoldKey();
   \   000012   ........     CALLA   #ZDAppCheckForHoldKey
    271          
    272            // Initialize ZDO items and setup the device - type of device to create.
    273            ZDO_Init();
   \   000016   ........     CALLA   #ZDO_Init
    274          
    275            // Register the endpoint description with the AF
    276            // This task doesn't have a Simple description, but we still need
    277            // to register the endpoint.
    278            afRegister( (endPointDesc_t *)&ZDApp_epDesc );
   \   00001A   3C40....     MOV.W   #ZDApp_epDesc, R12
   \   00001E   ........     CALLA   #afRegister
    279          
    280          #if defined( ZDO_USERDESC_RESPONSE )
    281            ZDApp_InitUserDesc();
   \   000022   ........     CALLA   #ZDApp_InitUserDesc
    282          #endif // ZDO_USERDESC_RESPONSE
    283          
    284            // Start the device?
    285            if ( devState != DEV_HOLD )
   \   000026   C293....     CMP.B   #0x0, &devState
   \   00002A   0424         JEQ     ??ZDApp_Init_0
    286            {
    287              ZDOInitDevice( 0 );
   \   00002C   0C43         MOV.W   #0x0, R12
   \   00002E   ........     CALLA   #ZDOInitDevice
   \   000032   0B3C         JMP     ??ZDApp_Init_1
    288            }
    289            else
    290            {
    291              ZDOInitDevice( ZDO_INIT_HOLD_NWK_START );
   \                     ??ZDApp_Init_0:
   \   000034   3C43         MOV.W   #0xffff, R12
   \   000036   ........     CALLA   #ZDOInitDevice
    292              // Blink LED to indicate HOLD_START
    293              HalLedBlink ( HAL_LED_4, 0, 50, 500 );
   \   00003A   3F40F401     MOV.W   #0x1f4, R15
   \   00003E   7E403200     MOV.B   #0x32, R14
   \   000042   4D43         MOV.B   #0x0, R13
   \   000044   7C42         MOV.B   #0x8, R12
   \   000046   ........     CALLA   #HalLedBlink
    294            }
    295          
    296            // Initialize the ZDO callback function pointers zdoCBFunc[]
    297            ZDApp_InitZdoCBFunc();
   \                     ??ZDApp_Init_1:
   \   00004A   ........     CALLA   #ZDApp_InitZdoCBFunc
    298          
    299            ZDApp_RegisterCBs();
   \   00004E   ........     BRA     #ZDApp_RegisterCBs
    300          } /* ZDApp_Init() */
    301          
    302          /*********************************************************************
    303           * @fn          ZDApp_SecInit
    304           *
    305           * @brief       ZDApp initialize security.
    306           *
    307           * @param       state - device initialization state
    308           *
    309           * @return      none
    310           */

   \                                 In  segment CODE, align 2
    311          void ZDApp_SecInit( uint8 state )
   \                     ZDApp_SecInit:
    312          {
    313            uint8 zgPreConfigKey[SEC_KEY_LEN];
    314          
    315            if ( ZG_SECURE_ENABLED && ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
    316            {
    317              // Set the Trust Center bit
    318              ZDO_Config_Node_Descriptor.ServerMask |= PRIM_TRUST_CENTER;
    319            }
    320          
    321            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
    322            {
    323              ZDO_Config_Node_Descriptor.CapabilityFlags |= CAPINFO_SECURITY_CAPABLE;
    324            }
    325          
    326            // Initialize ZigBee Device Security Manager
    327            ZDSecMgrInit(state);
   \   000000   ........     BRA     #ZDSecMgrInit
    328          
    329            if ( ZG_SECURE_ENABLED )
    330            {
    331              if ( state != ZDO_INITDEV_RESTORED_NETWORK_STATE )
    332              {
    333                nwkFrameCounter = 0;
    334          
    335                if( _NIB.nwkKeyLoaded == FALSE )
    336                {
    337                  if ( ( ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE          ) ||
    338                       ( ( zgSecurityMode == ZG_SECURITY_RESIDENTIAL ) && zgPreConfigKeys )    )
    339                  {
    340                      ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
    341                      SSP_UpdateNwkKey( zgPreConfigKey, 0);
    342                      SSP_SwitchNwkKey( 0 );
    343          
    344                      // clear local copy of key
    345                      osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
    346                  }
    347                }
    348              }
    349            }
    350          }
    351          
    352          /*********************************************************************
    353           * @fn      ZDApp_event_loop()
    354           *
    355           * @brief   Main event loop for Zigbee device objects task. This function
    356           *          should be called at periodic intervals.
    357           *
    358           * @param   task_id - Task ID
    359           * @param   events  - Bitmap of events
    360           *
    361           * @return  none
    362           */

   \                                 In  segment CODE, align 2
   \                     ??Subroutine7_0:
   \   000000   3D401000     MOV.W   #0x10, R13
   \   000004   5C42....     MOV.B   &ZDAppTaskID, R12
   \   000008   ........     BRA     #osal_set_event

   \                                 In  segment CODE, align 2
    363          UINT16 ZDApp_event_loop( uint8 task_id, UINT16 events )
   \                     ZDApp_event_loop:
    364          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4D         MOV.W   R13, R10
    365            uint8 *msg_ptr;
    366          
    367            if ( events & SYS_EVENT_MSG )
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   1838         JL      ??ZDApp_event_loop_2
    368            {
    369              while ( (msg_ptr = osal_msg_receive( ZDAppTaskID )) )
    370              {
    371                ZDApp_ProcessOSALMsg( (osal_event_hdr_t *)msg_ptr );
    372          
    373                // Release the memory
    374                osal_msg_deallocate( msg_ptr );
    375              }
    376          
    377              // Return unprocessed events
    378              return (events ^ SYS_EVENT_MSG);
    379            }
    380          
    381            if ( events & ZDO_NETWORK_INIT )
   \   000008   1DB3         BIT.W   #0x1, R13
   \   00000A   2028         JNC     ??ZDApp_event_loop_3
    382            {
    383              // Initialize apps and start the network
    384              devState = DEV_INIT;
   \   00000C   D243....     MOV.B   #0x1, &devState
    385              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   000010   ........     CALLA   #??Subroutine7_0
    386          
    387              ZDO_StartDevice( (uint8)ZDO_Config_Node_Descriptor.LogicalType, devStartMode,
    388                               DEFAULT_BEACON_ORDER, DEFAULT_SUPERFRAME_ORDER );
   \                     ??CrossCallReturnLabel_18:
   \   000014   7F400F00     MOV.B   #0xf, R15
   \   000018   4E4F         MOV.B   R15, R14
   \   00001A   5D42....     MOV.B   &devStartMode, R13
   \   00001E   5C42....     MOV.B   &ZDO_Config_Node_Descriptor, R12
   \   000022   7CF00700     AND.B   #0x7, R12
   \   000026   ........     CALLA   #ZDO_StartDevice
    389          
    390              // Return unprocessed events
    391              return (events ^ ZDO_NETWORK_INIT);
   \   00002A   1AE3         XOR.W   #0x1, R10
   \   00002C   2D3C         JMP     ??ZDApp_event_loop_1
    392            }
   \                     ??ZDApp_event_loop_0:
   \   00002E   ........     CALLA   #ZDApp_ProcessOSALMsg
   \   000032   0C4B         MOV.W   R11, R12
   \   000034   ........     CALLA   #osal_msg_deallocate
   \                     ??ZDApp_event_loop_2:
   \   000038   5C42....     MOV.B   &ZDAppTaskID, R12
   \   00003C   ........     CALLA   #osal_msg_receive
   \   000040   0B4C         MOV.W   R12, R11
   \   000042   0C93         CMP.W   #0x0, R12
   \   000044   F423         JNE     ??ZDApp_event_loop_0
   \   000046   3AE00080     XOR.W   #0x8000, R10
   \   00004A   1E3C         JMP     ??ZDApp_event_loop_1
    393          
    394            if ( ZSTACK_ROUTER_BUILD )
    395            {
    396              if ( events & ZDO_NETWORK_START )
    397              {
    398                ZDApp_NetworkStartEvt();
    399          
    400                // Return unprocessed events
    401                return (events ^ ZDO_NETWORK_START);
    402              }
    403          
    404              if ( events & ZDO_ROUTER_START )
    405              {
    406                if ( nwkStatus == ZSuccess )
    407                {
    408                  if ( devState == DEV_END_DEVICE )
    409                    devState = DEV_ROUTER;
    410          
    411                  osal_pwrmgr_device( PWRMGR_ALWAYS_ON );
    412                }
    413                else
    414                {
    415                  // remain as end device!!
    416                }
    417                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
    418          
    419                // Return unprocessed events
    420                return (events ^ ZDO_ROUTER_START);
    421              }
    422            }
    423          
    424            if ( events & ZDO_STATE_CHANGE_EVT )
   \                     ??ZDApp_event_loop_3:
   \   00004C   3DB01000     BIT.W   #0x10, R13
   \   000050   1228         JNC     ??ZDApp_event_loop_4
    425            {
    426              ZDO_UpdateNwkStatus( devState );
   \   000052   5C42....     MOV.B   &devState, R12
   \   000056   ........     CALLA   #ZDO_UpdateNwkStatus
    427          
    428              // At start up, do one MTO route discovery if the device is a concentrator
    429              if ( zgConcentratorEnable == TRUE )
   \   00005A   D293....     CMP.B   #0x1, &zgConcentratorEnable
   \   00005E   0820         JNE     ??ZDApp_event_loop_5
    430              {
    431                // Start next event
    432                osal_start_timerEx( NWK_TaskID, NWK_MTO_RTG_REQ_EVT, 100 );
   \   000060   3E406400     MOV.W   #0x64, R14
   \   000064   3D400008     MOV.W   #0x800, R13
   \   000068   5C42....     MOV.B   &NWK_TaskID, R12
   \   00006C   ........     CALLA   #osal_start_timerEx
    433              }
    434          
    435              // Return unprocessed events
    436              return (events ^ ZDO_STATE_CHANGE_EVT);
   \                     ??ZDApp_event_loop_5:
   \   000070   3AE01000     XOR.W   #0x10, R10
   \   000074   093C         JMP     ??ZDApp_event_loop_1
    437            }
    438          
    439            if ( events & ZDO_COMMAND_CNF )
   \                     ??ZDApp_event_loop_4:
   \   000076   3DB2         BIT.W   #0x8, R13
   \   000078   0228         JNC     ??ZDApp_event_loop_6
    440            {
    441              // User defined logic
    442          
    443              // Return unprocessed events
    444              return (events ^ ZDO_COMMAND_CNF);
   \   00007A   3AE2         XOR.W   #0x8, R10
   \   00007C   053C         JMP     ??ZDApp_event_loop_1
    445            }
    446          
    447            if ( events & ZDO_NWK_UPDATE_NV )
   \                     ??ZDApp_event_loop_6:
   \   00007E   3DB00002     BIT.W   #0x200, R13
   \   000082   0428         JNC     ??ZDApp_event_loop_7
    448            {
    449              ZDApp_SaveNetworkStateEvt();
    450          
    451              // Return unprocessed events
    452              return (events ^ ZDO_NWK_UPDATE_NV);
   \   000084   3AE00002     XOR.W   #0x200, R10
   \                     ??ZDApp_event_loop_1:
   \   000088   0C4A         MOV.W   R10, R12
   \   00008A   093C         JMP     ??ZDApp_event_loop_8
    453            }
    454          
    455            if ( events & ZDO_DEVICE_RESET )
   \                     ??ZDApp_event_loop_7:
   \   00008C   2DB2         BIT.W   #0x4, R13
   \   00008E   0628         JNC     ??ZDApp_event_loop_9
    456            {
    457          #ifdef ZBA_FALLBACK_NWKKEY
    458              if ( devState == DEV_END_DEVICE_UNAUTH )
    459              {
    460                ZDSecMgrFallbackNwkKey();
    461              }
    462              else
    463          #endif
    464              {
    465                // Set the NV startup option to force a "new" join.
    466                zgWriteStartupOptions( ZG_STARTUP_SET, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );
   \   000090   6D43         MOV.B   #0x2, R13
   \   000092   7C43         MOV.B   #0xff, R12
   \   000094   ........     CALLA   #zgWriteStartupOptions
    467          
    468                // The device has been in the UNAUTH state, so reset
    469                // Note: there will be no return from this call
    470                SystemResetSoft();
   \   000098   ........     CALLA   #Onboard_soft_reset
    471              }
    472            }
    473          
    474            if ( ZG_SECURE_ENABLED )
    475            {
    476              return ( ZDApp_ProcessSecEvent( task_id, events ) );
    477            }
    478            else
    479            {
    480              // Discard or make more handlers
    481              return 0;
   \                     ??ZDApp_event_loop_9:
   \   00009C   0C43         MOV.W   #0x0, R12
   \                     ??ZDApp_event_loop_8:
   \   00009E   1A17         POPM.W  #0x2, R11
   \   0000A0   1001         RETA
    482            }
    483          }
    484          
    485          /*********************************************************************
    486           * @fn      ZDApp_ProcessSecEvent()
    487           *
    488           * @brief   Process incoming security events.
    489           *
    490           * @param   task_id - Task ID
    491           * @param   events  - Bitmap of events
    492           *
    493           * @return  none
    494           */

   \                                 In  segment CODE, align 2
    495          UINT16 ZDApp_ProcessSecEvent( uint8 task_id, UINT16 events )
   \                     ZDApp_ProcessSecEvent:
    496          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4D         MOV.W   R13, R10
    497            (void)task_id;  // Intentionally unreferenced parameter
    498          
    499            if ( ZSTACK_ROUTER_BUILD )
    500            {
    501              if ( events & ZDO_NEW_DEVICE )
    502              {
    503                // process the new device event
    504                if ( ZDSecMgrNewDeviceEvent() == TRUE )
    505                {
    506                  osal_start_timerEx( ZDAppTaskID, ZDO_NEW_DEVICE, 1000 );
    507                }
    508          
    509                // Return unprocessed events
    510                return (events ^ ZDO_NEW_DEVICE);
    511              }
    512            }
    513          
    514            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
    515                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
    516            {
    517              if ( ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
    518              {
    519                if ( events & ZDO_SECMGR_EVENT )
    520                {
    521                  ZDSecMgrEvent();
    522          
    523                  // Return unprocessed events
    524                  return (events ^ ZDO_SECMGR_EVENT);
    525                }
    526              }
    527            }
    528          
    529            if ( events & ZDO_DEVICE_AUTH )
   \   000004   4D93         CMP.B   #0x0, R13
   \   000006   0534         JGE     ??ZDApp_ProcessSecEvent_1
    530            {
    531              ZDApp_DeviceAuthEvt();
   \   000008   ........     CALLA   #ZDApp_DeviceAuthEvt
    532          
    533              // Return unprocessed events
    534              return (events ^ ZDO_DEVICE_AUTH);
   \   00000C   3AE08000     XOR.W   #0x80, R10
   \   000010   1E3C         JMP     ??ZDApp_ProcessSecEvent_0
    535            }
    536          
    537            if ( events & ZDO_FRAMECOUNTER_CHANGE )
   \                     ??ZDApp_ProcessSecEvent_1:
   \   000012   3DB00004     BIT.W   #0x400, R13
   \   000016   0E28         JNC     ??ZDApp_ProcessSecEvent_2
    538            {
    539              if ( nwkFrameCounterChanges++ > MAX_NWK_FRAMECOUNTER_CHANGES )
   \   000018   1F42....     MOV.W   &nwkFrameCounterChanges, R15
   \   00001C   0E4F         MOV.W   R15, R14
   \   00001E   1E53         ADD.W   #0x1, R14
   \   000020   824E....     MOV.W   R14, &nwkFrameCounterChanges
   \   000024   3F90E903     CMP.W   #0x3e9, R15
   \   000028   0228         JNC     ??ZDApp_ProcessSecEvent_3
    540              {
    541                ZDApp_SaveNwkKey();
   \   00002A   ........     CALLA   #ZDApp_SaveNwkKey
    542              }
    543          
    544              // Return unprocessed events
    545              return (events ^ ZDO_FRAMECOUNTER_CHANGE);
   \                     ??ZDApp_ProcessSecEvent_3:
   \   00002E   3AE00004     XOR.W   #0x400, R10
   \   000032   0D3C         JMP     ??ZDApp_ProcessSecEvent_0
    546            }
    547          
    548            if ( events & ZDO_APS_FRAMECOUNTER_CHANGE )
   \                     ??ZDApp_ProcessSecEvent_2:
   \   000034   3DB00010     BIT.W   #0x1000, R13
   \   000038   0328         JNC     ??ZDApp_ProcessSecEvent_4
    549            {
    550          #if defined (NV_RESTORE)
    551              ZDSecMgrSaveApsLinkKey();
    552          #endif // (NV_RESTORE)
    553          
    554              // Return unprocessed events
    555              return (events ^ ZDO_APS_FRAMECOUNTER_CHANGE);
   \   00003A   3AE00010     XOR.W   #0x1000, R10
   \   00003E   073C         JMP     ??ZDApp_ProcessSecEvent_0
    556            }
    557          
    558            if ( events & ZDO_TCLK_FRAMECOUNTER_CHANGE )
   \                     ??ZDApp_ProcessSecEvent_4:
   \   000040   3DB00008     BIT.W   #0x800, R13
   \   000044   0628         JNC     ??ZDApp_ProcessSecEvent_5
    559            {
    560              ZDSecMgrSaveTCLinkKey();
   \   000046   ........     CALLA   #ZDSecMgrSaveTCLinkKey
    561          
    562              // Return unprocessed events
    563              return (events ^ ZDO_TCLK_FRAMECOUNTER_CHANGE);
   \   00004A   3AE00008     XOR.W   #0x800, R10
   \                     ??ZDApp_ProcessSecEvent_0:
   \   00004E   0C4A         MOV.W   R10, R12
   \   000050   013C         JMP     ??ZDApp_ProcessSecEvent_6
    564            }
    565          
    566            // Discard or make more handlers
    567            return 0;
   \                     ??ZDApp_ProcessSecEvent_5:
   \   000052   0C43         MOV.W   #0x0, R12
   \                     ??ZDApp_ProcessSecEvent_6:
   \   000054   3A41         POP.W   R10
   \   000056   1001         RETA
    568          }
    569          
    570          /*********************************************************************
    571           * Application Functions
    572           */
    573          
    574          /*********************************************************************
    575           * @fn      ZDOInitDevice
    576           *
    577           * @brief   Start the device in the network.  This function will read
    578           *   ZCD_NV_STARTUP_OPTION (NV item) to determine whether or not to
    579           *   restore the network state of the device.
    580           *
    581           * @param   startDelay - timeDelay to start device (in milliseconds).
    582           *                       There is a jitter added to this delay:
    583           *                       ((NWK_START_DELAY + startDelay)
    584           *                       + (osal_rand() & EXTENDED_JOINING_RANDOM_MASK))
    585           *                       When startDelay is set to ZDO_INIT_HOLD_NWK_START
    586           *                       this function will hold the network init. Application
    587           *                       can start the device.
    588           *
    589           * NOTE:    If the application would like to force a "new" join, the
    590           *          application should set the ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    591           *          bit in the ZCD_NV_STARTUP_OPTION NV item before calling
    592           *          this function. "new" join means to not restore the network
    593           *          state of the device. Use zgWriteStartupOptions() to set these
    594           *          options.
    595           *
    596           * @return
    597           *    ZDO_INITDEV_RESTORED_NETWORK_STATE  - The device's network state was
    598           *          restored.
    599           *    ZDO_INITDEV_NEW_NETWORK_STATE - The network state was initialized.
    600           *          This could mean that ZCD_NV_STARTUP_OPTION said to not restore, or
    601           *          it could mean that there was no network state to restore.
    602           *    ZDO_INITDEV_LEAVE_NOT_STARTED - Before the reset, a network leave was issued
    603           *          with the rejoin option set to TRUE.  So, the device was not
    604           *          started in the network (one time only).  The next time this
    605           *          function is called it will start.
    606           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   2153         ADD.W   #0x2, SP
   \   000002   3A41         POP.W   R10
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
    607          uint8 ZDOInitDevice( uint16 startDelay )
   \                     ZDOInitDevice:
    608          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0C12         PUSH.W  R12
    609            uint8 networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
    610            uint16 extendedDelay = 0;
    611          
    612            if ( devState == DEV_HOLD )
   \   000004   C293....     CMP.B   #0x0, &devState
   \   000008   0320         JNE     ??ZDOInitDevice_0
    613            {
    614              // Initialize the RAM items table, in case an NV item has been updated.
    615              zgInitItems( FALSE );
   \   00000A   4C43         MOV.B   #0x0, R12
   \   00000C   ........     CALLA   #zgInitItems
    616            }
    617          
    618            ZDConfig_InitDescriptors();
   \                     ??ZDOInitDevice_0:
   \   000010   ........     CALLA   #ZDConfig_InitDescriptors
    619            //devtag.071807.todo - fix this temporary solution
    620            _NIB.CapabilityFlags = ZDO_Config_Node_Descriptor.CapabilityFlags;
   \   000014   D242........ MOV.B   &ZDO_Config_Node_Descriptor + 2, &_NIB + 14
    621          
    622          #if defined ( NV_RESTORE )
    623            // Get Keypad directly to see if a reset nv is needed.
    624            // Hold down the SW_BYPASS_NV key (defined in OnBoard.h)
    625            // while booting to skip past NV Restore.
    626            if ( HalKeyRead() == SW_BYPASS_NV )
    627              networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
    628            else
    629            {
    630              // Determine if NV should be restored
    631              networkStateNV = ZDApp_ReadNetworkRestoreState();
    632            }
    633          
    634            if ( networkStateNV == ZDO_INITDEV_RESTORED_NETWORK_STATE )
    635            {
    636              networkStateNV = ZDApp_RestoreNetworkState();
    637            }
    638            else
    639            {
    640              // Wipe out the network state in NV
    641              NLME_InitNV();
    642              NLME_SetDefaultNV();
    643              // clear NWK key values
    644              ZDSecMgrClearNVKeyValues();
    645            }
    646          #endif
    647          
    648            if ( networkStateNV == ZDO_INITDEV_NEW_NETWORK_STATE )
    649            {
    650              ZDAppDetermineDeviceType();
   \   00001A   ........     CALLA   #ZDAppDetermineDeviceType
    651          
    652              // Only delay if joining network - not restoring network state
    653              extendedDelay = (uint16)((NWK_START_DELAY + startDelay)
    654                        + (osal_rand() & EXTENDED_JOINING_RANDOM_MASK));
   \   00001E   ........     CALLA   #osal_rand
   \   000022   0A4C         MOV.W   R12, R10
   \   000024   3AF07F00     AND.W   #0x7f, R10
   \   000028   2A51         ADD.W   @SP, R10
   \   00002A   3A506400     ADD.W   #0x64, R10
    655            }
    656          
    657            // Initialize the security for type of device
    658            ZDApp_SecInit( networkStateNV );
   \   00002E   5C43         MOV.B   #0x1, R12
   \   000030   ........     CALLA   #ZDSecMgrInit
    659          
    660            if( ZDO_INIT_HOLD_NWK_START != startDelay )
   \   000034   B1930000     CMP.W   #0xffff, 0(SP)
   \   000038   1824         JEQ     ??ZDOInitDevice_1
    661            {
    662              devState = DEV_INIT;    // Remove the Hold state
   \   00003A   D243....     MOV.B   #0x1, &devState
    663          
    664              // Initialize leave control logic
    665              ZDApp_LeaveCtrlInit();
   \   00003E   ........     CALLA   #ZDApp_LeaveCtrlInit
    666          
    667              // Check leave control reset settings
    668              ZDApp_LeaveCtrlStartup( &devState, &startDelay );
   \   000042   0D41         MOV.W   SP, R13
   \   000044   0D53         ADD.W   #0x0, R13
   \   000046   3C40....     MOV.W   #devState, R12
   \   00004A   ........     CALLA   #ZDApp_LeaveCtrlStartup
    669          
    670              // Leave may make the hold state come back
    671              if ( devState == DEV_HOLD )
   \   00004E   C293....     CMP.B   #0x0, &devState
   \   000052   0820         JNE     ??ZDOInitDevice_2
    672              {
    673                // Set the NV startup option to force a "new" join.
    674                zgWriteStartupOptions( ZG_STARTUP_SET, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );
   \   000054   6D43         MOV.B   #0x2, R13
   \   000056   7C43         MOV.B   #0xff, R12
   \   000058   ........     CALLA   #zgWriteStartupOptions
    675          
    676                // Notify the applications
    677                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   00005C   ........     CALLA   #??Subroutine7_0
    678          
    679                return ( ZDO_INITDEV_LEAVE_NOT_STARTED );   // Don't join - (one time).
   \                     ??CrossCallReturnLabel_19:
   \   000060   6C43         MOV.B   #0x2, R12
   \   000062   083C         JMP     ??ZDOInitDevice_3
    680              }
    681          
    682              // Trigger the network start
    683              ZDApp_NetworkInit( extendedDelay );
   \                     ??ZDOInitDevice_2:
   \   000064   0C4A         MOV.W   R10, R12
   \   000066   ........     CALLA   #ZDApp_NetworkInit
    684            }
    685          
    686            // set broadcast address mask to support broadcast filtering
    687            NLME_SetBroadcastFilter( ZDO_Config_Node_Descriptor.CapabilityFlags );
   \                     ??ZDOInitDevice_1:
   \   00006A   5C42....     MOV.B   &ZDO_Config_Node_Descriptor + 2, R12
   \   00006E   ........     CALLA   #NLME_SetBroadcastFilter
    688          
    689            return ( networkStateNV );
   \   000072   5C43         MOV.B   #0x1, R12
   \                     ??ZDOInitDevice_3:
   \   000074   ....         JMP     ?Subroutine1
    690          }
    691          
    692          /*********************************************************************
    693           * @fn      ZDApp_ReadNetworkRestoreState
    694           *
    695           * @brief   Read the ZCD_NV_STARTUP_OPTION NV Item to state whether
    696           *          or not to restore the network state.
    697           *          If the read value has the ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    698           *          bit set return the ZDO_INITDEV_NEW_NETWORK_STATE.
    699           *
    700           * @param   none
    701           *
    702           * @return  ZDO_INITDEV_NEW_NETWORK_STATE
    703           *          or ZDO_INITDEV_RESTORED_NETWORK_STATE based on whether or
    704           *          not ZCD_STARTOPT_DEFAULT_NETWORK_STATE bit is set in
    705           *          ZCD_NV_STARTUP_OPTION
    706           */

   \                                 In  segment CODE, align 2, keep-with-next
    707          uint8 ZDApp_ReadNetworkRestoreState( void )
   \                     ZDApp_ReadNetworkRestoreState:
    708          {
   \   000000   0A12         PUSH.W  R10
    709            uint8 networkStateNV = ZDO_INITDEV_RESTORED_NETWORK_STATE;
   \   000002   4A43         MOV.B   #0x0, R10
    710          
    711            // Look for the New Network State option.
    712            if ( zgReadStartupOptions() & ZCD_STARTOPT_DEFAULT_NETWORK_STATE )
   \   000004   ........     CALLA   #zgReadStartupOptions
   \   000008   6CB3         BIT.B   #0x2, R12
   \   00000A   0128         JNC     ??ZDApp_ReadNetworkRestoreState_0
    713            {
    714              networkStateNV = ZDO_INITDEV_NEW_NETWORK_STATE;
   \   00000C   5A43         MOV.B   #0x1, R10
    715            }
    716          
    717            return ( networkStateNV );
   \                     ??ZDApp_ReadNetworkRestoreState_0:
   \   00000E   4C4A         MOV.B   R10, R12
   \   000010   3A41         POP.W   R10
   \   000012   1001         RETA
    718          }
    719          
    720          /*********************************************************************
    721           * @fn      ZDAppDetermineDeviceType()
    722           *
    723           * @brief   Determines the type of device to start.
    724           *
    725           *          Looks at zgDeviceLogicalType and determines what type of
    726           *          device to start.  The types are:
    727           *            ZG_DEVICETYPE_COORDINATOR
    728           *            ZG_DEVICETYPE_ROUTER
    729           *            ZG_DEVICETYPE_ENDDEVICE
    730           *
    731           * @param   none
    732           *
    733           * @return  none
    734           */

   \                                 In  segment CODE, align 2, keep-with-next
    735          void ZDAppDetermineDeviceType( void )
   \                     ZDAppDetermineDeviceType:
    736          {
    737            if ( zgDeviceLogicalType == ZG_DEVICETYPE_COORDINATOR )
   \   000000   5E42....     MOV.B   &zgDeviceLogicalType, R14
   \   000004   4E93         CMP.B   #0x0, R14
   \   000006   0520         JNE     ??ZDAppDetermineDeviceType_1
    738            {
    739              devStartMode = MODE_HARD;     // Start as a coordinator
   \   000008   6E43         MOV.B   #0x2, R14
    740              ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
   \   00000A   F2F0F800.... AND.B   #0xf8, &ZDO_Config_Node_Descriptor
   \   000010   173C         JMP     ??ZDAppDetermineDeviceType_0
    741            }
    742            else
    743            {
    744              if ( zgDeviceLogicalType == ZG_DEVICETYPE_ROUTER  )
   \                     ??ZDAppDetermineDeviceType_1:
   \   000012   5F42....     MOV.B   &ZDO_Config_Node_Descriptor, R15
   \   000016   7FF0F800     AND.B   #0xf8, R15
   \   00001A   5E93         CMP.B   #0x1, R14
   \   00001C   0220         JNE     ??ZDAppDetermineDeviceType_2
    745                ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_ROUTER;
   \   00001E   5FD3         BIS.B   #0x1, R15
   \   000020   033C         JMP     ??ZDAppDetermineDeviceType_3
    746              else if ( zgDeviceLogicalType == ZG_DEVICETYPE_ENDDEVICE )
   \                     ??ZDAppDetermineDeviceType_2:
   \   000022   6E93         CMP.B   #0x2, R14
   \   000024   0320         JNE     ??ZDAppDetermineDeviceType_4
    747                ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_DEVICE;
   \   000026   6FD3         BIS.B   #0x2, R15
   \                     ??ZDAppDetermineDeviceType_3:
   \   000028   C24F....     MOV.B   R15, &ZDO_Config_Node_Descriptor
    748          
    749              // If AIB_apsUseExtendedPANID is set to a non-zero value by commissioning
    750              // The device shall do rejoin the network. Otherwise, do normal join
    751              if ( nwk_ExtPANIDValid( AIB_apsUseExtendedPANID ) == false )
   \                     ??ZDAppDetermineDeviceType_4:
   \   00002C   3C40....     MOV.W   #AIB_apsUseExtendedPANID, R12
   \   000030   ........     CALLA   #nwk_ExtPANIDValid
   \   000034   4C93         CMP.B   #0x0, R12
   \   000036   0324         JEQ     ??ZDAppDetermineDeviceType_5
   \   000038   7E400300     MOV.B   #0x3, R14
   \   00003C   013C         JMP     ??ZDAppDetermineDeviceType_0
   \                     ??ZDAppDetermineDeviceType_5:
   \   00003E   4E43         MOV.B   #0x0, R14
   \                     ??ZDAppDetermineDeviceType_0:
   \   000040   C24E....     MOV.B   R14, &devStartMode
    752              {
    753                devStartMode = MODE_JOIN;     // Assume joining
    754              }
    755              else
    756              {
    757                devStartMode = MODE_REJOIN;
    758              }
    759            }
    760          }
   \   000044   1001         RETA
    761          
    762          /*********************************************************************
    763           * @fn      ZDApp_NetworkStartEvt()
    764           *
    765           * @brief   Process the Network Start Event
    766           *
    767           * @param   none
    768           *
    769           * @return  none
    770           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   5C42....     MOV.B   &ZDAppTaskID, R12
   \   000004   ........     BRA     #osal_set_event

   \                                 In  segment CODE, align 2, keep-with-next
    771          void ZDApp_NetworkStartEvt( void )
   \                     ZDApp_NetworkStartEvt:
    772          {
    773            if ( nwkStatus == ZSuccess )
   \   000000   C293....     CMP.B   #0x0, &nwkStatus
   \   000004   0A20         JNE     ??ZDApp_NetworkStartEvt_0
    774            {
    775              // Successfully started a ZigBee network
    776              if ( devState == DEV_COORD_STARTING )
   \   000006   F292....     CMP.B   #0x8, &devState
   \   00000A   0320         JNE     ??ZDApp_NetworkStartEvt_1
    777              {
    778                devState = DEV_ZB_COORD;
   \   00000C   F2400900.... MOV.B   #0x9, &devState
    779              }
    780          
    781              osal_pwrmgr_device( PWRMGR_ALWAYS_ON );
   \                     ??ZDApp_NetworkStartEvt_1:
   \   000012   4C43         MOV.B   #0x0, R12
   \   000014   ........     CALLA   #osal_pwrmgr_device
    782              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   000018   123C         JMP     ??ZDApp_NetworkStartEvt_2
    783            }
    784            else
    785            {
    786              // Try again with a higher energy threshold !!
    787              if ( ( NLME_GetEnergyThreshold() + ENERGY_SCAN_INCREMENT ) < 0xff )
   \                     ??ZDApp_NetworkStartEvt_0:
   \   00001A   ........     CALLA   #NLME_GetEnergyThreshold
   \   00001E   4C4C         MOV.B   R12, R12
   \   000020   3C501000     ADD.W   #0x10, R12
   \   000024   3C90FF00     CMP.W   #0xff, R12
   \   000028   0834         JGE     ??ZDApp_NetworkStartEvt_3
    788              {
    789                NLME_SetEnergyThreshold( (uint8)(NLME_GetEnergyThreshold() + ENERGY_SCAN_INCREMENT) );
   \   00002A   ........     CALLA   #NLME_GetEnergyThreshold
   \   00002E   7C501000     ADD.B   #0x10, R12
   \   000032   ........     CALLA   #NLME_SetEnergyThreshold
    790                osal_set_event( ZDAppTaskID, ZDO_NETWORK_INIT );
   \   000036   1D43         MOV.W   #0x1, R13
   \   000038   043C         JMP     ??ZDApp_NetworkStartEvt_4
    791              }
    792              else
    793              {
    794                // Failed to start network. Enter a dormant state (until user intervenes)
    795                devState = DEV_INIT;
   \                     ??ZDApp_NetworkStartEvt_3:
   \   00003A   D243....     MOV.B   #0x1, &devState
    796                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \                     ??ZDApp_NetworkStartEvt_2:
   \   00003E   3D401000     MOV.W   #0x10, R13
    797              }
    798            }
   \                     ??ZDApp_NetworkStartEvt_4:
   \   000042   ........     BRA     #?Subroutine3
    799          }
    800          
    801          /*********************************************************************
    802           * @fn      ZDApp_DeviceAuthEvt()
    803           *
    804           * @brief   Process the Device Authentic Event
    805           *
    806           * @param   none
    807           *
    808           * @return  none
    809           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   F2400600.... MOV.B   #0x6, &devState
   \   000006                REQUIRE ??Subroutine7_0
   \   000006                // Fall through to label ??Subroutine7_0

   \                                 In  segment CODE, align 2, keep-with-next
    810          void ZDApp_DeviceAuthEvt( void )
   \                     ZDApp_DeviceAuthEvt:
    811          {
    812            // received authentication from trust center
    813            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000000   F2900500.... CMP.B   #0x5, &devState
   \   000006   0F20         JNE     ??ZDApp_DeviceAuthEvt_0
    814            {
    815              // Stop the reset timer so it doesn't reset
    816              ZDApp_ResetTimerCancel();
   \   000008   ........     CALLA   #ZDApp_ResetTimerCancel
    817          
    818              devState = DEV_END_DEVICE;
   \   00000C   ........     CALLA   #?Subroutine7
    819              osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
    820          
    821              // Set the Power Manager Device
    822          #if defined ( POWER_SAVING )
    823              osal_pwrmgr_device( PWRMGR_BATTERY );
    824          #endif
    825          
    826              if ( ZSTACK_ROUTER_BUILD )
    827              {
    828                if ( ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
    829                {
    830                  // NOTE: first two parameters are not used, see NLMEDE.h for details
    831                  NLME_StartRouterRequest( 0, 0, false );
    832                }
    833              }
    834          
    835              // Notify to save info into NV
    836              ZDApp_NVUpdate();
    837          
    838              // Save off the security
    839              ZDApp_SaveNwkKey();
   \                     ??CrossCallReturnLabel_22:
   \   000010   ........     CALLA   #ZDApp_SaveNwkKey
    840          
    841              ZDApp_AnnounceNewAddress();
   \   000014   ........     CALLA   #ZDApp_AnnounceNewAddress
    842          
    843              if ( (ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE) == 0 )
   \   000018   F2B2....     BIT.B   #0x8, &ZDO_Config_Node_Descriptor + 2
   \   00001C   042C         JC      ??ZDApp_DeviceAuthEvt_0
    844              {
    845                NLME_SetPollRate( ZDApp_SavedPollRate );
   \   00001E   1C42....     MOV.W   &ZDApp_SavedPollRate, R12
   \   000022   ........     CALLA   #NLME_SetPollRate
    846              }
    847            }
    848            else
    849            {
    850              ZDApp_NVUpdate();
    851            }
    852          }
   \                     ??ZDApp_DeviceAuthEvt_0:
   \   000026   1001         RETA
    853          
    854          /*********************************************************************
    855           * @fn      ZDApp_SaveNetworkStateEvt()
    856           *
    857           * @brief   Process the Save the Network State Event
    858           *
    859           * @param   none
    860           *
    861           * @return  none
    862           */

   \                                 In  segment CODE, align 2, keep-with-next
    863          void ZDApp_SaveNetworkStateEvt( void )
   \                     ZDApp_SaveNetworkStateEvt:
    864          {
    865          #if defined ( NV_RESTORE )
    866           #if defined ( NV_TURN_OFF_RADIO )
    867            // Turn off the radio's receiver during an NV update
    868            uint8 RxOnIdle;
    869            uint8 x = false;
    870            ZMacGetReq( ZMacRxOnIdle, &RxOnIdle );
    871            ZMacSetReq( ZMacRxOnIdle, &x );
    872           #endif
    873          
    874            // Update the Network State in NV
    875            NLME_UpdateNV( NWK_NV_NIB_ENABLE        |
    876                           NWK_NV_DEVICELIST_ENABLE |
    877                           NWK_NV_BINDING_ENABLE    |
    878                           NWK_NV_ADDRMGR_ENABLE );
    879          
    880            // Reset the NV startup option to resume from NV by
    881            // clearing the "New" join option.
    882            zgWriteStartupOptions( FALSE, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );
    883          
    884           #if defined ( NV_TURN_OFF_RADIO )
    885            ZMacSetReq( ZMacRxOnIdle, &RxOnIdle );
    886           #endif
    887          #endif  // NV_RESTORE
    888          }
   \   000000   1001         RETA
    889          
    890          /*********************************************************************
    891           * @fn      ZDApp_RestoreNetworkState()
    892           *
    893           * @brief   This function will restore the network state of the
    894           *          device if the network state is stored in NV.
    895           *
    896           * @param   none
    897           *
    898           * @return
    899           *    ZDO_INITDEV_RESTORED_NETWORK_STATE  - The device's network state was
    900           *          restored.
    901           *    ZDO_INITDEV_NEW_NETWORK_STATE - The network state was not used.
    902           *          This could mean that zgStartupOption said to not restore, or
    903           *          it could mean that there was no network state to restore.
    904           *
    905           */

   \                                 In  segment CODE, align 2, keep-with-next
    906          uint8 ZDApp_RestoreNetworkState( void )
   \                     ZDApp_RestoreNetworkState:
    907          {
   \   000000   0A12         PUSH.W  R10
    908            uint8 nvStat;
    909          
    910            // Initialize NWK NV items
    911            nvStat = NLME_InitNV();
   \   000002   ........     CALLA   #NLME_InitNV
   \   000006   4A4C         MOV.B   R12, R10
    912          
    913            if ( nvStat != NV_OPER_FAILED )
   \   000008   7C900A00     CMP.B   #0xa, R12
   \   00000C   1524         JEQ     ??ZDApp_RestoreNetworkState_0
    914            {
    915              if ( NLME_RestoreFromNV() )
   \   00000E   ........     CALLA   #NLME_RestoreFromNV
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   1124         JEQ     ??ZDApp_RestoreNetworkState_0
    916              {
    917                // Are we a coordinator
    918                ZDAppNwkAddr.addr.shortAddr = NLME_GetShortAddr();
   \   000016   ........     CALLA   #NLME_GetShortAddr
   \   00001A   824C....     MOV.W   R12, &ZDAppNwkAddr
    919                if ( ZDAppNwkAddr.addr.shortAddr == 0 )
   \   00001E   0C93         CMP.W   #0x0, R12
   \   000020   0320         JNE     ??ZDApp_RestoreNetworkState_1
    920                  ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_COORDINATOR;
   \   000022   F2F0F800.... AND.B   #0xf8, &ZDO_Config_Node_Descriptor
    921                devStartMode = MODE_RESUME;
   \                     ??ZDApp_RestoreNetworkState_1:
   \   000028   D243....     MOV.B   #0x1, &devStartMode
    922                osal_cpyExtAddr( ZDO_UseExtendedPANID, _NIB.extendedPANID );
   \   00002C   ........     CALLA   #?Subroutine15
    923              }
    924              else
    925                nvStat = NV_ITEM_UNINIT;
    926          
    927              if ( ZG_SECURE_ENABLED )
    928              {
    929                nwkFrameCounterChanges = 0;
    930          
    931                if ( ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
    932                {
    933                  ZDApp_RestoreNwkKey();
    934                }
    935              }
    936          
    937              // The default for RxOnWhenIdle is true for Routers and false for end devices
    938              // [setup in the NLME_RestoreFromNV()].  Change it here if you want something
    939              // other than default.
    940            }
    941          
    942            if ( nvStat == ZSUCCESS )
   \                     ??CrossCallReturnLabel_12:
   \   000030   4A93         CMP.B   #0x0, R10
   \   000032   0220         JNE     ??ZDApp_RestoreNetworkState_0
    943              return ( ZDO_INITDEV_RESTORED_NETWORK_STATE );
   \   000034   4C43         MOV.B   #0x0, R12
   \   000036   013C         JMP     ??ZDApp_RestoreNetworkState_2
    944            else
    945              return ( ZDO_INITDEV_NEW_NETWORK_STATE );
   \                     ??ZDApp_RestoreNetworkState_0:
   \   000038   5C43         MOV.B   #0x1, R12
   \                     ??ZDApp_RestoreNetworkState_2:
   \   00003A   3A41         POP.W   R10
   \   00003C   1001         RETA
    946          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine15:
   \   000000   3D40....     MOV.W   #_NIB + 57, R13
   \   000004   3C40....     MOV.W   #ZDO_UseExtendedPANID, R12
   \   000008   ........     BRA     #sAddrExtCpy
    947          
    948          /*********************************************************************
    949           * @fn      ZDApp_InitUserDesc()
    950           *
    951           * @brief   Initialize the User Descriptor, the descriptor is read from NV
    952           *          when needed.  If you want to initialize the User descriptor to
    953           *          something other than all zero, do it here.
    954           *
    955           * @param   none
    956           *
    957           * @return  none
    958           */

   \                                 In  segment CODE, align 2, keep-with-next
    959          void ZDApp_InitUserDesc( void )
   \                     ZDApp_InitUserDesc:
    960          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31801200     SUB.W   #0x12, SP
    961            UserDescriptorFormat_t ZDO_DefaultUserDescriptor;
    962          
    963            // Initialize the User Descriptor, the descriptor is read from NV
    964            // when needed.  If you want to initialize the User descriptor to something
    965            // other than all zero, do it here.
    966            osal_memset( &ZDO_DefaultUserDescriptor, 0, sizeof( UserDescriptorFormat_t ) );
   \   000006   0A41         MOV.W   SP, R10
   \   000008   0A53         ADD.W   #0x0, R10
   \   00000A   3E401100     MOV.W   #0x11, R14
   \   00000E   4D43         MOV.B   #0x0, R13
   \   000010   0C4A         MOV.W   R10, R12
   \   000012   ........     CALLA   #osal_memset
    967            if ( ZSUCCESS == osal_nv_item_init( ZCD_NV_USERDESC,
    968                   sizeof(UserDescriptorFormat_t), (void*)&ZDO_DefaultUserDescriptor ) )
   \   000016   0E4A         MOV.W   R10, R14
   \   000018   3D401100     MOV.W   #0x11, R13
   \   00001C   3C408100     MOV.W   #0x81, R12
   \   000020   ........     CALLA   #osal_nv_item_init
   \   000024   4C93         CMP.B   #0x0, R12
   \   000026   1020         JNE     ??ZDApp_InitUserDesc_0
    969            {
    970              if ( ZSUCCESS == osal_nv_read( ZCD_NV_USERDESC, 0,
    971                   sizeof(UserDescriptorFormat_t), (void*)&ZDO_DefaultUserDescriptor ) )
   \   000028   0F4A         MOV.W   R10, R15
   \   00002A   3E401100     MOV.W   #0x11, R14
   \   00002E   0D43         MOV.W   #0x0, R13
   \   000030   3C408100     MOV.W   #0x81, R12
   \   000034   ........     CALLA   #osal_nv_read
   \   000038   4C93         CMP.B   #0x0, R12
   \   00003A   0620         JNE     ??ZDApp_InitUserDesc_0
    972              {
    973                if ( ZDO_DefaultUserDescriptor.len != 0 )
   \   00003C   C1930000     CMP.B   #0x0, 0(SP)
   \   000040   0324         JEQ     ??ZDApp_InitUserDesc_0
    974                {
    975                  ZDO_Config_Node_Descriptor.UserDescAvail = TRUE;
   \   000042   F2D01000.... BIS.B   #0x10, &ZDO_Config_Node_Descriptor
    976                }
    977              }
    978            }
    979          }
   \                     ??ZDApp_InitUserDesc_0:
   \   000048   31501200     ADD.W   #0x12, SP
   \   00004C   3A41         POP.W   R10
   \   00004E   1001         RETA
    980          
    981          /*********************************************************************
    982           * @fn      ZDAppCheckForHoldKey()
    983           *
    984           * @brief   Check for key to set the device into Hold Auto Start
    985           *
    986           * @param   none
    987           *
    988           * @return  none
    989           */

   \                                 In  segment CODE, align 2, keep-with-next
    990          void ZDAppCheckForHoldKey( void )
   \                     ZDAppCheckForHoldKey:
    991          {
    992          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
    993            // Get Keypad directly to see if a HOLD_START is needed.
    994            // Hold down the SW_BYPASS_START key (see OnBoard.h)
    995            // while booting to avoid starting up the device.
    996            if ( HalKeyRead () == SW_BYPASS_START)
   \   000000   ........     CALLA   #HalKeyRead
   \   000004   5C93         CMP.B   #0x1, R12
   \   000006   0220         JNE     ??ZDAppCheckForHoldKey_0
    997            {
    998              // Change the device state to HOLD on start up
    999              devState = DEV_HOLD;
   \   000008   C243....     MOV.B   #0x0, &devState
   1000            }
   1001          #endif // HAL_KEY
   1002          }
   \                     ??ZDAppCheckForHoldKey_0:
   \   00000C   1001         RETA
   1003          
   1004          /*********************************************************************
   1005           * @fn      ZDApp_ProcessOSALMsg()
   1006           *
   1007           * @brief   Process the incoming task message.
   1008           *
   1009           * @param   msgPtr - message to process
   1010           *
   1011           * @return  none
   1012           */

   \                                 In  segment CODE, align 2, keep-with-next
   1013          void ZDApp_ProcessOSALMsg( osal_event_hdr_t *msgPtr )
   \                     ZDApp_ProcessOSALMsg:
   1014          {
   \   000000   0A12         PUSH.W  R10
   \   000002   2183         SUB.W   #0x2, SP
   1015            // Data Confirmation message fields
   1016            uint8 sentEP;       // This should always be 0
   1017            uint8 sentStatus;
   1018            afDataConfirm_t *afDataConfirm;
   1019            uint8 tmp;
   1020          
   1021            switch ( msgPtr->event )
   \   000004   5E42....     MOV.B   &zgDeviceLogicalType, R14
   \   000008   6F4C         MOV.B   @R12, R15
   \   00000A   5F83         SUB.B   #0x1, R15
   \   00000C   1124         JEQ     ??ZDApp_ProcessOSALMsg_0
   \   00000E   5F83         SUB.B   #0x1, R15
   \   000010   7C24         JEQ     ??ZDApp_ProcessOSALMsg_1
   \   000012   5F83         SUB.B   #0x1, R15
   \   000014   8124         JEQ     ??ZDApp_ProcessOSALMsg_2
   \   000016   7F801700     SUB.B   #0x17, R15
   \   00001A   0424         JEQ     ??ZDApp_ProcessOSALMsg_3
   \   00001C   7F80B900     SUB.B   #0xb9, R15
   \   000020   0424         JEQ     ??ZDApp_ProcessOSALMsg_4
   \   000022   8B3C         JMP     ??ZDApp_ProcessOSALMsg_5
   1022            {
   1023              // Incoming ZDO Message
   1024              case AF_INCOMING_MSG_CMD:
   1025                ZDP_IncomingData( (afIncomingMSGPacket_t *)msgPtr );
   \                     ??ZDApp_ProcessOSALMsg_3:
   \   000024   ........     CALLA   #ZDP_IncomingData
   1026                break;
   \   000028   883C         JMP     ??ZDApp_ProcessOSALMsg_5
   1027          
   1028              case ZDO_CB_MSG:
   1029                ZDApp_ProcessMsgCBs( (zdoIncomingMsg_t *)msgPtr );
   \                     ??ZDApp_ProcessOSALMsg_4:
   \   00002A   ........     CALLA   #ZDApp_ProcessMsgCBs
   1030                break;
   \   00002E   853C         JMP     ??ZDApp_ProcessOSALMsg_5
   1031          
   1032              case AF_DATA_CONFIRM_CMD:
   1033                // This message is received as a confirmation of a data packet sent.
   1034                // The status is of ZStatus_t type [defined in NLMEDE.h]
   1035                // The message fields are defined in AF.h
   1036                afDataConfirm = (afDataConfirm_t *)msgPtr;
   1037                sentEP = afDataConfirm->endpoint;
   1038                sentStatus = afDataConfirm->hdr.status;
   1039          
   1040                // Action taken when confirmation is received.
   1041          #if defined ( ZIGBEE_FREQ_AGILITY )
   1042                if ( pZDNwkMgr_ProcessDataConfirm )
   1043                  pZDNwkMgr_ProcessDataConfirm( afDataConfirm );
   1044          #endif
   1045                (void)sentEP;
   1046                (void)sentStatus;
   1047                break;
   1048          
   1049              case ZDO_NWK_DISC_CNF:
   1050                if (devState != DEV_NWK_DISC)
   \                     ??ZDApp_ProcessOSALMsg_0:
   \   000030   E293....     CMP.B   #0x2, &devState
   \   000034   8220         JNE     ??ZDApp_ProcessOSALMsg_5
   1051                  break;
   1052          
   1053                if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
   \   000036   5E93         CMP.B   #0x1, R14
   \   000038   0224         JEQ     ??ZDApp_ProcessOSALMsg_6
   \   00003A   6E93         CMP.B   #0x2, R14
   \   00003C   7E20         JNE     ??ZDApp_ProcessOSALMsg_5
   1054                {
   1055                  // Process the network discovery scan results and choose a parent
   1056                  // device to join/rejoin itself
   1057                  networkDesc_t *pChosenNwk;
   1058                  if ( ( (pChosenNwk = ZDApp_NwkDescListProcessing()) != NULL ) && (zdoDiscCounter > NUM_DISC_ATTEMPTS) )
   \                     ??ZDApp_ProcessOSALMsg_6:
   \   00003E   ........     CALLA   #ZDApp_NwkDescListProcessing
   \   000042   0A4C         MOV.W   R12, R10
   \   000044   0C93         CMP.W   #0x0, R12
   \   000046   5624         JEQ     ??ZDApp_ProcessOSALMsg_7
   \   000048   F2900300.... CMP.B   #0x3, &zdoDiscCounter
   \   00004E   5228         JNC     ??ZDApp_ProcessOSALMsg_7
   1059                  {
   1060                    if ( devStartMode == MODE_JOIN )
   \   000050   C293....     CMP.B   #0x0, &devStartMode
   \   000054   1720         JNE     ??ZDApp_ProcessOSALMsg_8
   1061                    {
   1062                      devState = DEV_NWK_JOINING;
   \   000056   F2400300.... MOV.B   #0x3, &devState
   1063          
   1064                      ZDApp_NodeProfileSync( pChosenNwk->stackProfile);
   \   00005C   5C4A0600     MOV.B   0x6(R10), R12
   \   000060   ........     CALLA   #ZDApp_NodeProfileSync
   1065          
   1066                      if ( NLME_JoinRequest( pChosenNwk->extendedPANID, pChosenNwk->panId,
   1067                                            pChosenNwk->logicalChannel,
   1068                                            ZDO_Config_Node_Descriptor.CapabilityFlags,
   1069                                            pChosenNwk->chosenRouter, pChosenNwk->chosenRouterDepth ) != ZSuccess )
   \   000064   5A120B00     PUSH.B  0xb(R10)
   \   000068   1A120800     PUSH.W  0x8(R10)
   \   00006C   5F42....     MOV.B   &ZDO_Config_Node_Descriptor + 2, R15
   \   000070   5E4A0200     MOV.B   0x2(R10), R14
   \   000074   2D4A         MOV.W   @R10, R13
   \   000076   3A500C00     ADD.W   #0xc, R10
   \   00007A   0C4A         MOV.W   R10, R12
   \   00007C   ........     CALLA   #NLME_JoinRequest
   \   000080   2152         ADD.W   #0x4, SP
   \   000082   2E3C         JMP     ??ZDApp_ProcessOSALMsg_9
   1070                      {
   1071                        ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1072                                                    + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   1073                      }
   1074                    } // if ( devStartMode == MODE_JOIN )
   1075                    else if ( devStartMode == MODE_REJOIN )
   \                     ??ZDApp_ProcessOSALMsg_8:
   \   000084   F2900300.... CMP.B   #0x3, &devStartMode
   \   00008A   2E20         JNE     ??ZDApp_ProcessOSALMsg_10
   1076                    {
   1077                      devState = DEV_NWK_REJOIN;
   \   00008C   E242....     MOV.B   #0x4, &devState
   1078          
   1079                      // Before trying to do rejoin, check if the device has a valid short address
   1080                      // If not, generate a random short address for itself
   1081                      if ( _NIB.nwkDevAddress == INVALID_NODE_ADDR )
   \   000090   B290FEFF.... CMP.W   #0xfffe, &_NIB + 22
   \   000096   0A20         JNE     ??ZDApp_ProcessOSALMsg_11
   1082                      {
   1083                        _NIB.nwkDevAddress = osal_rand();
   \   000098   ........     CALLA   #osal_rand
   \   00009C   824C....     MOV.W   R12, &_NIB + 22
   1084                        ZMacSetReq( ZMacShortAddress, (byte*)&_NIB.nwkDevAddress );
   \   0000A0   3D40....     MOV.W   #_NIB + 22, R13
   \   0000A4   7C405300     MOV.B   #0x53, R12
   \   0000A8   ........     CALLA   #ZMacSetReq
   1085                      }
   1086          
   1087                      if ( ZG_SECURE_ENABLED )
   1088                      {
   1089                        ZDApp_RestoreNwkKey();
   1090                      }
   1091          
   1092                      // Check if the device has a valid PanID, if not, set it to the discovered Pan
   1093                      if ( _NIB.nwkPanId == INVALID_PAN_ID )
   \                     ??ZDApp_ProcessOSALMsg_11:
   \   0000AC   B290FEFF.... CMP.W   #0xfffe, &_NIB + 36
   \   0000B2   0820         JNE     ??ZDApp_ProcessOSALMsg_12
   1094                      {
   1095                        _NIB.nwkPanId = pChosenNwk->panId;
   \   0000B4   A24A....     MOV.W   @R10, &_NIB + 36
   1096                        ZMacSetReq( ZMacPanId, (byte*)&(_NIB.nwkPanId) );
   \   0000B8   3D40....     MOV.W   #_NIB + 36, R13
   \   0000BC   7C405000     MOV.B   #0x50, R12
   \   0000C0   ........     CALLA   #ZMacSetReq
   1097                      }
   1098          
   1099                      tmp = true;
   \                     ??ZDApp_ProcessOSALMsg_12:
   \   0000C4   D1430000     MOV.B   #0x1, 0(SP)
   1100                      ZMacSetReq( ZMacRxOnIdle, &tmp ); // Set receiver always on during rejoin
   \   0000C8   0D41         MOV.W   SP, R13
   \   0000CA   0D53         ADD.W   #0x0, R13
   \   0000CC   7C405200     MOV.B   #0x52, R12
   \   0000D0   ........     CALLA   #ZMacSetReq
   1101                      if ( NLME_ReJoinRequest( ZDO_UseExtendedPANID, pChosenNwk->logicalChannel) != ZSuccess )
   \   0000D4   5D4A0200     MOV.B   0x2(R10), R13
   \   0000D8   3C40....     MOV.W   #ZDO_UseExtendedPANID, R12
   \   0000DC   ........     CALLA   #NLME_ReJoinRequest
   \                     ??ZDApp_ProcessOSALMsg_9:
   \   0000E0   4C93         CMP.B   #0x0, R12
   \   0000E2   0224         JEQ     ??ZDApp_ProcessOSALMsg_10
   1102                      {
   1103                        ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1104                                                    + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   \   0000E4   ........     CALLA   #?Subroutine9
   1105                      }
   1106                    } // else if ( devStartMode == MODE_REJOIN )
   1107          
   1108                    if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   \                     ??ZDApp_ProcessOSALMsg_10:
   \   0000E8   F2B2....     BIT.B   #0x8, &ZDO_Config_Node_Descriptor + 2
   \   0000EC   2628         JNC     ??ZDApp_ProcessOSALMsg_5
   1109                    {
   1110                      // The receiver is on, turn network layer polling off.
   1111                      NLME_SetPollRate( 0 );
   \   0000EE   ........     CALLA   #?Subroutine6
   1112                      NLME_SetQueuedPollRate( 0 );
   1113                      NLME_SetResponseRate( 0 );
   1114                    }
   1115                    else
   1116                    {
   1117                      if ( (ZG_SECURE_ENABLED) && (devStartMode == MODE_JOIN) )
   1118                      {
   1119                        ZDApp_SavedPollRate = zgPollRate;
   1120                        NLME_SetPollRate( zgRejoinPollRate );
   1121                      }
   1122                    }
   1123                  }
   \                     ??CrossCallReturnLabel_0:
   \   0000F2   233C         JMP     ??ZDApp_ProcessOSALMsg_5
   1124                  else
   1125                  {
   1126                    if ( continueJoining )
   \                     ??ZDApp_ProcessOSALMsg_7:
   \   0000F4   C293....     CMP.B   #0x0, &continueJoining
   \   0000F8   2024         JEQ     ??ZDApp_ProcessOSALMsg_5
   1127                    {
   1128              #if defined ( MANAGED_SCAN )
   1129                      ZDApp_NetworkInit( MANAGEDSCAN_DELAY_BETWEEN_SCANS );
   1130              #else
   1131                      zdoDiscCounter++;
   \   0000FA   D253....     ADD.B   #0x1, &zdoDiscCounter
   1132                      ZDApp_NetworkInit( (uint16)(BEACON_REQUEST_DELAY
   1133                            + ((uint16)(osal_rand()& BEACON_REQ_DELAY_MASK))) );
   \   0000FE   ........     CALLA   #osal_rand
   \   000102   7CF3         AND.B   #0xff, R12
   \   000104   3C506400     ADD.W   #0x64, R12
   \   000108   163C         JMP     ??ZDApp_ProcessOSALMsg_13
   1134              #endif
   1135                    }
   1136                  }
   1137                }
   1138                break;
   1139          
   1140              case ZDO_NWK_JOIN_IND:
   1141                if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
   \                     ??ZDApp_ProcessOSALMsg_1:
   \   00010A   5E93         CMP.B   #0x1, R14
   \   00010C   0224         JEQ     ??ZDApp_ProcessOSALMsg_14
   \   00010E   6E93         CMP.B   #0x2, R14
   \   000110   1420         JNE     ??ZDApp_ProcessOSALMsg_5
   1142                {
   1143                  ZDApp_ProcessNetworkJoin();
   \                     ??ZDApp_ProcessOSALMsg_14:
   \   000112   ........     CALLA   #ZDApp_ProcessNetworkJoin
   \   000116   113C         JMP     ??ZDApp_ProcessOSALMsg_5
   1144                }
   1145                break;
   1146          
   1147              case ZDO_NWK_JOIN_REQ:
   1148                if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
   \                     ??ZDApp_ProcessOSALMsg_2:
   \   000118   5E93         CMP.B   #0x1, R14
   \   00011A   0224         JEQ     ??ZDApp_ProcessOSALMsg_15
   \   00011C   6E93         CMP.B   #0x2, R14
   \   00011E   0D20         JNE     ??ZDApp_ProcessOSALMsg_5
   1149                {
   1150                  retryCnt = 0;
   \                     ??ZDApp_ProcessOSALMsg_15:
   \   000120   C243....     MOV.B   #0x0, &retryCnt
   1151                  devStartMode = MODE_RESUME;
   \   000124   D243....     MOV.B   #0x1, &devStartMode
   1152                  _tmpRejoinState = true;
   \   000128   D243....     MOV.B   #0x1, &_tmpRejoinState
   1153                  osal_cpyExtAddr( ZDO_UseExtendedPANID, _NIB.extendedPANID );
   \   00012C   ........     CALLA   #?Subroutine15
   1154                  zgDefaultStartingScanDuration = BEACON_ORDER_60_MSEC;
   \                     ??CrossCallReturnLabel_13:
   \   000130   E243....     MOV.B   #0x2, &zgDefaultStartingScanDuration
   1155                  ZDApp_NetworkInit( 0 );
   \   000134   0C43         MOV.W   #0x0, R12
   \                     ??ZDApp_ProcessOSALMsg_13:
   \   000136   ........     CALLA   #ZDApp_NetworkInit
   1156                }
   1157                break;
   1158          
   1159              default:
   1160                if ( ZG_SECURE_ENABLED )
   1161                  ZDApp_ProcessSecMsg( msgPtr );
   1162                break;
   1163            }
   1164          
   1165          }
   \                     ??ZDApp_ProcessOSALMsg_5:
   \   00013A                REQUIRE ?Subroutine1
   \   00013A                // Fall through to label ?Subroutine1

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   ........     CALLA   #osal_rand
   \   000004   3CF07F00     AND.W   #0x7f, R12
   \   000008   3C506400     ADD.W   #0x64, R12
   \   00000C   ........     BRA     #ZDApp_NetworkInit

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   0C43         MOV.W   #0x0, R12
   \   000002   ........     CALLA   #NLME_SetPollRate
   \   000006   0C43         MOV.W   #0x0, R12
   \   000008   ........     CALLA   #NLME_SetQueuedPollRate
   \   00000C   0C43         MOV.W   #0x0, R12
   \   00000E   ........     BRA     #NLME_SetResponseRate
   1166          
   1167          /*********************************************************************
   1168           * @fn      ZDApp_ProcessMsgCBs()
   1169           *
   1170           * @brief   Process response messages
   1171           *
   1172           * @param   none
   1173           *
   1174           * @return  none
   1175           */

   \                                 In  segment CODE, align 2, keep-with-next
   1176          void ZDApp_ProcessMsgCBs( zdoIncomingMsg_t *inMsg )
   \                     ZDApp_ProcessMsgCBs:
   1177          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31801800     SUB.W   #0x18, SP
   \   000006   0A4C         MOV.W   R12, R10
   1178            switch ( inMsg->clusterID )
   \   000008   1F4C0E00     MOV.W   0xe(R12), R15
   \   00000C   3F802100     SUB.W   #0x21, R15
   \   000010   1924         JEQ     ??ZDApp_ProcessMsgCBs_2
   \   000012   1F83         SUB.W   #0x1, R15
   \   000014   1724         JEQ     ??ZDApp_ProcessMsgCBs_2
   \   000016   3F80DE7F     SUB.W   #0x7fde, R15
   \   00001A   0224         JEQ     ??ZDApp_ProcessMsgCBs_0
   \   00001C   1F83         SUB.W   #0x1, R15
   \   00001E   1B20         JNE     ??ZDApp_ProcessMsgCBs_1
   1179            {
   1180          #if defined ( ZDO_NWKADDR_REQUEST ) || defined ( ZDO_IEEEADDR_REQUEST ) || defined ( REFLECTOR )
   1181              case NWK_addr_rsp:
   1182              case IEEE_addr_rsp:
   1183                {
   1184                  ZDO_NwkIEEEAddrResp_t *pAddrRsp;
   1185                  pAddrRsp = ZDO_ParseAddrRsp( inMsg );
   \                     ??ZDApp_ProcessMsgCBs_0:
   \   000020   ........     CALLA   #ZDO_ParseAddrRsp
   \   000024   0A4C         MOV.W   R12, R10
   1186                  if ( pAddrRsp )
   \   000026   0C93         CMP.W   #0x0, R12
   \   000028   1624         JEQ     ??ZDApp_ProcessMsgCBs_1
   1187                  {
   1188                    if ( pAddrRsp->status == ZSuccess )
   \   00002A   CC930000     CMP.B   #0x0, 0(R12)
   \   00002E   0620         JNE     ??ZDApp_ProcessMsgCBs_3
   1189                    {
   1190                      ZDO_UpdateAddrManager( pAddrRsp->nwkAddr, pAddrRsp->extAddr );
   \   000030   0D4C         MOV.W   R12, R13
   \   000032   2D52         ADD.W   #0x4, R13
   \   000034   1C4A0200     MOV.W   0x2(R10), R12
   \   000038   ........     CALLA   #ZDO_UpdateAddrManager
   1191                    }
   1192                    osal_mem_free( pAddrRsp );
   \                     ??ZDApp_ProcessMsgCBs_3:
   \   00003C   0C4A         MOV.W   R10, R12
   \   00003E   ........     CALLA   #osal_mem_free
   \   000042   093C         JMP     ??ZDApp_ProcessMsgCBs_1
   1193                  }
   1194                }
   1195                break;
   1196          #endif
   1197          
   1198          #if defined ( REFLECTOR )
   1199              case Bind_req:
   1200              case Unbind_req:
   1201                {
   1202                  ZDO_BindUnbindReq_t bindReq;
   1203                  ZDO_ParseBindUnbindReq( inMsg, &bindReq );
   \                     ??ZDApp_ProcessMsgCBs_2:
   \   000044   0D41         MOV.W   SP, R13
   \   000046   0D53         ADD.W   #0x0, R13
   \   000048   ........     CALLA   #ZDO_ParseBindUnbindReq
   1204                  ZDO_ProcessBindUnbindReq( inMsg, &bindReq );
   \   00004C   0D41         MOV.W   SP, R13
   \   00004E   0D53         ADD.W   #0x0, R13
   \   000050   0C4A         MOV.W   R10, R12
   \   000052   ........     CALLA   #ZDO_ProcessBindUnbindReq
   1205                }
   1206                break;
   1207          #endif
   1208          
   1209          #if ( ZG_BUILD_COORDINATOR_TYPE )
   1210              case Bind_rsp:
   1211              case Unbind_rsp:
   1212                if (ZG_DEVICE_COORDINATOR_TYPE && matchED)
   1213                {
   1214                  ZDMatchSendState(
   1215                       (uint8)((inMsg->clusterID == Bind_rsp) ? ZDMATCH_REASON_BIND_RSP : ZDMATCH_REASON_UNBIND_RSP),
   1216                       ZDO_ParseBindRsp(inMsg), inMsg->TransSeq );
   1217                }
   1218                break;
   1219          
   1220              case End_Device_Bind_req:
   1221                if (ZG_DEVICE_COORDINATOR_TYPE)
   1222                {
   1223                  ZDEndDeviceBind_t bindReq;
   1224                  ZDO_ParseEndDeviceBindReq( inMsg, &bindReq );
   1225                  ZDO_MatchEndDeviceBind( &bindReq );
   1226          
   1227                  // Freeing the cluster lists - if allocated.
   1228                  if ( bindReq.numInClusters )
   1229                    osal_mem_free( bindReq.inClusters );
   1230                  if ( bindReq.numOutClusters )
   1231                    osal_mem_free( bindReq.outClusters );
   1232                }
   1233                break;
   1234          #endif
   1235            }
   1236          }
   \                     ??ZDApp_ProcessMsgCBs_1:
   \   000056   31501800     ADD.W   #0x18, SP
   \   00005A   3A41         POP.W   R10
   \   00005C   1001         RETA
   1237          
   1238          /*********************************************************************
   1239           * @fn      ZDApp_RegisterCBs()
   1240           *
   1241           * @brief   Process response messages
   1242           *
   1243           * @param   none
   1244           *
   1245           * @return  none
   1246           */

   \                                 In  segment CODE, align 2, keep-with-next
   1247          void ZDApp_RegisterCBs( void )
   \                     ZDApp_RegisterCBs:
   1248          {
   \   000000   0A12         PUSH.W  R10
   1249          #if defined ( ZDO_IEEEADDR_REQUEST ) || defined ( REFLECTOR )
   1250            ZDO_RegisterForZDOMsg( ZDAppTaskID, IEEE_addr_rsp );
   \   000002   3A40....     MOV.W   #ZDAppTaskID, R10
   \   000006   3D400180     MOV.W   #0x8001, R13
   \   00000A   ........     CALLA   #?Subroutine16
   1251          #endif
   1252          #if defined ( ZDO_NWKADDR_REQUEST ) || defined ( REFLECTOR )
   1253            ZDO_RegisterForZDOMsg( ZDAppTaskID, NWK_addr_rsp );
   \                     ??CrossCallReturnLabel_17:
   \   00000E   3D400080     MOV.W   #0x8000, R13
   \   000012   ........     CALLA   #?Subroutine16
   1254          #endif
   1255          #if ZG_BUILD_COORDINATOR_TYPE
   1256            ZDO_RegisterForZDOMsg( ZDAppTaskID, Bind_rsp );
   1257            ZDO_RegisterForZDOMsg( ZDAppTaskID, Unbind_rsp );
   1258            ZDO_RegisterForZDOMsg( ZDAppTaskID, End_Device_Bind_req );
   1259          #endif
   1260          #if defined ( REFLECTOR )
   1261            ZDO_RegisterForZDOMsg( ZDAppTaskID, Bind_req );
   \                     ??CrossCallReturnLabel_16:
   \   000016   3D402100     MOV.W   #0x21, R13
   \   00001A   ........     CALLA   #?Subroutine16
   1262            ZDO_RegisterForZDOMsg( ZDAppTaskID, Unbind_req );
   \                     ??CrossCallReturnLabel_15:
   \   00001E   3D402200     MOV.W   #0x22, R13
   \   000022   ........     CALLA   #?Subroutine16
   1263          #endif
   1264          }
   \                     ??CrossCallReturnLabel_14:
   \   000026   3A41         POP.W   R10
   \   000028   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine16:
   \   000000   6C4A         MOV.B   @R10, R12
   \   000002   ........     BRA     #ZDO_RegisterForZDOMsg
   1265          
   1266          /*********************************************************************
   1267           * @fn      ZDApp_ProcessSecMsg()
   1268           *
   1269           * @brief   Process the incoming security message.
   1270           *
   1271           * @param   msgPtr - message to process
   1272           *
   1273           * @return  none
   1274           */

   \                                 In  segment CODE, align 2, keep-with-next
   1275          void ZDApp_ProcessSecMsg( osal_event_hdr_t *msgPtr )
   \                     ZDApp_ProcessSecMsg:
   1276          {
   1277            switch ( msgPtr->event )
   \   000000   5E42....     MOV.B   &zgDeviceLogicalType, R14
   \   000004   6F4C         MOV.B   @R12, R15
   \   000006   7F800600     SUB.B   #0x6, R15
   \   00000A   0324         JEQ     ??ZDApp_ProcessSecMsg_0
   \   00000C   6F82         SUB.B   #0x4, R15
   \   00000E   0724         JEQ     ??ZDApp_ProcessSecMsg_1
   \   000010   1001         RETA
   1278            {
   1279              case ZDO_ESTABLISH_KEY_CFM:
   1280                if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1281                {
   1282                  ZDSecMgrEstablishKeyCfm( (ZDO_EstablishKeyCfm_t*)msgPtr );
   1283                }
   1284                break;
   1285          
   1286              case ZDO_ESTABLISH_KEY_IND:
   1287                if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1288                {
   1289                  if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
   1290                  {
   1291                    ZDSecMgrEstablishKeyInd( (ZDO_EstablishKeyInd_t*)msgPtr );
   1292                  }
   1293                }
   1294                break;
   1295          
   1296              case ZDO_TRANSPORT_KEY_IND:
   1297                if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
   \                     ??ZDApp_ProcessSecMsg_0:
   \   000012   5E93         CMP.B   #0x1, R14
   \   000014   0224         JEQ     ??ZDApp_ProcessSecMsg_2
   \   000016   6E93         CMP.B   #0x2, R14
   \   000018   0820         JNE     ??ZDApp_ProcessSecMsg_3
   1298                {
   1299                  ZDSecMgrTransportKeyInd( (ZDO_TransportKeyInd_t*)msgPtr );
   \                     ??ZDApp_ProcessSecMsg_2:
   \   00001A   ........     BRA     #ZDSecMgrTransportKeyInd
   1300                }
   1301                break;
   1302          
   1303              case ZDO_UPDATE_DEVICE_IND:
   1304                if ( ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
   1305                {
   1306                  ZDSecMgrUpdateDeviceInd( (ZDO_UpdateDeviceInd_t*)msgPtr );
   1307                }
   1308                break;
   1309          
   1310              case ZDO_REMOVE_DEVICE_IND:
   1311                if ( ZG_BUILD_RTRONLY_TYPE && ( zgDeviceLogicalType == ZG_DEVICETYPE_ROUTER ) )
   1312                {
   1313                  ZDSecMgrRemoveDeviceInd( (ZDO_RemoveDeviceInd_t*)msgPtr );
   1314                }
   1315                break;
   1316          
   1317              case ZDO_REQUEST_KEY_IND:
   1318                if (( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH ) ||
   1319                    ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD ))
   1320                {
   1321                  if ( ZG_BUILD_COORDINATOR_TYPE && ZG_DEVICE_COORDINATOR_TYPE )
   1322                  {
   1323                    ZDSecMgrRequestKeyInd( (ZDO_RequestKeyInd_t*)msgPtr );
   1324                  }
   1325                }
   1326                break;
   1327          
   1328              case ZDO_SWITCH_KEY_IND:
   1329                if ( ZG_BUILD_JOINING_TYPE && ZG_DEVICE_JOINING_TYPE )
   \                     ??ZDApp_ProcessSecMsg_1:
   \   00001E   5E93         CMP.B   #0x1, R14
   \   000020   0224         JEQ     ??ZDApp_ProcessSecMsg_4
   \   000022   6E93         CMP.B   #0x2, R14
   \   000024   0220         JNE     ??ZDApp_ProcessSecMsg_3
   1330                {
   1331                  ZDSecMgrSwitchKeyInd( (ZDO_SwitchKeyInd_t*)msgPtr );
   \                     ??ZDApp_ProcessSecMsg_4:
   \   000026   ........     CALLA   #ZDSecMgrSwitchKeyInd
   1332                }
   1333                break;
   1334          
   1335              case ZDO_AUTHENTICATE_IND:
   1336                if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1337                {
   1338                  ZDSecMgrAuthenticateInd( (ZDO_AuthenticateInd_t*)msgPtr );
   1339                }
   1340                break;
   1341          
   1342              case ZDO_AUTHENTICATE_CFM:
   1343                if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1344                {
   1345                  ZDSecMgrAuthenticateCfm( (ZDO_AuthenticateCfm_t*)msgPtr );
   1346                }
   1347                break;
   1348          
   1349              default:
   1350                // Unsupported messages
   1351                break;
   1352            }
   1353          }
   \                     ??ZDApp_ProcessSecMsg_3:
   \   00002A   1001         RETA
   1354          
   1355          /*********************************************************************
   1356           * @fn      ZDApp_ProcessNetworkJoin()
   1357           *
   1358           * @brief
   1359           *
   1360           *   Save off the Network key information.
   1361           *
   1362           * @param   none
   1363           *
   1364           * @return  none
   1365           */

   \                                 In  segment CODE, align 2, keep-with-next
   1366          void ZDApp_ProcessNetworkJoin( void )
   \                     ZDApp_ProcessNetworkJoin:
   1367          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2183         SUB.W   #0x2, SP
   1368            if ( (devState == DEV_NWK_JOINING) ||
   1369                ((devState == DEV_NWK_ORPHAN)  &&
   1370                 (ZDO_Config_Node_Descriptor.LogicalType == NODETYPE_ROUTER)) )
   \   000004   5E42....     MOV.B   &devState, R14
   \   000008   3A40FEFF     MOV.W   #0xfffe, R10
   \   00000C   7B400300     MOV.B   #0x3, R11
   \   000010   4E9B         CMP.B   R11, R14
   \   000012   0924         JEQ     ??ZDApp_ProcessNetworkJoin_0
   \   000014   7E900A00     CMP.B   #0xa, R14
   \   000018   4120         JNE     ??ZDApp_ProcessNetworkJoin_1
   \   00001A   5E42....     MOV.B   &ZDO_Config_Node_Descriptor, R14
   \   00001E   7EF00700     AND.B   #0x7, R14
   \   000022   5E93         CMP.B   #0x1, R14
   \   000024   3D20         JNE     ??ZDApp_ProcessNetworkJoin_2
   1371            {
   1372              // Result of a Join attempt by this device.
   1373              if ( nwkStatus == ZSuccess )
   \                     ??ZDApp_ProcessNetworkJoin_0:
   \   000026   C293....     CMP.B   #0x0, &nwkStatus
   \   00002A   0B20         JNE     ??ZDApp_ProcessNetworkJoin_3
   1374              {
   1375                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   00002C   ........     CALLA   #??Subroutine7_0
   1376          
   1377          #if defined ( POWER_SAVING )
   1378                osal_pwrmgr_device( PWRMGR_BATTERY );
   1379          #endif
   1380          
   1381                if ( ZG_SECURE_ENABLED && ( ZDApp_RestoreNwkKey() == false ) )
   1382                {
   1383                  // wait for auth from trust center!!
   1384                  devState = DEV_END_DEVICE_UNAUTH;
   1385          
   1386                  // Start the reset timer for MAX UNAUTH time
   1387                  ZDApp_ResetTimerStart( 10000 );//MAX_DEVICE_UNAUTH_TIMEOUT );
   1388                }
   1389                else
   1390                {
   1391                  if ( ZSTACK_ROUTER_BUILD )
   1392                  {
   1393                    if ( devState == DEV_NWK_ORPHAN
   1394                      && ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
   1395                    {
   1396                      // Change NIB state to router for restore
   1397                      _NIB.nwkState = NWK_ROUTER;
   1398                    }
   1399                  }
   1400          
   1401                  if ( devState == DEV_NWK_JOINING )
   \                     ??CrossCallReturnLabel_20:
   \   000030   C29B....     CMP.B   R11, &devState
   \   000034   0220         JNE     ??ZDApp_ProcessNetworkJoin_4
   1402                  {
   1403                    ZDApp_AnnounceNewAddress();
   \   000036   ........     CALLA   #ZDApp_AnnounceNewAddress
   1404                  }
   1405          
   1406                  devState = DEV_END_DEVICE;
   \                     ??ZDApp_ProcessNetworkJoin_4:
   \   00003A   F2400600.... MOV.B   #0x6, &devState
   1407                  if ( ZSTACK_ROUTER_BUILD )
   \   000040   623C         JMP     ??ZDApp_ProcessNetworkJoin_5
   1408                  {
   1409                    // NOTE: first two parameters are not used, see NLMEDE.h for details
   1410                    if ( ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
   1411                    {
   1412                      NLME_StartRouterRequest( 0, 0, false );
   1413                    }
   1414                  }
   1415                }
   1416              }
   1417              else
   1418              {
   1419                if ( (devStartMode == MODE_RESUME) && (++retryCnt >= MAX_RESUME_RETRY) )
   \                     ??ZDApp_ProcessNetworkJoin_3:
   \   000042   D293....     CMP.B   #0x1, &devStartMode
   \   000046   1220         JNE     ??ZDApp_ProcessNetworkJoin_6
   \   000048   D253....     ADD.B   #0x1, &retryCnt
   \   00004C   C29B....     CMP.B   R11, &retryCnt
   \   000050   0D28         JNC     ??ZDApp_ProcessNetworkJoin_6
   1420                {
   1421                  if ( _NIB.nwkPanId == 0xFFFF || _NIB.nwkPanId == INVALID_PAN_ID )
   \   000052   B293....     CMP.W   #0xffff, &_NIB + 36
   \   000056   0324         JEQ     ??ZDApp_ProcessNetworkJoin_7
   \   000058   829A....     CMP.W   R10, &_NIB + 36
   \   00005C   0320         JNE     ??ZDApp_ProcessNetworkJoin_8
   1422                    devStartMode = MODE_JOIN;
   \                     ??ZDApp_ProcessNetworkJoin_7:
   \   00005E   C243....     MOV.B   #0x0, &devStartMode
   \   000062   043C         JMP     ??ZDApp_ProcessNetworkJoin_6
   1423                  else
   1424                  {
   1425                    devStartMode = MODE_REJOIN;
   \                     ??ZDApp_ProcessNetworkJoin_8:
   \   000064   C24B....     MOV.B   R11, &devStartMode
   1426                    _tmpRejoinState = true;
   \   000068   D243....     MOV.B   #0x1, &_tmpRejoinState
   1427                  }
   1428                }
   1429          
   1430                if ( (NLME_GetShortAddr() != INVALID_NODE_ADDR) ||
   1431                     (_NIB.nwkDevAddress != INVALID_NODE_ADDR) )
   \                     ??ZDApp_ProcessNetworkJoin_6:
   \   00006C   ........     CALLA   #NLME_GetShortAddr
   \   000070   0C9A         CMP.W   R10, R12
   \   000072   0320         JNE     ??ZDApp_ProcessNetworkJoin_9
   \   000074   829A....     CMP.W   R10, &_NIB + 22
   \   000078   0A24         JEQ     ??ZDApp_ProcessNetworkJoin_10
   1432                {
   1433                  uint16 addr = INVALID_NODE_ADDR;
   \                     ??ZDApp_ProcessNetworkJoin_9:
   \   00007A   814A0000     MOV.W   R10, 0(SP)
   1434                  // Invalidate nwk addr so end device does not use in its data reqs.
   1435                  _NIB.nwkDevAddress = INVALID_NODE_ADDR;
   \   00007E   824A....     MOV.W   R10, &_NIB + 22
   1436                  ZMacSetReq( ZMacShortAddress, (uint8 *)&addr );
   \   000082   0D41         MOV.W   SP, R13
   \   000084   0D53         ADD.W   #0x0, R13
   \   000086   7C405300     MOV.B   #0x53, R12
   \   00008A   ........     CALLA   #ZMacSetReq
   1437                }
   1438          
   1439                // Clear the neighbor Table and network discovery tables.
   1440                nwkNeighborInitTable();
   \                     ??ZDApp_ProcessNetworkJoin_10:
   \   00008E   ........     CALLA   #nwkNeighborInitTable
   1441                NLME_NwkDiscTerm();
   \   000092   ........     CALLA   #NLME_NwkDiscTerm
   1442          
   1443                zdoDiscCounter = 1;
   \   000096   D243....     MOV.B   #0x1, &zdoDiscCounter
   1444          
   1445          //      ZDApp_NetworkInit( (uint16)
   1446          //                         ((NWK_START_DELAY * (osal_rand() & 0x0F)) +
   1447          //                          (NWK_START_DELAY * 5)) );
   1448                ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1449                     + ((uint16)(osal_rand()& EXTENDED_JOINING_RANDOM_MASK))) );
   \   00009A   2B3C         JMP     ??ZDApp_ProcessNetworkJoin_11
   1450              }
   1451            }
   1452            else if ( devState == DEV_NWK_ORPHAN || devState == DEV_NWK_REJOIN )
   \                     ??ZDApp_ProcessNetworkJoin_1:
   \   00009C   6E92         CMP.B   #0x4, R14
   \   00009E   2C20         JNE     ??ZDApp_ProcessNetworkJoin_12
   1453            {
   1454              // results of an orphaning attempt by this device
   1455              if (nwkStatus == ZSuccess)
   \                     ??ZDApp_ProcessNetworkJoin_2:
   \   0000A0   C293....     CMP.B   #0x0, &nwkStatus
   \   0000A4   0A20         JNE     ??ZDApp_ProcessNetworkJoin_13
   1456              {
   1457                if ( ZG_SECURE_ENABLED )
   1458                {
   1459                  ZDApp_RestoreNwkKey();
   1460                }
   1461          
   1462                devState = DEV_END_DEVICE;
   \   0000A6   ........     CALLA   #?Subroutine7
   1463                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   1464                // setup Power Manager Device
   1465          #if defined ( POWER_SAVING )
   1466                osal_pwrmgr_device( PWRMGR_BATTERY );
   1467          #endif
   1468          
   1469                if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   \                     ??CrossCallReturnLabel_23:
   \   0000AA   F2B2....     BIT.B   #0x8, &ZDO_Config_Node_Descriptor + 2
   \   0000AE   0228         JNC     ??ZDApp_ProcessNetworkJoin_14
   1470                {
   1471                  // The receiver is on, turn network layer polling off.
   1472                  NLME_SetPollRate( 0 );
   \   0000B0   ........     CALLA   #?Subroutine6
   1473                  NLME_SetQueuedPollRate( 0 );
   1474                  NLME_SetResponseRate( 0 );
   1475                }
   1476          
   1477                if ( ZSTACK_ROUTER_BUILD )
   1478                {
   1479                  // NOTE: first two parameters are not used, see NLMEDE.h for details
   1480                  if ( ZDO_Config_Node_Descriptor.LogicalType != NODETYPE_DEVICE )
   1481                  {
   1482                    NLME_StartRouterRequest( 0, 0, false );
   1483                  }
   1484                }
   1485          
   1486                ZDApp_AnnounceNewAddress();
   \                     ??ZDApp_ProcessNetworkJoin_14:
   \   0000B4   ........     CALLA   #ZDApp_AnnounceNewAddress
   \   0000B8   263C         JMP     ??ZDApp_ProcessNetworkJoin_5
   1487              }
   1488              else
   1489              {
   1490                if ( devStartMode == MODE_RESUME )
   \                     ??ZDApp_ProcessNetworkJoin_13:
   \   0000BA   D293....     CMP.B   #0x1, &devStartMode
   \   0000BE   1520         JNE     ??ZDApp_ProcessNetworkJoin_15
   1491                {
   1492                  if ( ++retryCnt <= MAX_RESUME_RETRY )
   \   0000C0   D253....     ADD.B   #0x1, &retryCnt
   \   0000C4   E292....     CMP.B   #0x4, &retryCnt
   \   0000C8   0B2C         JC      ??ZDApp_ProcessNetworkJoin_16
   1493                  {
   1494                    if ( _NIB.nwkPanId == 0xFFFF || _NIB.nwkPanId == INVALID_PAN_ID )
   \   0000CA   B293....     CMP.W   #0xffff, &_NIB + 36
   \   0000CE   0B24         JEQ     ??ZDApp_ProcessNetworkJoin_17
   \   0000D0   829A....     CMP.W   R10, &_NIB + 36
   \   0000D4   0824         JEQ     ??ZDApp_ProcessNetworkJoin_17
   1495                      devStartMode = MODE_JOIN;
   1496                    else
   1497                    {
   1498                      devStartMode = MODE_REJOIN;
   \   0000D6   C24B....     MOV.B   R11, &devStartMode
   1499                      _tmpRejoinState = true;
   \   0000DA   D243....     MOV.B   #0x1, &_tmpRejoinState
   \   0000DE   053C         JMP     ??ZDApp_ProcessNetworkJoin_15
   1500                    }
   1501                  }
   1502                  // Do a normal join to the network after certain times of rejoin retries
   1503                  else if( AIB_apsUseInsecureJoin == true )
   \                     ??ZDApp_ProcessNetworkJoin_16:
   \   0000E0   D293....     CMP.B   #0x1, &AIB_apsUseInsecureJoin
   \   0000E4   0220         JNE     ??ZDApp_ProcessNetworkJoin_15
   1504                  {
   1505                    devStartMode = MODE_JOIN;
   \                     ??ZDApp_ProcessNetworkJoin_17:
   \   0000E6   C243....     MOV.B   #0x0, &devStartMode
   1506                  }
   1507                }
   1508          
   1509                // Clear the neighbor Table and network discovery tables.
   1510                nwkNeighborInitTable();
   \                     ??ZDApp_ProcessNetworkJoin_15:
   \   0000EA   ........     CALLA   #nwkNeighborInitTable
   1511                NLME_NwkDiscTerm();
   \   0000EE   ........     CALLA   #NLME_NwkDiscTerm
   1512          
   1513                // setup a retry for later...
   1514                ZDApp_NetworkInit( (uint16)(NWK_START_DELAY
   1515                     + (osal_rand()& EXTENDED_JOINING_RANDOM_MASK)) );
   1516              }
   1517            }
   \                     ??ZDApp_ProcessNetworkJoin_11:
   \   0000F2   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_2:
   \   0000F6   073C         JMP     ??ZDApp_ProcessNetworkJoin_5
   1518          #if defined ( ZIGBEE_STOCHASTIC_ADDRESSING )
   1519            else
   1520            {
   1521              // Assume from address conflict
   1522              if ( _NIB.nwkAddrAlloc == NWK_ADDRESSING_STOCHASTIC )
   \                     ??ZDApp_ProcessNetworkJoin_12:
   \   0000F8   E293....     CMP.B   #0x2, &_NIB + 100
   \   0000FC   0420         JNE     ??ZDApp_ProcessNetworkJoin_5
   1523              {
   1524                // Notify the network
   1525                ZDApp_AnnounceNewAddress();
   \   0000FE   ........     CALLA   #ZDApp_AnnounceNewAddress
   1526          
   1527                // Notify apps
   1528                osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   000102   ........     CALLA   #??Subroutine7_0
   1529              }
   1530            }
   1531          #endif
   1532          }
   \                     ??ZDApp_ProcessNetworkJoin_5:
   \   000106   2153         ADD.W   #0x2, SP
   \   000108   1A17         POPM.W  #0x2, R11
   \   00010A   1001         RETA
   1533          
   1534          /*********************************************************************
   1535           * @fn      ZDApp_SaveNwkKey()
   1536           *
   1537           * @brief   Save off the Network key information.
   1538           *
   1539           * @param   none
   1540           *
   1541           * @return  none
   1542           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   31501600     ADD.W   #0x16, SP
   \   000004   3A41         POP.W   R10
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1543          void ZDApp_SaveNwkKey( void )
   \                     ZDApp_SaveNwkKey:
   1544          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31801600     SUB.W   #0x16, SP
   1545            nwkActiveKeyItems keyItems;
   1546          
   1547            SSP_ReadNwkActiveKey( &keyItems );
   \   000006   0A41         MOV.W   SP, R10
   \   000008   0A53         ADD.W   #0x0, R10
   \   00000A   0C4A         MOV.W   R10, R12
   \   00000C   ........     CALLA   #SSP_ReadNwkActiveKey
   1548            keyItems.frameCounter++;
   \   000010   91531200     ADD.W   #0x1, 0x12(SP)
   \   000014   81631400     ADDC.W  #0x0, 0x14(SP)
   1549          
   1550            osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof( nwkActiveKeyItems ),
   1551                          (void *)&keyItems );
   \   000018   0F4A         MOV.W   R10, R15
   \   00001A   3E401600     MOV.W   #0x16, R14
   \   00001E   0D43         MOV.W   #0x0, R13
   \   000020   3C408200     MOV.W   #0x82, R12
   \   000024   ........     CALLA   #osal_nv_write
   1552          
   1553            nwkFrameCounterChanges = 0;
   \   000028   8243....     MOV.W   #0x0, &nwkFrameCounterChanges
   1554          
   1555            // Clear copy in RAM before return.
   1556            osal_memset( &keyItems, 0x00, sizeof(keyItems) );
   \   00002C   3E401600     MOV.W   #0x16, R14
   \   000030   4D43         MOV.B   #0x0, R13
   \   000032   0C4A         MOV.W   R10, R12
   \   000034   ........     CALLA   #osal_memset
   1557          
   1558          }
   \   000038   ....         JMP     ?Subroutine0
   1559          
   1560          /*********************************************************************
   1561           * @fn      ZDApp_ResetNwkKey()
   1562           *
   1563           * @brief   Reset the Network key information in NV.
   1564           *
   1565           * @param   none
   1566           *
   1567           * @return  none
   1568           */

   \                                 In  segment CODE, align 2, keep-with-next
   1569          void ZDApp_ResetNwkKey( void )
   \                     ZDApp_ResetNwkKey:
   1570          {
   \   000000   31801600     SUB.W   #0x16, SP
   1571            nwkActiveKeyItems keyItems;
   1572          
   1573            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \   000004   ........     CALLA   #?Subroutine12
   1574            osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof( nwkActiveKeyItems ),
   1575                          (void *)&keyItems );
   \                     ??CrossCallReturnLabel_6:
   \   000008   ........     CALLA   #?Subroutine13
   \                     ??CrossCallReturnLabel_9:
   \   00000C   ........     CALLA   #osal_nv_write
   1576          }
   \   000010   31501600     ADD.W   #0x16, SP
   \   000014   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine13:
   \   000000   0F41         MOV.W   SP, R15
   \   000002   2F52         ADD.W   #0x4, R15
   \   000004   3E401600     MOV.W   #0x16, R14
   \   000008   0D43         MOV.W   #0x0, R13
   \   00000A   3C408200     MOV.W   #0x82, R12
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine12:
   \   000000   3E401600     MOV.W   #0x16, R14
   \   000004   4D43         MOV.B   #0x0, R13
   \   000006   0C41         MOV.W   SP, R12
   \   000008   2C52         ADD.W   #0x4, R12
   \   00000A   ........     BRA     #osal_memset
   1577          
   1578          /*********************************************************************
   1579           * @fn      ZDApp_RestoreNwkKey()
   1580           *
   1581           * @brief
   1582           *
   1583           *   Save off the Network key information.
   1584           *
   1585           * @param   none
   1586           *
   1587           * @return  true if restored from NV, false if not
   1588           */

   \                                 In  segment CODE, align 2, keep-with-next
   1589          uint8 ZDApp_RestoreNwkKey( void )
   \                     ZDApp_RestoreNwkKey:
   1590          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31801600     SUB.W   #0x16, SP
   1591            nwkActiveKeyItems keyItems;
   1592            uint8 ret = false;
   \   000006   4A43         MOV.B   #0x0, R10
   1593          
   1594            if ( osal_nv_read( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), (void*)&keyItems )
   1595                == ZSUCCESS )
   \   000008   ........     CALLA   #?Subroutine13
   \                     ??CrossCallReturnLabel_8:
   \   00000C   ........     CALLA   #osal_nv_read
   \   000010   4C93         CMP.B   #0x0, R12
   \   000012   1520         JNE     ??ZDApp_RestoreNwkKey_0
   1596            {
   1597              if ( keyItems.frameCounter > 0 )
   \   000014   1F411200     MOV.W   0x12(SP), R15
   \   000018   1FD11400     BIS.W   0x14(SP), R15
   \   00001C   0F93         CMP.W   #0x0, R15
   \   00001E   0C24         JEQ     ??ZDApp_RestoreNwkKey_1
   1598              {
   1599                // Restore the key information
   1600                keyItems.frameCounter += MAX_NWK_FRAMECOUNTER_CHANGES;
   \   000020   B150E8031200 ADD.W   #0x3e8, 0x12(SP)
   \   000026   81631400     ADDC.W  #0x0, 0x14(SP)
   1601                nwkFrameCounter = keyItems.frameCounter;
   \   00002A   92411200.... MOV.W   0x12(SP), &nwkFrameCounter
   \   000030   92411400.... MOV.W   0x14(SP), &nwkFrameCounter + 2
   1602                ret = true;
   \   000036   5A43         MOV.B   #0x1, R10
   1603              }
   1604          
   1605              // Force a save for the first frame counter increment
   1606              nwkFrameCounterChanges = MAX_NWK_FRAMECOUNTER_CHANGES + 1;
   \                     ??ZDApp_RestoreNwkKey_1:
   \   000038   B240E903.... MOV.W   #0x3e9, &nwkFrameCounterChanges
   1607            }
   1608            // Clear copy in RAM before return.
   1609            osal_memset( &keyItems, 0x00, sizeof(keyItems) );
   \                     ??ZDApp_RestoreNwkKey_0:
   \   00003E   ........     CALLA   #?Subroutine12
   1610          
   1611            return ( ret );
   \                     ??CrossCallReturnLabel_7:
   \   000042   4C4A         MOV.B   R10, R12
   \   000044                REQUIRE ?Subroutine0
   \   000044                // Fall through to label ?Subroutine0
   1612          }
   1613          
   1614          /*********************************************************************
   1615           * @fn      ZDApp_ResetTimerStart
   1616           *
   1617           * @brief   Start the reset timer.
   1618           *
   1619           * @param   delay - delay time(ms) before reset
   1620           *
   1621           * @return  none
   1622           */

   \                                 In  segment CODE, align 2, keep-with-next
   1623          void ZDApp_ResetTimerStart( uint16 delay )
   \                     ZDApp_ResetTimerStart:
   1624          {
   1625            // Start the rest timer
   1626            osal_start_timerEx( ZDAppTaskID, ZDO_DEVICE_RESET, delay );
   \   000000   0E4C         MOV.W   R12, R14
   \   000002   2D42         MOV.W   #0x4, R13
   \   000004                REQUIRE ?Subroutine4
   \   000004                // Fall through to label ?Subroutine4
   1627          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   5C42....     MOV.B   &ZDAppTaskID, R12
   \   000004   ........     BRA     #osal_start_timerEx
   1628          
   1629          /*********************************************************************
   1630           * @fn      ZDApp_ResetTimerCancel
   1631           *
   1632           * @brief   Cancel the reset timer.
   1633           *
   1634           * @param   none
   1635           *
   1636           * @return  none
   1637           */

   \                                 In  segment CODE, align 2, keep-with-next
   1638          void ZDApp_ResetTimerCancel( void )
   \                     ZDApp_ResetTimerCancel:
   1639          {
   1640            // Cancel the reset timer
   1641            osal_stop_timerEx( ZDAppTaskID, ZDO_DEVICE_RESET );
   \   000000   2D42         MOV.W   #0x4, R13
   \   000002   5C42....     MOV.B   &ZDAppTaskID, R12
   \   000006   ........     BRA     #osal_stop_timerEx
   1642          }
   1643          
   1644          /*********************************************************************
   1645           * @fn      ZDApp_LeaveCtrlInit
   1646           *
   1647           * @brief   Initialize the leave control logic.
   1648           *
   1649           * @param   none
   1650           *
   1651           * @return  none
   1652           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine14:
   \   000000   3F40....     MOV.W   #ZDApp_LeaveCtrl, R15
   \   000004   1E43         MOV.W   #0x1, R14
   \   000006   0D43         MOV.W   #0x0, R13
   \   000008   3C408500     MOV.W   #0x85, R12
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1653          void ZDApp_LeaveCtrlInit( void )
   \                     ZDApp_LeaveCtrlInit:
   1654          {
   1655            uint8 status;
   1656          
   1657          
   1658            // Initialize control state
   1659            ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_INIT;
   \   000000   C243....     MOV.B   #0x0, &ZDApp_LeaveCtrl
   1660          
   1661            status = osal_nv_item_init( ZCD_NV_LEAVE_CTRL,
   1662                                        sizeof(ZDApp_LeaveCtrl),
   1663                                        &ZDApp_LeaveCtrl );
   1664          
   1665            if ( status == ZSUCCESS )
   \   000004   3E40....     MOV.W   #ZDApp_LeaveCtrl, R14
   \   000008   1D43         MOV.W   #0x1, R13
   \   00000A   3C408500     MOV.W   #0x85, R12
   \   00000E   ........     CALLA   #osal_nv_item_init
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   0420         JNE     ??ZDApp_LeaveCtrlInit_0
   1666            {
   1667              // Read saved control
   1668              osal_nv_read( ZCD_NV_LEAVE_CTRL,
   1669                            0,
   1670                            sizeof( uint8 ),
   1671                            &ZDApp_LeaveCtrl);
   \   000016   ........     CALLA   #?Subroutine14
   1672            }
   \                     ??CrossCallReturnLabel_10:
   \   00001A   ........     CALLA   #osal_nv_read
   1673          }
   \                     ??ZDApp_LeaveCtrlInit_0:
   \   00001E   1001         RETA
   1674          
   1675          /*********************************************************************
   1676           * @fn      ZDApp_LeaveCtrlSet
   1677           *
   1678           * @brief   Set the leave control logic.
   1679           *
   1680           * @param   ra - reassociate flag
   1681           *
   1682           * @return  none
   1683           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   ........     CALLA   #?Subroutine14
   \                     ??CrossCallReturnLabel_11:
   \   000004   ........     BRA     #osal_nv_write

   \                                 In  segment CODE, align 2, keep-with-next
   1684          void ZDApp_LeaveCtrlSet( uint8 ra )
   \                     ZDApp_LeaveCtrlSet:
   1685          {
   1686            ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_SET;
   \   000000   5E43         MOV.B   #0x1, R14
   1687          
   1688            if ( ra == TRUE )
   \   000002   5C93         CMP.B   #0x1, R12
   \   000004   0220         JNE     ??ZDApp_LeaveCtrlSet_0
   1689            {
   1690              ZDApp_LeaveCtrl |= ZDAPP_LEAVE_CTRL_RA;
   \   000006   7E400300     MOV.B   #0x3, R14
   \                     ??ZDApp_LeaveCtrlSet_0:
   \   00000A   C24E....     MOV.B   R14, &ZDApp_LeaveCtrl
   1691            }
   1692          
   1693            // Write the leave control
   1694            osal_nv_write( ZCD_NV_LEAVE_CTRL,
   1695                           0,
   1696                           sizeof( uint8 ),
   1697                           &ZDApp_LeaveCtrl);
   \   00000E   ....         JMP     ?Subroutine5
   1698          }
   1699          
   1700          /*********************************************************************
   1701           * @fn      ZDApp_LeaveCtrlReset
   1702           *
   1703           * @brief   Re-initialize the leave control logic.
   1704           *
   1705           * @param   none
   1706           *
   1707           * @return  none
   1708           */

   \                                 In  segment CODE, align 2, keep-with-next
   1709          void ZDApp_LeaveCtrlReset( void )
   \                     ZDApp_LeaveCtrlReset:
   1710          {
   1711            // Set leave control to initialized state
   1712            ZDApp_LeaveCtrl = ZDAPP_LEAVE_CTRL_INIT;
   \   000000   C243....     MOV.B   #0x0, &ZDApp_LeaveCtrl
   1713          
   1714            // Write initialized control
   1715            osal_nv_write( ZCD_NV_LEAVE_CTRL,
   1716                          0,
   1717                          sizeof( uint8 ),
   1718                          &ZDApp_LeaveCtrl);
   \   000004                REQUIRE ?Subroutine5
   \   000004                // Fall through to label ?Subroutine5
   1719          }
   1720          
   1721          /*********************************************************************
   1722           * @fn      ZDApp_LeaveCtrlBypass
   1723           *
   1724           * @brief   Check if NV restore should be skipped during a leave reset.
   1725           *
   1726           * @param   none
   1727           *
   1728           * @return  uint8 - (TRUE bypass:FALSE do not bypass)
   1729           */

   \                                 In  segment CODE, align 2, keep-with-next
   1730          uint8 ZDApp_LeaveCtrlBypass( void )
   \                     ZDApp_LeaveCtrlBypass:
   1731          {
   1732            uint8 bypass;
   1733          
   1734            if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_SET )
   1735            {
   1736              bypass = TRUE;
   1737            }
   1738            else
   1739            {
   1740              bypass = FALSE;
   1741            }
   1742          
   1743            return bypass;
   \   000000   5C42....     MOV.B   &ZDApp_LeaveCtrl, R12
   \   000004   5CF3         AND.B   #0x1, R12
   \   000006   1001         RETA
   1744          }
   1745          
   1746          /*********************************************************************
   1747           * @fn      ZDApp_LeaveCtrlStartup
   1748           *
   1749           * @brief   Check for startup conditions during a leave reset.
   1750           *
   1751           * @param   state      - devState_t determined by leave control logic
   1752           * @param   startDelay - startup delay
   1753           *
   1754           * @return  none
   1755           */

   \                                 In  segment CODE, align 2, keep-with-next
   1756          void ZDApp_LeaveCtrlStartup( devStates_t* state, uint16* startDelay )
   \                     ZDApp_LeaveCtrlStartup:
   1757          {
   1758            *startDelay = 0;
   \   000000   8D430000     MOV.W   #0x0, 0(R13)
   1759          
   1760            if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_SET )
   \   000004   D2B3....     BIT.B   #0x1, &ZDApp_LeaveCtrl
   \   000008   0B28         JNC     ??ZDApp_LeaveCtrlStartup_0
   1761            {
   1762              if ( ZDApp_LeaveCtrl & ZDAPP_LEAVE_CTRL_RA )
   \   00000A   E2B3....     BIT.B   #0x2, &ZDApp_LeaveCtrl
   \   00000E   0428         JNC     ??ZDApp_LeaveCtrlStartup_1
   1763              {
   1764                *startDelay = LEAVE_RESET_DELAY;
   \   000010   BD4088130000 MOV.W   #0x1388, 0(R13)
   \   000016   023C         JMP     ??ZDApp_LeaveCtrlStartup_2
   1765              }
   1766              else
   1767              {
   1768                *state = DEV_HOLD;
   \                     ??ZDApp_LeaveCtrlStartup_1:
   \   000018   CC430000     MOV.B   #0x0, 0(R12)
   1769              }
   1770          
   1771              // Reset leave control logic
   1772              ZDApp_LeaveCtrlReset();
   \                     ??ZDApp_LeaveCtrlStartup_2:
   \   00001C   ........     CALLA   #ZDApp_LeaveCtrlReset
   1773            }
   1774          }
   \                     ??ZDApp_LeaveCtrlStartup_0:
   \   000020   1001         RETA
   1775          
   1776          /*********************************************************************
   1777           * @fn      ZDApp_LeaveReset
   1778           *
   1779           * @brief   Setup a device reset due to a leave indication/confirm.
   1780           *
   1781           * @param   ra - reassociate flag
   1782           *
   1783           * @return  none
   1784           */

   \                                 In  segment CODE, align 2, keep-with-next
   1785          void ZDApp_LeaveReset( uint8 ra )
   \                     ZDApp_LeaveReset:
   1786          {
   1787            ZDApp_LeaveCtrlSet( ra );
   \   000000   ........     CALLA   #ZDApp_LeaveCtrlSet
   1788          
   1789            ZDApp_ResetTimerStart( LEAVE_RESET_DELAY );
   \   000004   3C408813     MOV.W   #0x1388, R12
   \   000008   ........     BRA     #ZDApp_ResetTimerStart
   1790          }
   1791          
   1792          /*********************************************************************
   1793           * @fn      ZDApp_LeaveUpdate
   1794           *
   1795           * @brief   Update local device data related to leaving device.
   1796           *
   1797           * @param   nwkAddr        - NWK address of leaving device
   1798           * @param   extAddr        - EXT address of leaving device
   1799           * @param   removeChildren - remove children of leaving device
   1800           *
   1801           * @return  none
   1802           */

   \                                 In  segment CODE, align 2, keep-with-next
   1803          void ZDApp_LeaveUpdate( uint16 nwkAddr, uint8* extAddr,
   \                     ZDApp_LeaveUpdate:
   1804                                  uint8 removeChildren )
   1805          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31800A00     SUB.W   #0xa, SP
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0B4D         MOV.W   R13, R11
   1806            // Remove Apps Key for leaving device
   1807            ZDSecMgrDeviceRemoveByExtAddr(extAddr);
   \   00000A   0C4D         MOV.W   R13, R12
   \   00000C   ........     CALLA   #ZDSecMgrDeviceRemoveByExtAddr
   1808          
   1809            // Clear SECURITY bit from Address Manager
   1810            ZDSecMgrAddrClear( extAddr );
   \   000010   0C4B         MOV.W   R11, R12
   \   000012   ........     CALLA   #ZDSecMgrAddrClear
   1811          
   1812            if ( pbindRemoveDev )
   \   000016   1F42....     MOV.W   &pbindRemoveDev, R15
   \   00001A   1FD2....     BIS.W   &pbindRemoveDev + 2, R15
   \   00001E   0F93         CMP.W   #0x0, R15
   \   000020   0D24         JEQ     ??ZDApp_LeaveUpdate_0
   1813            {
   1814              zAddrType_t devAddr;
   1815          
   1816              // Remove bind entry and all related data
   1817              devAddr.addrMode = Addr64Bit;
   \   000022   F14003000800 MOV.B   #0x3, 0x8(SP)
   1818              osal_memcpy(devAddr.addr.extAddr, extAddr, Z_EXTADDR_LEN);
   \   000028   3E42         MOV.W   #0x8, R14
   \   00002A   0D4B         MOV.W   R11, R13
   \   00002C   0C41         MOV.W   SP, R12
   \   00002E   0C53         ADD.W   #0x0, R12
   \   000030   ........     CALLA   #osal_memcpy
   1819          
   1820              pbindRemoveDev(&devAddr);
   \   000034   0C41         MOV.W   SP, R12
   \   000036   0C53         ADD.W   #0x0, R12
   \   000038   ........     CALLA   &pbindRemoveDev
   1821            }
   1822          
   1823            // Remove if child
   1824            if ( ZSTACK_ROUTER_BUILD )
   1825            {
   1826              NLME_RemoveChild( extAddr, removeChildren );
   1827            }
   1828          
   1829            // Remove Routing table related entry
   1830            RTG_RemoveRtgEntry( nwkAddr, 0 );
   \                     ??ZDApp_LeaveUpdate_0:
   \   00003C   4D43         MOV.B   #0x0, R13
   \   00003E   0C4A         MOV.W   R10, R12
   \   000040   ........     CALLA   #RTG_RemoveRtgEntry
   1831          
   1832            // Remove entry from neighborTable
   1833            nwkNeighborRemove( nwkAddr, _NIB.nwkPanId );
   \   000044   1D42....     MOV.W   &_NIB + 36, R13
   \   000048   0C4A         MOV.W   R10, R12
   \   00004A   ........     CALLA   #nwkNeighborRemove
   1834          
   1835            // Schedule to save data to NV
   1836            ZDApp_NwkWriteNVRequest();
   1837          }
   \   00004E   31500A00     ADD.W   #0xa, SP
   \   000052   1A17         POPM.W  #0x2, R11
   \   000054   1001         RETA
   1838          
   1839          /*********************************************************************
   1840           * @fn      ZDApp_NetworkDiscoveryReq
   1841           *
   1842           * @brief   Request a network discovery.
   1843           *
   1844           * @param  scanChannels -
   1845           * @param  scanDuration -
   1846           *
   1847           * @return  ZStatus_t
   1848           */

   \                                 In  segment CODE, align 2, keep-with-next
   1849          ZStatus_t ZDApp_NetworkDiscoveryReq( uint32 scanChannels, uint8 scanDuration)
   \                     ZDApp_NetworkDiscoveryReq:
   1850          {
   1851            // Setup optional filters - tbd
   1852          
   1853            // Request NLME network discovery
   1854            return NLME_NetworkDiscoveryRequest(scanChannels, scanDuration);
   \   000000   ........     BRA     #NLME_NetworkDiscoveryRequest
   1855          }
   1856          
   1857          /*********************************************************************
   1858           * @fn      ZDApp_JoinReq
   1859           *
   1860           * @brief   Request the device to join a parent in a network.
   1861           *
   1862           * @param   channel -
   1863           * @param   panID -
   1864           *
   1865           * @return  ZStatus_t
   1866           */

   \                                 In  segment CODE, align 2, keep-with-next
   1867          ZStatus_t ZDApp_JoinReq( uint8 channel, uint16 panID, uint8 *extendedPanID,
   \                     ZDApp_JoinReq:
   1868                                   uint16 chosenParent, uint8 parentDepth, uint8 stackProfile )
   1869          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   084E         MOV.W   R14, R8
   \   000008   094F         MOV.W   R15, R9
   \   00000A   56411000     MOV.B   0x10(SP), R6
   \   00000E   5C411200     MOV.B   0x12(SP), R12
   1870            // Sync up the node with the stack profile (In the case where a pro device
   1871            // joins a non-pro network, or verse versa)
   1872            ZDApp_NodeProfileSync( stackProfile);
   \   000012   ........     CALLA   #ZDApp_NodeProfileSync
   1873          
   1874            // Request NLME Join Request
   1875            return NLME_JoinRequest(extendedPanID, panID,channel,
   1876                                    ZDO_Config_Node_Descriptor.CapabilityFlags,
   1877                                    chosenParent, parentDepth);
   \   000016   4612         PUSH.B  R6
   \   000018   0912         PUSH.W  R9
   \   00001A   5F42....     MOV.B   &ZDO_Config_Node_Descriptor + 2, R15
   \   00001E   4E4A         MOV.B   R10, R14
   \   000020   0D4B         MOV.W   R11, R13
   \   000022   0C48         MOV.W   R8, R12
   \   000024   ........     CALLA   #NLME_JoinRequest
   \   000028   2152         ADD.W   #0x4, SP
   \   00002A   5617         POPM.W  #0x6, R11
   \   00002C   1001         RETA
   1878          
   1879          }
   1880          
   1881          /*********************************************************************
   1882           * @fn      ZDApp_DeviceConfigured
   1883           *
   1884           * @brief   Check to see if the local device is configured (i.e., part
   1885           *          of a network).
   1886           *
   1887           * @param   none
   1888           *
   1889           * @return  TRUE if configured. FALSE, otherwise.
   1890           */

   \                                 In  segment CODE, align 2, keep-with-next
   1891          uint8 ZDApp_DeviceConfigured( void )
   \                     ZDApp_DeviceConfigured:
   1892          {
   \   000000   2183         SUB.W   #0x2, SP
   1893            uint16 nwkAddr = INVALID_NODE_ADDR;
   \   000002   B140FEFF0000 MOV.W   #0xfffe, 0(SP)
   1894          
   1895            osal_nv_read( ZCD_NV_NIB, osal_offsetof( nwkIB_t, nwkDevAddress ),
   1896                          sizeof( uint16), &nwkAddr );
   \   000008   0F41         MOV.W   SP, R15
   \   00000A   0F53         ADD.W   #0x0, R15
   \   00000C   2E43         MOV.W   #0x2, R14
   \   00000E   3D401600     MOV.W   #0x16, R13
   \   000012   3C402100     MOV.W   #0x21, R12
   \   000016   ........     CALLA   #osal_nv_read
   1897          
   1898            // Does the NIB have anything more than default?
   1899            return ( nwkAddr == INVALID_NODE_ADDR ? FALSE : TRUE );
   \   00001A   B190FEFF0000 CMP.W   #0xfffe, 0(SP)
   \   000020   0224         JEQ     ??ZDApp_DeviceConfigured_0
   \   000022   5C43         MOV.B   #0x1, R12
   \   000024   013C         JMP     ??ZDApp_DeviceConfigured_1
   \                     ??ZDApp_DeviceConfigured_0:
   \   000026   4C43         MOV.B   #0x0, R12
   \                     ??ZDApp_DeviceConfigured_1:
   \   000028   2153         ADD.W   #0x2, SP
   \   00002A   1001         RETA
   1900          }
   1901          
   1902          /*********************************************************************
   1903           * CALLBACK FUNCTIONS
   1904           */
   1905          
   1906          
   1907          /*********************************************************************
   1908           * @fn      ZDApp_SendEventMsg()
   1909           *
   1910           * @brief
   1911           *
   1912           *   Sends a Network Join message
   1913           *
   1914           * @param  cmd - command ID
   1915           * @param  len - length (in bytes) of the buf field
   1916           * @param  buf - buffer for the rest of the message.
   1917           *
   1918           * @return  none
   1919           */

   \                                 In  segment CODE, align 2, keep-with-next
   1920          void ZDApp_SendEventMsg( uint8 cmd, uint8 len, uint8 *buf )
   \                     ZDApp_SendEventMsg:
   1921          {
   1922            ZDApp_SendMsg( ZDAppTaskID, cmd, len, buf );
   \   000000   0F4E         MOV.W   R14, R15
   \   000002   4E4D         MOV.B   R13, R14
   \   000004   4D4C         MOV.B   R12, R13
   \   000006   5C42....     MOV.B   &ZDAppTaskID, R12
   \   00000A   ........     BRA     #ZDApp_SendMsg
   1923          }
   1924          
   1925          /*********************************************************************
   1926           * @fn      ZDApp_SendMsg()
   1927           *
   1928           * @brief   Sends a OSAL message
   1929           *
   1930           * @param  taskID - Where to send the message
   1931           * @param  cmd - command ID
   1932           * @param  len - length (in bytes) of the buf field
   1933           * @param  buf - buffer for the rest of the message.
   1934           *
   1935           * @return  none
   1936           */

   \                                 In  segment CODE, align 2, keep-with-next
   1937          void ZDApp_SendMsg( uint8 taskID, uint8 cmd, uint8 len, uint8 *buf )
   \                     ZDApp_SendMsg:
   1938          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   4B4C         MOV.B   R12, R11
   \   000004   484D         MOV.B   R13, R8
   \   000006   4A4E         MOV.B   R14, R10
   \   000008   094F         MOV.W   R15, R9
   1939            osal_event_hdr_t *msgPtr;
   1940          
   1941            // Send the address to the task
   1942            msgPtr = (osal_event_hdr_t *)osal_msg_allocate( len );
   \   00000A   464E         MOV.B   R14, R6
   \   00000C   0C46         MOV.W   R6, R12
   \   00000E   ........     CALLA   #osal_msg_allocate
   \   000012   074C         MOV.W   R12, R7
   1943            if ( msgPtr )
   \   000014   0C93         CMP.W   #0x0, R12
   \   000016   0E24         JEQ     ??ZDApp_SendMsg_0
   1944            {
   1945              if ( (len > 0) && (buf != NULL) )
   \   000018   4A93         CMP.B   #0x0, R10
   \   00001A   0624         JEQ     ??ZDApp_SendMsg_1
   \   00001C   0993         CMP.W   #0x0, R9
   \   00001E   0424         JEQ     ??ZDApp_SendMsg_1
   1946                osal_memcpy( msgPtr, buf, len );
   \   000020   0E46         MOV.W   R6, R14
   \   000022   0D49         MOV.W   R9, R13
   \   000024   ........     CALLA   #osal_memcpy
   1947          
   1948              msgPtr->event = cmd;
   \                     ??ZDApp_SendMsg_1:
   \   000028   C7480000     MOV.B   R8, 0(R7)
   1949              osal_msg_send( taskID, (uint8 *)msgPtr );
   \   00002C   0D47         MOV.W   R7, R13
   \   00002E   4C4B         MOV.B   R11, R12
   \   000030   ........     CALLA   #osal_msg_send
   1950            }
   1951          }
   \                     ??ZDApp_SendMsg_0:
   \   000034   5617         POPM.W  #0x6, R11
   \   000036   1001         RETA
   1952          
   1953          /*********************************************************************
   1954           * Call Back Functions from NWK  - API
   1955           */
   1956          
   1957          /*********************************************************************
   1958           * @fn          ZDO_NetworkDiscoveryConfirmCB
   1959           *
   1960           * @brief       This function returns a choice of PAN to join.
   1961           *
   1962           * @param       status - return status of the nwk discovery confirm
   1963           *
   1964           * @return      ZStatus_t
   1965           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000   5C42....     MOV.B   &ZDAppTaskID, R12
   \   000004   ........     BRA     #ZDApp_SendMsg

   \                                 In  segment CODE, align 2, keep-with-next
   1966          ZStatus_t ZDO_NetworkDiscoveryConfirmCB(uint8 status)
   \                     ZDO_NetworkDiscoveryConfirmCB:
   1967          {
   \   000000   4C12         PUSH.B  R12
   \   000002   2183         SUB.W   #0x2, SP
   1968            osal_event_hdr_t msg;
   1969          
   1970            // If Scan is initiated by ZDO_MGMT_NWK_DISC_REQ
   1971            // Send ZDO_MGMT_NWK_DISC_RSP back
   1972          #if defined ( ZDO_MGMT_NWKDISC_RESPONSE )
   1973            if ( zdappMgmtNwkDiscReqInProgress )
   1974            {
   1975              zdappMgmtNwkDiscReqInProgress = false;
   1976              ZDO_FinishProcessingMgmtNwkDiscReq();
   1977            }
   1978            else
   1979          #endif
   1980            {
   1981              // Pass the confirm to another task if it registers the callback
   1982              // Otherwise, pass the confirm to ZDApp.
   1983              if (zdoCBFunc[ZDO_NWK_DISCOVERY_CNF_CBID] != NULL )
   \   000004   1F42....     MOV.W   &zdoCBFunc + 8, R15
   \   000008   1FD2....     BIS.W   &zdoCBFunc + 10, R15
   \   00000C   0F93         CMP.W   #0x0, R15
   \   00000E   0524         JEQ     ??ZDO_NetworkDiscoveryConfirmCB_0
   1984              {
   1985                zdoCBFunc[ZDO_NWK_DISCOVERY_CNF_CBID]( (void*)&status );
   \   000010   0C41         MOV.W   SP, R12
   \   000012   2C53         ADD.W   #0x2, R12
   \   000014   ........     CALLA   &zdoCBFunc + 8
   \   000018   083C         JMP     ??ZDO_NetworkDiscoveryConfirmCB_1
   1986              }
   1987              else
   1988              {
   1989                // Otherwise, send scan confirm to ZDApp task to proceed
   1990                msg.status = ZDO_SUCCESS;
   \                     ??ZDO_NetworkDiscoveryConfirmCB_0:
   \   00001A   C1430100     MOV.B   #0x0, 0x1(SP)
   1991                ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_DISC_CNF, sizeof(osal_event_hdr_t), (uint8 *)&msg );
   \   00001E   0F41         MOV.W   SP, R15
   \   000020   0F53         ADD.W   #0x0, R15
   \   000022   6E43         MOV.B   #0x2, R14
   \   000024   5D43         MOV.B   #0x1, R13
   \   000026   ........     CALLA   #?Subroutine8
   1992              }
   1993            }
   1994            return (ZSuccess);
   \                     ??ZDO_NetworkDiscoveryConfirmCB_1:
   \   00002A   4C43         MOV.B   #0x0, R12
   \   00002C   2152         ADD.W   #0x4, SP
   \   00002E   1001         RETA
   1995          }  // ZDO_NetworkDiscoveryConfirmCB
   1996          
   1997          /*********************************************************************
   1998           * @fn          ZDApp_NwkDescListProcessing
   1999           *
   2000           * @brief       This function process the network discovery result and select
   2001           *              a parent device to join itself.
   2002           *
   2003           * @param       none
   2004           *
   2005           * @return      ZStatus_t
   2006           */
   2007          #define STACK_PROFILE_MAX 2

   \                                 In  segment CODE, align 2, keep-with-next
   2008          networkDesc_t* ZDApp_NwkDescListProcessing(void)
   \                     ZDApp_NwkDescListProcessing:
   2009          {
   \   000000   5B15         PUSHM.W #0x6, R11
   2010            networkDesc_t *pNwkDesc;
   2011            uint8 i, ResultCount = 0;
   \   000002   4A43         MOV.B   #0x0, R10
   2012            uint8 stackProfile;
   2013            uint8 stackProfilePro;
   2014            uint8 selected;
   2015          
   2016            // Count the number of nwk descriptors in the list
   2017            pNwkDesc = nwk_getNwkDescList();
   \   000004   ........     CALLA   #nwk_getNwkDescList
   \   000008   0B4C         MOV.W   R12, R11
   \   00000A   033C         JMP     ??ZDApp_NwkDescListProcessing_6
   2018            while (pNwkDesc)
   2019            {
   2020              ResultCount++;
   \                     ??ZDApp_NwkDescListProcessing_0:
   \   00000C   5A53         ADD.B   #0x1, R10
   2021              pNwkDesc = pNwkDesc->nextDesc;
   \   00000E   1B4B1600     MOV.W   0x16(R11), R11
   2022            }
   \                     ??ZDApp_NwkDescListProcessing_6:
   \   000012   0B93         CMP.W   #0x0, R11
   \   000014   FB23         JNE     ??ZDApp_NwkDescListProcessing_0
   2023          
   2024            // process discovery results
   2025            stackProfilePro = FALSE;
   \   000016   4843         MOV.B   #0x0, R8
   2026            selected = FALSE;
   2027          
   2028          
   2029            for ( stackProfile = 0; stackProfile < STACK_PROFILE_MAX; stackProfile++ )
   \   000018   4943         MOV.B   #0x0, R9
   2030            {
   2031              pNwkDesc = nwk_getNwkDescList();
   \                     ??ZDApp_NwkDescListProcessing_5:
   \   00001A   ........     CALLA   #nwk_getNwkDescList
   \   00001E   0B4C         MOV.W   R12, R11
   2032              for ( i = 0; i < ResultCount; i++, pNwkDesc = pNwkDesc->nextDesc )
   \   000020   4643         MOV.B   #0x0, R6
   \   000022   0A3C         JMP     ??ZDApp_NwkDescListProcessing_7
   2033              {
   2034                if ( zgConfigPANID != 0xFFFF )
   2035                {
   2036                  // PAN Id is preconfigured. check if it matches
   2037                  if ( pNwkDesc->panId != zgConfigPANID )
   2038                    continue;
   2039                }
   2040          
   2041                if ( nwk_ExtPANIDValid( ZDO_UseExtendedPANID) == true )
   2042                {
   2043                  // If the extended Pan ID is commissioned to a non zero value
   2044                  // Only join the Pan that has match EPID
   2045                  if ( osal_ExtAddrEqual( ZDO_UseExtendedPANID, pNwkDesc->extendedPANID) == false )
   2046                    continue;
   2047          
   2048                }
   2049          
   2050                // check that network is allowing joining
   2051                if ( ZSTACK_ROUTER_BUILD )
   2052                {
   2053                  if ( stackProfilePro == FALSE )
   2054                  {
   2055                    if ( !pNwkDesc->routerCapacity )
   2056                    {
   2057                      continue;
   2058                    }
   2059                  }
   2060                  else
   2061                  {
   2062                    if ( !pNwkDesc->deviceCapacity )
   2063                    {
   2064                      continue;
   2065                    }
   2066                  }
   2067                }
   2068                else if ( ZSTACK_END_DEVICE_BUILD )
   2069                {
   2070                  if ( !pNwkDesc->deviceCapacity )
   2071                  {
   2072                    continue;
   2073                  }
   2074                }
   2075          
   2076                // check version of zigbee protocol
   2077                if ( pNwkDesc->version != _NIB.nwkProtocolVersion )
   2078                  continue;
   2079          
   2080                // check version of stack profile
   2081                if ( pNwkDesc->stackProfile != zgStackProfile  )
   2082                {
   2083                  if ( ((zgStackProfile == HOME_CONTROLS) && (pNwkDesc->stackProfile == ZIGBEEPRO_PROFILE))
   2084                      || ((zgStackProfile == ZIGBEEPRO_PROFILE) && (pNwkDesc->stackProfile == HOME_CONTROLS))  )
   \                     ??ZDApp_NwkDescListProcessing_2:
   \   000024   6E93         CMP.B   #0x2, R14
   \   000026   0320         JNE     ??ZDApp_NwkDescListProcessing_3
   \   000028   5F93         CMP.B   #0x1, R15
   \   00002A   0120         JNE     ??ZDApp_NwkDescListProcessing_3
   2085                  {
   2086                    stackProfilePro = TRUE;
   \                     ??ZDApp_NwkDescListProcessing_4:
   \   00002C   5843         MOV.B   #0x1, R8
   2087                  }
   2088          
   2089                  if ( stackProfile == 0 )
   \                     ??ZDApp_NwkDescListProcessing_3:
   \   00002E   4993         CMP.B   #0x0, R9
   \   000030   3620         JNE     ??ZDApp_NwkDescListProcessing_8
   \                     ??ZDApp_NwkDescListProcessing_1:
   \   000032   5653         ADD.B   #0x1, R6
   \   000034   1B4B1600     MOV.W   0x16(R11), R11
   \                     ??ZDApp_NwkDescListProcessing_7:
   \   000038   469A         CMP.B   R10, R6
   \   00003A   282C         JC      ??ZDApp_NwkDescListProcessing_9
   \   00003C   B293....     CMP.W   #0xffff, &zgConfigPANID
   \   000040   0424         JEQ     ??ZDApp_NwkDescListProcessing_10
   \   000042   9B92....0000 CMP.W   &zgConfigPANID, 0(R11)
   \   000048   F423         JNE     ??ZDApp_NwkDescListProcessing_1
   \                     ??ZDApp_NwkDescListProcessing_10:
   \   00004A   3C40....     MOV.W   #ZDO_UseExtendedPANID, R12
   \   00004E   ........     CALLA   #nwk_ExtPANIDValid
   \   000052   5C93         CMP.B   #0x1, R12
   \   000054   0920         JNE     ??ZDApp_NwkDescListProcessing_11
   \   000056   0D4B         MOV.W   R11, R13
   \   000058   3D500C00     ADD.W   #0xc, R13
   \   00005C   3C40....     MOV.W   #ZDO_UseExtendedPANID, R12
   \   000060   ........     CALLA   #sAddrExtCmp
   \   000064   4C93         CMP.B   #0x0, R12
   \   000066   E527         JEQ     ??ZDApp_NwkDescListProcessing_1
   \                     ??ZDApp_NwkDescListProcessing_11:
   \   000068   CB930400     CMP.B   #0x0, 0x4(R11)
   \   00006C   E227         JEQ     ??ZDApp_NwkDescListProcessing_1
   \   00006E   DB92....0500 CMP.B   &_NIB + 18, 0x5(R11)
   \   000074   DE23         JNE     ??ZDApp_NwkDescListProcessing_1
   \   000076   5F4B0600     MOV.B   0x6(R11), R15
   \   00007A   5E42....     MOV.B   &zgStackProfile, R14
   \   00007E   4F9E         CMP.B   R14, R15
   \   000080   0E24         JEQ     ??ZDApp_NwkDescListProcessing_8
   \   000082   5E93         CMP.B   #0x1, R14
   \   000084   CF23         JNE     ??ZDApp_NwkDescListProcessing_2
   \   000086   6F93         CMP.B   #0x2, R15
   \   000088   D223         JNE     ??ZDApp_NwkDescListProcessing_3
   \   00008A   D03F         JMP     ??ZDApp_NwkDescListProcessing_4
   2090                  {
   2091                    continue;
   2092                  }
   2093                }
   2094          
   2095                break;
   2096              }
   2097          
   2098              if (i < ResultCount)
   2099              {
   2100               selected = TRUE;
   2101                break;
   2102              }
   2103          
   2104              // break if selected or stack profile pro wasn't found
   2105              if ( (selected == TRUE) || (stackProfilePro == FALSE) )
   \                     ??ZDApp_NwkDescListProcessing_9:
   \   00008C   4893         CMP.B   #0x0, R8
   \   00008E   0324         JEQ     ??ZDApp_NwkDescListProcessing_12
   2106              {
   2107                break;
   2108              }
   2109            }
   \   000090   5953         ADD.B   #0x1, R9
   \   000092   6993         CMP.B   #0x2, R9
   \   000094   C22B         JNC     ??ZDApp_NwkDescListProcessing_5
   2110          
   2111            if ( i == ResultCount )
   \                     ??ZDApp_NwkDescListProcessing_12:
   \   000096   469A         CMP.B   R10, R6
   \   000098   0220         JNE     ??ZDApp_NwkDescListProcessing_8
   2112            {
   2113              return (NULL);   // couldn't find appropriate PAN to join !
   \   00009A   0C43         MOV.W   #0x0, R12
   \   00009C   013C         JMP     ??ZDApp_NwkDescListProcessing_13
   2114            }
   2115            else
   2116            {
   2117              return (pNwkDesc);
   \                     ??ZDApp_NwkDescListProcessing_8:
   \   00009E   0C4B         MOV.W   R11, R12
   \                     ??ZDApp_NwkDescListProcessing_13:
   \   0000A0   5617         POPM.W  #0x6, R11
   \   0000A2   1001         RETA
   2118            }
   2119          }// ZDApp_NwkDescListProcessing()
   2120          
   2121          /*********************************************************************
   2122           * @fn          ZDO_NetworkFormationConfirmCB
   2123           *
   2124           * @brief       This function reports the results of the request to
   2125           *              initialize a coordinator in a network.
   2126           *
   2127           * @param       Status - Result of NLME_NetworkFormationRequest()
   2128           *
   2129           * @return      none
   2130           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine11:
   \   000000   6D42         MOV.B   #0x4, R13
   \   000002   6C42         MOV.B   #0x4, R12
   \   000004   ........     BRA     #HalLedSet

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine10:
   \   000000   5D43         MOV.B   #0x1, R13
   \   000002   6C42         MOV.B   #0x4, R12
   \   000004   ........     CALLA   #HalLedSet
   \   000008   4D43         MOV.B   #0x0, R13
   \   00000A   7C42         MOV.B   #0x8, R12
   \   00000C   ........     CALLA   #HalLedSet
   \   000010   C293....     CMP.B   #0x0, &devState
   \   000014   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2131          void ZDO_NetworkFormationConfirmCB( ZStatus_t Status )
   \                     ZDO_NetworkFormationConfirmCB:
   2132          {
   2133            nwkStatus = (byte)Status;
   \   000000   C24C....     MOV.B   R12, &nwkStatus
   2134          
   2135            if ( Status == ZSUCCESS )
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   0620         JNE     ??ZDO_NetworkFormationConfirmCB_0
   2136            {
   2137              // LED on shows Coordinator started
   2138              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   \   000008   ........     CALLA   #?Subroutine10
   2139          
   2140              // LED off forgets HOLD_AUTO_START
   2141              HalLedSet (HAL_LED_4, HAL_LED_MODE_OFF);
   2142          
   2143          #if defined ( ZBIT )
   2144              SIM_SetColor(0xd0ffd0);
   2145          #endif
   2146          
   2147              if ( devState == DEV_HOLD )
   \                     ??CrossCallReturnLabel_5:
   \   00000C   0520         JNE     ??ZDO_NetworkFormationConfirmCB_1
   2148              {
   2149                // Began with HOLD_AUTO_START
   2150                devState = DEV_COORD_STARTING;
   \   00000E   F242....     MOV.B   #0x8, &devState
   \   000012   023C         JMP     ??ZDO_NetworkFormationConfirmCB_1
   2151              }
   2152            }
   2153          #if defined(BLINK_LEDS)
   2154            else
   2155            {
   2156              HalLedSet ( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   \                     ??ZDO_NetworkFormationConfirmCB_0:
   \   000014   ........     CALLA   #?Subroutine11
   2157            }
   2158          #endif
   2159          
   2160            osal_set_event( ZDAppTaskID, ZDO_NETWORK_START );
   \                     ??ZDO_NetworkFormationConfirmCB_1:
   \   000018   2D43         MOV.W   #0x2, R13
   \   00001A                REQUIRE ?Subroutine3
   \   00001A                // Fall through to label ?Subroutine3
   2161          }
   2162          
   2163          /****************************************************************************
   2164           * @fn          ZDApp_beaconIndProcessing
   2165           *
   2166           * @brief       This function processes the incoming beacon indication.
   2167           *
   2168           *              When another task (MT or App) is registered to process
   2169           *              beacon indication themselves, this function will parse the
   2170           *              beacon payload and pass the beacon descriptor to that task
   2171           *              If no other tasks registered, this function will process
   2172           *              the beacon payload and generate the network descriptor link
   2173           *              list.
   2174           *
   2175           * @param
   2176           *
   2177           * @return      none
   2178           *
   2179           */

   \                                 In  segment CODE, align 2, keep-with-next
   2180          void ZDO_beaconNotifyIndCB( NLME_beaconInd_t *pBeacon )
   \                     ZDO_beaconNotifyIndCB:
   2181          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4C         MOV.W   R12, R10
   2182            // Pass the beacon Indication to another task if it registers the callback
   2183            // Otherwise, process the beacon notification here.
   2184            if (zdoCBFunc[ZDO_BEACON_NOTIFY_IND_CBID] != NULL )
   \   000004   1F42....     MOV.W   &zdoCBFunc + 12, R15
   \   000008   1FD2....     BIS.W   &zdoCBFunc + 14, R15
   \   00000C   0F93         CMP.W   #0x0, R15
   \   00000E   0324         JEQ     ??ZDO_beaconNotifyIndCB_3
   2185            {
   2186              zdoCBFunc[ZDO_BEACON_NOTIFY_IND_CBID]( (void*)pBeacon );
   \   000010   ........     CALLA   &zdoCBFunc + 12
   \   000014   823C         JMP     ??ZDO_beaconNotifyIndCB_1
   2187            }
   2188            else
   2189            {
   2190              networkDesc_t *pNwkDesc;
   2191              networkDesc_t *pLastNwkDesc;
   2192              uint8 found = false;
   2193          
   2194              // Add the network to the Network Descriptor List
   2195              pNwkDesc = NwkDescList;
   \                     ??ZDO_beaconNotifyIndCB_3:
   \   000016   1B42....     MOV.W   &NwkDescList, R11
   \   00001A   084B         MOV.W   R11, R8
   2196              pLastNwkDesc = NwkDescList;
   \   00001C   0B3C         JMP     ??ZDO_beaconNotifyIndCB_4
   2197              while (pNwkDesc)
   2198              {
   2199                if ((pNwkDesc->panId == pBeacon->panID) &&
   2200                    (pNwkDesc->logicalChannel == pBeacon->logicalChannel))
   \                     ??ZDO_beaconNotifyIndCB_0:
   \   00001E   989C02000000 CMP.W   0x2(R12), 0(R8)
   \   000024   0420         JNE     ??ZDO_beaconNotifyIndCB_5
   \   000026   D89C04000200 CMP.B   0x4(R12), 0x2(R8)
   \   00002C   1E24         JEQ     ??ZDO_beaconNotifyIndCB_6
   2201                {
   2202                  found = true;
   2203                  break;
   2204                }
   2205                pLastNwkDesc = pNwkDesc;
   \                     ??ZDO_beaconNotifyIndCB_5:
   \   00002E   0B48         MOV.W   R8, R11
   2206                pNwkDesc = pNwkDesc->nextDesc;
   \   000030   18481600     MOV.W   0x16(R8), R8
   2207              }
   \                     ??ZDO_beaconNotifyIndCB_4:
   \   000034   0893         CMP.W   #0x0, R8
   \   000036   F323         JNE     ??ZDO_beaconNotifyIndCB_0
   2208          
   2209              // If no existing descriptor found, make a new one and add to the list
   2210              if (found == false)
   2211              {
   2212                pNwkDesc = osal_mem_alloc( sizeof(networkDesc_t)  );
   \   000038   3C401800     MOV.W   #0x18, R12
   \   00003C   ........     CALLA   #osal_mem_alloc
   \   000040   084C         MOV.W   R12, R8
   2213                if ( !pNwkDesc )
   \   000042   0C93         CMP.W   #0x0, R12
   \   000044   6A24         JEQ     ??ZDO_beaconNotifyIndCB_1
   2214                {
   2215                  // Memory alloc failed, discard this beacon
   2216                  return;
   2217                }
   2218          
   2219                // Clear the network descriptor
   2220                osal_memset( pNwkDesc, 0, sizeof(networkDesc_t)  );
   \   000046   3E401800     MOV.W   #0x18, R14
   \   00004A   4D43         MOV.B   #0x0, R13
   \   00004C   ........     CALLA   #osal_memset
   2221          
   2222                // Initialize the descriptor
   2223                pNwkDesc->chosenRouter = INVALID_NODE_ADDR;
   \   000050   B840FEFF0800 MOV.W   #0xfffe, 0x8(R8)
   2224                pNwkDesc->chosenRouterDepth = 0xFF;
   \   000056   F8430B00     MOV.B   #0xff, 0xb(R8)
   2225          
   2226                // Save new entry into the descriptor list
   2227                if ( !NwkDescList )
   \   00005A   8293....     CMP.W   #0x0, &NwkDescList
   \   00005E   0320         JNE     ??ZDO_beaconNotifyIndCB_7
   2228                {
   2229                  NwkDescList = pNwkDesc;
   \   000060   8248....     MOV.W   R8, &NwkDescList
   \   000064   023C         JMP     ??ZDO_beaconNotifyIndCB_6
   2230                }
   2231                else
   2232                {
   2233                  pLastNwkDesc->nextDesc = pNwkDesc;
   \                     ??ZDO_beaconNotifyIndCB_7:
   \   000066   8B481600     MOV.W   R8, 0x16(R11)
   2234                }
   2235              }
   2236          
   2237              // Update the descriptor with the incoming beacon
   2238              pNwkDesc->stackProfile   = pBeacon->stackProfile;
   \                     ??ZDO_beaconNotifyIndCB_6:
   \   00006A   D84A09000600 MOV.B   0x9(R10), 0x6(R8)
   2239              pNwkDesc->version        = pBeacon->protocolVersion;
   \   000070   D84A08000500 MOV.B   0x8(R10), 0x5(R8)
   2240              pNwkDesc->logicalChannel = pBeacon->logicalChannel;
   \   000076   D84A04000200 MOV.B   0x4(R10), 0x2(R8)
   2241              pNwkDesc->panId          = pBeacon->panID;
   \   00007C   984A02000000 MOV.W   0x2(R10), 0(R8)
   2242              pNwkDesc->updateId       = pBeacon->updateID;
   \   000082   D84A0C001400 MOV.B   0xc(R10), 0x14(R8)
   2243          
   2244              // Save the extended PAN ID from the beacon payload only if 1.1 version network
   2245              if ( pBeacon->protocolVersion != ZB_PROT_V1_0 )
   \   000088   DA930800     CMP.B   #0x1, 0x8(R10)
   \   00008C   0924         JEQ     ??ZDO_beaconNotifyIndCB_8
   2246              {
   2247                osal_cpyExtAddr( pNwkDesc->extendedPANID, pBeacon->extendedPanID );
   \   00008E   0D4A         MOV.W   R10, R13
   \   000090   3D500D00     ADD.W   #0xd, R13
   \   000094   0C48         MOV.W   R8, R12
   \   000096   3C500C00     ADD.W   #0xc, R12
   \   00009A   ........     CALLA   #sAddrExtCpy
   \   00009E   073C         JMP     ??ZDO_beaconNotifyIndCB_9
   2248              }
   2249              else
   2250              {
   2251                osal_memset( pNwkDesc->extendedPANID, 0xFF, Z_EXTADDR_LEN );
   \                     ??ZDO_beaconNotifyIndCB_8:
   \   0000A0   3E42         MOV.W   #0x8, R14
   \   0000A2   7D43         MOV.B   #0xff, R13
   \   0000A4   0C48         MOV.W   R8, R12
   \   0000A6   3C500C00     ADD.W   #0xc, R12
   \   0000AA   ........     CALLA   #osal_memset
   \                     ??ZDO_beaconNotifyIndCB_9:
   \   0000AE   5E4A0A00     MOV.B   0xa(R10), R14
   \   0000B2   C29E....     CMP.B   R14, &gMIN_TREE_LINK_COST
   \   0000B6   312C         JC      ??ZDO_beaconNotifyIndCB_1
   \   0000B8   DA930500     CMP.B   #0x1, 0x5(R10)
   \   0000BC   0324         JEQ     ??ZDO_beaconNotifyIndCB_10
   \   0000BE   C293....     CMP.B   #0x0, &_tmpRejoinState
   \   0000C2   2B24         JEQ     ??ZDO_beaconNotifyIndCB_1
   2252              }
   2253          
   2254              // check if this device is a better choice to join...
   2255              // ...dont bother checking assocPermit flag is doing a rejoin
   2256              if ( ( pBeacon->LQI > gMIN_TREE_LINK_COST ) &&
   2257                  ( ( pBeacon->permitJoining == TRUE ) || ( _tmpRejoinState ) ) )
   2258              {
   2259                uint8 selected = FALSE;
   \                     ??ZDO_beaconNotifyIndCB_10:
   \   0000C4   4F43         MOV.B   #0x0, R15
   2260                uint8 capacity = FALSE;
   2261          
   2262                if ( _NIB.nwkAddrAlloc == NWK_ADDRESSING_STOCHASTIC )
   \   0000C6   E293....     CMP.B   #0x2, &_NIB + 100
   \   0000CA   0B20         JNE     ??ZDO_beaconNotifyIndCB_11
   2263                {
   2264                  if ( ((pBeacon->LQI   > pNwkDesc->chosenRouterLinkQuality) &&
   2265                        (pBeacon->depth < MAX_NODE_DEPTH)) ||
   2266                      ((pBeacon->LQI   == pNwkDesc->chosenRouterLinkQuality) &&
   2267                       (pBeacon->depth < pNwkDesc->chosenRouterDepth)) )
   \   0000CC   5D480A00     MOV.B   0xa(R8), R13
   \   0000D0   4D9E         CMP.B   R14, R13
   \   0000D2   052C         JC      ??ZDO_beaconNotifyIndCB_12
   \   0000D4   FA9014000B00 CMP.B   #0x14, 0xb(R10)
   \   0000DA   0728         JNC     ??ZDO_beaconNotifyIndCB_13
   \   0000DC   073C         JMP     ??ZDO_beaconNotifyIndCB_14
   \                     ??ZDO_beaconNotifyIndCB_12:
   \   0000DE   4E9D         CMP.B   R13, R14
   \   0000E0   1220         JNE     ??ZDO_beaconNotifyIndCB_15
   2268                  {
   2269                    selected = TRUE;
   2270                  }
   2271                }
   2272                else
   2273                {
   2274                  if ( pBeacon->depth < pNwkDesc->chosenRouterDepth )
   \                     ??ZDO_beaconNotifyIndCB_11:
   \   0000E2   DA980B000B00 CMP.B   0xb(R8), 0xb(R10)
   \   0000E8   0E2C         JC      ??ZDO_beaconNotifyIndCB_15
   2275                  {
   2276                    selected = TRUE;
   \                     ??ZDO_beaconNotifyIndCB_13:
   \   0000EA   5F43         MOV.B   #0x1, R15
   2277                  }
   2278                }
   2279          
   2280                if ( ZSTACK_ROUTER_BUILD )
   2281                {
   2282                  capacity = pBeacon->routerCapacity;
   2283                }
   2284                else if ( ZSTACK_END_DEVICE_BUILD )
   2285                {
   2286                  capacity = pBeacon->deviceCapacity;
   2287                }
   2288          
   2289                if ( (capacity) && (selected) )
   \                     ??ZDO_beaconNotifyIndCB_14:
   \   0000EC   CA930700     CMP.B   #0x0, 0x7(R10)
   \   0000F0   0F24         JEQ     ??ZDO_beaconNotifyIndCB_16
   \   0000F2   5FB3         BIT.B   #0x1, R15
   \   0000F4   0B28         JNC     ??ZDO_beaconNotifyIndCB_17
   2290                {
   2291                  // this is the new chosen router for joining...
   2292                  pNwkDesc->chosenRouter            = pBeacon->sourceAddr;
   \   0000F6   A84A0800     MOV.W   @R10, 0x8(R8)
   2293                  pNwkDesc->chosenRouterLinkQuality = pBeacon->LQI;
   \   0000FA   D84A0A000A00 MOV.B   0xa(R10), 0xa(R8)
   2294                  pNwkDesc->chosenRouterDepth       = pBeacon->depth;
   \   000100   D84A0B000B00 MOV.B   0xb(R10), 0xb(R8)
   2295                }
   2296          
   2297                if ( pBeacon->deviceCapacity )
   \                     ??ZDO_beaconNotifyIndCB_15:
   \   000106   CA930700     CMP.B   #0x0, 0x7(R10)
   \   00010A   0224         JEQ     ??ZDO_beaconNotifyIndCB_16
   2298                  pNwkDesc->deviceCapacity = 1;
   \                     ??ZDO_beaconNotifyIndCB_17:
   \   00010C   D8430400     MOV.B   #0x1, 0x4(R8)
   2299          
   2300                if ( pBeacon->routerCapacity )
   \                     ??ZDO_beaconNotifyIndCB_16:
   \   000110   CA930600     CMP.B   #0x0, 0x6(R10)
   \   000114   0224         JEQ     ??ZDO_beaconNotifyIndCB_1
   2301                  pNwkDesc->routerCapacity = 1;
   \   000116   D8430300     MOV.B   #0x1, 0x3(R8)
   2302              }
   2303            }
   2304          }
   \                     ??ZDO_beaconNotifyIndCB_1:
   \   00011A   3817         POPM.W  #0x4, R11
   \   00011C   1001         RETA
   2305          
   2306          /*********************************************************************
   2307           * @fn          ZDO_StartRouterConfirmCB
   2308           *
   2309           * @brief       This function reports the results of the request to
   2310           *              start functioning as a router in a network.
   2311           *
   2312           * @param       Status - Result of NLME_StartRouterRequest()
   2313           *
   2314           * @return      none
   2315           */

   \                                 In  segment CODE, align 2, keep-with-next
   2316          void ZDO_StartRouterConfirmCB( ZStatus_t Status )
   \                     ZDO_StartRouterConfirmCB:
   2317          {
   2318            nwkStatus = (byte)Status;
   \   000000   C24C....     MOV.B   R12, &nwkStatus
   2319          
   2320            if ( Status == ZSUCCESS )
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   0720         JNE     ??ZDO_StartRouterConfirmCB_0
   2321            {
   2322              // LED on shows Router started
   2323              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   \   000008   ........     CALLA   #?Subroutine10
   2324              // LED off forgets HOLD_AUTO_START
   2325              HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF);
   2326              if ( devState == DEV_HOLD )
   \                     ??CrossCallReturnLabel_4:
   \   00000C   0620         JNE     ??ZDO_StartRouterConfirmCB_1
   2327              {
   2328                // Began with HOLD_AUTO_START
   2329                devState = DEV_END_DEVICE;
   \   00000E   F2400600.... MOV.B   #0x6, &devState
   \   000014   023C         JMP     ??ZDO_StartRouterConfirmCB_1
   2330              }
   2331            }
   2332          #if defined(BLINK_LEDS)
   2333            else
   2334            {
   2335              HalLedSet( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   \                     ??ZDO_StartRouterConfirmCB_0:
   \   000016   ........     CALLA   #?Subroutine11
   2336            }
   2337          #endif
   2338          
   2339            osal_set_event( ZDAppTaskID, ZDO_ROUTER_START );
   \                     ??ZDO_StartRouterConfirmCB_1:
   \   00001A   3D402000     MOV.W   #0x20, R13
   \   00001E   ....         JMP     ?Subroutine3
   2340          }
   2341          
   2342          /*********************************************************************
   2343           * @fn          ZDO_JoinConfirmCB
   2344           *
   2345           * @brief       This function allows the next hight layer to be notified
   2346           *              of the results of its request to join itself or another
   2347           *              device to a network.
   2348           *
   2349           * @param       Status - Result of NLME_JoinRequest()
   2350           *
   2351           * @return      none
   2352           */

   \                                 In  segment CODE, align 2, keep-with-next
   2353          void ZDO_JoinConfirmCB( uint16 PanId, ZStatus_t Status )
   \                     ZDO_JoinConfirmCB:
   2354          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31800600     SUB.W   #0x6, SP
   \   000006   4A4D         MOV.B   R13, R10
   2355            (void)PanId;  // remove if this parameter is used.
   2356          
   2357            nwkStatus = (byte)Status;
   \   000008   C24D....     MOV.B   R13, &nwkStatus
   2358          
   2359            if ( Status == ZSUCCESS )
   \   00000C   4D93         CMP.B   #0x0, R13
   \   00000E   0720         JNE     ??ZDO_JoinConfirmCB_0
   2360            {
   2361              // LED on shows device joined
   2362              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
   \   000010   ........     CALLA   #?Subroutine10
   2363              // LED off forgets HOLD_AUTO_START
   2364              HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF);
   2365              if ( (devState == DEV_HOLD) )
   \                     ??CrossCallReturnLabel_3:
   \   000014   0620         JNE     ??ZDO_JoinConfirmCB_1
   2366              {
   2367                // Began with HOLD_AUTO_START
   2368                devState = DEV_NWK_JOINING;
   \   000016   F2400300.... MOV.B   #0x3, &devState
   \   00001C   023C         JMP     ??ZDO_JoinConfirmCB_1
   2369              }
   2370          
   2371              if ( !ZG_SECURE_ENABLED )
   2372              {
   2373                // Notify to save info into NV
   2374                ZDApp_NVUpdate();
   2375              }
   2376            }
   2377            else
   2378            {
   2379          #if defined(BLINK_LEDS)
   2380              HalLedSet ( HAL_LED_3, HAL_LED_MODE_FLASH );  // Flash LED to show failure
   \                     ??ZDO_JoinConfirmCB_0:
   \   00001E   ........     CALLA   #?Subroutine11
   2381          #endif
   2382            }
   2383          
   2384            // Pass the join confirm to higher layer if callback registered
   2385            if (zdoCBFunc[ZDO_JOIN_CNF_CBID] != NULL )
   \                     ??ZDO_JoinConfirmCB_1:
   \   000022   1F42....     MOV.W   &zdoCBFunc + 16, R15
   \   000026   1FD2....     BIS.W   &zdoCBFunc + 18, R15
   \   00002A   0F93         CMP.W   #0x0, R15
   \   00002C   0C24         JEQ     ??ZDO_JoinConfirmCB_2
   2386            {
   2387              zdoJoinCnf_t joinCnf;
   2388          
   2389              joinCnf.status = Status;
   \   00002E   C14A0000     MOV.B   R10, 0(SP)
   2390              joinCnf.deviceAddr = _NIB.nwkDevAddress;
   \   000032   9142....0200 MOV.W   &_NIB + 22, 0x2(SP)
   2391              joinCnf.parentAddr = _NIB.nwkCoordAddress;
   \   000038   9142....0400 MOV.W   &_NIB + 26, 0x4(SP)
   2392          
   2393              zdoCBFunc[ZDO_JOIN_CNF_CBID]( (void*)&joinCnf );
   \   00003E   0C41         MOV.W   SP, R12
   \   000040   0C53         ADD.W   #0x0, R12
   \   000042   ........     CALLA   &zdoCBFunc + 16
   2394            }
   2395          
   2396            // Notify ZDApp
   2397            ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_JOIN_IND, sizeof(osal_event_hdr_t), (byte*)NULL );
   \                     ??ZDO_JoinConfirmCB_2:
   \   000046   0F43         MOV.W   #0x0, R15
   \   000048   6E43         MOV.B   #0x2, R14
   \   00004A   6D43         MOV.B   #0x2, R13
   \   00004C   ........     CALLA   #?Subroutine8
   2398          
   2399          }
   \                     ??CrossCallReturnLabel_1:
   \   000050   31500600     ADD.W   #0x6, SP
   \   000054   3A41         POP.W   R10
   \   000056   1001         RETA
   2400          
   2401          /*********************************************************************
   2402           * @fn          ZDO_AddrChangeIndicationCB
   2403           *
   2404           * @brief       This function notifies the application that this
   2405           *              device's address has changed.  Could happen in
   2406           *              a network with stochastic addressing (PRO).
   2407           *
   2408           * @param       newAddr - the new address
   2409           *
   2410           * @return      none
   2411           */

   \                                 In  segment CODE, align 2, keep-with-next
   2412          void ZDO_AddrChangeIndicationCB( uint16 newAddr )
   \                     ZDO_AddrChangeIndicationCB:
   2413          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   2414            ZDO_AddrChangeInd_t *pZDOAddrChangeMsg;
   2415            epList_t *pItem = epList;
   \   000004   1B42....     MOV.W   &epList, R11
   2416          
   2417            // Notify to save info into NV
   2418            ZDApp_NVUpdate();
   2419          
   2420            // Notify the applications
   2421            osal_set_event( ZDAppTaskID, ZDO_STATE_CHANGE_EVT );
   \   000008   ........     CALLA   #??Subroutine7_0
   \                     ??CrossCallReturnLabel_21:
   \   00000C   183C         JMP     ??ZDO_AddrChangeIndicationCB_1
   2422          
   2423            while (pItem != NULL)
   2424            {
   2425              if (pItem->epDesc->endPoint != ZDO_EP)
   \                     ??ZDO_AddrChangeIndicationCB_0:
   \   00000E   1F4B0200     MOV.W   0x2(R11), R15
   \   000012   CF930000     CMP.B   #0x0, 0(R15)
   \   000016   1224         JEQ     ??ZDO_AddrChangeIndicationCB_2
   2426              {
   2427                pZDOAddrChangeMsg = (ZDO_AddrChangeInd_t *)osal_msg_allocate( sizeof( ZDO_AddrChangeInd_t ) );
   \   000018   2C42         MOV.W   #0x4, R12
   \   00001A   ........     CALLA   #osal_msg_allocate
   2428                if (pZDOAddrChangeMsg != NULL)
   \   00001E   0C93         CMP.W   #0x0, R12
   \   000020   0D24         JEQ     ??ZDO_AddrChangeIndicationCB_2
   2429                {
   2430                  pZDOAddrChangeMsg->hdr.event = ZDO_ADDR_CHANGE_IND;
   \   000022   FC40D6000000 MOV.B   #0xd6, 0(R12)
   2431                  pZDOAddrChangeMsg->shortAddr = newAddr;
   \   000028   8C4A0200     MOV.W   R10, 0x2(R12)
   2432                  osal_msg_send( *(pItem->epDesc->task_id), (uint8 *)pZDOAddrChangeMsg );
   \   00002C   0D4C         MOV.W   R12, R13
   \   00002E   1F4B0200     MOV.W   0x2(R11), R15
   \   000032   1F4F0200     MOV.W   0x2(R15), R15
   \   000036   6C4F         MOV.B   @R15, R12
   \   000038   ........     CALLA   #osal_msg_send
   2433                }
   2434              }
   2435              pItem = pItem->nextDesc;
   \                     ??ZDO_AddrChangeIndicationCB_2:
   \   00003C   2B4B         MOV.W   @R11, R11
   2436            }
   \                     ??ZDO_AddrChangeIndicationCB_1:
   \   00003E   0B93         CMP.W   #0x0, R11
   \   000040   E623         JNE     ??ZDO_AddrChangeIndicationCB_0
   2437          
   2438            // Send out a device announce
   2439            ZDApp_AnnounceNewAddress();
   \   000042   ........     CALLA   #ZDApp_AnnounceNewAddress
   2440          }
   \   000046   1A17         POPM.W  #0x2, R11
   \   000048   1001         RETA
   2441          
   2442          /*********************************************************************
   2443           * @fn          ZDO_JoinIndicationCB
   2444           *
   2445           * @brief       This function allows the next higher layer of a
   2446           *              coordinator to be notified of a remote join request.
   2447           *
   2448           * @param       ShortAddress - 16-bit address
   2449           * @param       ExtendedAddress - IEEE (64-bit) address
   2450           * @param       CapabilityFlags - Association Capability Flags
   2451           * @param       type - of joining -
   2452           *                          NWK_ASSOC_JOIN
   2453           *                          NWK_ASSOC_REJOIN_UNSECURE
   2454           *                          NWK_ASSOC_REJOIN_SECURE
   2455           *
   2456           * @return      ZStatus_t
   2457           */

   \                                 In  segment CODE, align 2, keep-with-next
   2458          ZStatus_t ZDO_JoinIndicationCB(uint16 ShortAddress, uint8 *ExtendedAddress,
   \                     ZDO_JoinIndicationCB:
   2459                                          uint8 CapabilityFlags, uint8 type)
   2460          {
   2461            (void)ShortAddress;
   2462            (void)ExtendedAddress;
   2463          #if ZDO_NV_SAVE_RFDs
   2464            (void)CapabilityFlags;
   2465          
   2466          #else  // if !ZDO_NV_SAVE_RFDs
   2467            if (CapabilityFlags & CAPINFO_DEVICETYPE_FFD)
   2468          #endif
   2469            {
   2470              ZDApp_NVUpdate();  // Notify to save info into NV.
   2471            }
   2472          
   2473            if (ZG_SECURE_ENABLED)  // Send notification to TC of new device.
   2474            {
   2475              if (type == NWK_ASSOC_JOIN || type == NWK_ASSOC_REJOIN_UNSECURE)
   2476              {
   2477                osal_start_timerEx( ZDAppTaskID, ZDO_NEW_DEVICE, 600 );
   2478              }
   2479            }
   2480          
   2481            return ZSuccess;
   \   000000   4C43         MOV.B   #0x0, R12
   \   000002   1001         RETA
   2482          }
   2483          
   2484          /*********************************************************************
   2485           * @fn          ZDO_ConcentratorIndicationCB
   2486           *
   2487           * @brief       This function allows the next higher layer of a
   2488           *              device to be notified of existence of the concentrator.
   2489           *
   2490           * @param       nwkAddr - 16-bit NWK address of the concentrator
   2491           * @param       extAddr - pointer to extended Address
   2492           *                        NULL if not available
   2493           * @param       pktCost - PktCost from RREQ
   2494           *
   2495           * @return      void
   2496           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   31500600     ADD.W   #0x6, SP
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2497          void ZDO_ConcentratorIndicationCB( uint16 nwkAddr, uint8 *extAddr, uint8 pktCost )
   \                     ZDO_ConcentratorIndicationCB:
   2498          {
   \   000000   31800600     SUB.W   #0x6, SP
   2499            zdoConcentratorInd_t conInd;
   2500          
   2501            conInd.nwkAddr = nwkAddr;
   \   000004   814C0000     MOV.W   R12, 0(SP)
   2502            conInd.extAddr = extAddr;
   \   000008   814D0200     MOV.W   R13, 0x2(SP)
   2503            conInd.pktCost = pktCost;
   \   00000C   C14E0400     MOV.B   R14, 0x4(SP)
   2504          
   2505            if( zdoCBFunc[ZDO_CONCENTRATOR_IND_CBID] != NULL )
   \   000010   1F42....     MOV.W   &zdoCBFunc + 4, R15
   \   000014   1FD2....     BIS.W   &zdoCBFunc + 6, R15
   \   000018   0F93         CMP.W   #0x0, R15
   \   00001A   0424         JEQ     ??ZDO_ConcentratorIndicationCB_0
   2506            {
   2507              zdoCBFunc[ZDO_CONCENTRATOR_IND_CBID]( (void*)&conInd );
   \   00001C   0C41         MOV.W   SP, R12
   \   00001E   0C53         ADD.W   #0x0, R12
   \   000020   ........     CALLA   &zdoCBFunc + 4
   2508            }
   2509          }
   \                     ??ZDO_ConcentratorIndicationCB_0:
   \   000024   ....         JMP     ?Subroutine2
   2510          
   2511          /*********************************************************************
   2512           * @fn          ZDO_LeaveCnf
   2513           *
   2514           * @brief       This function allows the next higher layer to be
   2515           *              notified of the results of its request for this or
   2516           *              a child device to leave the network.
   2517           *
   2518           * @param       cnf - NLME_LeaveCnf_t
   2519           *
   2520           * @return      none
   2521           */

   \                                 In  segment CODE, align 2, keep-with-next
   2522          void ZDO_LeaveCnf( NLME_LeaveCnf_t* cnf )
   \                     ZDO_LeaveCnf:
   2523          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
   2524            // Check for this device
   2525            if ( osal_ExtAddrEqual( cnf->extAddr,
   2526                                    NLME_GetExtAddr() ) == TRUE )
   \   000004   ........     CALLA   #NLME_GetExtAddr
   \   000008   0D4C         MOV.W   R12, R13
   \   00000A   0C4A         MOV.W   R10, R12
   \   00000C   2C53         ADD.W   #0x2, R12
   \   00000E   ........     CALLA   #sAddrExtCmp
   \   000012   5C93         CMP.B   #0x1, R12
   \   000014   0F20         JNE     ??ZDO_LeaveCnf_0
   2527            {
   2528              // Pass the leave confirm to higher layer if callback registered
   2529              if ( ( zdoCBFunc[ZDO_LEAVE_CNF_CBID] == NULL ) ||
   2530                   ( (*zdoCBFunc[ZDO_LEAVE_CNF_CBID])( cnf ) == NULL ) )
   \   000016   1F42....     MOV.W   &zdoCBFunc + 20, R15
   \   00001A   1FD2....     BIS.W   &zdoCBFunc + 22, R15
   \   00001E   0F93         CMP.W   #0x0, R15
   \   000020   0524         JEQ     ??ZDO_LeaveCnf_1
   \   000022   0C4A         MOV.W   R10, R12
   \   000024   ........     CALLA   &zdoCBFunc + 20
   \   000028   0C93         CMP.W   #0x0, R12
   \   00002A   0420         JNE     ??ZDO_LeaveCnf_0
   2531              {
   2532                // Prepare to leave with reset
   2533                ZDApp_LeaveReset( cnf->rejoin );
   \                     ??ZDO_LeaveCnf_1:
   \   00002C   5C4A0B00     MOV.B   0xb(R10), R12
   \   000030   ........     CALLA   #ZDApp_LeaveReset
   2534              }
   2535            }
   2536            else if ( ZSTACK_ROUTER_BUILD )
   2537            {
   2538              // Remove device address(optionally descendents) from data
   2539              ZDApp_LeaveUpdate( cnf->dstAddr,
   2540                                 cnf->extAddr,
   2541                                 cnf->removeChildren );
   2542            }
   2543          }
   \                     ??ZDO_LeaveCnf_0:
   \   000034   3A41         POP.W   R10
   \   000036   1001         RETA
   2544          
   2545          /*********************************************************************
   2546           * @fn          ZDO_LeaveInd
   2547           *
   2548           * @brief       This function allows the next higher layer of a
   2549           *              device to be notified of a remote leave request or
   2550           *              indication.
   2551           *
   2552           * @param       ind - NLME_LeaveInd_t
   2553           *
   2554           * @return      none
   2555           */

   \                                 In  segment CODE, align 2, keep-with-next
   2556          void ZDO_LeaveInd( NLME_LeaveInd_t* ind )
   \                     ZDO_LeaveInd:
   2557          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
   2558            uint8 leave;
   2559          
   2560          
   2561            // Parent is requesting the leave - NWK layer filters out illegal
   2562            // requests
   2563            if ( ind->request == TRUE )
   \   000004   DC930A00     CMP.B   #0x1, 0xa(R12)
   \   000008   0F24         JEQ     ??ZDO_LeaveInd_0
   2564            {
   2565              // Notify network of leave
   2566              if ( ZSTACK_ROUTER_BUILD )
   2567              {
   2568                NLME_LeaveRsp_t rsp;
   2569                rsp.rejoin         = ind->rejoin;
   2570                rsp.removeChildren = ind->removeChildren;
   2571                NLME_LeaveRsp( &rsp );
   2572              }
   2573          
   2574              // Prepare to leave with reset
   2575              ZDApp_LeaveReset( ind->rejoin );
   2576            }
   2577            else
   2578            {
   2579              leave = FALSE;
   2580          
   2581              // Check if this device needs to leave as a child or descendent
   2582              if ( ind->srcAddr == NLME_GetCoordShortAddr() )
   \   00000A   ........     CALLA   #NLME_GetCoordShortAddr
   \   00000E   5E4A0B00     MOV.B   0xb(R10), R14
   \   000012   2F4A         MOV.W   @R10, R15
   \   000014   0F9C         CMP.W   R12, R15
   \   000016   0D20         JNE     ??ZDO_LeaveInd_1
   2583              {
   2584                if ( ( ind->removeChildren == TRUE               ) ||
   2585                     ( ZDO_Config_Node_Descriptor.LogicalType ==
   2586                       NODETYPE_DEVICE                           )    )
   \   000018   5E93         CMP.B   #0x1, R14
   \   00001A   0624         JEQ     ??ZDO_LeaveInd_0
   \   00001C   5D42....     MOV.B   &ZDO_Config_Node_Descriptor, R13
   \   000020   7DF00700     AND.B   #0x7, R13
   \   000024   6D93         CMP.B   #0x2, R13
   \   000026   0520         JNE     ??ZDO_LeaveInd_1
   2587                {
   2588                  leave = TRUE;
   2589                }
   2590              }
   2591              else if ( ind->removeChildren == TRUE )
   2592              {
   2593                // Check NWK address allocation algorithm
   2594                //leave = RTG_ANCESTOR(nwkAddr,thisAddr);
   2595              }
   2596          
   2597              if ( leave == TRUE )
   2598              {
   2599                // Prepare to leave with reset
   2600                ZDApp_LeaveReset( ind->rejoin );
   \                     ??ZDO_LeaveInd_0:
   \   000028   5C4A0C00     MOV.B   0xc(R10), R12
   \   00002C   ........     CALLA   #ZDApp_LeaveReset
   \   000030   053C         JMP     ??ZDO_LeaveInd_2
   2601              }
   2602              else
   2603              {
   2604                // Remove device address(optionally descendents) from data
   2605                ZDApp_LeaveUpdate( ind->srcAddr,
   2606                                   ind->extAddr,
   2607                                   ind->removeChildren );
   \                     ??ZDO_LeaveInd_1:
   \   000032   0D4A         MOV.W   R10, R13
   \   000034   2D53         ADD.W   #0x2, R13
   \   000036   0C4F         MOV.W   R15, R12
   \   000038   ........     CALLA   #ZDApp_LeaveUpdate
   2608              }
   2609            }
   2610          
   2611            // Pass the leave indication to higher layer if callback registered.
   2612            if (zdoCBFunc[ZDO_LEAVE_IND_CBID] != NULL)
   \                     ??ZDO_LeaveInd_2:
   \   00003C   1F42....     MOV.W   &zdoCBFunc + 24, R15
   \   000040   1FD2....     BIS.W   &zdoCBFunc + 26, R15
   \   000044   0F93         CMP.W   #0x0, R15
   \   000046   0324         JEQ     ??ZDO_LeaveInd_3
   2613            {
   2614              (void)zdoCBFunc[ZDO_LEAVE_IND_CBID](ind);
   \   000048   0C4A         MOV.W   R10, R12
   \   00004A   ........     CALLA   &zdoCBFunc + 24
   2615            }
   2616          }
   \                     ??ZDO_LeaveInd_3:
   \   00004E   3A41         POP.W   R10
   \   000050   1001         RETA
   2617          
   2618          /*********************************************************************
   2619           * @fn          ZDO_SyncIndicationCB
   2620           *
   2621           * @brief       This function allows the next higher layer of a
   2622           *              coordinator to be notified of a loss of synchronization
   2623           *                          with the parent/child device.
   2624           *
   2625           * @param       type: 0 - child; 1 - parent
   2626           *
   2627           *
   2628           * @return      none
   2629           */

   \                                 In  segment CODE, align 2, keep-with-next
   2630          void ZDO_SyncIndicationCB( uint8 type, uint16 shortAddr )
   \                     ZDO_SyncIndicationCB:
   2631          {
   2632            (void)shortAddr;  // Remove this line if this parameter is used.
   2633          
   2634            if ( ZSTACK_END_DEVICE_BUILD
   2635              || (ZSTACK_ROUTER_BUILD && ((_NIB.CapabilityFlags & ZMAC_ASSOC_CAPINFO_FFD_TYPE) == 0)))
   2636            {
   2637              if ( type == 1 )
   \   000000   5C93         CMP.B   #0x1, R12
   \   000002   0820         JNE     ??ZDO_SyncIndicationCB_0
   2638              {
   2639                // We lost contact with our parent.  Clear the neighbor Table.
   2640                nwkNeighborInitTable();
   \   000004   ........     CALLA   #nwkNeighborInitTable
   2641          
   2642                // Start the rejoin process.
   2643                ZDApp_SendMsg( ZDAppTaskID, ZDO_NWK_JOIN_REQ, sizeof(osal_event_hdr_t), NULL );
   \   000008   0F43         MOV.W   #0x0, R15
   \   00000A   6E43         MOV.B   #0x2, R14
   \   00000C   7D400300     MOV.B   #0x3, R13
   \   000010   ........     CALLA   #?Subroutine8
   2644              }
   2645            }
   2646          }
   \                     ??ZDO_SyncIndicationCB_0:
   \   000014   1001         RETA
   2647          
   2648          /*********************************************************************
   2649           * @fn          ZDO_ManytoOneFailureIndicationCB
   2650           *
   2651           * @brief       This function allows the next higher layer of a
   2652           *              concentrator to be notified of a many-to-one route
   2653           *              failure.
   2654           *
   2655           * @param       none
   2656           *
   2657           *
   2658           * @return      none
   2659           */

   \                                 In  segment CODE, align 2, keep-with-next
   2660          void ZDO_ManytoOneFailureIndicationCB()
   \                     ZDO_ManytoOneFailureIndicationCB:
   2661          {
   2662            // By default, the concentrator automatically redo many-to-one route
   2663            // discovery to update all many-to-one routes in the network
   2664            // If you want anything processing other than the default,
   2665            // please replace the following code.
   2666          
   2667            RTG_MTORouteReq();
   \   000000   ........     BRA     #RTG_MTORouteReq
   2668          }
   2669          
   2670          /*********************************************************************
   2671           * @fn          ZDO_PollConfirmCB
   2672           *
   2673           * @brief       This function allows the next higher layer to be
   2674           *              notified of a Poll Confirm.
   2675           *
   2676           * @param       none
   2677           *
   2678           * @return      none
   2679           */

   \                                 In  segment CODE, align 2, keep-with-next
   2680          void ZDO_PollConfirmCB( uint8 status )
   \                     ZDO_PollConfirmCB:
   2681          {
   2682            (void)status;  // Remove this line if this parameter is used.
   2683            return;
   \   000000   1001         RETA
   2684          }
   2685          
   2686          /******************************************************************************
   2687           * @fn          ZDApp_NwkWriteNVRequest (stubs AddrMgrWriteNVRequest)
   2688           *
   2689           * @brief       Stub routine implemented by NHLE. NHLE should call
   2690           *              <AddrMgrWriteNV> when appropriate.
   2691           *
   2692           * @param       none
   2693           *
   2694           * @return      none
   2695           */

   \                                 In  segment CODE, align 2, keep-with-next
   2696          void ZDApp_NwkWriteNVRequest( void )
   \                     AddrMgrWriteNVRequest:
   2697          {
   2698          #if defined ( NV_RESTORE )
   2699            if ( !osal_get_timeoutEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV ) )
   2700            {
   2701              // Trigger to save info into NV
   2702              ZDApp_NVUpdate();
   2703            }
   2704          #endif
   2705          }
   \   000000   1001         RETA
   2706          
   2707          /*********************************************************************
   2708           * Call Back Functions from Security  - API
   2709           */
   2710          
   2711           /*********************************************************************
   2712           * @fn          ZDO_UpdateDeviceIndication
   2713           *
   2714           * @brief       This function notifies the "Trust Center" of a
   2715           *              network when a device joins or leaves the network.
   2716           *
   2717           * @param       extAddr - pointer to 64 bit address of new device
   2718           * @param       status  - 0 if a new device joined securely
   2719           *                      - 1 if a new device joined un-securely
   2720           *                      - 2 if a device left the network
   2721           *
   2722           * @return      true if newly joined device should be allowed to
   2723           *                                              remain on network
   2724           */

   \                                 In  segment CODE, align 2, keep-with-next
   2725          ZStatus_t ZDO_UpdateDeviceIndication( uint8 *extAddr, uint8 status )
   \                     ZDO_UpdateDeviceIndication:
   2726          {
   2727            // can implement a network access policy based on the
   2728            // IEEE address of newly joining devices...
   2729            (void)extAddr;
   2730            (void)status;
   2731          
   2732            return ZSuccess;
   \   000000   4C43         MOV.B   #0x0, R12
   \   000002   1001         RETA
   2733          }
   2734          
   2735          /*********************************************************************
   2736           * @fn          ZDApp_InMsgCB
   2737           *
   2738           * @brief       This function is called to pass up any message that is
   2739           *              not yet supported.  This allows for the developer to
   2740           *              support features themselves..
   2741           *
   2742           * @return      none
   2743           */

   \                                 In  segment CODE, align 2, keep-with-next
   2744          void ZDApp_InMsgCB( zdoIncomingMsg_t *inMsg )
   \                     ZDApp_InMsgCB:
   2745          {
   2746            if ( inMsg->clusterID & ZDO_RESPONSE_BIT )
   \   000000   8C930E00     CMP.W   #0x0, 0xe(R12)
   \   000004   1738         JL      ??ZDApp_InMsgCB_0
   2747            {
   2748              // Handle the response message
   2749            }
   2750            else
   2751            {
   2752              // Handle the request message by sending a generic "not supported".
   2753              // Device Announce doesn't have a response.
   2754              if ( !(inMsg->wasBroadcast) && inMsg->clusterID != Device_annce )
   \   000006   CC930C00     CMP.B   #0x0, 0xc(R12)
   \   00000A   1420         JNE     ??ZDApp_InMsgCB_0
   \   00000C   1F4C0E00     MOV.W   0xe(R12), R15
   \   000010   3F901300     CMP.W   #0x13, R15
   \   000014   0F24         JEQ     ??ZDApp_InMsgCB_0
   2755              {
   2756                ZDP_GenericRsp( inMsg->TransSeq, &(inMsg->srcAddr), ZDP_NOT_SUPPORTED, 0,
   2757                                (uint16)(inMsg->clusterID | ZDO_RESPONSE_BIT), inMsg->SecurityUse );
   \   000016   5C121000     PUSH.B  0x10(R12)
   \   00001A   3FD00080     BIS.W   #0x8000, R15
   \   00001E   0F12         PUSH.W  R15
   \   000020   0F43         MOV.W   #0x0, R15
   \   000022   7E408400     MOV.B   #0x84, R14
   \   000026   0D4C         MOV.W   R12, R13
   \   000028   2D53         ADD.W   #0x2, R13
   \   00002A   5C4C1100     MOV.B   0x11(R12), R12
   \   00002E   ........     CALLA   #ZDP_GenericRsp
   \   000032   2152         ADD.W   #0x4, SP
   2758              }
   2759            }
   2760          }
   \                     ??ZDApp_InMsgCB_0:
   \   000034   1001         RETA
   2761          
   2762          
   2763          /*********************************************************************
   2764           * @fn      ZDApp_ChangeMatchDescRespPermission()
   2765           *
   2766           * @brief   Changes the Match Descriptor Response permission.
   2767           *
   2768           * @param   endpoint - endpoint to allow responses
   2769           * @param   action - true to allow responses, false to not
   2770           *
   2771           * @return  none
   2772           */

   \                                 In  segment CODE, align 2, keep-with-next
   2773          void ZDApp_ChangeMatchDescRespPermission( uint8 endpoint, uint8 action )
   \                     ZDApp_ChangeMatchDescRespPermission:
   2774          {
   2775            // Store the action
   2776            afSetMatch( endpoint, action );
   \   000000   ........     BRA     #afSetMatch
   2777          }
   2778          
   2779          /*********************************************************************
   2780           * @fn      ZDApp_NetworkInit()
   2781           *
   2782           * @brief   Used to start the network joining process
   2783           *
   2784           * @param   delay - mSec delay to wait before starting
   2785           *
   2786           * @return  none
   2787           */

   \                                 In  segment CODE, align 2, keep-with-next
   2788          void ZDApp_NetworkInit( uint16 delay )
   \                     ZDApp_NetworkInit:
   2789          {
   2790            if ( delay )
   \   000000   0C93         CMP.W   #0x0, R12
   \   000002   0424         JEQ     ??ZDApp_NetworkInit_0
   2791            {
   2792              // Wait awhile before starting the device
   2793              osal_start_timerEx( ZDAppTaskID, ZDO_NETWORK_INIT, delay );
   \   000004   0E4C         MOV.W   R12, R14
   \   000006   1D43         MOV.W   #0x1, R13
   \   000008   ........     BRA     #?Subroutine4
   2794            }
   2795            else
   2796            {
   2797              osal_set_event( ZDAppTaskID, ZDO_NETWORK_INIT );
   \                     ??ZDApp_NetworkInit_0:
   \   00000C   1D43         MOV.W   #0x1, R13
   \   00000E   ....         JMP     ?Subroutine3
   2798            }
   2799          }
   2800          
   2801          /*********************************************************************
   2802           * @fn      ZDApp_NwkStateUpdateCB()
   2803           *
   2804           * @brief   This function notifies that this device's network
   2805           *          state info has been changed.
   2806           *
   2807           * @param   none
   2808           *
   2809           * @return  none
   2810           */

   \                                 In  segment CODE, align 2, keep-with-next
   2811          void ZDApp_NwkStateUpdateCB( void )
   \                     ZDApp_NwkStateUpdateCB:
   2812          {
   2813            // Notify to save info into NV
   2814            if ( !osal_get_timeoutEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV ) )
   \   000000   3D400002     MOV.W   #0x200, R13
   \   000004   5C42....     MOV.B   &ZDAppTaskID, R12
   \   000008   ........     BRA     #osal_get_timeoutEx
   2815            {
   2816              // Trigger to save info into NV
   2817              ZDApp_NVUpdate();
   2818            }
   2819          }
   2820          
   2821          /*********************************************************************
   2822           * @fn      ZDApp_NodeProfileSync()
   2823           *
   2824           * @brief   Sync node with stack profile.
   2825           *
   2826           * @param   stackProfile - stack profile of the network to join
   2827           *
   2828           * @return  none
   2829           */

   \                                 In  segment CODE, align 2, keep-with-next
   2830          void ZDApp_NodeProfileSync( uint8 stackProfile )
   \                     ZDApp_NodeProfileSync:
   2831          {
   2832            if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_DEVICETYPE_FFD  )
   \   000000   E2B3....     BIT.B   #0x2, &ZDO_Config_Node_Descriptor + 2
   \   000004   1128         JNC     ??ZDApp_NodeProfileSync_0
   2833            {
   2834              if ( stackProfile != zgStackProfile )
   \   000006   5C92....     CMP.B   &zgStackProfile, R12
   \   00000A   0E24         JEQ     ??ZDApp_NodeProfileSync_0
   2835              {
   2836                ZDO_Config_Node_Descriptor.LogicalType = NODETYPE_DEVICE;
   \   00000C   5E42....     MOV.B   &ZDO_Config_Node_Descriptor, R14
   \   000010   7EF0F800     AND.B   #0xf8, R14
   \   000014   6ED3         BIS.B   #0x2, R14
   \   000016   C24E....     MOV.B   R14, &ZDO_Config_Node_Descriptor
   2837                ZDO_Config_Node_Descriptor.CapabilityFlags = CAPINFO_DEVICETYPE_RFD | CAPINFO_POWER_AC | CAPINFO_RCVR_ON_IDLE;
   \   00001A   F2400C00.... MOV.B   #0xc, &ZDO_Config_Node_Descriptor + 2
   2838                NLME_SetBroadcastFilter( ZDO_Config_Node_Descriptor.CapabilityFlags );
   \   000020   7C400C00     MOV.B   #0xc, R12
   \   000024   ........     CALLA   #NLME_SetBroadcastFilter
   2839              }
   2840            }
   2841          }
   \                     ??ZDApp_NodeProfileSync_0:
   \   000028   1001         RETA
   2842          
   2843          /*********************************************************************
   2844           * @fn      ZDApp_StartJoiningCycle()
   2845           *
   2846           * @brief   Starts the joining cycle of a device.  This will only
   2847           *          continue an already started (or stopped) joining cycle.
   2848           *
   2849           * @param   none
   2850           *
   2851           * @return  TRUE if joining stopped, FALSE if joining or rejoining
   2852           */

   \                                 In  segment CODE, align 2, keep-with-next
   2853          uint8 ZDApp_StartJoiningCycle( void )
   \                     ZDApp_StartJoiningCycle:
   2854          {
   2855            if ( devState == DEV_INIT || devState == DEV_NWK_DISC )
   \   000000   D293....     CMP.B   #0x1, &devState
   \   000004   0324         JEQ     ??ZDApp_StartJoiningCycle_0
   \   000006   E293....     CMP.B   #0x2, &devState
   \   00000A   0720         JNE     ??ZDApp_StartJoiningCycle_1
   2856            {
   2857              continueJoining = TRUE;
   \                     ??ZDApp_StartJoiningCycle_0:
   \   00000C   D243....     MOV.B   #0x1, &continueJoining
   2858              ZDApp_NetworkInit( 0 );
   \   000010   0C43         MOV.W   #0x0, R12
   \   000012   ........     CALLA   #ZDApp_NetworkInit
   2859          
   2860              return ( TRUE );
   \   000016   5C43         MOV.B   #0x1, R12
   \   000018   1001         RETA
   2861            }
   2862            else
   2863              return ( FALSE );
   \                     ??ZDApp_StartJoiningCycle_1:
   \   00001A   4C43         MOV.B   #0x0, R12
   \   00001C   1001         RETA
   2864          }
   2865          
   2866          /*********************************************************************
   2867           * @fn      ZDApp_StopJoiningCycle()
   2868           *
   2869           * @brief   Stops the joining or rejoining process of a device.
   2870           *
   2871           * @param   none
   2872           *
   2873           * @return  TRUE if joining stopped, FALSE if joining or rejoining
   2874           */

   \                                 In  segment CODE, align 2, keep-with-next
   2875          uint8 ZDApp_StopJoiningCycle( void )
   \                     ZDApp_StopJoiningCycle:
   2876          {
   2877            if ( devState == DEV_INIT || devState == DEV_NWK_DISC )
   \   000000   D293....     CMP.B   #0x1, &devState
   \   000004   0324         JEQ     ??ZDApp_StopJoiningCycle_0
   \   000006   E293....     CMP.B   #0x2, &devState
   \   00000A   0420         JNE     ??ZDApp_StopJoiningCycle_1
   2878            {
   2879              continueJoining = FALSE;
   \                     ??ZDApp_StopJoiningCycle_0:
   \   00000C   C243....     MOV.B   #0x0, &continueJoining
   2880              return ( TRUE );
   \   000010   5C43         MOV.B   #0x1, R12
   \   000012   1001         RETA
   2881            }
   2882            else
   2883              return ( FALSE );
   \                     ??ZDApp_StopJoiningCycle_1:
   \   000014   4C43         MOV.B   #0x0, R12
   \   000016   1001         RETA
   2884          }
   2885          
   2886          /*********************************************************************
   2887           * @fn      ZDApp_AnnounceNewAddress()
   2888           *
   2889           * @brief   Send Device Announce and hold all transmissions for
   2890           *          new address timeout.
   2891           *
   2892           * @param   none
   2893           *
   2894           * @return  none
   2895           */

   \                                 In  segment CODE, align 2, keep-with-next
   2896          void ZDApp_AnnounceNewAddress( void )
   \                     ZDApp_AnnounceNewAddress:
   2897          {
   \   000000   0A12         PUSH.W  R10
   2898          #if defined ( ZIGBEE_NWK_UNIQUE_ADDR_CHECK )
   2899            // Turn off data request hold
   2900            APSME_HoldDataRequests( 0 );
   \   000002   0C43         MOV.W   #0x0, R12
   \   000004   ........     CALLA   #APSME_HoldDataRequests
   2901          #endif
   2902          
   2903            ZDP_DeviceAnnce( NLME_GetShortAddr(), NLME_GetExtAddr(),
   2904                               ZDO_Config_Node_Descriptor.CapabilityFlags, 0 );
   \   000008   ........     CALLA   #NLME_GetExtAddr
   \   00000C   0A4C         MOV.W   R12, R10
   \   00000E   ........     CALLA   #NLME_GetShortAddr
   \   000012   4F43         MOV.B   #0x0, R15
   \   000014   5E42....     MOV.B   &ZDO_Config_Node_Descriptor + 2, R14
   \   000018   0D4A         MOV.W   R10, R13
   \   00001A   ........     CALLA   #ZDP_DeviceAnnce
   2905          
   2906          #if defined ( ZIGBEE_NWK_UNIQUE_ADDR_CHECK )
   2907            // Setup the timeout
   2908            APSME_HoldDataRequests( ZDAPP_HOLD_DATA_REQUESTS_TIMEOUT );
   \   00001E   0C43         MOV.W   #0x0, R12
   \   000020   ........     CALLA   #APSME_HoldDataRequests
   2909          #endif
   2910          }
   \   000024   3A41         POP.W   R10
   \   000026   1001         RETA
   2911          
   2912          /*********************************************************************
   2913           * @fn          ZDApp_NVUpdate
   2914           *
   2915           * @brief       Set the NV Update Timer.
   2916           *
   2917           * @param       none
   2918           *
   2919           * @return      none
   2920           */

   \                                 In  segment CODE, align 2, keep-with-next
   2921          void ZDApp_NVUpdate( void )
   \                     ZDApp_NVUpdate:
   2922          {
   2923          #if defined ( NV_RESTORE )
   2924            osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, ZDAPP_UPDATE_NWK_NV_TIME );
   2925          #endif
   2926          }
   \   000000   1001         RETA
   2927          
   2928          /*********************************************************************
   2929           * @fn      ZDApp_CoordStartPANIDConflictCB()
   2930           *
   2931           * @brief   Returns a PAN ID for the network layer to use during
   2932           *          a coordinator start and there is another network with
   2933           *          the intended PANID.
   2934           *
   2935           * @param   panid - the intended PAN ID
   2936           *
   2937           * @return  PANID to try
   2938           */

   \                                 In  segment CODE, align 2, keep-with-next
   2939          uint16 ZDApp_CoordStartPANIDConflictCB( uint16 panid )
   \                     ZDApp_CoordStartPANIDConflictCB:
   2940          {
   2941            return ( panid + 1 );
   \   000000   1C53         ADD.W   #0x1, R12
   \   000002   1001         RETA
   2942          }
   2943          
   2944          /*********************************************************************
   2945           * @fn          ZDO_SrcRtgIndCB
   2946           *
   2947           * @brief       This function notifies the ZDO available src route record received.
   2948           *
   2949           * @param       srcAddr - source address of the source route
   2950           * @param       relayCnt - number of devices in the relay list
   2951           * @param       relayList - relay list of the source route
   2952           *
   2953           * @return      none
   2954           */

   \                                 In  segment CODE, align 2, keep-with-next
   2955          void ZDO_SrcRtgIndCB (uint16 srcAddr, uint8 relayCnt, uint16* pRelayList )
   \                     ZDO_SrcRtgIndCB:
   2956          {
   \   000000   31800600     SUB.W   #0x6, SP
   2957            zdoSrcRtg_t srcRtg;
   2958          
   2959            srcRtg.srcAddr = srcAddr;
   \   000004   814C0000     MOV.W   R12, 0(SP)
   2960            srcRtg.relayCnt = relayCnt;
   \   000008   C14D0200     MOV.B   R13, 0x2(SP)
   2961            srcRtg.pRelayList = pRelayList;
   \   00000C   814E0400     MOV.W   R14, 0x4(SP)
   2962          
   2963            if( zdoCBFunc[ZDO_SRC_RTG_IND_CBID] != NULL )
   \   000010   1F42....     MOV.W   &zdoCBFunc, R15
   \   000014   1FD2....     BIS.W   &zdoCBFunc + 2, R15
   \   000018   0F93         CMP.W   #0x0, R15
   \   00001A   0424         JEQ     ??ZDO_SrcRtgIndCB_0
   2964            {
   2965              zdoCBFunc[ZDO_SRC_RTG_IND_CBID]( (void*)&srcRtg );
   \   00001C   0C41         MOV.W   SP, R12
   \   00001E   0C53         ADD.W   #0x0, R12
   \   000020   ........     CALLA   &zdoCBFunc
   2966            }
   2967          }
   \                     ??ZDO_SrcRtgIndCB_0:
   \   000024                REQUIRE ?Subroutine2
   \   000024                // Fall through to label ?Subroutine2
   2968          
   2969          /*********************************************************************
   2970           * @fn          ZDApp_InitZdoCBFunc
   2971           *
   2972           * @brief       Call this function to initialize zdoCBFunc[]
   2973           *
   2974           * @param       none
   2975           *
   2976           * @return      none
   2977           */

   \                                 In  segment CODE, align 2
   2978          void ZDApp_InitZdoCBFunc( void )
   \                     ZDApp_InitZdoCBFunc:
   2979          {
   2980            uint8 i;
   2981          
   2982            for ( i=0; i< MAX_ZDO_CB_FUNC; i++ )
   \   000000   4E43         MOV.B   #0x0, R14
   2983            {
   2984              zdoCBFunc[i] = NULL;
   \                     ??ZDApp_InitZdoCBFunc_0:
   \   000002   4F4E         MOV.B   R14, R15
   \   000004   5F06         RLAM.W  #0x2, R15
   \   000006   8F43....     MOV.W   #0x0, zdoCBFunc(R15)
   \   00000A   8F43....     MOV.W   #0x0, zdoCBFunc + 2(R15)
   2985            }
   \   00000E   5E53         ADD.B   #0x1, R14
   \   000010   7E900700     CMP.B   #0x7, R14
   \   000014   F62B         JNC     ??ZDApp_InitZdoCBFunc_0
   2986          }
   \   000016   1001         RETA
   2987          
   2988          /*********************************************************************
   2989           * @fn          ZDO_RegisterForZdoCB
   2990           *
   2991           * @brief       Call this function to register the higher layer (for
   2992           *              example, the Application layer or MT layer) with ZDO
   2993           *              callbacks to get notified of some ZDO indication like
   2994           *              existence of a concentrator or receipt of a source
   2995           *              route record.
   2996           *
   2997           * @param       indID - ZDO Indication ID
   2998           * @param       pFn   - Callback function pointer
   2999           *
   3000           * @return      ZSuccess - successful, ZInvalidParameter if not
   3001           */

   \                                 In  segment CODE, align 2
   3002          ZStatus_t ZDO_RegisterForZdoCB( uint8 indID, pfnZdoCb pFn )
   \                     ZDO_RegisterForZdoCB:
   3003          {
   3004            // Check the range of the indication ID
   3005            if ( indID < MAX_ZDO_CB_FUNC )
   \   000000   7C900700     CMP.B   #0x7, R12
   \   000004   082C         JC      ??ZDO_RegisterForZdoCB_0
   3006            {
   3007              zdoCBFunc[indID] = pFn;
   \   000006   4C4C         MOV.B   R12, R12
   \   000008   5C06         RLAM.W  #0x2, R12
   \   00000A   8C4E....     MOV.W   R14, zdoCBFunc(R12)
   \   00000E   8C4F....     MOV.W   R15, zdoCBFunc + 2(R12)
   3008              return ZSuccess;
   \   000012   4C43         MOV.B   #0x0, R12
   \   000014   1001         RETA
   3009            }
   3010          
   3011            return ZInvalidParameter;
   \                     ??ZDO_RegisterForZdoCB_0:
   \   000016   6C43         MOV.B   #0x2, R12
   \   000018   1001         RETA
   3012          }
   3013          
   3014          /*********************************************************************
   3015           * @fn          ZDO_DeregisterForZdoCB
   3016           *
   3017           * @brief       Call this function to de-register the higher layer (for
   3018           *              example, the Application layer or MT layer) with ZDO
   3019           *              callbacks to get notified of some ZDO indication like
   3020           *              existence of a concentrator or receipt of a source
   3021           *              route record.
   3022           *
   3023           * @param       indID - ZDO Indication ID
   3024           *
   3025           * @return      ZSuccess - successful, ZInvalidParameter if not
   3026           */

   \                                 In  segment CODE, align 2
   3027          ZStatus_t ZDO_DeregisterForZdoCB( uint8 indID )
   \                     ZDO_DeregisterForZdoCB:
   3028          {
   3029            // Check the range of the indication ID
   3030            if ( indID < MAX_ZDO_CB_FUNC )
   \   000000   7C900700     CMP.B   #0x7, R12
   \   000004   082C         JC      ??ZDO_DeregisterForZdoCB_0
   3031            {
   3032              zdoCBFunc[indID] = NULL;
   \   000006   4C4C         MOV.B   R12, R12
   \   000008   5C06         RLAM.W  #0x2, R12
   \   00000A   8C43....     MOV.W   #0x0, zdoCBFunc(R12)
   \   00000E   8C43....     MOV.W   #0x0, zdoCBFunc + 2(R12)
   3033              return ZSuccess;
   \   000012   4C43         MOV.B   #0x0, R12
   \   000014   1001         RETA
   3034            }
   3035          
   3036            return ZInvalidParameter;
   \                     ??ZDO_DeregisterForZdoCB_0:
   \   000016   6C43         MOV.B   #0x2, R12
   \   000018   1001         RETA
   3037          }

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for zdoDiscCounter>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for continueJoining>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for devState>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for ZDApp_epDesc>`:
   \   000000   0000         DC8 0, 0
   \   000002   ....0000     DC16 ZDAppTaskID, 0H
   \   000006   0000         DC8 0, 0

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for ZDApp_SavedPollRate>`:
   \   000000   E803         DC16 1000
   3038          
   3039          /*********************************************************************
   3040          *********************************************************************/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   AddrMgrWriteNVRequest
      4   ZDAppCheckForHoldKey
        4   -> HalKeyRead
      4   ZDAppDetermineDeviceType
        4   -> nwk_ExtPANIDValid
      6   ZDApp_AnnounceNewAddress
        6   -> APSME_HoldDataRequests
        6   -> NLME_GetExtAddr
        6   -> NLME_GetShortAddr
        6   -> ZDP_DeviceAnnce
      4   ZDApp_ChangeMatchDescRespPermission
        4   -> afSetMatch
      4   ZDApp_CoordStartPANIDConflictCB
      4   ZDApp_DeviceAuthEvt
        4   -> NLME_SetPollRate
        4   -> ZDApp_AnnounceNewAddress
        4   -> ZDApp_ResetTimerCancel
        4   -> ZDApp_SaveNwkKey
        4   -> osal_set_event
      6   ZDApp_DeviceConfigured
        6   -> osal_nv_read
      8   ZDApp_InMsgCB
        8   -> ZDP_GenericRsp
      4   ZDApp_Init
        4   -> HalLedBlink
        4   -> NLME_GetExtAddr
        4   -> ZDAppCheckForHoldKey
        4   -> ZDApp_InitUserDesc
        4   -> ZDApp_InitZdoCBFunc
        4   -> ZDApp_RegisterCBs
        4   -> ZDOInitDevice
        4   -> ZDO_Init
        4   -> afRegister
     24   ZDApp_InitUserDesc
       24   -> osal_memset
       24   -> osal_nv_item_init
       24   -> osal_nv_read
      4   ZDApp_InitZdoCBFunc
     20   ZDApp_JoinReq
       20   -> NLME_JoinRequest
       16   -> ZDApp_NodeProfileSync
      4   ZDApp_LeaveCtrlBypass
      4   ZDApp_LeaveCtrlInit
        4   -> osal_nv_item_init
        4   -> osal_nv_read
      4   ZDApp_LeaveCtrlReset
        4   -> osal_nv_write
      4   ZDApp_LeaveCtrlSet
        4   -> osal_nv_write
      4   ZDApp_LeaveCtrlStartup
        4   -> ZDApp_LeaveCtrlReset
      4   ZDApp_LeaveReset
        4   -> ZDApp_LeaveCtrlSet
        4   -> ZDApp_ResetTimerStart
     18   ZDApp_LeaveUpdate
       18   -- Indirect call
       18   -> RTG_RemoveRtgEntry
       18   -> ZDSecMgrAddrClear
       18   -> ZDSecMgrDeviceRemoveByExtAddr
       18   -> nwkNeighborRemove
       18   -> osal_memcpy
      4   ZDApp_NVUpdate
      4   ZDApp_NetworkDiscoveryReq
        4   -> NLME_NetworkDiscoveryRequest
      4   ZDApp_NetworkInit
        4   -> osal_set_event
        4   -> osal_start_timerEx
      4   ZDApp_NetworkStartEvt
        4   -> NLME_GetEnergyThreshold
        4   -> NLME_SetEnergyThreshold
        4   -> osal_pwrmgr_device
        4   -> osal_set_event
      4   ZDApp_NodeProfileSync
        4   -> NLME_SetBroadcastFilter
     16   ZDApp_NwkDescListProcessing
       16   -> nwk_ExtPANIDValid
       16   -> nwk_getNwkDescList
       16   -> sAddrExtCmp
      4   ZDApp_NwkStateUpdateCB
        4   -> osal_get_timeoutEx
     30   ZDApp_ProcessMsgCBs
       30   -> ZDO_ParseAddrRsp
       30   -> ZDO_ParseBindUnbindReq
       30   -> ZDO_ProcessBindUnbindReq
       30   -> ZDO_UpdateAddrManager
       30   -> osal_mem_free
     10   ZDApp_ProcessNetworkJoin
       10   -> NLME_GetShortAddr
       10   -> NLME_NwkDiscTerm
       10   -> NLME_SetPollRate
       10   -> NLME_SetQueuedPollRate
       10   -> NLME_SetResponseRate
       10   -> ZDApp_AnnounceNewAddress
       10   -> ZDApp_NetworkInit
       10   -> ZMacSetReq
       10   -> nwkNeighborInitTable
       10   -> osal_rand
       10   -> osal_set_event
     12   ZDApp_ProcessOSALMsg
       12   -> NLME_JoinRequest
        8   -> NLME_ReJoinRequest
        8   -> NLME_SetPollRate
        8   -> NLME_SetQueuedPollRate
        8   -> NLME_SetResponseRate
        8   -> ZDApp_NetworkInit
        8   -> ZDApp_NodeProfileSync
        8   -> ZDApp_NwkDescListProcessing
        8   -> ZDApp_ProcessMsgCBs
        8   -> ZDApp_ProcessNetworkJoin
        8   -> ZDP_IncomingData
        8   -> ZMacSetReq
        8   -> osal_rand
        8   -> sAddrExtCpy
      6   ZDApp_ProcessSecEvent
        6   -> ZDApp_DeviceAuthEvt
        6   -> ZDApp_SaveNwkKey
        6   -> ZDSecMgrSaveTCLinkKey
      4   ZDApp_ProcessSecMsg
        4   -> ZDSecMgrSwitchKeyInd
        4   -> ZDSecMgrTransportKeyInd
      6   ZDApp_ReadNetworkRestoreState
        6   -> zgReadStartupOptions
      6   ZDApp_RegisterCBs
        6   -> ZDO_RegisterForZDOMsg
     26   ZDApp_ResetNwkKey
       26   -> osal_memset
       26   -> osal_nv_write
      4   ZDApp_ResetTimerCancel
        4   -> osal_stop_timerEx
      4   ZDApp_ResetTimerStart
        4   -> osal_start_timerEx
      6   ZDApp_RestoreNetworkState
        6   -> NLME_GetShortAddr
        6   -> NLME_InitNV
        6   -> NLME_RestoreFromNV
        6   -> sAddrExtCpy
     28   ZDApp_RestoreNwkKey
       28   -> osal_memset
       28   -> osal_nv_read
      4   ZDApp_SaveNetworkStateEvt
     28   ZDApp_SaveNwkKey
       28   -> SSP_ReadNwkActiveKey
       28   -> osal_memset
       28   -> osal_nv_write
      4   ZDApp_SecInit
        4   -> ZDSecMgrInit
      4   ZDApp_SendEventMsg
        4   -> ZDApp_SendMsg
     16   ZDApp_SendMsg
       16   -> osal_memcpy
       16   -> osal_msg_allocate
       16   -> osal_msg_send
      4   ZDApp_StartJoiningCycle
        4   -> ZDApp_NetworkInit
      4   ZDApp_StopJoiningCycle
      8   ZDApp_event_loop
        8   -> Onboard_soft_reset
        8   -> ZDApp_ProcessOSALMsg
        8   -> ZDO_StartDevice
        8   -> ZDO_UpdateNwkStatus
        8   -> osal_msg_deallocate
        8   -> osal_msg_receive
        8   -> osal_set_event
        8   -> osal_start_timerEx
        8   -> zgWriteStartupOptions
      8   ZDOInitDevice
        8   -> NLME_SetBroadcastFilter
        8   -> ZDAppDetermineDeviceType
        8   -> ZDApp_LeaveCtrlInit
        8   -> ZDApp_LeaveCtrlStartup
        8   -> ZDApp_NetworkInit
        8   -> ZDConfig_InitDescriptors
        8   -> ZDSecMgrInit
        8   -> osal_rand
        8   -> osal_set_event
        8   -> zgInitItems
        8   -> zgWriteStartupOptions
      8   ZDO_AddrChangeIndicationCB
        8   -> ZDApp_AnnounceNewAddress
        8   -> osal_msg_allocate
        8   -> osal_msg_send
        8   -> osal_set_event
     10   ZDO_ConcentratorIndicationCB
       10   -- Indirect call
      4   ZDO_DeregisterForZdoCB
     12   ZDO_JoinConfirmCB
       12   -- Indirect call
       12   -> HalLedSet
       12   -> ZDApp_SendMsg
      4   ZDO_JoinIndicationCB
      6   ZDO_LeaveCnf
        6   -- Indirect call
        6   -> NLME_GetExtAddr
        6   -> ZDApp_LeaveReset
        6   -> sAddrExtCmp
      6   ZDO_LeaveInd
        6   -- Indirect call
        6   -> NLME_GetCoordShortAddr
        6   -> ZDApp_LeaveReset
        6   -> ZDApp_LeaveUpdate
      4   ZDO_ManytoOneFailureIndicationCB
        4   -> RTG_MTORouteReq
      8   ZDO_NetworkDiscoveryConfirmCB
        8   -- Indirect call
        8   -> ZDApp_SendMsg
      4   ZDO_NetworkFormationConfirmCB
        4   -> HalLedSet
        4   -> osal_set_event
      4   ZDO_PollConfirmCB
      4   ZDO_RegisterForZdoCB
     10   ZDO_SrcRtgIndCB
       10   -- Indirect call
      4   ZDO_StartRouterConfirmCB
        4   -> HalLedSet
        4   -> osal_set_event
      4   ZDO_SyncIndicationCB
        4   -> ZDApp_SendMsg
        4   -> nwkNeighborInitTable
      4   ZDO_UpdateDeviceIndication
     12   ZDO_beaconNotifyIndCB
       12   -- Indirect call
       12   -> osal_mem_alloc
       12   -> osal_memset
       12   -> sAddrExtCpy


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for ZDApp_SavedPollRate>
       8  ?<Initializer for ZDApp_epDesc>
       1  ?<Initializer for continueJoining>
       1  ?<Initializer for devState>
       1  ?<Initializer for zdoDiscCounter>
      12  ??Subroutine7_0
       8  ?Subroutine0
       6  ?Subroutine1
      22  ?Subroutine10
       8  ?Subroutine11
      14  ?Subroutine12
      16  ?Subroutine13
      14  ?Subroutine14
      12  ?Subroutine15
       6  ?Subroutine16
       6  ?Subroutine2
       8  ?Subroutine3
       8  ?Subroutine4
       8  ?Subroutine5
      18  ?Subroutine6
       6  ?Subroutine7
       8  ?Subroutine8
      16  ?Subroutine9
       2  AddrMgrWriteNVRequest
       1  MatchRsps
      14  ZDAppCheckForHoldKey
      70  ZDAppDetermineDeviceType
      10  ZDAppNwkAddr
       1  ZDAppTaskID
      40  ZDApp_AnnounceNewAddress
       2  ZDApp_AutoFindMode_epDesc
       4  ZDApp_ChangeMatchDescRespPermission
       4  ZDApp_CoordStartPANIDConflictCB
      40  ZDApp_DeviceAuthEvt
      44  ZDApp_DeviceConfigured
      54  ZDApp_InMsgCB
      82  ZDApp_Init
      80  ZDApp_InitUserDesc
      24  ZDApp_InitZdoCBFunc
      46  ZDApp_JoinReq
       1  ZDApp_LeaveCtrl
       8  ZDApp_LeaveCtrlBypass
      32  ZDApp_LeaveCtrlInit
       4  ZDApp_LeaveCtrlReset
      16  ZDApp_LeaveCtrlSet
      34  ZDApp_LeaveCtrlStartup
      12  ZDApp_LeaveReset
      86  ZDApp_LeaveUpdate
       2  ZDApp_NVUpdate
       4  ZDApp_NetworkDiscoveryReq
      16  ZDApp_NetworkInit
      70  ZDApp_NetworkStartEvt
      42  ZDApp_NodeProfileSync
     164  ZDApp_NwkDescListProcessing
      12  ZDApp_NwkStateUpdateCB
      94  ZDApp_ProcessMsgCBs
     268  ZDApp_ProcessNetworkJoin
     314  ZDApp_ProcessOSALMsg
      88  ZDApp_ProcessSecEvent
      44  ZDApp_ProcessSecMsg
      20  ZDApp_ReadNetworkRestoreState
      42  ZDApp_RegisterCBs
      22  ZDApp_ResetNwkKey
      10  ZDApp_ResetTimerCancel
       4  ZDApp_ResetTimerStart
      62  ZDApp_RestoreNetworkState
      68  ZDApp_RestoreNwkKey
       2  ZDApp_SaveNetworkStateEvt
      58  ZDApp_SaveNwkKey
       2  ZDApp_SavedPollRate
       4  ZDApp_SecInit
      14  ZDApp_SendEventMsg
      56  ZDApp_SendMsg
      30  ZDApp_StartJoiningCycle
      24  ZDApp_StopJoiningCycle
       8  ZDApp_epDesc
     162  ZDApp_event_loop
     118  ZDOInitDevice
      74  ZDO_AddrChangeIndicationCB
      38  ZDO_ConcentratorIndicationCB
      26  ZDO_DeregisterForZdoCB
      88  ZDO_JoinConfirmCB
       4  ZDO_JoinIndicationCB
      56  ZDO_LeaveCnf
      82  ZDO_LeaveInd
       4  ZDO_ManytoOneFailureIndicationCB
      48  ZDO_NetworkDiscoveryConfirmCB
      26  ZDO_NetworkFormationConfirmCB
       2  ZDO_PollConfirmCB
      26  ZDO_RegisterForZdoCB
      36  ZDO_SrcRtgIndCB
      32  ZDO_StartRouterConfirmCB
      22  ZDO_SyncIndicationCB
       4  ZDO_UpdateDeviceIndication
       8  ZDO_UseExtendedPANID
     286  ZDO_beaconNotifyIndCB
       1  _tmpRejoinState
       1  continueJoining
       1  devStartMode
       1  devState
       2  nwkFrameCounterChanges
       1  nwkStatus
       1  retryCnt
       1  zdappMgmtNwkDiscReqInProgress
      10  zdappMgmtNwkDiscRspAddr
       1  zdappMgmtNwkDiscRspTransSeq
       1  zdappMgmtNwkDiscStartIndex
       1  zdappMgmtSavedNwkState
      28  zdoCBFunc
       1  zdoDiscCounter

 
 3 560 bytes in segment CODE
    13 bytes in segment DATA16_I
    13 bytes in segment DATA16_ID
    71 bytes in segment DATA16_Z
 
 3 560 bytes of CODE  memory
    13 bytes of CONST memory
    84 bytes of DATA  memory

Errors: none
Warnings: none

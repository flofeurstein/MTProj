###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       10/Jun/2013  17:10:43 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\ma #
#                     c\low_level\srf04\mac_autopend.c                        #
#    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\..\To #
#                     ols\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0      #
#                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                       #
#                     -DDEFAULT_CHANLIST=0x00000800                           #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100      #
#                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                   #
#                     -DBEACON_REQUEST_DELAY=100                              #
#                     -DBEACON_REQ_DELAY_MASK=0x00FF                          #
#                     -DLINK_STATUS_JITTER_MASK=0x007F                        #
#                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED= #
#                     3000 -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8  #
#                     -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2     #
#                     -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9              #
#                     -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40                #
#                     -DNWK_MAX_BINDING_ENTRIES=4                             #
#                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,       #
#                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,   #
#                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                    #
#                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=2 #
#                     0 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000           #
#                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100         #
#                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wEndev.cfg" (-DCPU6MHZ -DMAC_CFG_TX_DATA_MAX=3         #
#                     -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "C:\Texas     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC          #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)                #
#                     -DZCL_DEVICE_MGMT "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_lev #
#                     el\srf04\mac_autopend.c" -D MSP430F2618 -D              #
#                     NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D  #
#                     MT_ZDO_FUNC -D LCD_SUPPORTED -lC "C:\Texas              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\EndDevice\List\" -lA     #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\List #
#                     \" --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826    #
#                     -o "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\O #
#                     bj\" --debug -D__MSP430F2618__ -e --double=32 --clib    #
#                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\" -I        #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\..\Source\"    #
#                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\Sourc #
#                     e\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Proje #
#                     cts\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\. #
#                     .\ZMain\MSP2618\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\target\MSP2618CC2520\" -I "C:\Texas               #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\high_level\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\" -I "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\dual_chip\" -I "C:\Texas          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pr #
#                     ojects\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\. #
#                     .\..\..\..\Components\osal\include\" -I "C:\Texas       #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\osal\mcu\msp430\" -I "C:\Texas                        #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\saddr\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\sdata\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\af\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2520D #
#                     B\..\..\..\..\..\Components\stack\nwk\" -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sec\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sapi\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sys\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zcl\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zdo\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ #
#                     Projects\zstack\HomeAutomation\SampleSwitch\CC2520DB\.. #
#                     \..\..\..\..\Components\zmac\f8w\" --core=430X          #
#                     --data_model=small -Ohz --multiplier=16s                #
#                     --require_prototypes                                    #
#    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\List\ #
#                     mac_autopend.lst                                        #
#    Object file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\Obj\m #
#                     ac_autopend.r43                                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\mac\low_level\srf04\mac_autopend.c
      1          /**************************************************************************************************
      2            Filename:       mac_autopend.c
      3            Revised:        $Date: 2009-08-28 09:29:33 -0700 (Fri, 28 Aug 2009) $
      4            Revision:       $Revision: 20674 $
      5          
      6            Description:    This file implements the TIMAC Autopend feature.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* low-level */
     41          #include "mac_api.h"
     42          #include "mac_radio_defs.h"
     43          
     44          /* osal */
     45          #include "OSAL.h"
     46          #include "saddr.h"
     47          #include "ZComDef.h"
     48          
     49          #include "mac_autopend.h"
     50          
     51          /* ------------------------------------------------------------------------------------------------
     52           *                                           Defines
     53           * ------------------------------------------------------------------------------------------------
     54           */
     55          #define MAC_SRCMATCH_INVALID_INDEX           0xFF
     56          
     57          #define MAC_SRCMATCH_SHORT_ENTRY_SIZE        4
     58          #define MAC_SRCMATCH_EXT_ENTRY_SIZE          Z_EXTADDR_LEN
     59          
     60          #define MAC_SRCMATCH_SHORT_MAX_NUM_ENTRIES   24
     61          #define MAC_SRCMATCH_EXT_MAX_NUM_ENTRIES     12
     62          
     63          #define MAC_SRCMATCH_ENABLE_BITMAP_LEN       3
     64                    
     65          /* ------------------------------------------------------------------------------------------------
     66           *                                      Global Variables
     67           * ------------------------------------------------------------------------------------------------
     68           */

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     69          bool macSrcMatchIsEnabled = FALSE; 
   \                     macSrcMatchIsEnabled:
   \   000000                DS8 1
     70          
     71          /* ------------------------------------------------------------------------------------------------
     72           *                                         Local Variables
     73           * ------------------------------------------------------------------------------------------------
     74           */
     75          
     76          /* 
     77           The following local Varables are only set in MAC_SrcMatchEnable()  
     78           They are read only to the rest of the module.
     79           */

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     80          uint8 macSrcMatchMaxNumEntries = 0;   
   \                     macSrcMatchMaxNumEntries:
   \   000000                DS8 1

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     81          uint8 macSrcMatchAddrMode = SADDR_MODE_SHORT;  
   \                     macSrcMatchAddrMode:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for macSrcMatchAddrMode>`

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     82          bool macSrcMatchIsAckAllPending = FALSE;
   \                     macSrcMatchIsAckAllPending:
   \   000000                DS8 1
     83          
     84          /* ------------------------------------------------------------------------------------------------
     85           *                                         Local Functions
     86           * ------------------------------------------------------------------------------------------------
     87           */
     88          static uint8 macSrcMatchFindEmptyEntry( void );
     89          static uint8 macSrcMatchCheckSrcAddr ( sAddr_t *addr, uint16 panID  );
     90          static void macSrcMatchSetPendEnBit( uint8 index );
     91          static void macSrcMatchSetEnableBit( uint8 index, bool option );
     92          static bool macSrcMatchCheckEnableBit( uint8 index );
     93          static uint24 macSrcMatchGetEnableBit( void );
     94          static uint24 macSrcMatchGetPendEnBit( void );
     95          
     96          /*********************************************************************
     97           * @fn          MAC_SrcMatchEnable
     98           *
     99           * @brief      Enabled AUTOPEND and source address matching. If number of source
    100           *             address table entries asked for is more than the hardware
    101           *             supports. It will allocate maximum number of entries and return 
    102           *             MAC_INVALID_PARAMETER. This function shall be not be called from 
    103           *             ISR. It is not thread safe.
    104           *
    105           * @param      addressType - address type that the application uses
    106           *                           SADDR_MODE_SHORT or SADDR_MODE_EXT
    107           * @param      num - number of source address table entries to be used
    108           *
    109           * @return     MAC_SUCCESS or MAC_INVALID_PARAMETER
    110           */

   \                                 In  segment CODE, align 2
    111          uint8 MAC_SrcMatchEnable ( uint8 addrType, uint8 num  )
   \                     MAC_SrcMatchEnable:
    112          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
    113            uint8 rtn;
    114            uint8 maxNum;
    115              
    116            /* Verify the address type */
    117            if( addrType != SADDR_MODE_SHORT && addrType != SADDR_MODE_EXT )
   \   000006   6C93         CMP.B   #0x2, R12
   \   000008   0624         JEQ     ??MAC_SrcMatchEnable_0
   \   00000A   7C900300     CMP.B   #0x3, R12
   \   00000E   0624         JEQ     ??MAC_SrcMatchEnable_1
    118            {
    119              return MAC_INVALID_PARAMETER;
   \   000010   7C40E800     MOV.B   #0xe8, R12
   \   000014   213C         JMP     ??MAC_SrcMatchEnable_2
    120            }
   \                     ??MAC_SrcMatchEnable_0:
   \   000016   7E401800     MOV.B   #0x18, R14
   \   00001A   023C         JMP     ??MAC_SrcMatchEnable_3
   \                     ??MAC_SrcMatchEnable_1:
   \   00001C   7E400C00     MOV.B   #0xc, R14
    121            
    122            maxNum = ( addrType == SADDR_MODE_SHORT ) ? 
    123                     MAC_SRCMATCH_SHORT_MAX_NUM_ENTRIES : MAC_SRCMATCH_EXT_MAX_NUM_ENTRIES;
    124                     
    125            if( num > maxNum )
   \                     ??MAC_SrcMatchEnable_3:
   \   000020   4E9D         CMP.B   R13, R14
   \   000022   042C         JC      ??MAC_SrcMatchEnable_4
    126            {
    127              rtn = MAC_INVALID_PARAMETER;
   \   000024   7840E800     MOV.B   #0xe8, R8
    128              num = maxNum;
   \   000028   4B4E         MOV.B   R14, R11
   \   00002A   013C         JMP     ??MAC_SrcMatchEnable_5
    129            }
    130            else
    131            {
    132              rtn = MAC_SUCCESS;
   \                     ??MAC_SrcMatchEnable_4:
   \   00002C   4843         MOV.B   #0x0, R8
    133            }
    134              
    135            /* Turn on Frame Filter (TIMAC enables frame filter by default), TBD */
    136            MAC_RADIO_TURN_ON_RX_FRAME_FILTERING();
   \                     ??MAC_SrcMatchEnable_5:
   \   00002E   7C400500     MOV.B   #0x5, R12
   \   000032   ........     CALLA   #macDualchipOrFRMFILT0
    137            
    138            /* Turn on Auto ACK (TIMAC turn on Auto ACK by default), TBD */
    139            MAC_RADIO_TURN_ON_AUTO_ACK();
   \   000036   7D406000     MOV.B   #0x60, R13
   \   00003A   7C400C00     MOV.B   #0xc, R12
   \   00003E   ........     CALLA   #macSpiWriteReg
    140            
    141            /* Turn on Autopend: set SRCMATCH.AUTOPEND and SRCMATCH.SRC_MATCH_EN */
    142            MAC_RADIO_TURN_ON_SRC_MATCH();
   \   000042   ........     CALLA   #?Subroutine1
    143           
    144            /* Set SRCMATCH.AUTOPEND */
    145            MAC_RADIO_TURN_ON_AUTOPEND();
   \                     ??CrossCallReturnLabel_3:
   \   000046   ........     CALLA   #?Subroutine1
    146            
    147            /* Configure all the globals */
    148            macSrcMatchIsEnabled = TRUE;
   \                     ??CrossCallReturnLabel_2:
   \   00004A   D243....     MOV.B   #0x1, &macSrcMatchIsEnabled
    149            macSrcMatchMaxNumEntries = num;
   \   00004E   C24B....     MOV.B   R11, &macSrcMatchMaxNumEntries
    150            macSrcMatchAddrMode = addrType;           
   \   000052   C24A....     MOV.B   R10, &macSrcMatchAddrMode
    151          
    152            return rtn;
   \   000056   4C48         MOV.B   R8, R12
   \                     ??MAC_SrcMatchEnable_2:
   \   000058   3817         POPM.W  #0x4, R11
   \   00005A   1001         RETA
    153          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   7D400700     MOV.B   #0x7, R13
   \   000004   6C43         MOV.B   #0x2, R12
   \   000006   ........     BRA     #macSpiWriteReg
    154          
    155          /*********************************************************************
    156           * @fn          MAC_SrcMatchAddEntry
    157           *
    158           * @brief       Add a short or extended address to source address table. This 
    159           *              function shall be not be called from ISR. It is not thread safe.
    160           *
    161           * @param       addr - a pointer to sAddr_t which contains addrMode 
    162           *                     and a union of a short 16-bit MAC address or an extended 
    163           *                     64-bit MAC address to be added to the source address table. 
    164           * @param       panID - the device PAN ID. It is only used when the addr is 
    165           *                      using short address 
    166          
    167           * @return      MAC_SUCCESS or MAC_NO_RESOURCES (source address table full) 
    168           *              or MAC_DUPLICATED_ENTRY (the entry added is duplicated),
    169           *              or MAC_INVALID_PARAMETER if the input parameters are invalid.
    170           */

   \                                 In  segment CODE, align 2
    171          uint8 MAC_SrcMatchAddEntry ( sAddr_t *addr, uint16 panID )
   \                     MAC_SrcMatchAddEntry:
    172          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2182         SUB.W   #0x4, SP
   \   000004   084C         MOV.W   R12, R8
   \   000006   0B4D         MOV.W   R13, R11
    173            uint8 index;
    174            uint8 entry[MAC_SRCMATCH_SHORT_ENTRY_SIZE];
    175            
    176            /* Check if the input parameters are valid */
    177            if ( addr == NULL || addr->addrMode != macSrcMatchAddrMode )
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0424         JEQ     ??MAC_SrcMatchAddEntry_0
   \   00000C   DC92....0800 CMP.B   &macSrcMatchAddrMode, 0x8(R12)
   \   000012   0324         JEQ     ??MAC_SrcMatchAddEntry_1
    178            {
    179              return MAC_INVALID_PARAMETER;  
   \                     ??MAC_SrcMatchAddEntry_0:
   \   000014   7C40E800     MOV.B   #0xe8, R12
   \   000018   333C         JMP     ??MAC_SrcMatchAddEntry_2
    180            }
    181            
    182            /* Check if the entry already exists. Do not add duplicated entry */
    183            if ( macSrcMatchCheckSrcAddr( addr, panID ) != MAC_SRCMATCH_INVALID_INDEX )
   \                     ??MAC_SrcMatchAddEntry_1:
   \   00001A   ........     CALLA   #macSrcMatchCheckSrcAddr
   \   00001E   7C93         CMP.B   #0xff, R12
   \   000020   0324         JEQ     ??MAC_SrcMatchAddEntry_3
    184            {
    185              return MAC_DUPLICATED_ENTRY; 
   \   000022   7C401E00     MOV.B   #0x1e, R12
   \   000026   2C3C         JMP     ??MAC_SrcMatchAddEntry_2
    186            }
    187            
    188            /* If not duplicated, write to the radio RAM and enable the control bit */
    189            
    190            /* Find the first empty entry */
    191            index = macSrcMatchFindEmptyEntry();
   \                     ??MAC_SrcMatchAddEntry_3:
   \   000028   ........     CALLA   #macSrcMatchFindEmptyEntry
   \   00002C   4A4C         MOV.B   R12, R10
    192            if ( index == macSrcMatchMaxNumEntries )
   \   00002E   5C92....     CMP.B   &macSrcMatchMaxNumEntries, R12
   \   000032   0320         JNE     ??MAC_SrcMatchAddEntry_4
    193            {
    194              return MAC_NO_RESOURCES;   /* Table is full */
   \   000034   7C401A00     MOV.B   #0x1a, R12
   \   000038   233C         JMP     ??MAC_SrcMatchAddEntry_2
    195            }
    196            
    197            if ( macSrcMatchAddrMode == SADDR_MODE_SHORT )
   \                     ??MAC_SrcMatchAddEntry_4:
   \   00003A   4C4A         MOV.B   R10, R12
   \   00003C   E293....     CMP.B   #0x2, &macSrcMatchAddrMode
   \   000040   1020         JNE     ??MAC_SrcMatchAddEntry_5
    198            {
    199              /* Write the PanID and short address */
    200              entry[0] = LO_UINT16( panID );  /* Little Endian for the radio RAM */
   \   000042   C14B0000     MOV.B   R11, 0(SP)
    201              entry[1] = HI_UINT16( panID );
   \   000046                RPT     #0x8
   \   000046   47190B10     RRUX.W  R11
   \   00004A   C14B0100     MOV.B   R11, 0x1(SP)
    202              entry[2] = LO_UINT16( addr->addr.shortAddr );
   \   00004E   E1480200     MOV.B   @R8, 0x2(SP)
    203              entry[3] = HI_UINT16( addr->addr.shortAddr );
   \   000052   D14801000300 MOV.B   0x1(R8), 0x3(SP)
    204              MAC_RADIO_SRC_MATCH_TABLE_WRITE( ( index * MAC_SRCMATCH_SHORT_ENTRY_SIZE ), 
    205                             entry, MAC_SRCMATCH_SHORT_ENTRY_SIZE );
   \   000058   6E42         MOV.B   #0x4, R14
   \   00005A   0D41         MOV.W   SP, R13
   \   00005C   0D53         ADD.W   #0x0, R13
   \   00005E   5C06         RLAM.W  #0x2, R12
   \   000060   033C         JMP     ??MAC_SrcMatchAddEntry_6
    206            }
    207            else
    208            {
    209              /* Write the extended address */
    210              MAC_RADIO_SRC_MATCH_TABLE_WRITE( ( index * MAC_SRCMATCH_EXT_ENTRY_SIZE ), 
    211                             addr->addr.extAddr, MAC_SRCMATCH_EXT_ENTRY_SIZE ); 
   \                     ??MAC_SrcMatchAddEntry_5:
   \   000062   7E42         MOV.B   #0x8, R14
   \   000064   0D48         MOV.W   R8, R13
   \   000066   5C0A         RLAM.W  #0x3, R12
   \                     ??MAC_SrcMatchAddEntry_6:
   \   000068   3C508003     ADD.W   #0x380, R12
   \   00006C   ........     CALLA   #macSpiWriteRam
    212            }
    213            
    214            /* Set the Autopend enable bits */
    215            macSrcMatchSetPendEnBit( index );
   \   000070   4C4A         MOV.B   R10, R12
   \   000072   ........     CALLA   #macSrcMatchSetPendEnBit
    216            
    217            /* Set the Src Match enable bits */
    218            macSrcMatchSetEnableBit( index, TRUE );
   \   000076   5D43         MOV.B   #0x1, R13
   \   000078   4C4A         MOV.B   R10, R12
   \   00007A   ........     CALLA   #macSrcMatchSetEnableBit
    219            
    220            return MAC_SUCCESS;
   \   00007E   4C43         MOV.B   #0x0, R12
   \                     ??MAC_SrcMatchAddEntry_2:
   \   000080   2152         ADD.W   #0x4, SP
   \   000082   3817         POPM.W  #0x4, R11
   \   000084   1001         RETA
    221          }
    222          
    223          /*********************************************************************
    224           * @fn         MAC_SrcMatchDeleteEntry
    225           *
    226           * @brief      Delete a short or extended address from source address table. 
    227           *             This function shall be not be called from ISR. It is not thread safe.
    228           *
    229           * @param      addr - a pointer to sAddr_t which contains addrMode 
    230           *                    and a union of a short 16-bit MAC address or an extended 
    231           *                    64-bit MAC address to be deleted from the source address table. 
    232           * @param      panID - the device PAN ID. It is only used when the addr is 
    233           *                     using short address  
    234           *
    235           * @return     MAC_SUCCESS or MAC_INVALID_PARAMETER (address to be deleted 
    236           *                  cannot be found in the source address table).
    237           */

   \                                 In  segment CODE, align 2
    238          uint8 MAC_SrcMatchDeleteEntry ( sAddr_t *addr, uint16 panID  )
   \                     MAC_SrcMatchDeleteEntry:
    239          {
    240            uint8 index;
    241            
    242            if ( addr == NULL || addr->addrMode != macSrcMatchAddrMode )
   \   000000   0C93         CMP.W   #0x0, R12
   \   000002   0824         JEQ     ??MAC_SrcMatchDeleteEntry_0
   \   000004   DC92....0800 CMP.B   &macSrcMatchAddrMode, 0x8(R12)
   \   00000A   0420         JNE     ??MAC_SrcMatchDeleteEntry_0
    243            {
    244              return MAC_INVALID_PARAMETER;  
    245            }
    246            
    247            /* Look up the source address table and find the entry. */
    248            index = macSrcMatchCheckSrcAddr( addr, panID );
   \   00000C   ........     CALLA   #macSrcMatchCheckSrcAddr
    249          
    250            if( index == MAC_SRCMATCH_INVALID_INDEX )
   \   000010   7C93         CMP.B   #0xff, R12
   \   000012   0320         JNE     ??MAC_SrcMatchDeleteEntry_1
    251            {
    252              return MAC_INVALID_PARAMETER; 
   \                     ??MAC_SrcMatchDeleteEntry_0:
   \   000014   7C40E800     MOV.B   #0xe8, R12
   \   000018   1001         RETA
    253            }
    254            
    255            /* Clear Src Match enable bits */
    256            macSrcMatchSetEnableBit( index, FALSE );
   \                     ??MAC_SrcMatchDeleteEntry_1:
   \   00001A   4D43         MOV.B   #0x0, R13
   \   00001C   ........     CALLA   #macSrcMatchSetEnableBit
    257          
    258            return MAC_SUCCESS;
   \   000020   4C43         MOV.B   #0x0, R12
   \   000022   1001         RETA
    259          }
    260                            
    261          /*********************************************************************
    262           * @fn          MAC_SrcMatchAckAllPending
    263           *
    264           * @brief       Enabled/disable acknowledging all packets with pending bit set
    265           *              The application normally enables it when adding new entries to 
    266           *              the source address table fails due to the table is full, or 
    267           *              disables it when more entries are deleted and the table has
    268           *              empty slots.
    269           *
    270           * @param       option - TRUE (acknowledging all packets with pending field set)
    271           *                       FALSE (acknowledging all packets with pending field cleared) 
    272           *
    273           * @return      none
    274           */

   \                                 In  segment CODE, align 2
    275          void MAC_SrcMatchAckAllPending ( uint8 option  ) 
   \                     MAC_SrcMatchAckAllPending:
    276          {
    277            if( option == TRUE )
   \   000000   5C93         CMP.B   #0x1, R12
   \   000002   0520         JNE     ??MAC_SrcMatchAckAllPending_0
    278            {
    279              macSrcMatchIsAckAllPending = TRUE;
   \   000004   D243....     MOV.B   #0x1, &macSrcMatchIsAckAllPending
    280              
    281              /* Set the PENDING_OR register */
    282              MAC_RADIO_TURN_ON_PENDING_OR();
   \   000008   7D400500     MOV.B   #0x5, R13
   \   00000C   033C         JMP     ??MAC_SrcMatchAckAllPending_1
    283            }
    284            else
    285            {
    286              macSrcMatchIsAckAllPending = FALSE;
   \                     ??MAC_SrcMatchAckAllPending_0:
   \   00000E   C243....     MOV.B   #0x0, &macSrcMatchIsAckAllPending
    287              
    288              /* Clear the PENDING_OR register */
    289              MAC_RADIO_TURN_OFF_PENDING_OR();
   \   000012   5D43         MOV.B   #0x1, R13
   \                     ??MAC_SrcMatchAckAllPending_1:
   \   000014   7C400D00     MOV.B   #0xd, R12
   \   000018   ........     BRA     #macSpiWriteReg
    290            }
    291          }
    292          
    293          /*********************************************************************
    294           * @fn          MAC_SrcMatchCheckAllPending
    295           *
    296           * @brief       Check if acknowledging all packets with pending bit set
    297           *              is enabled. 
    298           *
    299           * @param       none 
    300           *
    301           * @return      MAC_AUTOACK_PENDING_ALL_ON or MAC_AUTOACK_PENDING_ALL_OFF
    302           */

   \                                 In  segment CODE, align 2
    303          uint8 MAC_SrcMatchCheckAllPending ( void )
   \                     MAC_SrcMatchCheckAllPending:
    304          {
    305            if( macSrcMatchIsAckAllPending == TRUE )
   \   000000   D293....     CMP.B   #0x1, &macSrcMatchIsAckAllPending
   \   000004   0320         JNE     ??MAC_SrcMatchCheckAllPending_0
    306            {
    307              return MAC_AUTOACK_PENDING_ALL_ON; 
   \   000006   7C40FE00     MOV.B   #0xfe, R12
   \   00000A   1001         RETA
    308            }
    309            
    310            return MAC_AUTOACK_PENDING_ALL_OFF;
   \                     ??MAC_SrcMatchCheckAllPending_0:
   \   00000C   7C43         MOV.B   #0xff, R12
   \   00000E   1001         RETA
    311          }
    312          
    313          /*********************************************************************
    314           * @fn          MAC_SrcMatchCheckResult
    315           *
    316           * @brief       Check the result of source matching
    317           *
    318           * @param       index - index of the entry in the source address table
    319           *
    320           * @return      TRUE or FALSE
    321           */

   \                                 In  segment CODE, align 2
    322          MAC_INTERNAL_API bool MAC_SrcMatchCheckResult( void )
   \                     MAC_SrcMatchCheckResult:
    323          {
   \   000000   2183         SUB.W   #0x2, SP
    324            uint8 resIndex;
    325            
    326            if ( macSrcMatchIsAckAllPending )
   \   000002   C293....     CMP.B   #0x0, &macSrcMatchIsAckAllPending
   \   000006   0224         JEQ     ??MAC_SrcMatchCheckResult_0
    327            {
    328              return (TRUE);
   \   000008   5C43         MOV.B   #0x1, R12
   \   00000A   0A3C         JMP     ??MAC_SrcMatchCheckResult_1
    329            }
    330            
    331            MAC_RADIO_SRC_MATCH_RESINDEX( resIndex );
   \                     ??MAC_SrcMatchCheckResult_0:
   \   00000C   5E43         MOV.B   #0x1, R14
   \   00000E   0D41         MOV.W   SP, R13
   \   000010   0D53         ADD.W   #0x0, R13
   \   000012   3C40E303     MOV.W   #0x3e3, R12
   \   000016   ........     CALLA   #macSpiReadRam
    332            
    333            return ( resIndex & AUTOPEND_RES );
   \   00001A   6C41         MOV.B   @SP, R12
   \   00001C   7CF04000     AND.B   #0x40, R12
   \                     ??MAC_SrcMatchCheckResult_1:
   \   000020   2153         ADD.W   #0x2, SP
   \   000022   1001         RETA
    334          }
    335          
    336          /*********************************************************************
    337           * @fn          macSrcMatchFindEmptyEntry
    338           *
    339           * @brief       return index of the first empty entry found
    340           *
    341           * @param       none
    342           *
    343           * @return      uint8 - return index of the first empty entry found
    344           */

   \                                 In  segment CODE, align 2
    345          static uint8 macSrcMatchFindEmptyEntry( void )
   \                     macSrcMatchFindEmptyEntry:
    346          {
   \   000000   1B15         PUSHM.W #0x2, R11
    347            uint8  index;
    348            uint24 enable;
    349               
    350            enable = MAC_RADIO_SRC_MATCH_GET_EN();
   \   000002   ........     CALLA   #macSrcMatchGetEnableBit
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0B4D         MOV.W   R13, R11
    351                  
    352            if( macSrcMatchAddrMode == SADDR_MODE_SHORT )
   \   00000A   E293....     CMP.B   #0x2, &macSrcMatchAddrMode
   \   00000E   4F43         MOV.B   #0x0, R15
   \   000010   0D20         JNE     ??macSrcMatchFindEmptyEntry_3
    353            {
    354              for( index = 0; index < macSrcMatchMaxNumEntries; index++ )
   \                     ??macSrcMatchFindEmptyEntry_0:
   \   000012   5F92....     CMP.B   &macSrcMatchMaxNumEntries, R15
   \   000016   152C         JC      ??macSrcMatchFindEmptyEntry_4
    355              {  
    356                if( ( enable & ( (uint24)0x01 << index ) ) == 0 )
   \   000018   0C4A         MOV.W   R10, R12
   \   00001A   0D4B         MOV.W   R11, R13
   \   00001C   4E4F         MOV.B   R15, R14
   \   00001E   ........     CALLA   #?ShiftRight32u
   \   000022   5CB3         BIT.B   #0x1, R12
   \   000024   0E24         JEQ     ??macSrcMatchFindEmptyEntry_4
    357                {
    358                  return index;
    359                }
    360              }
   \   000026   5F53         ADD.B   #0x1, R15
   \   000028   F43F         JMP     ??macSrcMatchFindEmptyEntry_0
    361            }
    362            else
    363            {
    364              for( index = 0; index < macSrcMatchMaxNumEntries; index++ )
   \                     ??macSrcMatchFindEmptyEntry_1:
   \   00002A   5F53         ADD.B   #0x1, R15
   \                     ??macSrcMatchFindEmptyEntry_3:
   \   00002C   5F92....     CMP.B   &macSrcMatchMaxNumEntries, R15
   \   000030   082C         JC      ??macSrcMatchFindEmptyEntry_4
    365              {  
    366                if( ( enable & ( (uint24)0x01 << ( index * 2 ) ) ) == 0 )
   \   000032   0C4A         MOV.W   R10, R12
   \   000034   0D4B         MOV.W   R11, R13
   \   000036   4E4F         MOV.B   R15, R14
   \   000038   4E5E         RLA.B   R14
   \   00003A   ........     CALLA   #?ShiftRight32u
   \   00003E   5CB3         BIT.B   #0x1, R12
   \   000040   F423         JNE     ??macSrcMatchFindEmptyEntry_1
    367                {
    368                  return index;
    369                }
    370              }
    371            }
    372            
    373            /* 
    374             The value of index shall be macSrcMatchMaxNumEntries when it executes
    375             here. The table is full.
    376            */
    377            return index;
   \                     ??macSrcMatchFindEmptyEntry_4:
   \   000042   4C4F         MOV.B   R15, R12
   \   000044   1A17         POPM.W  #0x2, R11
   \   000046   1001         RETA
    378          }
    379          
    380          /*********************************************************************
    381           * @fn         macSrcMatchCheckSrcAddr
    382           *
    383           * @brief      Check if a short or extended address is in the source address table.
    384           *             This function shall not be called from ISR. It is not thread safe.
    385           *
    386           * @param      addr - a pointer to sAddr_t which contains addrMode 
    387           *                    and a union of a short 16-bit MAC address or an extended 
    388           *                    64-bit MAC address to be checked in the source address table. 
    389           * @param      panID - the device PAN ID. It is only used when the addr is 
    390           *                     using short address 
    391          
    392           * @return     uint8 - index of the entry in the table. Return 
    393           *                     MAC_SRCMATCH_INVALID_INDEX (0xFF) if address not found.
    394           */

   \                                 In  segment CODE, align 2
    395          static uint8 macSrcMatchCheckSrcAddr ( sAddr_t *addr, uint16 panID  )
   \                     macSrcMatchCheckSrcAddr:
    396          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31800C00     SUB.W   #0xc, SP
   \   000006   084C         MOV.W   R12, R8
    397            uint8 index;     
    398            uint8 *pAddr;
    399            uint8 entrySize;
    400            uint8 entry[MAC_SRCMATCH_SHORT_ENTRY_SIZE];  
    401            uint8 ramEntry[MAC_SRCMATCH_EXT_ENTRY_SIZE];
    402                
    403            /*
    404             Currently, shadow memory is not supported to optimize SPI traffic.
    405            */
    406            
    407            if( macSrcMatchAddrMode == SADDR_MODE_SHORT )
   \   000008   E293....     CMP.B   #0x2, &macSrcMatchAddrMode
   \   00000C   0F20         JNE     ??macSrcMatchCheckSrcAddr_1
    408            {
    409              entry[0] = LO_UINT16( panID );  /* Little Endian for the radio RAM */
   \   00000E   C14D0000     MOV.B   R13, 0(SP)
    410              entry[1] = HI_UINT16( panID );
   \   000012                RPT     #0x8
   \   000012   47190D10     RRUX.W  R13
   \   000016   C14D0100     MOV.B   R13, 0x1(SP)
    411              entry[2] = LO_UINT16( addr->addr.shortAddr );
   \   00001A   E14C0200     MOV.B   @R12, 0x2(SP)
    412              entry[3] = HI_UINT16( addr->addr.shortAddr );
   \   00001E   D14C01000300 MOV.B   0x1(R12), 0x3(SP)
    413              pAddr = entry;
   \   000024   0841         MOV.W   SP, R8
   \   000026   0853         ADD.W   #0x0, R8
    414              entrySize = MAC_SRCMATCH_SHORT_ENTRY_SIZE;
   \   000028   6A42         MOV.B   #0x4, R10
   \   00002A   013C         JMP     ??macSrcMatchCheckSrcAddr_2
    415            }
    416            else
    417            {
    418              pAddr = addr->addr.extAddr;
    419              entrySize = MAC_SRCMATCH_EXT_ENTRY_SIZE;
   \                     ??macSrcMatchCheckSrcAddr_1:
   \   00002C   7A42         MOV.B   #0x8, R10
    420            }
    421            
    422            for( index = 0; index < macSrcMatchMaxNumEntries; index++ )
   \                     ??macSrcMatchCheckSrcAddr_2:
   \   00002E   4B43         MOV.B   #0x0, R11
   \   000030   013C         JMP     ??macSrcMatchCheckSrcAddr_3
   \                     ??macSrcMatchCheckSrcAddr_0:
   \   000032   5B53         ADD.B   #0x1, R11
   \                     ??macSrcMatchCheckSrcAddr_3:
   \   000034   5B92....     CMP.B   &macSrcMatchMaxNumEntries, R11
   \   000038   282C         JC      ??macSrcMatchCheckSrcAddr_4
    423            {
    424              /* Check if the entry is enabled */
    425              if( macSrcMatchCheckEnableBit( index ) == FALSE )
   \   00003A   494B         MOV.B   R11, R9
   \   00003C   F2900300.... CMP.B   #0x3, &macSrcMatchAddrMode
   \   000042   0120         JNE     ??macSrcMatchCheckSrcAddr_5
   \   000044   4959         RLA.B   R9
   \                     ??macSrcMatchCheckSrcAddr_5:
   \   000046   ........     CALLA   #macSrcMatchGetEnableBit
   \   00004A   4E49         MOV.B   R9, R14
   \   00004C   ........     CALLA   #?ShiftRight32u
   \   000050   5CB3         BIT.B   #0x1, R12
   \   000052   EF27         JEQ     ??macSrcMatchCheckSrcAddr_0
    426              {
    427                continue; 
    428              }
    429                
    430              /* Compare the short address and pan ID */
    431              MAC_RADIO_SRC_MATCH_TABLE_READ( ( index * entrySize ), ramEntry, entrySize );
   \   000054   4E4A         MOV.B   R10, R14
   \   000056   0D41         MOV.W   SP, R13
   \   000058   2D52         ADD.W   #0x4, R13
   \   00005A   0212         PUSH.W  SR
   \   00005C   32C2         DINT
   \   00005E   0343         NOP
   \   000060   C24B3001     MOV.B   R11, &0x130
   \   000064   C24A3801     MOV.B   R10, &0x138
   \   000068   1C423A01     MOV.W   &0x13a, R12
   \   00006C   3241         POP.W   SR
   \   00006E   3C508003     ADD.W   #0x380, R12
   \   000072   ........     CALLA   #macSpiReadRam
    432               
    433              if( osal_memcmp( pAddr, ramEntry, entrySize ) == TRUE )
   \   000076   4E4A         MOV.B   R10, R14
   \   000078   0D41         MOV.W   SP, R13
   \   00007A   2D52         ADD.W   #0x4, R13
   \   00007C   0C48         MOV.W   R8, R12
   \   00007E   ........     CALLA   #osal_memcmp
   \   000082   5C93         CMP.B   #0x1, R12
   \   000084   D623         JNE     ??macSrcMatchCheckSrcAddr_0
    434              {
    435                /* Match found */
    436                return index;
   \   000086   4C4B         MOV.B   R11, R12
   \   000088   013C         JMP     ??macSrcMatchCheckSrcAddr_6
    437              }
    438            }
    439            
    440            return MAC_SRCMATCH_INVALID_INDEX;
   \                     ??macSrcMatchCheckSrcAddr_4:
   \   00008A   7C43         MOV.B   #0xff, R12
   \                     ??macSrcMatchCheckSrcAddr_6:
   \   00008C   31500C00     ADD.W   #0xc, SP
   \   000090   3817         POPM.W  #0x4, R11
   \   000092   1001         RETA
    441          }
    442          
    443          /*********************************************************************
    444           * @fn          macSrcMatchSetPendEnBit
    445           *
    446           * @brief       Set the enable bit in the source address table
    447           *
    448           * @param       index - index of the entry in the source address table
    449           *
    450           * @return      none
    451           */

   \                                 In  segment CODE, align 2
    452          static void macSrcMatchSetPendEnBit( uint8 index )
   \                     macSrcMatchSetPendEnBit:
    453          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   31800600     SUB.W   #0x6, SP
   \   000006   464C         MOV.B   R12, R6
    454            uint24 enable;
    455            uint8 buf[MAC_SRCMATCH_ENABLE_BITMAP_LEN];
    456                 
    457            enable = MAC_RADIO_SRC_MATCH_GET_PENDEN(); 
   \   000008   7A400300     MOV.B   #0x3, R10
   \   00000C   0B41         MOV.W   SP, R11
   \   00000E   0B53         ADD.W   #0x0, R11
   \   000010   E293....     CMP.B   #0x2, &macSrcMatchAddrMode
   \   000014   4E4A         MOV.B   R10, R14
   \   000016   0D4B         MOV.W   R11, R13
   \   000018   0320         JNE     ??macSrcMatchSetPendEnBit_0
   \   00001A   3C40E703     MOV.W   #0x3e7, R12
   \   00001E   023C         JMP     ??macSrcMatchSetPendEnBit_1
   \                     ??macSrcMatchSetPendEnBit_0:
   \   000020   3C40E403     MOV.W   #0x3e4, R12
   \                     ??macSrcMatchSetPendEnBit_1:
   \   000024   ........     CALLA   #macSpiReadRam
   \   000028   4D4A         MOV.B   R10, R13
   \   00002A   0C4B         MOV.W   R11, R12
   \   00002C   ........     CALLA   #osal_build_uint32
   \   000030   084C         MOV.W   R12, R8
   \   000032   094D         MOV.W   R13, R9
    458                
    459            if( macSrcMatchAddrMode == SADDR_MODE_SHORT )
   \   000034   0B5A         ADD.W   R10, R11
   \   000036   E293....     CMP.B   #0x2, &macSrcMatchAddrMode
   \   00003A   0520         JNE     ??macSrcMatchSetPendEnBit_2
    460            {
    461              enable |= ( (uint24)0x01 << index );
    462              osal_buffer_uint24( buf, enable );
   \   00003C   ........     CALLA   #?Subroutine0
    463              MAC_RADIO_SRC_MATCH_SET_SHORTPENDEN( buf );
    464            }
   \                     ??CrossCallReturnLabel_0:
   \   000040   3C40E703     MOV.W   #0x3e7, R12
   \   000044   053C         JMP     ??macSrcMatchSetPendEnBit_3
    465            else
    466            {
    467              enable |= ( (uint24)0x01 << ( index * 2 ) );
    468              osal_buffer_uint24( buf, enable );
   \                     ??macSrcMatchSetPendEnBit_2:
   \   000046   4656         RLA.B   R6
   \   000048   ........     CALLA   #?Subroutine0
    469              MAC_RADIO_SRC_MATCH_SET_EXTPENDEN( buf );
    470            }
   \                     ??CrossCallReturnLabel_1:
   \   00004C   3C40E403     MOV.W   #0x3e4, R12
   \                     ??macSrcMatchSetPendEnBit_3:
   \   000050   ........     CALLA   #macSpiWriteRam
    471          }
   \   000054   31500600     ADD.W   #0x6, SP
   \   000058   5617         POPM.W  #0x6, R11
   \   00005A   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   4C46         MOV.B   R6, R12
   \   000002   ........     CALLA   #?OneBitMask32
   \   000006   08DC         BIS.W   R12, R8
   \   000008   09DD         BIS.W   R13, R9
   \   00000A   0E48         MOV.W   R8, R14
   \   00000C   0F49         MOV.W   R9, R15
   \   00000E   0C4B         MOV.W   R11, R12
   \   000010   ........     CALLA   #osal_buffer_uint24
   \   000014   4E4A         MOV.B   R10, R14
   \   000016   0D4B         MOV.W   R11, R13
   \   000018   1001         RETA
    472          
    473          /*********************************************************************
    474           * @fn          macSrcMatchSetEnableBit
    475           *
    476           * @brief       Set or clear the enable bit in the SRCMATCH EN register
    477           *
    478           * @param       index - index of the entry in the source address table
    479           * @param       option - true (set the enable bit), or false (clear the enable bit)
    480           *
    481           * @return      none
    482           */

   \                                 In  segment CODE, align 2
    483          static void macSrcMatchSetEnableBit( uint8 index, bool option )
   \                     macSrcMatchSetEnableBit:
    484          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   484C         MOV.B   R12, R8
   \   000004   494D         MOV.B   R13, R9
    485            uint24 enable;  
    486            
    487            enable = MAC_RADIO_SRC_MATCH_GET_EN(); 
   \   000006   ........     CALLA   #macSrcMatchGetEnableBit
   \   00000A   0A4C         MOV.W   R12, R10
   \   00000C   4B4D         MOV.B   R13, R11
    488                
    489            if( option == TRUE )
   \   00000E   4C48         MOV.B   R8, R12
   \   000010   4C5C         RLA.B   R12
   \   000012   ........     CALLA   #?OneBitMask32
   \   000016   064C         MOV.W   R12, R6
   \   000018   474D         MOV.B   R13, R7
   \   00001A   4C48         MOV.B   R8, R12
   \   00001C   ........     CALLA   #?OneBitMask32
   \   000020   5993         CMP.B   #0x1, R9
   \   000022   0920         JNE     ??macSrcMatchSetEnableBit_1
    490            {
    491              if( macSrcMatchAddrMode == SADDR_MODE_SHORT )
   \   000024   E293....     CMP.B   #0x2, &macSrcMatchAddrMode
   \   000028   0320         JNE     ??macSrcMatchSetEnableBit_2
    492              {
    493                enable |= ( (uint24)0x01 << index );
   \   00002A   0ADC         BIS.W   R12, R10
   \   00002C   4BDD         BIS.B   R13, R11
    494                MAC_RADIO_SRC_MATCH_SET_SHORTEN( enable );
   \   00002E   083C         JMP     ??macSrcMatchSetEnableBit_3
    495              }
    496              else
    497              {
    498                enable |= ( (uint24)0x01 << ( index * 2 ) );
   \                     ??macSrcMatchSetEnableBit_2:
   \   000030   0AD6         BIS.W   R6, R10
   \   000032   4BD7         BIS.B   R7, R11
    499                MAC_RADIO_SRC_MATCH_SET_EXTEN( enable );
   \   000034   163C         JMP     ??macSrcMatchSetEnableBit_4
    500              }
    501            }
    502            else
    503            {
    504              if( macSrcMatchAddrMode == SADDR_MODE_SHORT )
   \                     ??macSrcMatchSetEnableBit_1:
   \   000036   E293....     CMP.B   #0x2, &macSrcMatchAddrMode
   \   00003A   1120         JNE     ??macSrcMatchSetEnableBit_5
    505              {
    506                enable &= ~( (uint24)0x01 << index );
   \   00003C   0ACC         BIC.W   R12, R10
   \   00003E   4BCD         BIC.B   R13, R11
    507                MAC_RADIO_SRC_MATCH_SET_SHORTEN( enable );
   \                     ??macSrcMatchSetEnableBit_3:
   \   000040   4D4A         MOV.B   R10, R13
   \   000042   6C42         MOV.B   #0x4, R12
   \   000044   ........     CALLA   #macSpiWriteReg
   \   000048   0D4A         MOV.W   R10, R13
   \   00004A                RPT     #0x8
   \   00004A   47190D10     RRUX.W  R13
   \   00004E   7C400500     MOV.B   #0x5, R12
   \   000052   ........     CALLA   #macSpiWriteReg
   \   000056   4D4B         MOV.B   R11, R13
   \   000058   7C400600     MOV.B   #0x6, R12
   \   00005C   103C         JMP     ??macSrcMatchSetEnableBit_0
    508              }
    509              else
    510              {
    511                enable &= ~( (uint24)0x01 << ( index * 2 ) );
   \                     ??macSrcMatchSetEnableBit_5:
   \   00005E   0AC6         BIC.W   R6, R10
   \   000060   4BC7         BIC.B   R7, R11
    512                MAC_RADIO_SRC_MATCH_SET_EXTEN( enable );
   \                     ??macSrcMatchSetEnableBit_4:
   \   000062   4D4A         MOV.B   R10, R13
   \   000064   7C42         MOV.B   #0x8, R12
   \   000066   ........     CALLA   #macSpiWriteReg
   \   00006A   0D4A         MOV.W   R10, R13
   \   00006C                RPT     #0x8
   \   00006C   47190D10     RRUX.W  R13
   \   000070   7C400900     MOV.B   #0x9, R12
   \   000074   ........     CALLA   #macSpiWriteReg
   \   000078   4D4B         MOV.B   R11, R13
   \   00007A   7C400A00     MOV.B   #0xa, R12
   \                     ??macSrcMatchSetEnableBit_0:
   \   00007E   ........     CALLA   #macSpiWriteReg
    513              }
    514            }
    515          }
   \   000082   5617         POPM.W  #0x6, R11
   \   000084   1001         RETA
    516          
    517          /*********************************************************************
    518           * @fn          macSrcMatchCheckEnableBit
    519           *
    520           * @brief       Check the enable bit in the source address table
    521           *
    522           * @param       index - index of the entry in the source address table
    523           *
    524           * @return      TRUE or FALSE
    525           */
    526          static bool macSrcMatchCheckEnableBit( uint8 index )
    527          {
    528            uint24 enable;
    529            
    530            if( macSrcMatchAddrMode == SADDR_MODE_EXT )
    531            {
    532              index *= 2;
    533            }
    534            
    535            enable = MAC_RADIO_SRC_MATCH_GET_EN();
    536               
    537            if( enable & ( (uint24)0x01 << index ) )
    538            {
    539              return TRUE;
    540            }
    541          
    542            return FALSE; 
    543          }
    544           
    545          /*********************************************************************
    546           * @fn          macSrcMatchGetEnableBit
    547           *
    548           * @brief       Return the SRCMATCH enable bitmap
    549           *
    550           * @param       none
    551           *
    552           * @return      uint24 - 24 bits bitmap
    553           */

   \                                 In  segment CODE, align 2
    554          static uint24 macSrcMatchGetEnableBit( void )
   \                     macSrcMatchGetEnableBit:
    555          { 
   \   000000   2182         SUB.W   #0x4, SP
    556            uint8 buf[MAC_SRCMATCH_ENABLE_BITMAP_LEN];
    557            
    558            if( macSrcMatchAddrMode == SADDR_MODE_SHORT )
   \   000002   E293....     CMP.B   #0x2, &macSrcMatchAddrMode
   \   000006   0E20         JNE     ??macSrcMatchGetEnableBit_0
    559            {
    560              MAC_RADIO_GET_SRC_SHORTEN( buf );
   \   000008   6C42         MOV.B   #0x4, R12
   \   00000A   ........     CALLA   #macSpiReadReg
   \   00000E   C14C0000     MOV.B   R12, 0(SP)
   \   000012   7C400500     MOV.B   #0x5, R12
   \   000016   ........     CALLA   #macSpiReadReg
   \   00001A   C14C0100     MOV.B   R12, 0x1(SP)
   \   00001E   7C400600     MOV.B   #0x6, R12
   \   000022   0D3C         JMP     ??macSrcMatchGetEnableBit_1
    561            }
    562            else
    563            {
    564              MAC_RADIO_GET_SRC_EXTEN( buf );
   \                     ??macSrcMatchGetEnableBit_0:
   \   000024   7C42         MOV.B   #0x8, R12
   \   000026   ........     CALLA   #macSpiReadReg
   \   00002A   C14C0000     MOV.B   R12, 0(SP)
   \   00002E   7C400900     MOV.B   #0x9, R12
   \   000032   ........     CALLA   #macSpiReadReg
   \   000036   C14C0100     MOV.B   R12, 0x1(SP)
   \   00003A   7C400A00     MOV.B   #0xa, R12
   \                     ??macSrcMatchGetEnableBit_1:
   \   00003E   ........     CALLA   #macSpiReadReg
   \   000042   C14C0200     MOV.B   R12, 0x2(SP)
    565            }
    566            
    567            return osal_build_uint32( buf, MAC_SRCMATCH_ENABLE_BITMAP_LEN );
   \   000046   7D400300     MOV.B   #0x3, R13
   \   00004A   0C41         MOV.W   SP, R12
   \   00004C   0C53         ADD.W   #0x0, R12
   \   00004E   ........     CALLA   #osal_build_uint32
   \   000052   2152         ADD.W   #0x4, SP
   \   000054   1001         RETA
    568          }

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for macSrcMatchAddrMode>`:
   \   000000   02           DC8 2
    569          
    570          /*********************************************************************
    571           * @fn          macSrcMatchGetPendEnBit
    572           *
    573           * @brief       Return the SRCMATCH Pend enable bitmap
    574           *
    575           * @param       none
    576           *
    577           * @return      uint24 - 24 bits bitmap
    578           */
    579          static uint24 macSrcMatchGetPendEnBit( void )
    580          {
    581            uint8 buf[MAC_SRCMATCH_ENABLE_BITMAP_LEN];
    582          
    583            if( macSrcMatchAddrMode == SADDR_MODE_SHORT )
    584            {
    585              MAC_RADIO_GET_SRC_SHORTPENDEN( buf );
    586            }
    587            else
    588            {
    589              MAC_RADIO_GET_SRC_EXTENPEND( buf );
    590            }
    591            
    592            return osal_build_uint32( buf, MAC_SRCMATCH_ENABLE_BITMAP_LEN );
    593          }
    594          
    595          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   MAC_SrcMatchAckAllPending
        4   -> macSpiWriteReg
     16   MAC_SrcMatchAddEntry
       16   -> macSpiWriteRam
       16   -> macSrcMatchCheckSrcAddr
       16   -> macSrcMatchFindEmptyEntry
       16   -> macSrcMatchSetEnableBit
       16   -> macSrcMatchSetPendEnBit
      4   MAC_SrcMatchCheckAllPending
      6   MAC_SrcMatchCheckResult
        6   -> macSpiReadRam
      4   MAC_SrcMatchDeleteEntry
        4   -> macSrcMatchCheckSrcAddr
        4   -> macSrcMatchSetEnableBit
     12   MAC_SrcMatchEnable
       12   -> macDualchipOrFRMFILT0
       12   -> macSpiWriteReg
     26   macSrcMatchCheckSrcAddr
       24   -> macSpiReadRam
       24   -> macSrcMatchGetEnableBit
       24   -> osal_memcmp
      8   macSrcMatchFindEmptyEntry
        8   -> macSrcMatchGetEnableBit
      8   macSrcMatchGetEnableBit
        8   -> macSpiReadReg
        8   -> osal_build_uint32
     16   macSrcMatchSetEnableBit
       16   -> macSpiWriteReg
       16   -> macSrcMatchGetEnableBit
     22   macSrcMatchSetPendEnBit
       22   -> macSpiReadRam
       22   -> macSpiWriteRam
       22   -> osal_buffer_uint24
       22   -> osal_build_uint32


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for macSrcMatchAddrMode>
      26  ?Subroutine0
      10  ?Subroutine1
      28  MAC_SrcMatchAckAllPending
     134  MAC_SrcMatchAddEntry
      16  MAC_SrcMatchCheckAllPending
      36  MAC_SrcMatchCheckResult
      36  MAC_SrcMatchDeleteEntry
      92  MAC_SrcMatchEnable
       1  macSrcMatchAddrMode
     148  macSrcMatchCheckSrcAddr
      72  macSrcMatchFindEmptyEntry
      86  macSrcMatchGetEnableBit
       1  macSrcMatchIsAckAllPending
       1  macSrcMatchIsEnabled
       1  macSrcMatchMaxNumEntries
     134  macSrcMatchSetEnableBit
      92  macSrcMatchSetPendEnBit

 
 910 bytes in segment CODE
   1 byte  in segment DATA16_I
   1 byte  in segment DATA16_ID
   3 bytes in segment DATA16_Z
 
 910 bytes of CODE  memory
   1 byte  of CONST memory
   4 bytes of DATA  memory

Errors: none
Warnings: none

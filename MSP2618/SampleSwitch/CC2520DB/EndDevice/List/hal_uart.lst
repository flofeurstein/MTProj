###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.52.1.50724/W32 for MSP430       10/Jun/2013  17:10:43 #
# Copyright 1996-2013 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\ha #
#                     l\target\MSP2618CC2520\hal_uart.c                       #
#    Command line  =  -f "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\..\To #
#                     ols\MSP2618\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0      #
#                     -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                       #
#                     -DDEFAULT_CHANLIST=0x00000800                           #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DNWK_START_DELAY=100      #
#                     -DEXTENDED_JOINING_RANDOM_MASK=0x007F                   #
#                     -DBEACON_REQUEST_DELAY=100                              #
#                     -DBEACON_REQ_DELAY_MASK=0x00FF                          #
#                     -DLINK_STATUS_JITTER_MASK=0x007F                        #
#                     -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_POLLED= #
#                     3000 -DNWK_INDIRECT_MSG_TIMEOUT=7 -DMAX_RREQ_ENTRIES=8  #
#                     -DAPSC_MAX_FRAME_RETRIES=3 -DNWK_MAX_DATA_RETRIES=2     #
#                     -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9              #
#                     -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40                #
#                     -DNWK_MAX_BINDING_ENTRIES=4                             #
#                     -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,       #
#                     0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02,   #
#                     0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"                    #
#                     -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=2 #
#                     0 -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000           #
#                     -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100         #
#                     -DREJOIN_POLL_RATE=440) -f "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wEndev.cfg" (-DCPU6MHZ -DMAC_CFG_TX_DATA_MAX=3         #
#                     -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "C:\Texas     #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\Tools\MSP2618\f #
#                     8wZCL.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC          #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE -DZCL_TUNNELING -DZCL_TOU)                #
#                     -DZCL_DEVICE_MGMT "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Components\hal\target\ #
#                     MSP2618CC2520\hal_uart.c" -D MSP430F2618 -D             #
#                     NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D  #
#                     MT_ZDO_FUNC -D LCD_SUPPORTED -lC "C:\Texas              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\EndDevice\List\" -lA     #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\List #
#                     \" --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826    #
#                     -o "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\O #
#                     bj\" --debug -D__MSP430F2618__ -e --double=32 --clib    #
#                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\" -I        #
#                     "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zst #
#                     ack\HomeAutomation\SampleSwitch\CC2520DB\..\Source\"    #
#                     -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\ #
#                     zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\Sourc #
#                     e\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Proje #
#                     cts\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\..\. #
#                     .\ZMain\MSP2618\" -I "C:\Texas                          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\hal\target\MSP2618CC2520\" -I "C:\Texas               #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\include\" -I "C:\Texas                            #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\high_level\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\" -I "C:\Texas                    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mac\low_level\srf04\dual_chip\" -I "C:\Texas          #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\mt\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\Pr #
#                     ojects\zstack\HomeAutomation\SampleSwitch\CC2520DB\..\. #
#                     .\..\..\..\Components\osal\include\" -I "C:\Texas       #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\osal\mcu\msp430\" -I "C:\Texas                        #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\saddr\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\services\sdata\" -I "C:\Texas                         #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\af\" -I "C:\Texas Instruments\ZStack-MSP2618-2. #
#                     5.1\Projects\zstack\HomeAutomation\SampleSwitch\CC2520D #
#                     B\..\..\..\..\..\Components\stack\nwk\" -I "C:\Texas    #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sec\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sapi\" -I "C:\Texas                             #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\sys\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zcl\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\stack\zdo\" -I "C:\Texas                              #
#                     Instruments\ZStack-MSP2618-2.5.1\Projects\zstack\HomeAu #
#                     tomation\SampleSwitch\CC2520DB\..\..\..\..\..\Component #
#                     s\zmac\" -I "C:\Texas Instruments\ZStack-MSP2618-2.5.1\ #
#                     Projects\zstack\HomeAutomation\SampleSwitch\CC2520DB\.. #
#                     \..\..\..\..\Components\zmac\f8w\" --core=430X          #
#                     --data_model=small -Ohz --multiplier=16s                #
#                     --require_prototypes                                    #
#    List file     =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\List\ #
#                     hal_uart.lst                                            #
#    Object file   =  C:\Texas Instruments\ZStack-MSP2618-2.5.1\Projects\zsta #
#                     ck\HomeAutomation\SampleSwitch\CC2520DB\EndDevice\Obj\h #
#                     al_uart.r43                                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-MSP2618-2.5.1\Components\hal\target\MSP2618CC2520\hal_uart.c
      1          /**************************************************************************************************
      2            Filename:       hal_uart.c
      3            Revised:        $Date: 2009-03-11 15:33:59 -0700 (Wed, 11 Mar 2009) $
      4            Revision:       $Revision: 19383 $
      5          
      6            Description:    This file contains the interface to the UART.
      7          
      8          
      9            Copyright 2007-2008 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "hal_types.h"
     44          #include "hal_uart.h"

   \                                 In  segment DATA16_AN, at 0x1
   \   unsigned char volatile IE2
   \                     IE2:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x3
   \   unsigned char volatile IFG2
   \                     IFG2:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x29
   \   unsigned char volatile P2OUT
   \                     P2OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2a
   \   unsigned char volatile P2DIR
   \                     P2DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1b
   \   unsigned char volatile P3SEL
   \                     P3SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x60
   \   unsigned char volatile UCA0CTL0
   \                     UCA0CTL0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x61
   \   unsigned char volatile UCA0CTL1
   \                     UCA0CTL1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x62
   \   unsigned char volatile UCA0BR0
   \                     UCA0BR0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x63
   \   unsigned char volatile UCA0BR1
   \                     UCA0BR1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x66
   \   unsigned char const volatile UCA0RXBUF
   \                     UCA0RXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x67
   \   unsigned char volatile UCA0TXBUF
   \                     UCA0TXBUF:
   \   000000                DS8 1
     45          #include "osal.h"
     46          #include "OSAL_Timers.h"
     47          #include "hal_mcu.h"
     48          
     49          /*-------------------------------------------------------------------------------------------------
     50                                                         MACROS
     51           ------------------------------------------------------------------------------------------------*/
     52          
     53          /* Get 1 byte from UART */
     54          #define HAL_UART_GETBYTE() UCA0RXBUF
     55          
     56          /* Put 1 byte into the UART */
     57          #define HAL_UART_PUTBYTE(x) UCA0TXBUF = x;
     58          
     59          /* Set Baud rate */
     60          #define HAL_UART_SETBAUDRATE(baudrate) { UCA0BR1 = (baudrate) >> 8;  UCA0BR0 = (baudrate);}
     61          
     62          /* Set Source Clock */
     63          #define HAL_UART_SET_SRC_CLK()         { UCA0CTL1 |= UCSSEL1; UCA0CTL1 &= ~UCSSEL0; } /* SMCLK */
     64          
     65          /* Setup TXD and RXD Port */
     66          #define HAL_UART_PORT_CONFIG()         { P3SEL |= BV(4) | BV(5); }      /* P3.4, P3.5 - UCA0TXD and RXD */
     67          
     68          /* Setup format frame */
     69          #define HAL_UART_FRAME_CONFIG()        { UCA0CTL0 &= ~UCPEN; UCA0CTL0 &= ~UCSPB; UCA0CTL0 &= ~UC7BIT; } /* 8N1 */
     70          
     71          /* Enable/Disable TX */
     72          #define HAL_UART_TX_ENABLE()           /* N/A */
     73          #define HAL_UART_TX_DISABLE()          /* N/A */
     74          
     75          /* Enable/Disable TX INT */
     76          #define HAL_UART_TX_INT_ENABLE()       { IE2 |= UCA0TXIE; }
     77          #define HAL_UART_TX_INT_DISABLE()      { IE2 &= ~UCA0TXIE; }
     78          
     79          /* Enable/Disable RX */
     80          #define HAL_UART_RX_ENABLE()           /* N/A */
     81          #define HAL_UART_RX_DISABLE()          /* N/A */
     82          
     83          /* Enable/Disable TX INT */
     84          #define HAL_UART_RX_INT_ENABLE()       { IE2 |= UCA0RXIE; }
     85          #define HAL_UART_RX_INT_DISABLE()      { IE2 &= ~UCA0RXIE; }
     86          
     87          /* Enable/Disable SWRST */
     88          #define HAL_UART_SWRST_ENABLE()        { UCA0CTL1 |= UCSWRST; }
     89          #define HAL_UART_SWRST_DISABLE()       { UCA0CTL1 &= ~UCSWRST; }
     90          
     91          /* Get Rx/Tx status bit */
     92          #define HAL_UART_GET_RX_STATUS()      (IFG2 & UCA0RXIFG)
     93          #define HAL_UART_GET_TX_STATUS()      (IFG2 & UCA0TXIFG)
     94          #define HAL_UART_CLR_TX_STATUS()      (IFG2 &= ~UCA0TXIFG)
     95          
     96          /* UART CTS and RTS */
     97          #define HAL_UART_CTS_PORT              P2OUT
     98          #define HAL_UART_CTS_BIT               BV(6)
     99          
    100          #define HAL_UART_RTS_PORT              P2IN
    101          #define HAL_UART_RTS_BIT               BV(7)
    102          
    103          #define HAL_UART_FLOWCONTROL_INIT()    {P2DIR |= HAL_UART_CTS_BIT; P2DIR &= ~HAL_UART_RTS_BIT;}
    104          
    105          
    106          /*-------------------------------------------------------------------------------------------------
    107                                                    GLOBAL VARIABLES
    108          -------------------------------------------------------------------------------------------------*/
    109          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    110          halUARTCfg_t uartRecord;
   \                     uartRecord:
   \   000000                DS8 34
    111          
    112          #define HAL_GET_UBRR(BAUD_BPS)   ((uint32)(HAL_CPU_CLOCK_MHZ * 1000000) / (uint32)BAUD_BPS)
    113          
    114          /* UBRR table */

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    115          uint16 UBRRTable[] = { HAL_GET_UBRR (9600),
   \                     UBRRTable:
   \   000000                DS8 10
   \   00000A                REQUIRE `?<Initializer for UBRRTable>`
    116                                 HAL_GET_UBRR (19200),
    117                                 HAL_GET_UBRR (38400),
    118                                 HAL_GET_UBRR (57600),
    119                                 HAL_GET_UBRR (115200) };
    120          
    121          /*-------------------------------------------------------------------------------------------------
    122                                                   FUNCTIONS - LOCAL
    123          -------------------------------------------------------------------------------------------------*/
    124          
    125          static void Hal_UART_BufferInit(void);
    126          static void Hal_UART_RxProcessEvent(void);
    127          static void Hal_UART_TxProcessEvent(void);
    128          static void Hal_UART_SendCallBack(uint8 port, uint8 event);
    129          
    130          /*-------------------------------------------------------------------------------------------------
    131                                            Application Level Functions
    132          -------------------------------------------------------------------------------------------------*/
    133          
    134          /*************************************************************************************************
    135           * @fn      HalUARTInit()
    136           *
    137           * @brief   Initialize the UART
    138           *
    139           * @param   none
    140           *
    141           * @return  none
    142           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    143          void HalUARTInit ( void )
   \                     HalUARTInit:
    144          {
    145            Hal_UART_BufferInit();
   \   000000   ........     BRA     #Hal_UART_BufferInit
    146          }
    147          
    148          /*************************************************************************************************
    149           * @fn      HalBufferInit()
    150           *
    151           * @brief   Initialize the UART Buffers
    152           *
    153           * @param   none
    154           *
    155           * @return  none
    156           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    157          static void Hal_UART_BufferInit (void)
   \                     Hal_UART_BufferInit:
    158          {
    159            uartRecord.configured        = FALSE;
   \   000000   C243....     MOV.B   #0x0, &uartRecord
    160            uartRecord.rx.bufferHead     = 0;
   \   000004   8243....     MOV.W   #0x0, &uartRecord + 8
    161            uartRecord.rx.bufferTail     = 0;
   \   000008   8243....     MOV.W   #0x0, &uartRecord + 10
    162            uartRecord.rx.pBuffer        = (uint8 *)NULL;
   \   00000C   8243....     MOV.W   #0x0, &uartRecord + 14
    163            uartRecord.tx.bufferHead     = 0;
   \   000010   8243....     MOV.W   #0x0, &uartRecord + 16
    164            uartRecord.tx.bufferTail     = 0;
   \   000014   8243....     MOV.W   #0x0, &uartRecord + 18
    165            uartRecord.tx.pBuffer        = (uint8 *)NULL;
   \   000018   8243....     MOV.W   #0x0, &uartRecord + 22
    166            uartRecord.rxChRvdTime       = 0;
   \   00001C   8243....     MOV.W   #0x0, &uartRecord + 26
   \   000020   8243....     MOV.W   #0x0, &uartRecord + 28
    167            uartRecord.intEnable         = FALSE;
   \   000024   C243....     MOV.B   #0x0, &uartRecord + 24
    168          }
   \   000028   1001         RETA
    169          
    170          /*************************************************************************************************
    171           * @fn      HalUARTOpen()
    172           *
    173           * @brief   Open a port based on the configuration
    174           *
    175           * @param   port   - UART port
    176           *          config - contains configuration information
    177           *          cBack  - Call back function where events will be reported back
    178           *
    179           * @return  Status of the function call
    180           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    181          uint8 HalUARTOpen ( uint8 port, halUARTCfg_t *config )
   \                     HalUARTOpen:
    182          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4D         MOV.W   R13, R10
    183            /* Save important information */
    184            uartRecord.baudRate             = config->baudRate;
   \   000004   D24D0100.... MOV.B   0x1(R13), &uartRecord + 1
    185            uartRecord.flowControl          = config->flowControl;
   \   00000A   D24D0200.... MOV.B   0x2(R13), &uartRecord + 2
   \   000010   924D0400.... MOV.W   0x4(R13), &uartRecord + 4
    186            uartRecord.flowControlThreshold = config->flowControlThreshold;
    187            uartRecord.rx.maxBufSize        = config->rx.maxBufSize;
   \   000016   924D0C00.... MOV.W   0xc(R13), &uartRecord + 12
    188            uartRecord.tx.maxBufSize        = config->tx.maxBufSize;
   \   00001C   924D1400.... MOV.W   0x14(R13), &uartRecord + 20
    189            uartRecord.idleTimeout          = config->idleTimeout;
   \   000022   D24D0600.... MOV.B   0x6(R13), &uartRecord + 6
    190            uartRecord.intEnable            = config->intEnable;
   \   000028   D24D1800.... MOV.B   0x18(R13), &uartRecord + 24
    191            uartRecord.callBackFunc         = config->callBackFunc;
   \   00002E   924D1E00.... MOV.W   0x1e(R13), &uartRecord + 30
   \   000034   924D2000.... MOV.W   0x20(R13), &uartRecord + 32
    192          
    193            /* Set SWRST - UART logic held in reset state */
    194            HAL_UART_SWRST_ENABLE();
   \   00003A   D2D36100     BIS.B   #0x1, &0x61
    195          
    196            /* Setup GPIO */
    197            HAL_UART_PORT_CONFIG();
   \   00003E   F2D030001B00 BIS.B   #0x30, &0x1b
    198          
    199            /* Set Frame Format */
    200            HAL_UART_FRAME_CONFIG();
   \   000044   F2C080006000 BIC.B   #0x80, &0x60
   \   00004A   F2C26000     BIC.B   #0x8, &0x60
   \   00004E   F2C010006000 BIC.B   #0x10, &0x60
    201          
    202            /* Set source clock */
    203            HAL_UART_SET_SRC_CLK();
   \   000054   F2D080006100 BIS.B   #0x80, &0x61
   \   00005A   F2C040006100 BIC.B   #0x40, &0x61
    204          
    205            /* Setup Baudrate */
    206            if (config->baudRate > HAL_UART_BR_115200)
   \   000060   5F4D0100     MOV.B   0x1(R13), R15
   \   000064   7F900500     CMP.B   #0x5, R15
   \   000068   0228         JNC     ??HalUARTOpen_1
    207            {
    208              return HAL_UART_BAUDRATE_ERROR;
   \   00006A   6C42         MOV.B   #0x4, R12
   \   00006C   443C         JMP     ??HalUARTOpen_2
    209            }
    210            else
    211            {
    212              HAL_UART_SETBAUDRATE(UBRRTable[config->baudRate]);  /* Set baud rate */
   \                     ??HalUARTOpen_1:
   \   00006E   0F5F         RLA.W   R15
   \   000070   D24F....6300 MOV.B   UBRRTable + 1(R15), &0x63
   \   000076   5F4D0100     MOV.B   0x1(R13), R15
   \   00007A   0F5F         RLA.W   R15
   \   00007C   D24F....6200 MOV.B   UBRRTable(R15), &0x62
    213            }
    214          
    215            /* Setup Flow Control */
    216            if (uartRecord.flowControl)
   \   000082   C293....     CMP.B   #0x0, &uartRecord + 2
   \   000086   0A24         JEQ     ??HalUARTOpen_3
    217            {
    218              HAL_UART_FLOWCONTROL_INIT();
   \   000088   F2D040002A00 BIS.B   #0x40, &0x2a
   \   00008E   F2C080002A00 BIC.B   #0x80, &0x2a
    219              Hal_UART_FlowControlSet (port, uartRecord.flowControl);
   \   000094   5D42....     MOV.B   &uartRecord + 2, R13
   \   000098   ........     CALLA   #Hal_UART_FlowControlSet
    220            }
    221          
    222            /* Setup threshold */
    223            if (config->flowControlThreshold > config->rx.maxBufSize)
   \                     ??HalUARTOpen_3:
   \   00009C   1F4A0400     MOV.W   0x4(R10), R15
   \   0000A0   8A9F0C00     CMP.W   R15, 0xc(R10)
   \   0000A4   012C         JC      ??HalUARTOpen_0
    224              uartRecord.flowControlThreshold = 0;
   \   0000A6   0F43         MOV.W   #0x0, R15
    225            else
    226              uartRecord.flowControlThreshold = config->flowControlThreshold;
   \                     ??HalUARTOpen_0:
   \   0000A8   824F....     MOV.W   R15, &uartRecord + 4
    227          
    228            /* Allocate memory for Rx and Tx buffer */
    229            uartRecord.rx.pBuffer = osal_mem_alloc (uartRecord.rx.maxBufSize);
   \   0000AC   1C42....     MOV.W   &uartRecord + 12, R12
   \   0000B0   ........     CALLA   #osal_mem_alloc
   \   0000B4   824C....     MOV.W   R12, &uartRecord + 14
    230            uartRecord.tx.pBuffer = osal_mem_alloc (uartRecord.tx.maxBufSize);
   \   0000B8   1C42....     MOV.W   &uartRecord + 20, R12
   \   0000BC   ........     CALLA   #osal_mem_alloc
   \   0000C0   824C....     MOV.W   R12, &uartRecord + 22
    231          
    232            /* Validate buffers */
    233            if ((uartRecord.rx.pBuffer) && (uartRecord.tx.pBuffer))
   \   0000C4   8293....     CMP.W   #0x0, &uartRecord + 14
   \   0000C8   1224         JEQ     ??HalUARTOpen_4
   \   0000CA   0C93         CMP.W   #0x0, R12
   \   0000CC   1024         JEQ     ??HalUARTOpen_4
    234            {
    235              /* Enable RX  Enable Rx Int */
    236              HAL_UART_RX_ENABLE();
    237          
    238              /* Clear SWRST - releaset to operation */
    239              HAL_UART_SWRST_DISABLE();
   \   0000CE   D2C36100     BIC.B   #0x1, &0x61
    240          
    241              /* Enable interrupt (optional) */
    242              if (config->intEnable)
   \   0000D2   CA931800     CMP.B   #0x0, 0x18(R10)
   \   0000D6   0324         JEQ     ??HalUARTOpen_5
    243              {
    244                HAL_UART_RX_INT_ENABLE();
   \   0000D8   D2D30100     BIS.B   #0x1, &0x1
   \   0000DC   023C         JMP     ??HalUARTOpen_6
    245              }
    246              else
    247              {
    248                HAL_UART_RX_INT_DISABLE();
   \                     ??HalUARTOpen_5:
   \   0000DE   D2C30100     BIC.B   #0x1, &0x1
    249              }
    250          
    251              HAL_UART_CLR_TX_STATUS();
   \                     ??HalUARTOpen_6:
   \   0000E2   E2C30300     BIC.B   #0x2, &0x3
    252          
    253              /* Mark record as "configured" */
    254              uartRecord.configured = TRUE;
   \   0000E6   D243....     MOV.B   #0x1, &uartRecord
    255          
    256              /* Ready to be used. */
    257              return HAL_UART_SUCCESS;
   \   0000EA   4C43         MOV.B   #0x0, R12
   \   0000EC   043C         JMP     ??HalUARTOpen_2
    258            }
    259            else
    260            {
    261              /* If memory allocation failed, not "configured" */
    262              uartRecord.configured = FALSE;
   \                     ??HalUARTOpen_4:
   \   0000EE   C243....     MOV.B   #0x0, &uartRecord
    263          
    264              /* Failed to allocate Rx and Tx Buffer, end of the story */
    265              return HAL_UART_MEM_FAIL;
   \   0000F2   7C400300     MOV.B   #0x3, R12
   \                     ??HalUARTOpen_2:
   \   0000F6   3A41         POP.W   R10
   \   0000F8   1001         RETA
   \   0000FA                REQUIRE UCA0CTL1
   \   0000FA                REQUIRE P3SEL
   \   0000FA                REQUIRE UCA0CTL0
   \   0000FA                REQUIRE UCA0BR1
   \   0000FA                REQUIRE UCA0BR0
   \   0000FA                REQUIRE P2DIR
   \   0000FA                REQUIRE IE2
   \   0000FA                REQUIRE IFG2
    266            }
    267          }
    268          
    269          /*************************************************************************************************
    270           * @fn      Hal_UARTPoll
    271           *
    272           * @brief   This routine simulate polling and has to be called by the main loop
    273           *
    274           * @param   void
    275           *
    276           * @return  void
    277           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    278          void HalUARTPoll(void)
   \                     HalUARTPoll:
    279          {
    280            if (!uartRecord.configured)  // If port is not configured, no point to poll it.
   \   000000   C293....     CMP.B   #0x0, &uartRecord
   \   000004   5124         JEQ     ??HalUARTPoll_0
    281            {
    282              return;
    283            }
    284          
    285            if (!uartRecord.intEnable)  // Check Port for items to process.
   \   000006   C293....     CMP.B   #0x0, &uartRecord + 24
   \   00000A   0A20         JNE     ??HalUARTPoll_2
    286            {
    287              if (HAL_UART_GET_RX_STATUS())
   \   00000C   D2B30300     BIT.B   #0x1, &0x3
   \   000010   0228         JNC     ??HalUARTPoll_3
    288              {
    289                Hal_UART_RxProcessEvent();
   \   000012   ........     CALLA   #Hal_UART_RxProcessEvent
    290              }
    291          
    292              if (HAL_UART_GET_TX_STATUS())
   \                     ??HalUARTPoll_3:
   \   000016   E2B30300     BIT.B   #0x2, &0x3
   \   00001A   0228         JNC     ??HalUARTPoll_2
    293              {
    294                Hal_UART_TxProcessEvent();
   \   00001C   ........     CALLA   #Hal_UART_TxProcessEvent
    295              }
    296            }
    297          
    298            if ((Hal_UART_RxBufLen(0) + 1) >= uartRecord.rx.maxBufSize)  // Report if Rx Buffer is full.
   \                     ??HalUARTPoll_2:
   \   000020   ........     CALLA   #?Subroutine0
   \                     ??CrossCallReturnLabel_2:
   \   000024   1C53         ADD.W   #0x1, R12
   \   000026   1C92....     CMP.W   &uartRecord + 12, R12
   \   00002A   0428         JNC     ??HalUARTPoll_4
    299            {
    300              Hal_UART_SendCallBack (0, HAL_UART_RX_FULL) ;
   \   00002C   5D43         MOV.B   #0x1, R13
   \   00002E   4C43         MOV.B   #0x0, R12
   \   000030   ........     CALLA   #Hal_UART_SendCallBack
    301            }
    302          
    303            if ((uartRecord.rxChRvdTime != 0) &&  // Report if Rx Buffer is idled.
    304               ((osal_GetSystemClock() - uartRecord.rxChRvdTime) > uartRecord.idleTimeout))
   \                     ??HalUARTPoll_4:
   \   000034   1F42....     MOV.W   &uartRecord + 26, R15
   \   000038   1FD2....     BIS.W   &uartRecord + 28, R15
   \   00003C   0F93         CMP.W   #0x0, R15
   \   00003E   1624         JEQ     ??HalUARTPoll_5
   \   000040   ........     CALLA   #osal_GetSystemClock
   \   000044   5E42....     MOV.B   &uartRecord + 6, R14
   \   000048   0F43         MOV.W   #0x0, R15
   \   00004A   1C82....     SUB.W   &uartRecord + 26, R12
   \   00004E   1D72....     SUBC.W  &uartRecord + 28, R13
   \   000052   0F9D         CMP.W   R13, R15
   \   000054   0328         JNC     ??HalUARTPoll_6
   \   000056   0A20         JNE     ??HalUARTPoll_5
   \   000058   0E9C         CMP.W   R12, R14
   \   00005A   082C         JC      ??HalUARTPoll_5
    305            {
    306              Hal_UART_SendCallBack (0, HAL_UART_RX_TIMEOUT) ;
   \                     ??HalUARTPoll_6:
   \   00005C   6D42         MOV.B   #0x4, R13
   \   00005E   4C43         MOV.B   #0x0, R12
   \   000060   ........     CALLA   #Hal_UART_SendCallBack
    307              uartRecord.rxChRvdTime = 0;
   \   000064   8243....     MOV.W   #0x0, &uartRecord + 26
   \   000068   8243....     MOV.W   #0x0, &uartRecord + 28
    308            }
    309          
    310            /* Send back warning when buffer it threshold  and turn off flow */
    311            if (Hal_UART_RxBufLen(0) >= uartRecord.rx.maxBufSize - uartRecord.flowControlThreshold)
   \                     ??HalUARTPoll_5:
   \   00006C   ........     CALLA   #?Subroutine0
   \                     ??CrossCallReturnLabel_1:
   \   000070   1F42....     MOV.W   &uartRecord + 12, R15
   \   000074   1F82....     SUB.W   &uartRecord + 4, R15
   \   000078   0C9F         CMP.W   R15, R12
   \   00007A   0428         JNC     ??HalUARTPoll_7
    312            {
    313              Hal_UART_SendCallBack (0, HAL_UART_RX_ABOUT_FULL) ;
   \   00007C   6D43         MOV.B   #0x2, R13
   \   00007E   4C43         MOV.B   #0x0, R12
   \   000080   ........     CALLA   #Hal_UART_SendCallBack
    314            }
    315          
    316            if (uartRecord.flowControl)
   \                     ??HalUARTPoll_7:
   \   000084   C293....     CMP.B   #0x0, &uartRecord + 2
   \   000088   0F24         JEQ     ??HalUARTPoll_0
    317            {
    318              if (Hal_UART_RxBufLen(0) > uartRecord.rx.maxBufSize / 2)
   \   00008A   ........     CALLA   #?Subroutine0
   \                     ??CrossCallReturnLabel_0:
   \   00008E   1F42....     MOV.W   &uartRecord + 12, R15
   \   000092   5F03         RRUM.W  #0x1, R15
   \   000094   0F9C         CMP.W   R12, R15
   \   000096   042C         JC      ??HalUARTPoll_8
    319              {
    320                Hal_UART_FlowControlSet (0, HAL_UART_FLOW_OFF);
   \   000098   4D43         MOV.B   #0x0, R13
   \   00009A   4C43         MOV.B   #0x0, R12
   \   00009C   ........     BRA     #Hal_UART_FlowControlSet
    321              }
    322              else
    323              {
    324                Hal_UART_FlowControlSet (0, HAL_UART_FLOW_ON);
   \                     ??HalUARTPoll_8:
   \   0000A0   5D43         MOV.B   #0x1, R13
   \   0000A2   4C43         MOV.B   #0x0, R12
   \   0000A4   ........     CALLA   #Hal_UART_FlowControlSet
    325              }
    326            }
    327          }
   \                     ??HalUARTPoll_0:
   \   0000A8   1001         RETA
   \   0000AA                REQUIRE IFG2

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   4C43         MOV.B   #0x0, R12
   \   000002   ........     BRA     #Hal_UART_RxBufLen
    328          
    329          /*************************************************************************************************
    330           * @fn      HalUARTClose()
    331           *
    332           * @brief   Close the UART
    333           *
    334           * @param   port - UART port (not used.)
    335           *
    336           * @return  none
    337           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    338          void HalUARTClose ( uint8 port )
   \                     HalUARTClose:
    339          {
    340            /* Disable Rx Int */
    341            HAL_UART_RX_INT_DISABLE();
   \   000000   D2C30100     BIC.B   #0x1, &0x1
    342          
    343            /* Disable RX */
    344            HAL_UART_RX_DISABLE();
    345          
    346            /* Deallocate Rx and Tx Buffers */
    347            if (uartRecord.configured)
   \   000004   C293....     CMP.B   #0x0, &uartRecord
   \   000008   0A24         JEQ     ??HalUARTClose_0
    348            {
    349              /* Free Tx and Rx buffer */
    350              osal_mem_free (uartRecord.rx.pBuffer);
   \   00000A   1C42....     MOV.W   &uartRecord + 14, R12
   \   00000E   ........     CALLA   #osal_mem_free
    351              osal_mem_free (uartRecord.tx.pBuffer);
   \   000012   1C42....     MOV.W   &uartRecord + 22, R12
   \   000016   ........     CALLA   #osal_mem_free
    352          
    353              /* Re-Initialze buffers again */
    354              Hal_UART_BufferInit();
   \   00001A   ........     CALLA   #Hal_UART_BufferInit
    355            }
    356          }
   \                     ??HalUARTClose_0:
   \   00001E   1001         RETA
   \   000020                REQUIRE IE2
    357          
    358          /*************************************************************************************************
    359           * @fn      HalUARTRead()
    360           *
    361           * @brief   Read a buffer from the UART
    362           *
    363           * @param   port - UART port (not used.)
    364           *          ppBuffer - pointer to a pointer that points to the data that will be read
    365           *          length - length of the requested buffer
    366           *
    367           * @return  length of buffer that was read
    368           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    369          uint16 HalUARTRead ( uint8 port, uint8 *pBuffer, uint16 length )
   \                     HalUARTRead:
    370          {
   \   000000   1B15         PUSHM.W #0x2, R11
    371            uint16 cnt, idx;
    372          
    373            if (!uartRecord.configured)  // If port is not configured, no point to read it.
   \   000002   C293....     CMP.B   #0x0, &uartRecord
   \   000006   0220         JNE     ??HalUARTRead_1
    374            {
    375              return 0;
   \   000008   0C43         MOV.W   #0x0, R12
   \   00000A   1B3C         JMP     ??HalUARTRead_2
    376            }
    377          
    378            // If requested length is bigger than what in buffer, re-adjust it to the buffer length.
    379            cnt = Hal_UART_RxBufLen(0);
   \                     ??HalUARTRead_1:
   \   00000C   ........     CALLA   #?Subroutine0
    380            if (cnt < length)
   \                     ??CrossCallReturnLabel_3:
   \   000010   0C9E         CMP.W   R14, R12
   \   000012   012C         JC      ??HalUARTRead_3
    381            {
    382              length = cnt;
   \   000014   0E4C         MOV.W   R12, R14
    383            }
    384          
    385            idx = uartRecord.rx.bufferHead;
   \                     ??HalUARTRead_3:
   \   000016   1A42....     MOV.W   &uartRecord + 8, R10
    386            for (cnt = 0; cnt < length; cnt++)
   \   00001A   0C43         MOV.W   #0x0, R12
   \   00001C   0D3C         JMP     ??HalUARTRead_4
    387            {
    388              pBuffer[cnt] = uartRecord.rx.pBuffer[idx++];
   \                     ??HalUARTRead_0:
   \   00001E   1B42....     MOV.W   &uartRecord + 14, R11
   \   000022   0B5A         ADD.W   R10, R11
   \   000024   0F4D         MOV.W   R13, R15
   \   000026   0F5C         ADD.W   R12, R15
   \   000028   EF4B0000     MOV.B   @R11, 0(R15)
   \   00002C   1A53         ADD.W   #0x1, R10
    389          
    390              if (idx >= uartRecord.rx.maxBufSize)
   \   00002E   1A92....     CMP.W   &uartRecord + 12, R10
   \   000032   0128         JNC     ??HalUARTRead_5
    391              {
    392                idx = 0;
   \   000034   0A43         MOV.W   #0x0, R10
    393              }
    394            }
   \                     ??HalUARTRead_5:
   \   000036   1C53         ADD.W   #0x1, R12
   \                     ??HalUARTRead_4:
   \   000038   0C9E         CMP.W   R14, R12
   \   00003A   F12B         JNC     ??HalUARTRead_0
    395            uartRecord.rx.bufferHead = idx;
   \   00003C   824A....     MOV.W   R10, &uartRecord + 8
    396          
    397            return length;  // Return number of bytes read.
   \   000040   0C4E         MOV.W   R14, R12
   \                     ??HalUARTRead_2:
   \   000042   1A17         POPM.W  #0x2, R11
   \   000044   1001         RETA
    398          }
    399          
    400          /*************************************************************************************************
    401           * @fn      HalUARTWrite()
    402           *
    403           * @brief   Write a buffer to the UART
    404           *
    405           * @param   port    - UART port (not used.)
    406           *          pBuffer - pointer to the buffer that will be written
    407           *          length  - length of
    408           *
    409           * @return  length of the buffer that was sent
    410           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    411          uint16 HalUARTWrite ( uint8 port, uint8 *pBuffer, uint16 length )
   \                     HalUARTWrite:
    412          {
   \   000000   1B15         PUSHM.W #0x2, R11
    413            uint16 cnt, idx;
    414            halIntState_t intState;
    415          
    416            if (!uartRecord.configured)
   \   000002   C293....     CMP.B   #0x0, &uartRecord
   \   000006   1224         JEQ     ??HalUARTWrite_1
    417            {
    418              return 0;
    419            }
    420          
    421            // Capture the value of the volatile variables.
    422            idx = uartRecord.tx.bufferHead;
   \   000008   1F42....     MOV.W   &uartRecord + 16, R15
    423            cnt = uartRecord.tx.bufferTail;
   \   00000C   1C42....     MOV.W   &uartRecord + 18, R12
   \   000010   1A42....     MOV.W   &uartRecord + 20, R10
   \   000014   0C9F         CMP.W   R15, R12
   \   000016   0220         JNE     ??HalUARTWrite_2
    424            if (cnt == idx)
    425            {
    426              cnt = uartRecord.tx.maxBufSize;
   \   000018   0F4A         MOV.W   R10, R15
   \   00001A   063C         JMP     ??HalUARTWrite_3
    427            }
    428            else if (cnt > idx)
   \                     ??HalUARTWrite_2:
   \   00001C   0F9C         CMP.W   R12, R15
   \   00001E   032C         JC      ??HalUARTWrite_4
    429            {
    430              cnt = uartRecord.tx.maxBufSize - cnt + idx;
   \   000020   0A8C         SUB.W   R12, R10
   \   000022   0F5A         ADD.W   R10, R15
   \   000024   013C         JMP     ??HalUARTWrite_3
    431            }
    432            else // (cnt < idx)
    433            {
    434              cnt = idx - cnt;
   \                     ??HalUARTWrite_4:
   \   000026   0F8C         SUB.W   R12, R15
    435            }
    436             
    437            // Accept "all-or-none" on write request.
    438            if (cnt < length)
   \                     ??HalUARTWrite_3:
   \   000028   0F9E         CMP.W   R14, R15
   \   00002A   022C         JC      ??HalUARTWrite_5
    439            {
    440              return 0;
   \                     ??HalUARTWrite_1:
   \   00002C   0C43         MOV.W   #0x0, R12
   \   00002E   2A3C         JMP     ??HalUARTWrite_6
    441            }
    442          
    443            idx = uartRecord.tx.bufferTail;
   \                     ??HalUARTWrite_5:
   \   000030   1A42....     MOV.W   &uartRecord + 18, R10
    444          
    445            for (cnt = 0; cnt < length; cnt++)
   \   000034   0F43         MOV.W   #0x0, R15
   \   000036   0D3C         JMP     ??HalUARTWrite_7
    446            {
    447              uartRecord.tx.pBuffer[idx++] = pBuffer[cnt];
   \                     ??HalUARTWrite_0:
   \   000038   0C4D         MOV.W   R13, R12
   \   00003A   0C5F         ADD.W   R15, R12
   \   00003C   1B42....     MOV.W   &uartRecord + 22, R11
   \   000040   0B5A         ADD.W   R10, R11
   \   000042   EB4C0000     MOV.B   @R12, 0(R11)
   \   000046   1A53         ADD.W   #0x1, R10
    448          
    449              if (idx >= uartRecord.tx.maxBufSize)
   \   000048   1A92....     CMP.W   &uartRecord + 20, R10
   \   00004C   0128         JNC     ??HalUARTWrite_8
    450              {
    451                idx = 0;
   \   00004E   0A43         MOV.W   #0x0, R10
    452              }
    453            }
   \                     ??HalUARTWrite_8:
   \   000050   1F53         ADD.W   #0x1, R15
   \                     ??HalUARTWrite_7:
   \   000052   0F9E         CMP.W   R14, R15
   \   000054   F12B         JNC     ??HalUARTWrite_0
    454          
    455            HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
   \   000056   0F42         MOV.W   SR, R15
   \   000058   32C2         dint
   \   00005A   0343         nop
    456            cnt = uartRecord.tx.bufferTail;
   \   00005C   1D42....     MOV.W   &uartRecord + 18, R13
    457            if (cnt == uartRecord.tx.bufferHead)
   \   000060   1D92....     CMP.W   &uartRecord + 16, R13
   \   000064   0B20         JNE     ??HalUARTWrite_9
    458            {
    459              if (uartRecord.intEnable)
   \   000066   C293....     CMP.B   #0x0, &uartRecord + 24
   \   00006A   0224         JEQ     ??HalUARTWrite_10
    460              {
    461                HAL_UART_TX_INT_ENABLE();
   \   00006C   E2D30100     BIS.B   #0x2, &0x1
    462              }
    463              HAL_UART_PUTBYTE(uartRecord.tx.pBuffer[uartRecord.tx.bufferHead]);  // Send a char to UART.
   \                     ??HalUARTWrite_10:
   \   000070   1B42....     MOV.W   &uartRecord + 22, R11
   \   000074   1B52....     ADD.W   &uartRecord + 16, R11
   \   000078   E24B6700     MOV.B   @R11, &0x67
    464            }
    465            uartRecord.tx.bufferTail = idx;
   \                     ??HalUARTWrite_9:
   \   00007C   824A....     MOV.W   R10, &uartRecord + 18
    466            HAL_EXIT_CRITICAL_SECTION(intState);  // Restore interrupt enable.
   \   000080   024F         MOV.W   R15, SR
    467          
    468            return length;  // Return the number of bytes actually put into the buffer.
   \   000082   0C4E         MOV.W   R14, R12
   \                     ??HalUARTWrite_6:
   \   000084   1A17         POPM.W  #0x2, R11
   \   000086   1001         RETA
   \   000088                REQUIRE IE2
   \   000088                REQUIRE UCA0TXBUF
    469          }
    470          
    471          /*************************************************************************************************
    472           * @fn      Hal_UART_RxBufLen()
    473           *
    474           * @brief   Calculate Rx Buffer length of a port
    475           *
    476           * @param   port - UART port (not used.)
    477           *
    478           * @return  length of current Rx Buffer
    479           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    480          uint16 Hal_UART_RxBufLen (uint8 port)
   \                     Hal_UART_RxBufLen:
    481          {
    482            int16 length = uartRecord.rx.bufferTail;
   \   000000   1C42....     MOV.W   &uartRecord + 10, R12
    483          
    484            length -= uartRecord.rx.bufferHead;
   \   000004   1C82....     SUB.W   &uartRecord + 8, R12
    485            if  (length < 0)
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0234         JGE     ??Hal_UART_RxBufLen_0
    486              length += uartRecord.rx.maxBufSize;
   \   00000C   1C52....     ADD.W   &uartRecord + 12, R12
    487          
    488            return (uint16)length;
   \                     ??Hal_UART_RxBufLen_0:
   \   000010   1001         RETA
    489          }
    490          
    491          /*************************************************************************************************
    492           * @fn      Hal_UART_TxBufLen()
    493           *
    494           * @brief   Calculate Tx Buffer length of a port
    495           *
    496           * @param   port - UART port (not used.)
    497           *
    498           * @return  length of current Tx buffer
    499           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    500          uint16 Hal_UART_TxBufLen ( uint8 port )
   \                     Hal_UART_TxBufLen:
    501          {
    502            int16 length = uartRecord.tx.bufferTail;
   \   000000   1C42....     MOV.W   &uartRecord + 18, R12
    503          
    504            length -= uartRecord.tx.bufferHead;
   \   000004   1C82....     SUB.W   &uartRecord + 16, R12
    505            if  (length < 0)
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0234         JGE     ??Hal_UART_TxBufLen_0
    506              length += uartRecord.tx.maxBufSize;
   \   00000C   1C52....     ADD.W   &uartRecord + 20, R12
    507          
    508            return (uint16)length;
   \                     ??Hal_UART_TxBufLen_0:
   \   000010   1001         RETA
    509          }
    510          
    511          /*-------------------------------------------------------------------------------------------------
    512                                                     HELP FUNCTIONS
    513          -------------------------------------------------------------------------------------------------*/
    514          
    515          /*************************************************************************************************
    516           * @fn      HalUARTSendCallBack
    517           *
    518           * @brief   Send Callback back to the caller
    519           *
    520           * @param   port - UART port
    521           *          event - event that causes the call back
    522           *
    523           * @return  None
    524           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    525          static void Hal_UART_SendCallBack(uint8 port, uint8 event)
   \                     Hal_UART_SendCallBack:
    526          {
    527            if (uartRecord.callBackFunc)
   \   000000   1F42....     MOV.W   &uartRecord + 30, R15
   \   000004   1FD2....     BIS.W   &uartRecord + 32, R15
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   0224         JEQ     ??Hal_UART_SendCallBack_0
    528            {
    529              (uartRecord.callBackFunc)(port, event);
   \   00000C   ........     CALLA   &uartRecord + 30
    530            }
    531          }
   \                     ??Hal_UART_SendCallBack_0:
   \   000010   1001         RETA
    532          
    533          /*************************************************************************************************
    534           * @fn      Hal_UART_ProcessRxEvent
    535           *
    536           * @brief   Process the Rx data by putting them in Rx Buffer. Callback will happen if idle timeout
    537           *          or Rx buffer is full
    538           *
    539           * @param   void
    540           *
    541           * @return  void
    542           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    543          static void Hal_UART_RxProcessEvent(void)
   \                     Hal_UART_RxProcessEvent:
    544          {
    545            uint8 ch = HAL_UART_GETBYTE();
   \   000000   5E426600     MOV.B   &0x66, R14
    546          
    547            uartRecord.rx.pBuffer[uartRecord.rx.bufferTail++] = ch;
   \   000004   1F42....     MOV.W   &uartRecord + 10, R15
   \   000008   0D4F         MOV.W   R15, R13
   \   00000A   1D53         ADD.W   #0x1, R13
   \   00000C   824D....     MOV.W   R13, &uartRecord + 10
   \   000010   1D42....     MOV.W   &uartRecord + 14, R13
   \   000014   0D5F         ADD.W   R15, R13
   \   000016   CD4E0000     MOV.B   R14, 0(R13)
    548            if (uartRecord.rx.bufferTail >= uartRecord.rx.maxBufSize)
   \   00001A   9292........ CMP.W   &uartRecord + 12, &uartRecord + 10
   \   000020   0228         JNC     ??Hal_UART_RxProcessEvent_0
    549            {
    550              uartRecord.rx.bufferTail = 0;
   \   000022   8243....     MOV.W   #0x0, &uartRecord + 10
    551            }
    552          
    553            uartRecord.rxChRvdTime = osal_GetSystemClock();
   \                     ??Hal_UART_RxProcessEvent_0:
   \   000026   ........     CALLA   #osal_GetSystemClock
   \   00002A   824C....     MOV.W   R12, &uartRecord + 26
   \   00002E   824D....     MOV.W   R13, &uartRecord + 28
    554          }
   \   000032   1001         RETA
   \   000034                REQUIRE UCA0RXBUF
    555          
    556          /*************************************************************************************************
    557           * @fn      Hal_UART_ProcessTxEvent
    558           *
    559           * @brief   Process Tx buffer and events
    560           *
    561           * @param   void
    562           *
    563           * @return  void
    564           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    565          static void Hal_UART_TxProcessEvent(void)
   \                     Hal_UART_TxProcessEvent:
    566          {
    567            uint16 tail = uartRecord.tx.bufferTail;
   \   000000   1F42....     MOV.W   &uartRecord + 18, R15
    568          
    569            if (++uartRecord.tx.bufferHead >= uartRecord.tx.maxBufSize)
   \   000004   1E42....     MOV.W   &uartRecord + 16, R14
   \   000008   1E53         ADD.W   #0x1, R14
   \   00000A   824E....     MOV.W   R14, &uartRecord + 16
   \   00000E   1E92....     CMP.W   &uartRecord + 20, R14
   \   000012   0228         JNC     ??Hal_UART_TxProcessEvent_0
    570            {
    571              uartRecord.tx.bufferHead = 0;
   \   000014   8243....     MOV.W   #0x0, &uartRecord + 16
    572            }
    573          
    574            if (uartRecord.tx.bufferHead != tail)
   \                     ??Hal_UART_TxProcessEvent_0:
   \   000018   829F....     CMP.W   R15, &uartRecord + 16
   \   00001C   0724         JEQ     ??Hal_UART_TxProcessEvent_1
    575            {
    576              HAL_UART_PUTBYTE(uartRecord.tx.pBuffer[uartRecord.tx.bufferHead]);  // Send a char to UART.
   \   00001E   1F42....     MOV.W   &uartRecord + 22, R15
   \   000022   1F52....     ADD.W   &uartRecord + 16, R15
   \   000026   E24F6700     MOV.B   @R15, &0x67
   \   00002A   1001         RETA
    577            }
    578            else
    579            {
    580              HAL_UART_TX_INT_DISABLE();
   \                     ??Hal_UART_TxProcessEvent_1:
   \   00002C   E2C30100     BIC.B   #0x2, &0x1
    581              HAL_UART_CLR_TX_STATUS();
   \   000030   E2C30300     BIC.B   #0x2, &0x3
    582            }
    583          }
   \   000034   1001         RETA
   \   000036                REQUIRE UCA0TXBUF
   \   000036                REQUIRE IE2
   \   000036                REQUIRE IFG2
    584          
    585          /*************************************************************************************************
    586           * @fn      Hal_UART_SetFlowControl
    587           *
    588           * @brief   Set UART Rx flow control
    589           *
    590           * @param   port: serial port (not used.)
    591           *          on:   0=OFF, !0=ON
    592           *
    593           * @return  none
    594           *
    595           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    596          void Hal_UART_FlowControlSet( uint8 port, uint8 status )
   \                     Hal_UART_FlowControlSet:
    597          {
    598            if ( status == HAL_UART_FLOW_ON )
   \   000000   5D93         CMP.B   #0x1, R13
   \   000002   0420         JNE     ??Hal_UART_FlowControlSet_0
    599              HAL_UART_CTS_PORT &= ~HAL_UART_CTS_BIT;  /* Enable RX flow */
   \   000004   F2C040002900 BIC.B   #0x40, &0x29
   \   00000A   1001         RETA
    600            else
    601              HAL_UART_CTS_PORT |= HAL_UART_CTS_BIT;   /* Disable RX flow */  
   \                     ??Hal_UART_FlowControlSet_0:
   \   00000C   F2D040002900 BIS.B   #0x40, &0x29
    602          }
   \   000012   1001         RETA
   \   000014                REQUIRE P2OUT
    603          
    604          /*-------------------------------------------------------------------------------------------------
    605                                              Interrupt Service Routines
    606          -------------------------------------------------------------------------------------------------*/
    607          
    608          /*************************************************************************************************
    609           * @fn      UART Rx/Tx ISR
    610           *
    611           * @brief   Called when a serial byte is ready to read and/or write.
    612           *  NOTE:   Assumes that uartRecord.configured is TRUE if this interrupt is enabled.
    613           *
    614           * @param   void
    615           *
    616           * @return  void
    617          **************************************************************************************************/
    618          

   \                                 In  segment ISR_CODE, align 2
    619          INTERRUPT_UART_RX_READY()
   \                     halBoardUart1RxReadyIsr:
    620          {
   \   000000   3F15         PUSHM.W #0x4, R15
    621            Hal_UART_RxProcessEvent();
   \   000002   ........     CALLA   #Hal_UART_RxProcessEvent
    622          }
   \   000006   3C17         POPM.W  #0x4, R15
   \   000008   0013         RETI
    623          
    624          
    625          /**************************************************************************************************
    626           * @fn      INTERRUPT_UART0_TX_READY
    627           *
    628           * @brief   Called when xmtr shift register and buffer are both empty.
    629           *
    630           * @param   void
    631           *
    632           * @return  void
    633           **************************************************************************************************/
    634          

   \                                 In  segment ISR_CODE, align 2
    635          INTERRUPT_UART_TX_READY()
   \                     halBoardUart1TxReadyIsr:
    636          {
   \   000000   3F15         PUSHM.W #0x4, R15
    637            Hal_UART_TxProcessEvent();
   \   000002   ........     CALLA   #Hal_UART_TxProcessEvent
    638          }
   \   000006   3C17         POPM.W  #0x4, R15
   \   000008   0013         RETI

   \                                 In  segment INTVEC, offset 0x2c, root
   \                     `??halBoardUart1TxReadyIsr??INTVEC 44`:
   \   00002C   ....         DC16    halBoardUart1TxReadyIsr

   \                                 In  segment INTVEC, offset 0x2e, root
   \                     `??halBoardUart1RxReadyIsr??INTVEC 46`:
   \   00002E   ....         DC16    halBoardUart1RxReadyIsr

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for UBRRTable>`:
   \   000000   710238019C00 DC16 625, 312, 156, 104, 52
   \            68003400    
    639          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   HalUARTClose
        4   -> Hal_UART_BufferInit
        4   -> osal_mem_free
      4   HalUARTInit
        4   -> Hal_UART_BufferInit
      6   HalUARTOpen
        6   -> Hal_UART_FlowControlSet
        6   -> osal_mem_alloc
      4   HalUARTPoll
        4   -> Hal_UART_FlowControlSet
        4   -> Hal_UART_RxBufLen
        4   -> Hal_UART_RxProcessEvent
        4   -> Hal_UART_SendCallBack
        4   -> Hal_UART_TxProcessEvent
        4   -> osal_GetSystemClock
      8   HalUARTRead
        8   -> Hal_UART_RxBufLen
      8   HalUARTWrite
      4   Hal_UART_BufferInit
      4   Hal_UART_FlowControlSet
      4   Hal_UART_RxBufLen
      4   Hal_UART_RxProcessEvent
        4   -> osal_GetSystemClock
      4   Hal_UART_SendCallBack
        4   -- Indirect call
      4   Hal_UART_TxBufLen
      4   Hal_UART_TxProcessEvent
     12   halBoardUart1RxReadyIsr
       12   -> Hal_UART_RxProcessEvent
     12   halBoardUart1TxReadyIsr
       12   -> Hal_UART_TxProcessEvent


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?<Initializer for UBRRTable>
       2  ??halBoardUart1RxReadyIsr??INTVEC 46
       2  ??halBoardUart1TxReadyIsr??INTVEC 44
       6  ?Subroutine0
      32  HalUARTClose
       4  HalUARTInit
     250  HalUARTOpen
     170  HalUARTPoll
      70  HalUARTRead
     136  HalUARTWrite
      42  Hal_UART_BufferInit
      20  Hal_UART_FlowControlSet
      18  Hal_UART_RxBufLen
      52  Hal_UART_RxProcessEvent
      18  Hal_UART_SendCallBack
      18  Hal_UART_TxBufLen
      54  Hal_UART_TxProcessEvent
       1  IE2
       1  IFG2
       1  P2DIR
       1  P2OUT
       1  P3SEL
      10  UBRRTable
       1  UCA0BR0
       1  UCA0BR1
       1  UCA0CTL0
       1  UCA0CTL1
       1  UCA0RXBUF
       1  UCA0TXBUF
      10  halBoardUart1RxReadyIsr
      10  halBoardUart1TxReadyIsr
      34  uartRecord

 
 890 bytes in segment CODE
  11 bytes in segment DATA16_AN
  10 bytes in segment DATA16_I
  10 bytes in segment DATA16_ID
  34 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
  20 bytes in segment ISR_CODE
 
 910 bytes of CODE  memory
  10 bytes of CONST memory (+  4 bytes shared)
  44 bytes of DATA  memory (+ 11 bytes shared)

Errors: none
Warnings: none
